"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/minipass";
exports.ids = ["vendor-chunks/minipass"];
exports.modules = {

/***/ "(rsc)/./node_modules/minipass/dist/commonjs/index.js":
/*!******************************************************!*\
  !*** ./node_modules/minipass/dist/commonjs/index.js ***!
  \******************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;\nconst proc = typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n    };\nconst node_events_1 = __webpack_require__(/*! node:events */ \"node:events\");\nconst node_stream_1 = __importDefault(__webpack_require__(/*! node:stream */ \"node:stream\"));\nconst node_string_decoder_1 = __webpack_require__(/*! node:string_decoder */ \"node:string_decoder\");\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nconst isStream = (s) => !!s &&\n    typeof s === 'object' &&\n    (s instanceof Minipass ||\n        s instanceof node_stream_1.default ||\n        (0, exports.isReadable)(s) ||\n        (0, exports.isWritable)(s));\nexports.isStream = isStream;\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nconst isReadable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof node_events_1.EventEmitter &&\n    typeof s.pipe === 'function' &&\n    // node core Writable streams have a pipe() method, but it throws\n    s.pipe !== node_stream_1.default.Writable.prototype.pipe;\nexports.isReadable = isReadable;\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nconst isWritable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof node_events_1.EventEmitter &&\n    typeof s.write === 'function' &&\n    typeof s.end === 'function';\nexports.isWritable = isWritable;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed');\n// internal event when stream has an error\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\nconst DATALISTENERS = Symbol('dataListeners');\nconst DISCARDED = Symbol('discarded');\nconst defer = (fn) => Promise.resolve().then(fn);\nconst nodefer = (fn) => fn();\nconst isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBufferLike = (b) => b instanceof ArrayBuffer ||\n    (!!b &&\n        typeof b === 'object' &&\n        b.constructor &&\n        b.constructor.name === 'ArrayBuffer' &&\n        b.byteLength >= 0);\nconst isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe {\n    src;\n    dest;\n    opts;\n    ondrain;\n    constructor(src, dest, opts) {\n        this.src = src;\n        this.dest = dest;\n        this.opts = opts;\n        this.ondrain = () => src[RESUME]();\n        this.dest.on('drain', this.ondrain);\n    }\n    unpipe() {\n        this.dest.removeListener('drain', this.ondrain);\n    }\n    // only here for the prototype\n    /* c8 ignore start */\n    proxyErrors(_er) { }\n    /* c8 ignore stop */\n    end() {\n        this.unpipe();\n        if (this.opts.end)\n            this.dest.end();\n    }\n}\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors extends Pipe {\n    unpipe() {\n        this.src.removeListener('error', this.proxyErrors);\n        super.unpipe();\n    }\n    constructor(src, dest, opts) {\n        super(src, dest, opts);\n        this.proxyErrors = er => dest.emit('error', er);\n        src.on('error', this.proxyErrors);\n    }\n}\nconst isObjectModeOptions = (o) => !!o.objectMode;\nconst isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nclass Minipass extends node_events_1.EventEmitter {\n    [FLOWING] = false;\n    [PAUSED] = false;\n    [PIPES] = [];\n    [BUFFER] = [];\n    [OBJECTMODE];\n    [ENCODING];\n    [ASYNC];\n    [DECODER];\n    [EOF] = false;\n    [EMITTED_END] = false;\n    [EMITTING_END] = false;\n    [CLOSED] = false;\n    [EMITTED_ERROR] = null;\n    [BUFFERLENGTH] = 0;\n    [DESTROYED] = false;\n    [SIGNAL];\n    [ABORTED] = false;\n    [DATALISTENERS] = 0;\n    [DISCARDED] = false;\n    /**\n     * true if the stream can be written\n     */\n    writable = true;\n    /**\n     * true if the stream can be read\n     */\n    readable = true;\n    /**\n     * If `RType` is Buffer, then options do not need to be provided.\n     * Otherwise, an options object must be provided to specify either\n     * {@link Minipass.SharedOptions.objectMode} or\n     * {@link Minipass.SharedOptions.encoding}, as appropriate.\n     */\n    constructor(...args) {\n        const options = (args[0] ||\n            {});\n        super();\n        if (options.objectMode && typeof options.encoding === 'string') {\n            throw new TypeError('Encoding and objectMode may not be used together');\n        }\n        if (isObjectModeOptions(options)) {\n            this[OBJECTMODE] = true;\n            this[ENCODING] = null;\n        }\n        else if (isEncodingOptions(options)) {\n            this[ENCODING] = options.encoding;\n            this[OBJECTMODE] = false;\n        }\n        else {\n            this[OBJECTMODE] = false;\n            this[ENCODING] = null;\n        }\n        this[ASYNC] = !!options.async;\n        this[DECODER] = this[ENCODING]\n            ? new node_string_decoder_1.StringDecoder(this[ENCODING])\n            : null;\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposeBuffer === true) {\n            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });\n        }\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposePipes === true) {\n            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });\n        }\n        const { signal } = options;\n        if (signal) {\n            this[SIGNAL] = signal;\n            if (signal.aborted) {\n                this[ABORT]();\n            }\n            else {\n                signal.addEventListener('abort', () => this[ABORT]());\n            }\n        }\n    }\n    /**\n     * The amount of data stored in the buffer waiting to be read.\n     *\n     * For Buffer strings, this will be the total byte length.\n     * For string encoding streams, this will be the string character length,\n     * according to JavaScript's `string.length` logic.\n     * For objectMode streams, this is a count of the items waiting to be\n     * emitted.\n     */\n    get bufferLength() {\n        return this[BUFFERLENGTH];\n    }\n    /**\n     * The `BufferEncoding` currently in use, or `null`\n     */\n    get encoding() {\n        return this[ENCODING];\n    }\n    /**\n     * @deprecated - This is a read only property\n     */\n    set encoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * @deprecated - Encoding may only be set at instantiation time\n     */\n    setEncoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * True if this is an objectMode stream\n     */\n    get objectMode() {\n        return this[OBJECTMODE];\n    }\n    /**\n     * @deprecated - This is a read-only property\n     */\n    set objectMode(_om) {\n        throw new Error('objectMode must be set at instantiation time');\n    }\n    /**\n     * true if this is an async stream\n     */\n    get ['async']() {\n        return this[ASYNC];\n    }\n    /**\n     * Set to true to make this stream async.\n     *\n     * Once set, it cannot be unset, as this would potentially cause incorrect\n     * behavior.  Ie, a sync stream can be made async, but an async stream\n     * cannot be safely made sync.\n     */\n    set ['async'](a) {\n        this[ASYNC] = this[ASYNC] || !!a;\n    }\n    // drop everything and get out of the flow completely\n    [ABORT]() {\n        this[ABORTED] = true;\n        this.emit('abort', this[SIGNAL]?.reason);\n        this.destroy(this[SIGNAL]?.reason);\n    }\n    /**\n     * True if the stream has been aborted.\n     */\n    get aborted() {\n        return this[ABORTED];\n    }\n    /**\n     * No-op setter. Stream aborted status is set via the AbortSignal provided\n     * in the constructor options.\n     */\n    set aborted(_) { }\n    write(chunk, encoding, cb) {\n        if (this[ABORTED])\n            return false;\n        if (this[EOF])\n            throw new Error('write after end');\n        if (this[DESTROYED]) {\n            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));\n            return true;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (!encoding)\n            encoding = 'utf8';\n        const fn = this[ASYNC] ? defer : nodefer;\n        // convert array buffers and typed array views into buffers\n        // at some point in the future, we may want to do the opposite!\n        // leave strings and buffers as-is\n        // anything is only allowed if in object mode, so throw\n        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n            if (isArrayBufferView(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n            }\n            else if (isArrayBufferLike(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk);\n            }\n            else if (typeof chunk !== 'string') {\n                throw new Error('Non-contiguous data written to non-objectMode stream');\n            }\n        }\n        // handle object mode up front, since it's simpler\n        // this yields better performance, fewer checks later.\n        if (this[OBJECTMODE]) {\n            // maybe impossible?\n            /* c8 ignore start */\n            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n                this[FLUSH](true);\n            /* c8 ignore stop */\n            if (this[FLOWING])\n                this.emit('data', chunk);\n            else\n                this[BUFFERPUSH](chunk);\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // at this point the chunk is a buffer or string\n        // don't buffer it up or send it to the decoder\n        if (!chunk.length) {\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // fast-path writing strings of same encoding to a stream with\n        // an empty buffer, skipping the buffer/decoder dance\n        if (typeof chunk === 'string' &&\n            // unless it is a string already ready for us to use\n            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = this[DECODER].write(chunk);\n        }\n        // Note: flushing CAN potentially switch us into not-flowing mode\n        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n            this[FLUSH](true);\n        if (this[FLOWING])\n            this.emit('data', chunk);\n        else\n            this[BUFFERPUSH](chunk);\n        if (this[BUFFERLENGTH] !== 0)\n            this.emit('readable');\n        if (cb)\n            fn(cb);\n        return this[FLOWING];\n    }\n    /**\n     * Low-level explicit read method.\n     *\n     * In objectMode, the argument is ignored, and one item is returned if\n     * available.\n     *\n     * `n` is the number of bytes (or in the case of encoding streams,\n     * characters) to consume. If `n` is not provided, then the entire buffer\n     * is returned, or `null` is returned if no data is available.\n     *\n     * If `n` is greater that the amount of data in the internal buffer,\n     * then `null` is returned.\n     */\n    read(n) {\n        if (this[DESTROYED])\n            return null;\n        this[DISCARDED] = false;\n        if (this[BUFFERLENGTH] === 0 ||\n            n === 0 ||\n            (n && n > this[BUFFERLENGTH])) {\n            this[MAYBE_EMIT_END]();\n            return null;\n        }\n        if (this[OBJECTMODE])\n            n = null;\n        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n            // not object mode, so if we have an encoding, then RType is string\n            // otherwise, must be Buffer\n            this[BUFFER] = [\n                (this[ENCODING]\n                    ? this[BUFFER].join('')\n                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),\n            ];\n        }\n        const ret = this[READ](n || null, this[BUFFER][0]);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [READ](n, chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERSHIFT]();\n        else {\n            const c = chunk;\n            if (n === c.length || n === null)\n                this[BUFFERSHIFT]();\n            else if (typeof c === 'string') {\n                this[BUFFER][0] = c.slice(n);\n                chunk = c.slice(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n            else {\n                this[BUFFER][0] = c.subarray(n);\n                chunk = c.subarray(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n        }\n        this.emit('data', chunk);\n        if (!this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n        return chunk;\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (chunk !== undefined)\n            this.write(chunk, encoding);\n        if (cb)\n            this.once('end', cb);\n        this[EOF] = true;\n        this.writable = false;\n        // if we haven't written anything, then go ahead and emit,\n        // even if we're not reading.\n        // we'll re-emit if a new 'end' listener is added anyway.\n        // This makes MP more suitable to write-only use cases.\n        if (this[FLOWING] || !this[PAUSED])\n            this[MAYBE_EMIT_END]();\n        return this;\n    }\n    // don't let the internal resume be overwritten\n    [RESUME]() {\n        if (this[DESTROYED])\n            return;\n        if (!this[DATALISTENERS] && !this[PIPES].length) {\n            this[DISCARDED] = true;\n        }\n        this[PAUSED] = false;\n        this[FLOWING] = true;\n        this.emit('resume');\n        if (this[BUFFER].length)\n            this[FLUSH]();\n        else if (this[EOF])\n            this[MAYBE_EMIT_END]();\n        else\n            this.emit('drain');\n    }\n    /**\n     * Resume the stream if it is currently in a paused state\n     *\n     * If called when there are no pipe destinations or `data` event listeners,\n     * this will place the stream in a \"discarded\" state, where all data will\n     * be thrown away. The discarded state is removed if a pipe destination or\n     * data handler is added, if pause() is called, or if any synchronous or\n     * asynchronous iteration is started.\n     */\n    resume() {\n        return this[RESUME]();\n    }\n    /**\n     * Pause the stream\n     */\n    pause() {\n        this[FLOWING] = false;\n        this[PAUSED] = true;\n        this[DISCARDED] = false;\n    }\n    /**\n     * true if the stream has been forcibly destroyed\n     */\n    get destroyed() {\n        return this[DESTROYED];\n    }\n    /**\n     * true if the stream is currently in a flowing state, meaning that\n     * any writes will be immediately emitted.\n     */\n    get flowing() {\n        return this[FLOWING];\n    }\n    /**\n     * true if the stream is currently in a paused state\n     */\n    get paused() {\n        return this[PAUSED];\n    }\n    [BUFFERPUSH](chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] += 1;\n        else\n            this[BUFFERLENGTH] += chunk.length;\n        this[BUFFER].push(chunk);\n    }\n    [BUFFERSHIFT]() {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] -= 1;\n        else\n            this[BUFFERLENGTH] -= this[BUFFER][0].length;\n        return this[BUFFER].shift();\n    }\n    [FLUSH](noDrain = false) {\n        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n            this[BUFFER].length);\n        if (!noDrain && !this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n    }\n    [FLUSHCHUNK](chunk) {\n        this.emit('data', chunk);\n        return this[FLOWING];\n    }\n    /**\n     * Pipe all data emitted by this stream into the destination provided.\n     *\n     * Triggers the flow of data.\n     */\n    pipe(dest, opts) {\n        if (this[DESTROYED])\n            return dest;\n        this[DISCARDED] = false;\n        const ended = this[EMITTED_END];\n        opts = opts || {};\n        if (dest === proc.stdout || dest === proc.stderr)\n            opts.end = false;\n        else\n            opts.end = opts.end !== false;\n        opts.proxyErrors = !!opts.proxyErrors;\n        // piping an ended stream ends immediately\n        if (ended) {\n            if (opts.end)\n                dest.end();\n        }\n        else {\n            // \"as\" here just ignores the WType, which pipes don't care about,\n            // since they're only consuming from us, and writing to the dest\n            this[PIPES].push(!opts.proxyErrors\n                ? new Pipe(this, dest, opts)\n                : new PipeProxyErrors(this, dest, opts));\n            if (this[ASYNC])\n                defer(() => this[RESUME]());\n            else\n                this[RESUME]();\n        }\n        return dest;\n    }\n    /**\n     * Fully unhook a piped destination stream.\n     *\n     * If the destination stream was the only consumer of this stream (ie,\n     * there are no other piped destinations or `'data'` event listeners)\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    unpipe(dest) {\n        const p = this[PIPES].find(p => p.dest === dest);\n        if (p) {\n            if (this[PIPES].length === 1) {\n                if (this[FLOWING] && this[DATALISTENERS] === 0) {\n                    this[FLOWING] = false;\n                }\n                this[PIPES] = [];\n            }\n            else\n                this[PIPES].splice(this[PIPES].indexOf(p), 1);\n            p.unpipe();\n        }\n    }\n    /**\n     * Alias for {@link Minipass#on}\n     */\n    addListener(ev, handler) {\n        return this.on(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.on`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * - Adding a 'data' event handler will trigger the flow of data\n     *\n     * - Adding a 'readable' event handler when there is data waiting to be read\n     *   will cause 'readable' to be emitted immediately.\n     *\n     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n     *   already passed will cause the event to be emitted immediately and all\n     *   handlers removed.\n     *\n     * - Adding an 'error' event handler after an error has been emitted will\n     *   cause the event to be re-emitted immediately with the error previously\n     *   raised.\n     */\n    on(ev, handler) {\n        const ret = super.on(ev, handler);\n        if (ev === 'data') {\n            this[DISCARDED] = false;\n            this[DATALISTENERS]++;\n            if (!this[PIPES].length && !this[FLOWING]) {\n                this[RESUME]();\n            }\n        }\n        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n            super.emit('readable');\n        }\n        else if (isEndish(ev) && this[EMITTED_END]) {\n            super.emit(ev);\n            this.removeAllListeners(ev);\n        }\n        else if (ev === 'error' && this[EMITTED_ERROR]) {\n            const h = handler;\n            if (this[ASYNC])\n                defer(() => h.call(this, this[EMITTED_ERROR]));\n            else\n                h.call(this, this[EMITTED_ERROR]);\n        }\n        return ret;\n    }\n    /**\n     * Alias for {@link Minipass#off}\n     */\n    removeListener(ev, handler) {\n        return this.off(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.off`\n     *\n     * If a 'data' event handler is removed, and it was the last consumer\n     * (ie, there are no pipe destinations or other 'data' event listeners),\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    off(ev, handler) {\n        const ret = super.off(ev, handler);\n        // if we previously had listeners, and now we don't, and we don't\n        // have any pipes, then stop the flow, unless it's been explicitly\n        // put in a discarded flowing state via stream.resume().\n        if (ev === 'data') {\n            this[DATALISTENERS] = this.listeners('data').length;\n            if (this[DATALISTENERS] === 0 &&\n                !this[DISCARDED] &&\n                !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Mostly identical to `EventEmitter.removeAllListeners`\n     *\n     * If all 'data' event handlers are removed, and they were the last consumer\n     * (ie, there are no pipe destinations), then the flow of data will stop\n     * until there is another consumer or {@link Minipass#resume} is explicitly\n     * called.\n     */\n    removeAllListeners(ev) {\n        const ret = super.removeAllListeners(ev);\n        if (ev === 'data' || ev === undefined) {\n            this[DATALISTENERS] = 0;\n            if (!this[DISCARDED] && !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * true if the 'end' event has been emitted\n     */\n    get emittedEnd() {\n        return this[EMITTED_END];\n    }\n    [MAYBE_EMIT_END]() {\n        if (!this[EMITTING_END] &&\n            !this[EMITTED_END] &&\n            !this[DESTROYED] &&\n            this[BUFFER].length === 0 &&\n            this[EOF]) {\n            this[EMITTING_END] = true;\n            this.emit('end');\n            this.emit('prefinish');\n            this.emit('finish');\n            if (this[CLOSED])\n                this.emit('close');\n            this[EMITTING_END] = false;\n        }\n    }\n    /**\n     * Mostly identical to `EventEmitter.emit`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * If the stream has been destroyed, and the event is something other\n     * than 'close' or 'error', then `false` is returned and no handlers\n     * are called.\n     *\n     * If the event is 'end', and has already been emitted, then the event\n     * is ignored. If the stream is in a paused or non-flowing state, then\n     * the event will be deferred until data flow resumes. If the stream is\n     * async, then handlers will be called on the next tick rather than\n     * immediately.\n     *\n     * If the event is 'close', and 'end' has not yet been emitted, then\n     * the event will be deferred until after 'end' is emitted.\n     *\n     * If the event is 'error', and an AbortSignal was provided for the stream,\n     * and there are no listeners, then the event is ignored, matching the\n     * behavior of node core streams in the presense of an AbortSignal.\n     *\n     * If the event is 'finish' or 'prefinish', then all listeners will be\n     * removed after emitting the event, to prevent double-firing.\n     */\n    emit(ev, ...args) {\n        const data = args[0];\n        // error and close are only events allowed after calling destroy()\n        if (ev !== 'error' &&\n            ev !== 'close' &&\n            ev !== DESTROYED &&\n            this[DESTROYED]) {\n            return false;\n        }\n        else if (ev === 'data') {\n            return !this[OBJECTMODE] && !data\n                ? false\n                : this[ASYNC]\n                    ? (defer(() => this[EMITDATA](data)), true)\n                    : this[EMITDATA](data);\n        }\n        else if (ev === 'end') {\n            return this[EMITEND]();\n        }\n        else if (ev === 'close') {\n            this[CLOSED] = true;\n            // don't emit close before 'end' and 'finish'\n            if (!this[EMITTED_END] && !this[DESTROYED])\n                return false;\n            const ret = super.emit('close');\n            this.removeAllListeners('close');\n            return ret;\n        }\n        else if (ev === 'error') {\n            this[EMITTED_ERROR] = data;\n            super.emit(ERROR, data);\n            const ret = !this[SIGNAL] || this.listeners('error').length\n                ? super.emit('error', data)\n                : false;\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'resume') {\n            const ret = super.emit('resume');\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'finish' || ev === 'prefinish') {\n            const ret = super.emit(ev);\n            this.removeAllListeners(ev);\n            return ret;\n        }\n        // Some other unknown event\n        const ret = super.emit(ev, ...args);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITDATA](data) {\n        for (const p of this[PIPES]) {\n            if (p.dest.write(data) === false)\n                this.pause();\n        }\n        const ret = this[DISCARDED] ? false : super.emit('data', data);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITEND]() {\n        if (this[EMITTED_END])\n            return false;\n        this[EMITTED_END] = true;\n        this.readable = false;\n        return this[ASYNC]\n            ? (defer(() => this[EMITEND2]()), true)\n            : this[EMITEND2]();\n    }\n    [EMITEND2]() {\n        if (this[DECODER]) {\n            const data = this[DECODER].end();\n            if (data) {\n                for (const p of this[PIPES]) {\n                    p.dest.write(data);\n                }\n                if (!this[DISCARDED])\n                    super.emit('data', data);\n            }\n        }\n        for (const p of this[PIPES]) {\n            p.end();\n        }\n        const ret = super.emit('end');\n        this.removeAllListeners('end');\n        return ret;\n    }\n    /**\n     * Return a Promise that resolves to an array of all emitted data once\n     * the stream ends.\n     */\n    async collect() {\n        const buf = Object.assign([], {\n            dataLength: 0,\n        });\n        if (!this[OBJECTMODE])\n            buf.dataLength = 0;\n        // set the promise first, in case an error is raised\n        // by triggering the flow here.\n        const p = this.promise();\n        this.on('data', c => {\n            buf.push(c);\n            if (!this[OBJECTMODE])\n                buf.dataLength += c.length;\n        });\n        await p;\n        return buf;\n    }\n    /**\n     * Return a Promise that resolves to the concatenation of all emitted data\n     * once the stream ends.\n     *\n     * Not allowed on objectMode streams.\n     */\n    async concat() {\n        if (this[OBJECTMODE]) {\n            throw new Error('cannot concat in objectMode');\n        }\n        const buf = await this.collect();\n        return (this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength));\n    }\n    /**\n     * Return a void Promise that resolves once the stream ends.\n     */\n    async promise() {\n        return new Promise((resolve, reject) => {\n            this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n            this.on('error', er => reject(er));\n            this.on('end', () => resolve());\n        });\n    }\n    /**\n     * Asynchronous `for await of` iteration.\n     *\n     * This will continue emitting all chunks until the stream terminates.\n     */\n    [Symbol.asyncIterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = async () => {\n            this.pause();\n            stopped = true;\n            return { value: undefined, done: true };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const res = this.read();\n            if (res !== null)\n                return Promise.resolve({ done: false, value: res });\n            if (this[EOF])\n                return stop();\n            let resolve;\n            let reject;\n            const onerr = (er) => {\n                this.off('data', ondata);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                reject(er);\n            };\n            const ondata = (value) => {\n                this.off('error', onerr);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                this.pause();\n                resolve({ value, done: !!this[EOF] });\n            };\n            const onend = () => {\n                this.off('error', onerr);\n                this.off('data', ondata);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                resolve({ done: true, value: undefined });\n            };\n            const ondestroy = () => onerr(new Error('stream destroyed'));\n            return new Promise((res, rej) => {\n                reject = rej;\n                resolve = res;\n                this.once(DESTROYED, ondestroy);\n                this.once('error', onerr);\n                this.once('end', onend);\n                this.once('data', ondata);\n            });\n        };\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Synchronous `for of` iteration.\n     *\n     * The iteration will terminate when the internal buffer runs out, even\n     * if the stream has not yet terminated.\n     */\n    [Symbol.iterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = () => {\n            this.pause();\n            this.off(ERROR, stop);\n            this.off(DESTROYED, stop);\n            this.off('end', stop);\n            stopped = true;\n            return { done: true, value: undefined };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const value = this.read();\n            return value === null ? stop() : { done: false, value };\n        };\n        this.once('end', stop);\n        this.once(ERROR, stop);\n        this.once(DESTROYED, stop);\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Destroy a stream, preventing it from being used for any further purpose.\n     *\n     * If the stream has a `close()` method, then it will be called on\n     * destruction.\n     *\n     * After destruction, any attempt to write data, read data, or emit most\n     * events will be ignored.\n     *\n     * If an error argument is provided, then it will be emitted in an\n     * 'error' event.\n     */\n    destroy(er) {\n        if (this[DESTROYED]) {\n            if (er)\n                this.emit('error', er);\n            else\n                this.emit(DESTROYED);\n            return this;\n        }\n        this[DESTROYED] = true;\n        this[DISCARDED] = true;\n        // throw away all buffered data, it's never coming out\n        this[BUFFER].length = 0;\n        this[BUFFERLENGTH] = 0;\n        const wc = this;\n        if (typeof wc.close === 'function' && !this[CLOSED])\n            wc.close();\n        if (er)\n            this.emit('error', er);\n        // if no error to emit, still reject pending promises\n        else\n            this.emit(DESTROYED);\n        return this;\n    }\n    /**\n     * Alias for {@link isStream}\n     *\n     * Former export location, maintained for backwards compatibility.\n     *\n     * @deprecated\n     */\n    static get isStream() {\n        return exports.isStream;\n    }\n}\nexports.Minipass = Minipass;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbWluaXBhc3MvZGlzdC9jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0EsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLGtCQUFrQixHQUFHLGdCQUFnQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMzQyxzQ0FBc0MsbUJBQU8sQ0FBQyxnQ0FBYTtBQUMzRCw4QkFBOEIsbUJBQU8sQ0FBQyxnREFBcUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLCtCQUErQjtBQUM1QztBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHlDQUF5QztBQUNqRCxRQUFRLHNDQUFzQztBQUM5QztBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QseUJBQXlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCx3QkFBd0I7QUFDM0U7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRHQUE0Ryw4QkFBOEI7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVCQUF1QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSx1QkFBdUI7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHVCQUF1QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLHlCQUF5QjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwQkFBMEI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDhCQUE4QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQiIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9taW5pcGFzcy9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5NaW5pcGFzcyA9IGV4cG9ydHMuaXNXcml0YWJsZSA9IGV4cG9ydHMuaXNSZWFkYWJsZSA9IGV4cG9ydHMuaXNTdHJlYW0gPSB2b2lkIDA7XG5jb25zdCBwcm9jID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3NcbiAgICA/IHByb2Nlc3NcbiAgICA6IHtcbiAgICAgICAgc3Rkb3V0OiBudWxsLFxuICAgICAgICBzdGRlcnI6IG51bGwsXG4gICAgfTtcbmNvbnN0IG5vZGVfZXZlbnRzXzEgPSByZXF1aXJlKFwibm9kZTpldmVudHNcIik7XG5jb25zdCBub2RlX3N0cmVhbV8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJub2RlOnN0cmVhbVwiKSk7XG5jb25zdCBub2RlX3N0cmluZ19kZWNvZGVyXzEgPSByZXF1aXJlKFwibm9kZTpzdHJpbmdfZGVjb2RlclwiKTtcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgdGhlIGFyZ3VtZW50IGlzIGEgTWluaXBhc3Mgc3RyZWFtLCBOb2RlIHN0cmVhbSwgb3Igc29tZXRoaW5nXG4gKiBlbHNlIHRoYXQgTWluaXBhc3MgY2FuIGludGVyYWN0IHdpdGguXG4gKi9cbmNvbnN0IGlzU3RyZWFtID0gKHMpID0+ICEhcyAmJlxuICAgIHR5cGVvZiBzID09PSAnb2JqZWN0JyAmJlxuICAgIChzIGluc3RhbmNlb2YgTWluaXBhc3MgfHxcbiAgICAgICAgcyBpbnN0YW5jZW9mIG5vZGVfc3RyZWFtXzEuZGVmYXVsdCB8fFxuICAgICAgICAoMCwgZXhwb3J0cy5pc1JlYWRhYmxlKShzKSB8fFxuICAgICAgICAoMCwgZXhwb3J0cy5pc1dyaXRhYmxlKShzKSk7XG5leHBvcnRzLmlzU3RyZWFtID0gaXNTdHJlYW07XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhIHZhbGlkIHtAbGluayBNaW5pcGFzcy5SZWFkYWJsZX1cbiAqL1xuY29uc3QgaXNSZWFkYWJsZSA9IChzKSA9PiAhIXMgJiZcbiAgICB0eXBlb2YgcyA9PT0gJ29iamVjdCcgJiZcbiAgICBzIGluc3RhbmNlb2Ygbm9kZV9ldmVudHNfMS5FdmVudEVtaXR0ZXIgJiZcbiAgICB0eXBlb2Ygcy5waXBlID09PSAnZnVuY3Rpb24nICYmXG4gICAgLy8gbm9kZSBjb3JlIFdyaXRhYmxlIHN0cmVhbXMgaGF2ZSBhIHBpcGUoKSBtZXRob2QsIGJ1dCBpdCB0aHJvd3NcbiAgICBzLnBpcGUgIT09IG5vZGVfc3RyZWFtXzEuZGVmYXVsdC5Xcml0YWJsZS5wcm90b3R5cGUucGlwZTtcbmV4cG9ydHMuaXNSZWFkYWJsZSA9IGlzUmVhZGFibGU7XG4vKipcbiAqIFJldHVybiB0cnVlIGlmIHRoZSBhcmd1bWVudCBpcyBhIHZhbGlkIHtAbGluayBNaW5pcGFzcy5Xcml0YWJsZX1cbiAqL1xuY29uc3QgaXNXcml0YWJsZSA9IChzKSA9PiAhIXMgJiZcbiAgICB0eXBlb2YgcyA9PT0gJ29iamVjdCcgJiZcbiAgICBzIGluc3RhbmNlb2Ygbm9kZV9ldmVudHNfMS5FdmVudEVtaXR0ZXIgJiZcbiAgICB0eXBlb2Ygcy53cml0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIHR5cGVvZiBzLmVuZCA9PT0gJ2Z1bmN0aW9uJztcbmV4cG9ydHMuaXNXcml0YWJsZSA9IGlzV3JpdGFibGU7XG5jb25zdCBFT0YgPSBTeW1ib2woJ0VPRicpO1xuY29uc3QgTUFZQkVfRU1JVF9FTkQgPSBTeW1ib2woJ21heWJlRW1pdEVuZCcpO1xuY29uc3QgRU1JVFRFRF9FTkQgPSBTeW1ib2woJ2VtaXR0ZWRFbmQnKTtcbmNvbnN0IEVNSVRUSU5HX0VORCA9IFN5bWJvbCgnZW1pdHRpbmdFbmQnKTtcbmNvbnN0IEVNSVRURURfRVJST1IgPSBTeW1ib2woJ2VtaXR0ZWRFcnJvcicpO1xuY29uc3QgQ0xPU0VEID0gU3ltYm9sKCdjbG9zZWQnKTtcbmNvbnN0IFJFQUQgPSBTeW1ib2woJ3JlYWQnKTtcbmNvbnN0IEZMVVNIID0gU3ltYm9sKCdmbHVzaCcpO1xuY29uc3QgRkxVU0hDSFVOSyA9IFN5bWJvbCgnZmx1c2hDaHVuaycpO1xuY29uc3QgRU5DT0RJTkcgPSBTeW1ib2woJ2VuY29kaW5nJyk7XG5jb25zdCBERUNPREVSID0gU3ltYm9sKCdkZWNvZGVyJyk7XG5jb25zdCBGTE9XSU5HID0gU3ltYm9sKCdmbG93aW5nJyk7XG5jb25zdCBQQVVTRUQgPSBTeW1ib2woJ3BhdXNlZCcpO1xuY29uc3QgUkVTVU1FID0gU3ltYm9sKCdyZXN1bWUnKTtcbmNvbnN0IEJVRkZFUiA9IFN5bWJvbCgnYnVmZmVyJyk7XG5jb25zdCBQSVBFUyA9IFN5bWJvbCgncGlwZXMnKTtcbmNvbnN0IEJVRkZFUkxFTkdUSCA9IFN5bWJvbCgnYnVmZmVyTGVuZ3RoJyk7XG5jb25zdCBCVUZGRVJQVVNIID0gU3ltYm9sKCdidWZmZXJQdXNoJyk7XG5jb25zdCBCVUZGRVJTSElGVCA9IFN5bWJvbCgnYnVmZmVyU2hpZnQnKTtcbmNvbnN0IE9CSkVDVE1PREUgPSBTeW1ib2woJ29iamVjdE1vZGUnKTtcbi8vIGludGVybmFsIGV2ZW50IHdoZW4gc3RyZWFtIGlzIGRlc3Ryb3llZFxuY29uc3QgREVTVFJPWUVEID0gU3ltYm9sKCdkZXN0cm95ZWQnKTtcbi8vIGludGVybmFsIGV2ZW50IHdoZW4gc3RyZWFtIGhhcyBhbiBlcnJvclxuY29uc3QgRVJST1IgPSBTeW1ib2woJ2Vycm9yJyk7XG5jb25zdCBFTUlUREFUQSA9IFN5bWJvbCgnZW1pdERhdGEnKTtcbmNvbnN0IEVNSVRFTkQgPSBTeW1ib2woJ2VtaXRFbmQnKTtcbmNvbnN0IEVNSVRFTkQyID0gU3ltYm9sKCdlbWl0RW5kMicpO1xuY29uc3QgQVNZTkMgPSBTeW1ib2woJ2FzeW5jJyk7XG5jb25zdCBBQk9SVCA9IFN5bWJvbCgnYWJvcnQnKTtcbmNvbnN0IEFCT1JURUQgPSBTeW1ib2woJ2Fib3J0ZWQnKTtcbmNvbnN0IFNJR05BTCA9IFN5bWJvbCgnc2lnbmFsJyk7XG5jb25zdCBEQVRBTElTVEVORVJTID0gU3ltYm9sKCdkYXRhTGlzdGVuZXJzJyk7XG5jb25zdCBESVNDQVJERUQgPSBTeW1ib2woJ2Rpc2NhcmRlZCcpO1xuY29uc3QgZGVmZXIgPSAoZm4pID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm4pO1xuY29uc3Qgbm9kZWZlciA9IChmbikgPT4gZm4oKTtcbmNvbnN0IGlzRW5kaXNoID0gKGV2KSA9PiBldiA9PT0gJ2VuZCcgfHwgZXYgPT09ICdmaW5pc2gnIHx8IGV2ID09PSAncHJlZmluaXNoJztcbmNvbnN0IGlzQXJyYXlCdWZmZXJMaWtlID0gKGIpID0+IGIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgICghIWIgJiZcbiAgICAgICAgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmXG4gICAgICAgIGIuY29uc3RydWN0b3IgJiZcbiAgICAgICAgYi5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInICYmXG4gICAgICAgIGIuYnl0ZUxlbmd0aCA+PSAwKTtcbmNvbnN0IGlzQXJyYXlCdWZmZXJWaWV3ID0gKGIpID0+ICFCdWZmZXIuaXNCdWZmZXIoYikgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KGIpO1xuLyoqXG4gKiBJbnRlcm5hbCBjbGFzcyByZXByZXNlbnRpbmcgYSBwaXBlIHRvIGEgZGVzdGluYXRpb24gc3RyZWFtLlxuICpcbiAqIEBpbnRlcm5hbFxuICovXG5jbGFzcyBQaXBlIHtcbiAgICBzcmM7XG4gICAgZGVzdDtcbiAgICBvcHRzO1xuICAgIG9uZHJhaW47XG4gICAgY29uc3RydWN0b3Ioc3JjLCBkZXN0LCBvcHRzKSB7XG4gICAgICAgIHRoaXMuc3JjID0gc3JjO1xuICAgICAgICB0aGlzLmRlc3QgPSBkZXN0O1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICB0aGlzLm9uZHJhaW4gPSAoKSA9PiBzcmNbUkVTVU1FXSgpO1xuICAgICAgICB0aGlzLmRlc3Qub24oJ2RyYWluJywgdGhpcy5vbmRyYWluKTtcbiAgICB9XG4gICAgdW5waXBlKCkge1xuICAgICAgICB0aGlzLmRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgdGhpcy5vbmRyYWluKTtcbiAgICB9XG4gICAgLy8gb25seSBoZXJlIGZvciB0aGUgcHJvdG90eXBlXG4gICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgcHJveHlFcnJvcnMoX2VyKSB7IH1cbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIGVuZCgpIHtcbiAgICAgICAgdGhpcy51bnBpcGUoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0cy5lbmQpXG4gICAgICAgICAgICB0aGlzLmRlc3QuZW5kKCk7XG4gICAgfVxufVxuLyoqXG4gKiBJbnRlcm5hbCBjbGFzcyByZXByZXNlbnRpbmcgYSBwaXBlIHRvIGEgZGVzdGluYXRpb24gc3RyZWFtIHdoZXJlXG4gKiBlcnJvcnMgYXJlIHByb3hpZWQuXG4gKlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIFBpcGVQcm94eUVycm9ycyBleHRlbmRzIFBpcGUge1xuICAgIHVucGlwZSgpIHtcbiAgICAgICAgdGhpcy5zcmMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycyk7XG4gICAgICAgIHN1cGVyLnVucGlwZSgpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihzcmMsIGRlc3QsIG9wdHMpIHtcbiAgICAgICAgc3VwZXIoc3JjLCBkZXN0LCBvcHRzKTtcbiAgICAgICAgdGhpcy5wcm94eUVycm9ycyA9IGVyID0+IGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICAgIHNyYy5vbignZXJyb3InLCB0aGlzLnByb3h5RXJyb3JzKTtcbiAgICB9XG59XG5jb25zdCBpc09iamVjdE1vZGVPcHRpb25zID0gKG8pID0+ICEhby5vYmplY3RNb2RlO1xuY29uc3QgaXNFbmNvZGluZ09wdGlvbnMgPSAobykgPT4gIW8ub2JqZWN0TW9kZSAmJiAhIW8uZW5jb2RpbmcgJiYgby5lbmNvZGluZyAhPT0gJ2J1ZmZlcic7XG4vKipcbiAqIE1haW4gZXhwb3J0LCB0aGUgTWluaXBhc3MgY2xhc3NcbiAqXG4gKiBgUlR5cGVgIGlzIHRoZSB0eXBlIG9mIGRhdGEgZW1pdHRlZCwgZGVmYXVsdHMgdG8gQnVmZmVyXG4gKlxuICogYFdUeXBlYCBpcyB0aGUgdHlwZSBvZiBkYXRhIHRvIGJlIHdyaXR0ZW4sIGlmIFJUeXBlIGlzIGJ1ZmZlciBvciBzdHJpbmcsXG4gKiB0aGVuIGFueSB7QGxpbmsgTWluaXBhc3MuQ29udGlndW91c0RhdGF9IGlzIGFsbG93ZWQuXG4gKlxuICogYEV2ZW50c2AgaXMgdGhlIHNldCBvZiBldmVudCBoYW5kbGVyIHNpZ25hdHVyZXMgdGhhdCB0aGlzIG9iamVjdFxuICogd2lsbCBlbWl0LCBzZWUge0BsaW5rIE1pbmlwYXNzLkV2ZW50c31cbiAqL1xuY2xhc3MgTWluaXBhc3MgZXh0ZW5kcyBub2RlX2V2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgW0ZMT1dJTkddID0gZmFsc2U7XG4gICAgW1BBVVNFRF0gPSBmYWxzZTtcbiAgICBbUElQRVNdID0gW107XG4gICAgW0JVRkZFUl0gPSBbXTtcbiAgICBbT0JKRUNUTU9ERV07XG4gICAgW0VOQ09ESU5HXTtcbiAgICBbQVNZTkNdO1xuICAgIFtERUNPREVSXTtcbiAgICBbRU9GXSA9IGZhbHNlO1xuICAgIFtFTUlUVEVEX0VORF0gPSBmYWxzZTtcbiAgICBbRU1JVFRJTkdfRU5EXSA9IGZhbHNlO1xuICAgIFtDTE9TRURdID0gZmFsc2U7XG4gICAgW0VNSVRURURfRVJST1JdID0gbnVsbDtcbiAgICBbQlVGRkVSTEVOR1RIXSA9IDA7XG4gICAgW0RFU1RST1lFRF0gPSBmYWxzZTtcbiAgICBbU0lHTkFMXTtcbiAgICBbQUJPUlRFRF0gPSBmYWxzZTtcbiAgICBbREFUQUxJU1RFTkVSU10gPSAwO1xuICAgIFtESVNDQVJERURdID0gZmFsc2U7XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgc3RyZWFtIGNhbiBiZSB3cml0dGVuXG4gICAgICovXG4gICAgd3JpdGFibGUgPSB0cnVlO1xuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhlIHN0cmVhbSBjYW4gYmUgcmVhZFxuICAgICAqL1xuICAgIHJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvKipcbiAgICAgKiBJZiBgUlR5cGVgIGlzIEJ1ZmZlciwgdGhlbiBvcHRpb25zIGRvIG5vdCBuZWVkIHRvIGJlIHByb3ZpZGVkLlxuICAgICAqIE90aGVyd2lzZSwgYW4gb3B0aW9ucyBvYmplY3QgbXVzdCBiZSBwcm92aWRlZCB0byBzcGVjaWZ5IGVpdGhlclxuICAgICAqIHtAbGluayBNaW5pcGFzcy5TaGFyZWRPcHRpb25zLm9iamVjdE1vZGV9IG9yXG4gICAgICoge0BsaW5rIE1pbmlwYXNzLlNoYXJlZE9wdGlvbnMuZW5jb2Rpbmd9LCBhcyBhcHByb3ByaWF0ZS5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvciguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSAoYXJnc1swXSB8fFxuICAgICAgICAgICAge30pO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAob3B0aW9ucy5vYmplY3RNb2RlICYmIHR5cGVvZiBvcHRpb25zLmVuY29kaW5nID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRW5jb2RpbmcgYW5kIG9iamVjdE1vZGUgbWF5IG5vdCBiZSB1c2VkIHRvZ2V0aGVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzT2JqZWN0TW9kZU9wdGlvbnMob3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoaXNbT0JKRUNUTU9ERV0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpc1tFTkNPRElOR10gPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRW5jb2RpbmdPcHRpb25zKG9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGlzW0VOQ09ESU5HXSA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gICAgICAgICAgICB0aGlzW09CSkVDVE1PREVdID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzW09CSkVDVE1PREVdID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzW0VOQ09ESU5HXSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tBU1lOQ10gPSAhIW9wdGlvbnMuYXN5bmM7XG4gICAgICAgIHRoaXNbREVDT0RFUl0gPSB0aGlzW0VOQ09ESU5HXVxuICAgICAgICAgICAgPyBuZXcgbm9kZV9zdHJpbmdfZGVjb2Rlcl8xLlN0cmluZ0RlY29kZXIodGhpc1tFTkNPRElOR10pXG4gICAgICAgICAgICA6IG51bGw7XG4gICAgICAgIC8vQHRzLWlnbm9yZSAtIHByaXZhdGUgb3B0aW9uIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmdcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1Z0V4cG9zZUJ1ZmZlciA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdidWZmZXInLCB7IGdldDogKCkgPT4gdGhpc1tCVUZGRVJdIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vQHRzLWlnbm9yZSAtIHByaXZhdGUgb3B0aW9uIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmdcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5kZWJ1Z0V4cG9zZVBpcGVzID09PSB0cnVlKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ3BpcGVzJywgeyBnZXQ6ICgpID0+IHRoaXNbUElQRVNdIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgc2lnbmFsIH0gPSBvcHRpb25zO1xuICAgICAgICBpZiAoc2lnbmFsKSB7XG4gICAgICAgICAgICB0aGlzW1NJR05BTF0gPSBzaWduYWw7XG4gICAgICAgICAgICBpZiAoc2lnbmFsLmFib3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzW0FCT1JUXSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gdGhpc1tBQk9SVF0oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFtb3VudCBvZiBkYXRhIHN0b3JlZCBpbiB0aGUgYnVmZmVyIHdhaXRpbmcgdG8gYmUgcmVhZC5cbiAgICAgKlxuICAgICAqIEZvciBCdWZmZXIgc3RyaW5ncywgdGhpcyB3aWxsIGJlIHRoZSB0b3RhbCBieXRlIGxlbmd0aC5cbiAgICAgKiBGb3Igc3RyaW5nIGVuY29kaW5nIHN0cmVhbXMsIHRoaXMgd2lsbCBiZSB0aGUgc3RyaW5nIGNoYXJhY3RlciBsZW5ndGgsXG4gICAgICogYWNjb3JkaW5nIHRvIEphdmFTY3JpcHQncyBgc3RyaW5nLmxlbmd0aGAgbG9naWMuXG4gICAgICogRm9yIG9iamVjdE1vZGUgc3RyZWFtcywgdGhpcyBpcyBhIGNvdW50IG9mIHRoZSBpdGVtcyB3YWl0aW5nIHRvIGJlXG4gICAgICogZW1pdHRlZC5cbiAgICAgKi9cbiAgICBnZXQgYnVmZmVyTGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tCVUZGRVJMRU5HVEhdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYEJ1ZmZlckVuY29kaW5nYCBjdXJyZW50bHkgaW4gdXNlLCBvciBgbnVsbGBcbiAgICAgKi9cbiAgICBnZXQgZW5jb2RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0VOQ09ESU5HXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgLSBUaGlzIGlzIGEgcmVhZCBvbmx5IHByb3BlcnR5XG4gICAgICovXG4gICAgc2V0IGVuY29kaW5nKF9lbmMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFbmNvZGluZyBtdXN0IGJlIHNldCBhdCBpbnN0YW50aWF0aW9uIHRpbWUnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgLSBFbmNvZGluZyBtYXkgb25seSBiZSBzZXQgYXQgaW5zdGFudGlhdGlvbiB0aW1lXG4gICAgICovXG4gICAgc2V0RW5jb2RpbmcoX2VuYykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY29kaW5nIG11c3QgYmUgc2V0IGF0IGluc3RhbnRpYXRpb24gdGltZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcnVlIGlmIHRoaXMgaXMgYW4gb2JqZWN0TW9kZSBzdHJlYW1cbiAgICAgKi9cbiAgICBnZXQgb2JqZWN0TW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbT0JKRUNUTU9ERV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIC0gVGhpcyBpcyBhIHJlYWQtb25seSBwcm9wZXJ0eVxuICAgICAqL1xuICAgIHNldCBvYmplY3RNb2RlKF9vbSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29iamVjdE1vZGUgbXVzdCBiZSBzZXQgYXQgaW5zdGFudGlhdGlvbiB0aW1lJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHRydWUgaWYgdGhpcyBpcyBhbiBhc3luYyBzdHJlYW1cbiAgICAgKi9cbiAgICBnZXQgWydhc3luYyddKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tBU1lOQ107XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCB0byB0cnVlIHRvIG1ha2UgdGhpcyBzdHJlYW0gYXN5bmMuXG4gICAgICpcbiAgICAgKiBPbmNlIHNldCwgaXQgY2Fubm90IGJlIHVuc2V0LCBhcyB0aGlzIHdvdWxkIHBvdGVudGlhbGx5IGNhdXNlIGluY29ycmVjdFxuICAgICAqIGJlaGF2aW9yLiAgSWUsIGEgc3luYyBzdHJlYW0gY2FuIGJlIG1hZGUgYXN5bmMsIGJ1dCBhbiBhc3luYyBzdHJlYW1cbiAgICAgKiBjYW5ub3QgYmUgc2FmZWx5IG1hZGUgc3luYy5cbiAgICAgKi9cbiAgICBzZXQgWydhc3luYyddKGEpIHtcbiAgICAgICAgdGhpc1tBU1lOQ10gPSB0aGlzW0FTWU5DXSB8fCAhIWE7XG4gICAgfVxuICAgIC8vIGRyb3AgZXZlcnl0aGluZyBhbmQgZ2V0IG91dCBvZiB0aGUgZmxvdyBjb21wbGV0ZWx5XG4gICAgW0FCT1JUXSgpIHtcbiAgICAgICAgdGhpc1tBQk9SVEVEXSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdCgnYWJvcnQnLCB0aGlzW1NJR05BTF0/LnJlYXNvbik7XG4gICAgICAgIHRoaXMuZGVzdHJveSh0aGlzW1NJR05BTF0/LnJlYXNvbik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRydWUgaWYgdGhlIHN0cmVhbSBoYXMgYmVlbiBhYm9ydGVkLlxuICAgICAqL1xuICAgIGdldCBhYm9ydGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tBQk9SVEVEXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTm8tb3Agc2V0dGVyLiBTdHJlYW0gYWJvcnRlZCBzdGF0dXMgaXMgc2V0IHZpYSB0aGUgQWJvcnRTaWduYWwgcHJvdmlkZWRcbiAgICAgKiBpbiB0aGUgY29uc3RydWN0b3Igb3B0aW9ucy5cbiAgICAgKi9cbiAgICBzZXQgYWJvcnRlZChfKSB7IH1cbiAgICB3cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgICAgIGlmICh0aGlzW0FCT1JURURdKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAodGhpc1tFT0ZdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgICAgICAgaWYgKHRoaXNbREVTVFJPWUVEXSkge1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIE9iamVjdC5hc3NpZ24obmV3IEVycm9yKCdDYW5ub3QgY2FsbCB3cml0ZSBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJyksIHsgY29kZTogJ0VSUl9TVFJFQU1fREVTVFJPWUVEJyB9KSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGVuY29kaW5nO1xuICAgICAgICAgICAgZW5jb2RpbmcgPSAndXRmOCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFlbmNvZGluZylcbiAgICAgICAgICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgICAgICBjb25zdCBmbiA9IHRoaXNbQVNZTkNdID8gZGVmZXIgOiBub2RlZmVyO1xuICAgICAgICAvLyBjb252ZXJ0IGFycmF5IGJ1ZmZlcnMgYW5kIHR5cGVkIGFycmF5IHZpZXdzIGludG8gYnVmZmVyc1xuICAgICAgICAvLyBhdCBzb21lIHBvaW50IGluIHRoZSBmdXR1cmUsIHdlIG1heSB3YW50IHRvIGRvIHRoZSBvcHBvc2l0ZSFcbiAgICAgICAgLy8gbGVhdmUgc3RyaW5ncyBhbmQgYnVmZmVycyBhcy1pc1xuICAgICAgICAvLyBhbnl0aGluZyBpcyBvbmx5IGFsbG93ZWQgaWYgaW4gb2JqZWN0IG1vZGUsIHNvIHRocm93XG4gICAgICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgICAgICAgICAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KGNodW5rKSkge1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZSAtIHNpbmZ1bCB1bnNhZmUgdHlwZSBjaGFuZ2luZ1xuICAgICAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmsuYnVmZmVyLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlCdWZmZXJMaWtlKGNodW5rKSkge1xuICAgICAgICAgICAgICAgIC8vQHRzLWlnbm9yZSAtIHNpbmZ1bCB1bnNhZmUgdHlwZSBjaGFuZ2luZ1xuICAgICAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uLWNvbnRpZ3VvdXMgZGF0YSB3cml0dGVuIHRvIG5vbi1vYmplY3RNb2RlIHN0cmVhbScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIGhhbmRsZSBvYmplY3QgbW9kZSB1cCBmcm9udCwgc2luY2UgaXQncyBzaW1wbGVyXG4gICAgICAgIC8vIHRoaXMgeWllbGRzIGJldHRlciBwZXJmb3JtYW5jZSwgZmV3ZXIgY2hlY2tzIGxhdGVyLlxuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSkge1xuICAgICAgICAgICAgLy8gbWF5YmUgaW1wb3NzaWJsZT9cbiAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgaWYgKHRoaXNbRkxPV0lOR10gJiYgdGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICAgICAgICAgIHRoaXNbRkxVU0hdKHRydWUpO1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIGlmICh0aGlzW0ZMT1dJTkddKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzW0JVRkZFUlBVU0hdKGNodW5rKTtcbiAgICAgICAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgICAgICAgaWYgKGNiKVxuICAgICAgICAgICAgICAgIGZuKGNiKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0ZMT1dJTkddO1xuICAgICAgICB9XG4gICAgICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIGNodW5rIGlzIGEgYnVmZmVyIG9yIHN0cmluZ1xuICAgICAgICAvLyBkb24ndCBidWZmZXIgaXQgdXAgb3Igc2VuZCBpdCB0byB0aGUgZGVjb2RlclxuICAgICAgICBpZiAoIWNodW5rLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICAgICAgZm4oY2IpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXNbRkxPV0lOR107XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmFzdC1wYXRoIHdyaXRpbmcgc3RyaW5ncyBvZiBzYW1lIGVuY29kaW5nIHRvIGEgc3RyZWFtIHdpdGhcbiAgICAgICAgLy8gYW4gZW1wdHkgYnVmZmVyLCBza2lwcGluZyB0aGUgYnVmZmVyL2RlY29kZXIgZGFuY2VcbiAgICAgICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIC8vIHVubGVzcyBpdCBpcyBhIHN0cmluZyBhbHJlYWR5IHJlYWR5IGZvciB1cyB0byB1c2VcbiAgICAgICAgICAgICEoZW5jb2RpbmcgPT09IHRoaXNbRU5DT0RJTkddICYmICF0aGlzW0RFQ09ERVJdPy5sYXN0TmVlZCkpIHtcbiAgICAgICAgICAgIC8vQHRzLWlnbm9yZSAtIHNpbmZ1bCB1bnNhZmUgdHlwZSBjaGFuZ2VcbiAgICAgICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGNodW5rKSAmJiB0aGlzW0VOQ09ESU5HXSkge1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlIC0gc2luZnVsIHVuc2FmZSB0eXBlIGNoYW5nZVxuICAgICAgICAgICAgY2h1bmsgPSB0aGlzW0RFQ09ERVJdLndyaXRlKGNodW5rKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3RlOiBmbHVzaGluZyBDQU4gcG90ZW50aWFsbHkgc3dpdGNoIHVzIGludG8gbm90LWZsb3dpbmcgbW9kZVxuICAgICAgICBpZiAodGhpc1tGTE9XSU5HXSAmJiB0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgICAgICB0aGlzW0ZMVVNIXSh0cnVlKTtcbiAgICAgICAgaWYgKHRoaXNbRkxPV0lOR10pXG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSUFVTSF0oY2h1bmspO1xuICAgICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICBmbihjYik7XG4gICAgICAgIHJldHVybiB0aGlzW0ZMT1dJTkddO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb3ctbGV2ZWwgZXhwbGljaXQgcmVhZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBJbiBvYmplY3RNb2RlLCB0aGUgYXJndW1lbnQgaXMgaWdub3JlZCwgYW5kIG9uZSBpdGVtIGlzIHJldHVybmVkIGlmXG4gICAgICogYXZhaWxhYmxlLlxuICAgICAqXG4gICAgICogYG5gIGlzIHRoZSBudW1iZXIgb2YgYnl0ZXMgKG9yIGluIHRoZSBjYXNlIG9mIGVuY29kaW5nIHN0cmVhbXMsXG4gICAgICogY2hhcmFjdGVycykgdG8gY29uc3VtZS4gSWYgYG5gIGlzIG5vdCBwcm92aWRlZCwgdGhlbiB0aGUgZW50aXJlIGJ1ZmZlclxuICAgICAqIGlzIHJldHVybmVkLCBvciBgbnVsbGAgaXMgcmV0dXJuZWQgaWYgbm8gZGF0YSBpcyBhdmFpbGFibGUuXG4gICAgICpcbiAgICAgKiBJZiBgbmAgaXMgZ3JlYXRlciB0aGF0IHRoZSBhbW91bnQgb2YgZGF0YSBpbiB0aGUgaW50ZXJuYWwgYnVmZmVyLFxuICAgICAqIHRoZW4gYG51bGxgIGlzIHJldHVybmVkLlxuICAgICAqL1xuICAgIHJlYWQobikge1xuICAgICAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdID09PSAwIHx8XG4gICAgICAgICAgICBuID09PSAwIHx8XG4gICAgICAgICAgICAobiAmJiBuID4gdGhpc1tCVUZGRVJMRU5HVEhdKSkge1xuICAgICAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICAgICAgbiA9IG51bGw7XG4gICAgICAgIGlmICh0aGlzW0JVRkZFUl0ubGVuZ3RoID4gMSAmJiAhdGhpc1tPQkpFQ1RNT0RFXSkge1xuICAgICAgICAgICAgLy8gbm90IG9iamVjdCBtb2RlLCBzbyBpZiB3ZSBoYXZlIGFuIGVuY29kaW5nLCB0aGVuIFJUeXBlIGlzIHN0cmluZ1xuICAgICAgICAgICAgLy8gb3RoZXJ3aXNlLCBtdXN0IGJlIEJ1ZmZlclxuICAgICAgICAgICAgdGhpc1tCVUZGRVJdID0gW1xuICAgICAgICAgICAgICAgICh0aGlzW0VOQ09ESU5HXVxuICAgICAgICAgICAgICAgICAgICA/IHRoaXNbQlVGRkVSXS5qb2luKCcnKVxuICAgICAgICAgICAgICAgICAgICA6IEJ1ZmZlci5jb25jYXQodGhpc1tCVUZGRVJdLCB0aGlzW0JVRkZFUkxFTkdUSF0pKSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmV0ID0gdGhpc1tSRUFEXShuIHx8IG51bGwsIHRoaXNbQlVGRkVSXVswXSk7XG4gICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIFtSRUFEXShuLCBjaHVuaykge1xuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSU0hJRlRdKCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgYyA9IGNodW5rO1xuICAgICAgICAgICAgaWYgKG4gPT09IGMubGVuZ3RoIHx8IG4gPT09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJTSElGVF0oKTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSXVswXSA9IGMuc2xpY2Uobik7XG4gICAgICAgICAgICAgICAgY2h1bmsgPSBjLnNsaWNlKDAsIG4pO1xuICAgICAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSBuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJdWzBdID0gYy5zdWJhcnJheShuKTtcbiAgICAgICAgICAgICAgICBjaHVuayA9IGMuc3ViYXJyYXkoMCwgbik7XG4gICAgICAgICAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IG47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICBpZiAoIXRoaXNbQlVGRkVSXS5sZW5ndGggJiYgIXRoaXNbRU9GXSlcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgICAgICAgcmV0dXJuIGNodW5rO1xuICAgIH1cbiAgICBlbmQoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYiA9IGNodW5rO1xuICAgICAgICAgICAgY2h1bmsgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2IgPSBlbmNvZGluZztcbiAgICAgICAgICAgIGVuY29kaW5nID0gJ3V0ZjgnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaHVuayAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIGNiKTtcbiAgICAgICAgdGhpc1tFT0ZdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlbid0IHdyaXR0ZW4gYW55dGhpbmcsIHRoZW4gZ28gYWhlYWQgYW5kIGVtaXQsXG4gICAgICAgIC8vIGV2ZW4gaWYgd2UncmUgbm90IHJlYWRpbmcuXG4gICAgICAgIC8vIHdlJ2xsIHJlLWVtaXQgaWYgYSBuZXcgJ2VuZCcgbGlzdGVuZXIgaXMgYWRkZWQgYW55d2F5LlxuICAgICAgICAvLyBUaGlzIG1ha2VzIE1QIG1vcmUgc3VpdGFibGUgdG8gd3JpdGUtb25seSB1c2UgY2FzZXMuXG4gICAgICAgIGlmICh0aGlzW0ZMT1dJTkddIHx8ICF0aGlzW1BBVVNFRF0pXG4gICAgICAgICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gZG9uJ3QgbGV0IHRoZSBpbnRlcm5hbCByZXN1bWUgYmUgb3ZlcndyaXR0ZW5cbiAgICBbUkVTVU1FXSgpIHtcbiAgICAgICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKCF0aGlzW0RBVEFMSVNURU5FUlNdICYmICF0aGlzW1BJUEVTXS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpc1tQQVVTRURdID0gZmFsc2U7XG4gICAgICAgIHRoaXNbRkxPV0lOR10gPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoJ3Jlc3VtZScpO1xuICAgICAgICBpZiAodGhpc1tCVUZGRVJdLmxlbmd0aClcbiAgICAgICAgICAgIHRoaXNbRkxVU0hdKCk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXNbRU9GXSlcbiAgICAgICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdW1lIHRoZSBzdHJlYW0gaWYgaXQgaXMgY3VycmVudGx5IGluIGEgcGF1c2VkIHN0YXRlXG4gICAgICpcbiAgICAgKiBJZiBjYWxsZWQgd2hlbiB0aGVyZSBhcmUgbm8gcGlwZSBkZXN0aW5hdGlvbnMgb3IgYGRhdGFgIGV2ZW50IGxpc3RlbmVycyxcbiAgICAgKiB0aGlzIHdpbGwgcGxhY2UgdGhlIHN0cmVhbSBpbiBhIFwiZGlzY2FyZGVkXCIgc3RhdGUsIHdoZXJlIGFsbCBkYXRhIHdpbGxcbiAgICAgKiBiZSB0aHJvd24gYXdheS4gVGhlIGRpc2NhcmRlZCBzdGF0ZSBpcyByZW1vdmVkIGlmIGEgcGlwZSBkZXN0aW5hdGlvbiBvclxuICAgICAqIGRhdGEgaGFuZGxlciBpcyBhZGRlZCwgaWYgcGF1c2UoKSBpcyBjYWxsZWQsIG9yIGlmIGFueSBzeW5jaHJvbm91cyBvclxuICAgICAqIGFzeW5jaHJvbm91cyBpdGVyYXRpb24gaXMgc3RhcnRlZC5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW1JFU1VNRV0oKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2UgdGhlIHN0cmVhbVxuICAgICAqL1xuICAgIHBhdXNlKCkge1xuICAgICAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2U7XG4gICAgICAgIHRoaXNbUEFVU0VEXSA9IHRydWU7XG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSBzdHJlYW0gaGFzIGJlZW4gZm9yY2libHkgZGVzdHJveWVkXG4gICAgICovXG4gICAgZ2V0IGRlc3Ryb3llZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbREVTVFJPWUVEXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBpbiBhIGZsb3dpbmcgc3RhdGUsIG1lYW5pbmcgdGhhdFxuICAgICAqIGFueSB3cml0ZXMgd2lsbCBiZSBpbW1lZGlhdGVseSBlbWl0dGVkLlxuICAgICAqL1xuICAgIGdldCBmbG93aW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpc1tGTE9XSU5HXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogdHJ1ZSBpZiB0aGUgc3RyZWFtIGlzIGN1cnJlbnRseSBpbiBhIHBhdXNlZCBzdGF0ZVxuICAgICAqL1xuICAgIGdldCBwYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW1BBVVNFRF07XG4gICAgfVxuICAgIFtCVUZGRVJQVVNIXShjaHVuaykge1xuICAgICAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSArPSAxO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB0aGlzW0JVRkZFUl0ucHVzaChjaHVuayk7XG4gICAgfVxuICAgIFtCVUZGRVJTSElGVF0oKSB7XG4gICAgICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgICAgICAgdGhpc1tCVUZGRVJMRU5HVEhdIC09IDE7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSB0aGlzW0JVRkZFUl1bMF0ubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpc1tCVUZGRVJdLnNoaWZ0KCk7XG4gICAgfVxuICAgIFtGTFVTSF0obm9EcmFpbiA9IGZhbHNlKSB7XG4gICAgICAgIGRvIHsgfSB3aGlsZSAodGhpc1tGTFVTSENIVU5LXSh0aGlzW0JVRkZFUlNISUZUXSgpKSAmJlxuICAgICAgICAgICAgdGhpc1tCVUZGRVJdLmxlbmd0aCk7XG4gICAgICAgIGlmICghbm9EcmFpbiAmJiAhdGhpc1tCVUZGRVJdLmxlbmd0aCAmJiAhdGhpc1tFT0ZdKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdkcmFpbicpO1xuICAgIH1cbiAgICBbRkxVU0hDSFVOS10oY2h1bmspIHtcbiAgICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgICAgICByZXR1cm4gdGhpc1tGTE9XSU5HXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGlwZSBhbGwgZGF0YSBlbWl0dGVkIGJ5IHRoaXMgc3RyZWFtIGludG8gdGhlIGRlc3RpbmF0aW9uIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogVHJpZ2dlcnMgdGhlIGZsb3cgb2YgZGF0YS5cbiAgICAgKi9cbiAgICBwaXBlKGRlc3QsIG9wdHMpIHtcbiAgICAgICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgICAgIHJldHVybiBkZXN0O1xuICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAgICAgY29uc3QgZW5kZWQgPSB0aGlzW0VNSVRURURfRU5EXTtcbiAgICAgICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgICAgIGlmIChkZXN0ID09PSBwcm9jLnN0ZG91dCB8fCBkZXN0ID09PSBwcm9jLnN0ZGVycilcbiAgICAgICAgICAgIG9wdHMuZW5kID0gZmFsc2U7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIG9wdHMuZW5kID0gb3B0cy5lbmQgIT09IGZhbHNlO1xuICAgICAgICBvcHRzLnByb3h5RXJyb3JzID0gISFvcHRzLnByb3h5RXJyb3JzO1xuICAgICAgICAvLyBwaXBpbmcgYW4gZW5kZWQgc3RyZWFtIGVuZHMgaW1tZWRpYXRlbHlcbiAgICAgICAgaWYgKGVuZGVkKSB7XG4gICAgICAgICAgICBpZiAob3B0cy5lbmQpXG4gICAgICAgICAgICAgICAgZGVzdC5lbmQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFwiYXNcIiBoZXJlIGp1c3QgaWdub3JlcyB0aGUgV1R5cGUsIHdoaWNoIHBpcGVzIGRvbid0IGNhcmUgYWJvdXQsXG4gICAgICAgICAgICAvLyBzaW5jZSB0aGV5J3JlIG9ubHkgY29uc3VtaW5nIGZyb20gdXMsIGFuZCB3cml0aW5nIHRvIHRoZSBkZXN0XG4gICAgICAgICAgICB0aGlzW1BJUEVTXS5wdXNoKCFvcHRzLnByb3h5RXJyb3JzXG4gICAgICAgICAgICAgICAgPyBuZXcgUGlwZSh0aGlzLCBkZXN0LCBvcHRzKVxuICAgICAgICAgICAgICAgIDogbmV3IFBpcGVQcm94eUVycm9ycyh0aGlzLCBkZXN0LCBvcHRzKSk7XG4gICAgICAgICAgICBpZiAodGhpc1tBU1lOQ10pXG4gICAgICAgICAgICAgICAgZGVmZXIoKCkgPT4gdGhpc1tSRVNVTUVdKCkpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXNbUkVTVU1FXSgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGdWxseSB1bmhvb2sgYSBwaXBlZCBkZXN0aW5hdGlvbiBzdHJlYW0uXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZGVzdGluYXRpb24gc3RyZWFtIHdhcyB0aGUgb25seSBjb25zdW1lciBvZiB0aGlzIHN0cmVhbSAoaWUsXG4gICAgICogdGhlcmUgYXJlIG5vIG90aGVyIHBpcGVkIGRlc3RpbmF0aW9ucyBvciBgJ2RhdGEnYCBldmVudCBsaXN0ZW5lcnMpXG4gICAgICogdGhlbiB0aGUgZmxvdyBvZiBkYXRhIHdpbGwgc3RvcCB1bnRpbCB0aGVyZSBpcyBhbm90aGVyIGNvbnN1bWVyIG9yXG4gICAgICoge0BsaW5rIE1pbmlwYXNzI3Jlc3VtZX0gaXMgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICovXG4gICAgdW5waXBlKGRlc3QpIHtcbiAgICAgICAgY29uc3QgcCA9IHRoaXNbUElQRVNdLmZpbmQocCA9PiBwLmRlc3QgPT09IGRlc3QpO1xuICAgICAgICBpZiAocCkge1xuICAgICAgICAgICAgaWYgKHRoaXNbUElQRVNdLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzW0ZMT1dJTkddICYmIHRoaXNbREFUQUxJU1RFTkVSU10gPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzW1BJUEVTXSA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXNbUElQRVNdLnNwbGljZSh0aGlzW1BJUEVTXS5pbmRleE9mKHApLCAxKTtcbiAgICAgICAgICAgIHAudW5waXBlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBNaW5pcGFzcyNvbn1cbiAgICAgKi9cbiAgICBhZGRMaXN0ZW5lcihldiwgaGFuZGxlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vbihldiwgaGFuZGxlcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1vc3RseSBpZGVudGljYWwgdG8gYEV2ZW50RW1pdHRlci5vbmAsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgICAqIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRvIHByZXZlbnQgZGF0YSBsb3NzIGFuZCB1bm5lY2Vzc2FyeSBoYW5nczpcbiAgICAgKlxuICAgICAqIC0gQWRkaW5nIGEgJ2RhdGEnIGV2ZW50IGhhbmRsZXIgd2lsbCB0cmlnZ2VyIHRoZSBmbG93IG9mIGRhdGFcbiAgICAgKlxuICAgICAqIC0gQWRkaW5nIGEgJ3JlYWRhYmxlJyBldmVudCBoYW5kbGVyIHdoZW4gdGhlcmUgaXMgZGF0YSB3YWl0aW5nIHRvIGJlIHJlYWRcbiAgICAgKiAgIHdpbGwgY2F1c2UgJ3JlYWRhYmxlJyB0byBiZSBlbWl0dGVkIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogLSBBZGRpbmcgYW4gJ2VuZGlzaCcgZXZlbnQgaGFuZGxlciAoJ2VuZCcsICdmaW5pc2gnLCBldGMuKSB3aGljaCBoYXNcbiAgICAgKiAgIGFscmVhZHkgcGFzc2VkIHdpbGwgY2F1c2UgdGhlIGV2ZW50IHRvIGJlIGVtaXR0ZWQgaW1tZWRpYXRlbHkgYW5kIGFsbFxuICAgICAqICAgaGFuZGxlcnMgcmVtb3ZlZC5cbiAgICAgKlxuICAgICAqIC0gQWRkaW5nIGFuICdlcnJvcicgZXZlbnQgaGFuZGxlciBhZnRlciBhbiBlcnJvciBoYXMgYmVlbiBlbWl0dGVkIHdpbGxcbiAgICAgKiAgIGNhdXNlIHRoZSBldmVudCB0byBiZSByZS1lbWl0dGVkIGltbWVkaWF0ZWx5IHdpdGggdGhlIGVycm9yIHByZXZpb3VzbHlcbiAgICAgKiAgIHJhaXNlZC5cbiAgICAgKi9cbiAgICBvbihldiwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCByZXQgPSBzdXBlci5vbihldiwgaGFuZGxlcik7XG4gICAgICAgIGlmIChldiA9PT0gJ2RhdGEnKSB7XG4gICAgICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXNbREFUQUxJU1RFTkVSU10rKztcbiAgICAgICAgICAgIGlmICghdGhpc1tQSVBFU10ubGVuZ3RoICYmICF0aGlzW0ZMT1dJTkddKSB7XG4gICAgICAgICAgICAgICAgdGhpc1tSRVNVTUVdKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgdGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKSB7XG4gICAgICAgICAgICBzdXBlci5lbWl0KCdyZWFkYWJsZScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRW5kaXNoKGV2KSAmJiB0aGlzW0VNSVRURURfRU5EXSkge1xuICAgICAgICAgICAgc3VwZXIuZW1pdChldik7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdlcnJvcicgJiYgdGhpc1tFTUlUVEVEX0VSUk9SXSkge1xuICAgICAgICAgICAgY29uc3QgaCA9IGhhbmRsZXI7XG4gICAgICAgICAgICBpZiAodGhpc1tBU1lOQ10pXG4gICAgICAgICAgICAgICAgZGVmZXIoKCkgPT4gaC5jYWxsKHRoaXMsIHRoaXNbRU1JVFRFRF9FUlJPUl0pKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBoLmNhbGwodGhpcywgdGhpc1tFTUlUVEVEX0VSUk9SXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWxpYXMgZm9yIHtAbGluayBNaW5pcGFzcyNvZmZ9XG4gICAgICovXG4gICAgcmVtb3ZlTGlzdGVuZXIoZXYsIGhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2LCBoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9zdGx5IGlkZW50aWNhbCB0byBgRXZlbnRFbWl0dGVyLm9mZmBcbiAgICAgKlxuICAgICAqIElmIGEgJ2RhdGEnIGV2ZW50IGhhbmRsZXIgaXMgcmVtb3ZlZCwgYW5kIGl0IHdhcyB0aGUgbGFzdCBjb25zdW1lclxuICAgICAqIChpZSwgdGhlcmUgYXJlIG5vIHBpcGUgZGVzdGluYXRpb25zIG9yIG90aGVyICdkYXRhJyBldmVudCBsaXN0ZW5lcnMpLFxuICAgICAqIHRoZW4gdGhlIGZsb3cgb2YgZGF0YSB3aWxsIHN0b3AgdW50aWwgdGhlcmUgaXMgYW5vdGhlciBjb25zdW1lciBvclxuICAgICAqIHtAbGluayBNaW5pcGFzcyNyZXN1bWV9IGlzIGV4cGxpY2l0bHkgY2FsbGVkLlxuICAgICAqL1xuICAgIG9mZihldiwgaGFuZGxlcikge1xuICAgICAgICBjb25zdCByZXQgPSBzdXBlci5vZmYoZXYsIGhhbmRsZXIpO1xuICAgICAgICAvLyBpZiB3ZSBwcmV2aW91c2x5IGhhZCBsaXN0ZW5lcnMsIGFuZCBub3cgd2UgZG9uJ3QsIGFuZCB3ZSBkb24ndFxuICAgICAgICAvLyBoYXZlIGFueSBwaXBlcywgdGhlbiBzdG9wIHRoZSBmbG93LCB1bmxlc3MgaXQncyBiZWVuIGV4cGxpY2l0bHlcbiAgICAgICAgLy8gcHV0IGluIGEgZGlzY2FyZGVkIGZsb3dpbmcgc3RhdGUgdmlhIHN0cmVhbS5yZXN1bWUoKS5cbiAgICAgICAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHRoaXNbREFUQUxJU1RFTkVSU10gPSB0aGlzLmxpc3RlbmVycygnZGF0YScpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmICh0aGlzW0RBVEFMSVNURU5FUlNdID09PSAwICYmXG4gICAgICAgICAgICAgICAgIXRoaXNbRElTQ0FSREVEXSAmJlxuICAgICAgICAgICAgICAgICF0aGlzW1BJUEVTXS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9zdGx5IGlkZW50aWNhbCB0byBgRXZlbnRFbWl0dGVyLnJlbW92ZUFsbExpc3RlbmVyc2BcbiAgICAgKlxuICAgICAqIElmIGFsbCAnZGF0YScgZXZlbnQgaGFuZGxlcnMgYXJlIHJlbW92ZWQsIGFuZCB0aGV5IHdlcmUgdGhlIGxhc3QgY29uc3VtZXJcbiAgICAgKiAoaWUsIHRoZXJlIGFyZSBubyBwaXBlIGRlc3RpbmF0aW9ucyksIHRoZW4gdGhlIGZsb3cgb2YgZGF0YSB3aWxsIHN0b3BcbiAgICAgKiB1bnRpbCB0aGVyZSBpcyBhbm90aGVyIGNvbnN1bWVyIG9yIHtAbGluayBNaW5pcGFzcyNyZXN1bWV9IGlzIGV4cGxpY2l0bHlcbiAgICAgKiBjYWxsZWQuXG4gICAgICovXG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2KSB7XG4gICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLnJlbW92ZUFsbExpc3RlbmVycyhldik7XG4gICAgICAgIGlmIChldiA9PT0gJ2RhdGEnIHx8IGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXNbREFUQUxJU1RFTkVSU10gPSAwO1xuICAgICAgICAgICAgaWYgKCF0aGlzW0RJU0NBUkRFRF0gJiYgIXRoaXNbUElQRVNdLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRoaXNbRkxPV0lOR10gPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB0cnVlIGlmIHRoZSAnZW5kJyBldmVudCBoYXMgYmVlbiBlbWl0dGVkXG4gICAgICovXG4gICAgZ2V0IGVtaXR0ZWRFbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW0VNSVRURURfRU5EXTtcbiAgICB9XG4gICAgW01BWUJFX0VNSVRfRU5EXSgpIHtcbiAgICAgICAgaWYgKCF0aGlzW0VNSVRUSU5HX0VORF0gJiZcbiAgICAgICAgICAgICF0aGlzW0VNSVRURURfRU5EXSAmJlxuICAgICAgICAgICAgIXRoaXNbREVTVFJPWUVEXSAmJlxuICAgICAgICAgICAgdGhpc1tCVUZGRVJdLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpc1tFT0ZdKSB7XG4gICAgICAgICAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdlbmQnKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncHJlZmluaXNoJyk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICAgICAgaWYgKHRoaXNbQ0xPU0VEXSlcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gICAgICAgICAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBNb3N0bHkgaWRlbnRpY2FsIHRvIGBFdmVudEVtaXR0ZXIuZW1pdGAsIHdpdGggdGhlIGZvbGxvd2luZ1xuICAgICAqIGJlaGF2aW9yIGRpZmZlcmVuY2VzIHRvIHByZXZlbnQgZGF0YSBsb3NzIGFuZCB1bm5lY2Vzc2FyeSBoYW5nczpcbiAgICAgKlxuICAgICAqIElmIHRoZSBzdHJlYW0gaGFzIGJlZW4gZGVzdHJveWVkLCBhbmQgdGhlIGV2ZW50IGlzIHNvbWV0aGluZyBvdGhlclxuICAgICAqIHRoYW4gJ2Nsb3NlJyBvciAnZXJyb3InLCB0aGVuIGBmYWxzZWAgaXMgcmV0dXJuZWQgYW5kIG5vIGhhbmRsZXJzXG4gICAgICogYXJlIGNhbGxlZC5cbiAgICAgKlxuICAgICAqIElmIHRoZSBldmVudCBpcyAnZW5kJywgYW5kIGhhcyBhbHJlYWR5IGJlZW4gZW1pdHRlZCwgdGhlbiB0aGUgZXZlbnRcbiAgICAgKiBpcyBpZ25vcmVkLiBJZiB0aGUgc3RyZWFtIGlzIGluIGEgcGF1c2VkIG9yIG5vbi1mbG93aW5nIHN0YXRlLCB0aGVuXG4gICAgICogdGhlIGV2ZW50IHdpbGwgYmUgZGVmZXJyZWQgdW50aWwgZGF0YSBmbG93IHJlc3VtZXMuIElmIHRoZSBzdHJlYW0gaXNcbiAgICAgKiBhc3luYywgdGhlbiBoYW5kbGVycyB3aWxsIGJlIGNhbGxlZCBvbiB0aGUgbmV4dCB0aWNrIHJhdGhlciB0aGFuXG4gICAgICogaW1tZWRpYXRlbHkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgJ2Nsb3NlJywgYW5kICdlbmQnIGhhcyBub3QgeWV0IGJlZW4gZW1pdHRlZCwgdGhlblxuICAgICAqIHRoZSBldmVudCB3aWxsIGJlIGRlZmVycmVkIHVudGlsIGFmdGVyICdlbmQnIGlzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgZXZlbnQgaXMgJ2Vycm9yJywgYW5kIGFuIEFib3J0U2lnbmFsIHdhcyBwcm92aWRlZCBmb3IgdGhlIHN0cmVhbSxcbiAgICAgKiBhbmQgdGhlcmUgYXJlIG5vIGxpc3RlbmVycywgdGhlbiB0aGUgZXZlbnQgaXMgaWdub3JlZCwgbWF0Y2hpbmcgdGhlXG4gICAgICogYmVoYXZpb3Igb2Ygbm9kZSBjb3JlIHN0cmVhbXMgaW4gdGhlIHByZXNlbnNlIG9mIGFuIEFib3J0U2lnbmFsLlxuICAgICAqXG4gICAgICogSWYgdGhlIGV2ZW50IGlzICdmaW5pc2gnIG9yICdwcmVmaW5pc2gnLCB0aGVuIGFsbCBsaXN0ZW5lcnMgd2lsbCBiZVxuICAgICAqIHJlbW92ZWQgYWZ0ZXIgZW1pdHRpbmcgdGhlIGV2ZW50LCB0byBwcmV2ZW50IGRvdWJsZS1maXJpbmcuXG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBkYXRhID0gYXJnc1swXTtcbiAgICAgICAgLy8gZXJyb3IgYW5kIGNsb3NlIGFyZSBvbmx5IGV2ZW50cyBhbGxvd2VkIGFmdGVyIGNhbGxpbmcgZGVzdHJveSgpXG4gICAgICAgIGlmIChldiAhPT0gJ2Vycm9yJyAmJlxuICAgICAgICAgICAgZXYgIT09ICdjbG9zZScgJiZcbiAgICAgICAgICAgIGV2ICE9PSBERVNUUk9ZRUQgJiZcbiAgICAgICAgICAgIHRoaXNbREVTVFJPWUVEXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAgICAgICAgIHJldHVybiAhdGhpc1tPQkpFQ1RNT0RFXSAmJiAhZGF0YVxuICAgICAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IHRoaXNbQVNZTkNdXG4gICAgICAgICAgICAgICAgICAgID8gKGRlZmVyKCgpID0+IHRoaXNbRU1JVERBVEFdKGRhdGEpKSwgdHJ1ZSlcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzW0VNSVREQVRBXShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChldiA9PT0gJ2VuZCcpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzW0VNSVRFTkRdKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdjbG9zZScpIHtcbiAgICAgICAgICAgIHRoaXNbQ0xPU0VEXSA9IHRydWU7XG4gICAgICAgICAgICAvLyBkb24ndCBlbWl0IGNsb3NlIGJlZm9yZSAnZW5kJyBhbmQgJ2ZpbmlzaCdcbiAgICAgICAgICAgIGlmICghdGhpc1tFTUlUVEVEX0VORF0gJiYgIXRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdjbG9zZScpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2Nsb3NlJyk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnZXJyb3InKSB7XG4gICAgICAgICAgICB0aGlzW0VNSVRURURfRVJST1JdID0gZGF0YTtcbiAgICAgICAgICAgIHN1cGVyLmVtaXQoRVJST1IsIGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gIXRoaXNbU0lHTkFMXSB8fCB0aGlzLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGhcbiAgICAgICAgICAgICAgICA/IHN1cGVyLmVtaXQoJ2Vycm9yJywgZGF0YSlcbiAgICAgICAgICAgICAgICA6IGZhbHNlO1xuICAgICAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgICAgIHJldHVybiByZXQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXYgPT09ICdyZXN1bWUnKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdyZXN1bWUnKTtcbiAgICAgICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ID09PSAnZmluaXNoJyB8fCBldiA9PT0gJ3ByZWZpbmlzaCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoZXYpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpO1xuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIG90aGVyIHVua25vd24gZXZlbnRcbiAgICAgICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdChldiwgLi4uYXJncyk7XG4gICAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKCk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIFtFTUlUREFUQV0oZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpc1tQSVBFU10pIHtcbiAgICAgICAgICAgIGlmIChwLmRlc3Qud3JpdGUoZGF0YSkgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB0aGlzW0RJU0NBUkRFRF0gPyBmYWxzZSA6IHN1cGVyLmVtaXQoJ2RhdGEnLCBkYXRhKTtcbiAgICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgW0VNSVRFTkRdKCkge1xuICAgICAgICBpZiAodGhpc1tFTUlUVEVEX0VORF0pXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIHRoaXNbRU1JVFRFRF9FTkRdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gdGhpc1tBU1lOQ11cbiAgICAgICAgICAgID8gKGRlZmVyKCgpID0+IHRoaXNbRU1JVEVORDJdKCkpLCB0cnVlKVxuICAgICAgICAgICAgOiB0aGlzW0VNSVRFTkQyXSgpO1xuICAgIH1cbiAgICBbRU1JVEVORDJdKCkge1xuICAgICAgICBpZiAodGhpc1tERUNPREVSXSkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHRoaXNbREVDT0RFUl0uZW5kKCk7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcCBvZiB0aGlzW1BJUEVTXSkge1xuICAgICAgICAgICAgICAgICAgICBwLmRlc3Qud3JpdGUoZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdGhpc1tESVNDQVJERURdKVxuICAgICAgICAgICAgICAgICAgICBzdXBlci5lbWl0KCdkYXRhJywgZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXNbUElQRVNdKSB7XG4gICAgICAgICAgICBwLmVuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ2VuZCcpO1xuICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnZW5kJyk7XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byBhbiBhcnJheSBvZiBhbGwgZW1pdHRlZCBkYXRhIG9uY2VcbiAgICAgKiB0aGUgc3RyZWFtIGVuZHMuXG4gICAgICovXG4gICAgYXN5bmMgY29sbGVjdCgpIHtcbiAgICAgICAgY29uc3QgYnVmID0gT2JqZWN0LmFzc2lnbihbXSwge1xuICAgICAgICAgICAgZGF0YUxlbmd0aDogMCxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgICAgIGJ1Zi5kYXRhTGVuZ3RoID0gMDtcbiAgICAgICAgLy8gc2V0IHRoZSBwcm9taXNlIGZpcnN0LCBpbiBjYXNlIGFuIGVycm9yIGlzIHJhaXNlZFxuICAgICAgICAvLyBieSB0cmlnZ2VyaW5nIHRoZSBmbG93IGhlcmUuXG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnByb21pc2UoKTtcbiAgICAgICAgdGhpcy5vbignZGF0YScsIGMgPT4ge1xuICAgICAgICAgICAgYnVmLnB1c2goYyk7XG4gICAgICAgICAgICBpZiAoIXRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgICAgICAgICAgYnVmLmRhdGFMZW5ndGggKz0gYy5sZW5ndGg7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBwO1xuICAgICAgICByZXR1cm4gYnVmO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBQcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGNvbmNhdGVuYXRpb24gb2YgYWxsIGVtaXR0ZWQgZGF0YVxuICAgICAqIG9uY2UgdGhlIHN0cmVhbSBlbmRzLlxuICAgICAqXG4gICAgICogTm90IGFsbG93ZWQgb24gb2JqZWN0TW9kZSBzdHJlYW1zLlxuICAgICAqL1xuICAgIGFzeW5jIGNvbmNhdCgpIHtcbiAgICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNvbmNhdCBpbiBvYmplY3RNb2RlJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVmID0gYXdhaXQgdGhpcy5jb2xsZWN0KCk7XG4gICAgICAgIHJldHVybiAodGhpc1tFTkNPRElOR11cbiAgICAgICAgICAgID8gYnVmLmpvaW4oJycpXG4gICAgICAgICAgICA6IEJ1ZmZlci5jb25jYXQoYnVmLCBidWYuZGF0YUxlbmd0aCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB2b2lkIFByb21pc2UgdGhhdCByZXNvbHZlcyBvbmNlIHRoZSBzdHJlYW0gZW5kcy5cbiAgICAgKi9cbiAgICBhc3luYyBwcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbihERVNUUk9ZRUQsICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ3N0cmVhbSBkZXN0cm95ZWQnKSkpO1xuICAgICAgICAgICAgdGhpcy5vbignZXJyb3InLCBlciA9PiByZWplY3QoZXIpKTtcbiAgICAgICAgICAgIHRoaXMub24oJ2VuZCcsICgpID0+IHJlc29sdmUoKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3luY2hyb25vdXMgYGZvciBhd2FpdCBvZmAgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGNvbnRpbnVlIGVtaXR0aW5nIGFsbCBjaHVua3MgdW50aWwgdGhlIHN0cmVhbSB0ZXJtaW5hdGVzLlxuICAgICAqL1xuICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIC8vIHNldCB0aGlzIHVwIGZyb250LCBpbiBjYXNlIHRoZSBjb25zdW1lciBkb2Vzbid0IGNhbGwgbmV4dCgpXG4gICAgICAgIC8vIHJpZ2h0IGF3YXkuXG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzdG9wID0gYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RvcHBlZClcbiAgICAgICAgICAgICAgICByZXR1cm4gc3RvcCgpO1xuICAgICAgICAgICAgY29uc3QgcmVzID0gdGhpcy5yZWFkKCk7XG4gICAgICAgICAgICBpZiAocmVzICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoeyBkb25lOiBmYWxzZSwgdmFsdWU6IHJlcyB9KTtcbiAgICAgICAgICAgIGlmICh0aGlzW0VPRl0pXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICAgICAgICAgIGxldCByZXNvbHZlO1xuICAgICAgICAgICAgbGV0IHJlamVjdDtcbiAgICAgICAgICAgIGNvbnN0IG9uZXJyID0gKGVyKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2RhdGEnLCBvbmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdlbmQnLCBvbmVuZCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoREVTVFJPWUVELCBvbmRlc3Ryb3kpO1xuICAgICAgICAgICAgICAgIHN0b3AoKTtcbiAgICAgICAgICAgICAgICByZWplY3QoZXIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9uZGF0YSA9ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKCdlcnJvcicsIG9uZXJyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZW5kJywgb25lbmQpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKERFU1RST1lFRCwgb25kZXN0cm95KTtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7IHZhbHVlLCBkb25lOiAhIXRoaXNbRU9GXSB9KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCBvbmVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZignZXJyb3InLCBvbmVycik7XG4gICAgICAgICAgICAgICAgdGhpcy5vZmYoJ2RhdGEnLCBvbmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMub2ZmKERFU1RST1lFRCwgb25kZXN0cm95KTtcbiAgICAgICAgICAgICAgICBzdG9wKCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3Qgb25kZXN0cm95ID0gKCkgPT4gb25lcnIobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdCA9IHJlajtcbiAgICAgICAgICAgICAgICByZXNvbHZlID0gcmVzO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShERVNUUk9ZRUQsIG9uZGVzdHJveSk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKCdlcnJvcicsIG9uZXJyKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2RhdGEnLCBvbmRhdGEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBuZXh0LFxuICAgICAgICAgICAgdGhyb3c6IHN0b3AsXG4gICAgICAgICAgICByZXR1cm46IHN0b3AsXG4gICAgICAgICAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXMgYGZvciBvZmAgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogVGhlIGl0ZXJhdGlvbiB3aWxsIHRlcm1pbmF0ZSB3aGVuIHRoZSBpbnRlcm5hbCBidWZmZXIgcnVucyBvdXQsIGV2ZW5cbiAgICAgKiBpZiB0aGUgc3RyZWFtIGhhcyBub3QgeWV0IHRlcm1pbmF0ZWQuXG4gICAgICovXG4gICAgW1N5bWJvbC5pdGVyYXRvcl0oKSB7XG4gICAgICAgIC8vIHNldCB0aGlzIHVwIGZyb250LCBpbiBjYXNlIHRoZSBjb25zdW1lciBkb2Vzbid0IGNhbGwgbmV4dCgpXG4gICAgICAgIC8vIHJpZ2h0IGF3YXkuXG4gICAgICAgIHRoaXNbRElTQ0FSREVEXSA9IGZhbHNlO1xuICAgICAgICBsZXQgc3RvcHBlZCA9IGZhbHNlO1xuICAgICAgICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5wYXVzZSgpO1xuICAgICAgICAgICAgdGhpcy5vZmYoRVJST1IsIHN0b3ApO1xuICAgICAgICAgICAgdGhpcy5vZmYoREVTVFJPWUVELCBzdG9wKTtcbiAgICAgICAgICAgIHRoaXMub2ZmKCdlbmQnLCBzdG9wKTtcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHN0b3BwZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0b3AoKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5yZWFkKCk7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyBzdG9wKCkgOiB7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9O1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIHN0b3ApO1xuICAgICAgICB0aGlzLm9uY2UoRVJST1IsIHN0b3ApO1xuICAgICAgICB0aGlzLm9uY2UoREVTVFJPWUVELCBzdG9wKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5leHQsXG4gICAgICAgICAgICB0aHJvdzogc3RvcCxcbiAgICAgICAgICAgIHJldHVybjogc3RvcCxcbiAgICAgICAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVzdHJveSBhIHN0cmVhbSwgcHJldmVudGluZyBpdCBmcm9tIGJlaW5nIHVzZWQgZm9yIGFueSBmdXJ0aGVyIHB1cnBvc2UuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgc3RyZWFtIGhhcyBhIGBjbG9zZSgpYCBtZXRob2QsIHRoZW4gaXQgd2lsbCBiZSBjYWxsZWQgb25cbiAgICAgKiBkZXN0cnVjdGlvbi5cbiAgICAgKlxuICAgICAqIEFmdGVyIGRlc3RydWN0aW9uLCBhbnkgYXR0ZW1wdCB0byB3cml0ZSBkYXRhLCByZWFkIGRhdGEsIG9yIGVtaXQgbW9zdFxuICAgICAqIGV2ZW50cyB3aWxsIGJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiBJZiBhbiBlcnJvciBhcmd1bWVudCBpcyBwcm92aWRlZCwgdGhlbiBpdCB3aWxsIGJlIGVtaXR0ZWQgaW4gYW5cbiAgICAgKiAnZXJyb3InIGV2ZW50LlxuICAgICAqL1xuICAgIGRlc3Ryb3koZXIpIHtcbiAgICAgICAgaWYgKHRoaXNbREVTVFJPWUVEXSkge1xuICAgICAgICAgICAgaWYgKGVyKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KERFU1RST1lFRCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzW0RFU1RST1lFRF0gPSB0cnVlO1xuICAgICAgICB0aGlzW0RJU0NBUkRFRF0gPSB0cnVlO1xuICAgICAgICAvLyB0aHJvdyBhd2F5IGFsbCBidWZmZXJlZCBkYXRhLCBpdCdzIG5ldmVyIGNvbWluZyBvdXRcbiAgICAgICAgdGhpc1tCVUZGRVJdLmxlbmd0aCA9IDA7XG4gICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSA9IDA7XG4gICAgICAgIGNvbnN0IHdjID0gdGhpcztcbiAgICAgICAgaWYgKHR5cGVvZiB3Yy5jbG9zZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpc1tDTE9TRURdKVxuICAgICAgICAgICAgd2MuY2xvc2UoKTtcbiAgICAgICAgaWYgKGVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAgICAgLy8gaWYgbm8gZXJyb3IgdG8gZW1pdCwgc3RpbGwgcmVqZWN0IHBlbmRpbmcgcHJvbWlzZXNcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdGhpcy5lbWl0KERFU1RST1lFRCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIGlzU3RyZWFtfVxuICAgICAqXG4gICAgICogRm9ybWVyIGV4cG9ydCBsb2NhdGlvbiwgbWFpbnRhaW5lZCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIHN0YXRpYyBnZXQgaXNTdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiBleHBvcnRzLmlzU3RyZWFtO1xuICAgIH1cbn1cbmV4cG9ydHMuTWluaXBhc3MgPSBNaW5pcGFzcztcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/minipass/dist/commonjs/index.js\n");

/***/ })

};
;