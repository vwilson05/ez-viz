"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/lru-cache";
exports.ids = ["vendor-chunks/lru-cache"];
exports.modules = {

/***/ "(rsc)/./node_modules/lru-cache/dist/commonjs/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/lru-cache/dist/commonjs/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * @module LRUCache\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.LRUCache = void 0;\nconst perf = typeof performance === 'object' &&\n    performance &&\n    typeof performance.now === 'function'\n    ? performance\n    : Date;\nconst warned = new Set();\n/* c8 ignore start */\nconst PROCESS = (typeof process === 'object' && !!process ? process : {});\n/* c8 ignore start */\nconst emitWarning = (msg, type, code, fn) => {\n    typeof PROCESS.emitWarning === 'function'\n        ? PROCESS.emitWarning(msg, type, code, fn)\n        : console.error(`[${code}] ${type}: ${msg}`);\n};\nlet AC = globalThis.AbortController;\nlet AS = globalThis.AbortSignal;\n/* c8 ignore start */\nif (typeof AC === 'undefined') {\n    //@ts-ignore\n    AS = class AbortSignal {\n        onabort;\n        _onabort = [];\n        reason;\n        aborted = false;\n        addEventListener(_, fn) {\n            this._onabort.push(fn);\n        }\n    };\n    //@ts-ignore\n    AC = class AbortController {\n        constructor() {\n            warnACPolyfill();\n        }\n        signal = new AS();\n        abort(reason) {\n            if (this.signal.aborted)\n                return;\n            //@ts-ignore\n            this.signal.reason = reason;\n            //@ts-ignore\n            this.signal.aborted = true;\n            //@ts-ignore\n            for (const fn of this.signal._onabort) {\n                fn(reason);\n            }\n            this.signal.onabort?.(reason);\n        }\n    };\n    let printACPolyfillWarning = PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== '1';\n    const warnACPolyfill = () => {\n        if (!printACPolyfillWarning)\n            return;\n        printACPolyfillWarning = false;\n        emitWarning('AbortController is not defined. If using lru-cache in ' +\n            'node 14, load an AbortController polyfill from the ' +\n            '`node-abort-controller` package. A minimal polyfill is ' +\n            'provided for use by LRUCache.fetch(), but it should not be ' +\n            'relied upon in other contexts (eg, passing it to other APIs that ' +\n            'use AbortController/AbortSignal might have undesirable effects). ' +\n            'You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.', 'NO_ABORT_CONTROLLER', 'ENOTSUP', warnACPolyfill);\n    };\n}\n/* c8 ignore stop */\nconst shouldWarn = (code) => !warned.has(code);\nconst TYPE = Symbol('type');\nconst isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);\n/* c8 ignore start */\n// This is a little bit ridiculous, tbh.\n// The maximum array length is 2^32-1 or thereabouts on most JS impls.\n// And well before that point, you're caching the entire world, I mean,\n// that's ~32GB of just integers for the next/prev links, plus whatever\n// else to hold that many keys and values.  Just filling the memory with\n// zeroes at init time is brutal when you get that big.\n// But why not be complete?\n// Maybe in the future, these limits will have expanded.\nconst getUintArray = (max) => !isPosInt(max)\n    ? null\n    : max <= Math.pow(2, 8)\n        ? Uint8Array\n        : max <= Math.pow(2, 16)\n            ? Uint16Array\n            : max <= Math.pow(2, 32)\n                ? Uint32Array\n                : max <= Number.MAX_SAFE_INTEGER\n                    ? ZeroArray\n                    : null;\n/* c8 ignore stop */\nclass ZeroArray extends Array {\n    constructor(size) {\n        super(size);\n        this.fill(0);\n    }\n}\nclass Stack {\n    heap;\n    length;\n    // private constructor\n    static #constructing = false;\n    static create(max) {\n        const HeapCls = getUintArray(max);\n        if (!HeapCls)\n            return [];\n        Stack.#constructing = true;\n        const s = new Stack(max, HeapCls);\n        Stack.#constructing = false;\n        return s;\n    }\n    constructor(max, HeapCls) {\n        /* c8 ignore start */\n        if (!Stack.#constructing) {\n            throw new TypeError('instantiate Stack using Stack.create(n)');\n        }\n        /* c8 ignore stop */\n        this.heap = new HeapCls(max);\n        this.length = 0;\n    }\n    push(n) {\n        this.heap[this.length++] = n;\n    }\n    pop() {\n        return this.heap[--this.length];\n    }\n}\n/**\n * Default export, the thing you're using this module to get.\n *\n * The `K` and `V` types define the key and value types, respectively. The\n * optional `FC` type defines the type of the `context` object passed to\n * `cache.fetch()` and `cache.memo()`.\n *\n * Keys and values **must not** be `null` or `undefined`.\n *\n * All properties from the options object (with the exception of `max`,\n * `maxSize`, `fetchMethod`, `memoMethod`, `dispose` and `disposeAfter`) are\n * added as normal public members. (The listed options are read-only getters.)\n *\n * Changing any of these will alter the defaults for subsequent method calls.\n */\nclass LRUCache {\n    // options that cannot be changed without disaster\n    #max;\n    #maxSize;\n    #dispose;\n    #disposeAfter;\n    #fetchMethod;\n    #memoMethod;\n    /**\n     * {@link LRUCache.OptionsBase.ttl}\n     */\n    ttl;\n    /**\n     * {@link LRUCache.OptionsBase.ttlResolution}\n     */\n    ttlResolution;\n    /**\n     * {@link LRUCache.OptionsBase.ttlAutopurge}\n     */\n    ttlAutopurge;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnGet}\n     */\n    updateAgeOnGet;\n    /**\n     * {@link LRUCache.OptionsBase.updateAgeOnHas}\n     */\n    updateAgeOnHas;\n    /**\n     * {@link LRUCache.OptionsBase.allowStale}\n     */\n    allowStale;\n    /**\n     * {@link LRUCache.OptionsBase.noDisposeOnSet}\n     */\n    noDisposeOnSet;\n    /**\n     * {@link LRUCache.OptionsBase.noUpdateTTL}\n     */\n    noUpdateTTL;\n    /**\n     * {@link LRUCache.OptionsBase.maxEntrySize}\n     */\n    maxEntrySize;\n    /**\n     * {@link LRUCache.OptionsBase.sizeCalculation}\n     */\n    sizeCalculation;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}\n     */\n    noDeleteOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}\n     */\n    noDeleteOnStaleGet;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}\n     */\n    allowStaleOnFetchAbort;\n    /**\n     * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}\n     */\n    allowStaleOnFetchRejection;\n    /**\n     * {@link LRUCache.OptionsBase.ignoreFetchAbort}\n     */\n    ignoreFetchAbort;\n    // computed properties\n    #size;\n    #calculatedSize;\n    #keyMap;\n    #keyList;\n    #valList;\n    #next;\n    #prev;\n    #head;\n    #tail;\n    #free;\n    #disposed;\n    #sizes;\n    #starts;\n    #ttls;\n    #hasDispose;\n    #hasFetchMethod;\n    #hasDisposeAfter;\n    /**\n     * Do not call this method unless you need to inspect the\n     * inner workings of the cache.  If anything returned by this\n     * object is modified in any way, strange breakage may occur.\n     *\n     * These fields are private for a reason!\n     *\n     * @internal\n     */\n    static unsafeExposeInternals(c) {\n        return {\n            // properties\n            starts: c.#starts,\n            ttls: c.#ttls,\n            sizes: c.#sizes,\n            keyMap: c.#keyMap,\n            keyList: c.#keyList,\n            valList: c.#valList,\n            next: c.#next,\n            prev: c.#prev,\n            get head() {\n                return c.#head;\n            },\n            get tail() {\n                return c.#tail;\n            },\n            free: c.#free,\n            // methods\n            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),\n            backgroundFetch: (k, index, options, context) => c.#backgroundFetch(k, index, options, context),\n            moveToTail: (index) => c.#moveToTail(index),\n            indexes: (options) => c.#indexes(options),\n            rindexes: (options) => c.#rindexes(options),\n            isStale: (index) => c.#isStale(index),\n        };\n    }\n    // Protected read-only members\n    /**\n     * {@link LRUCache.OptionsBase.max} (read-only)\n     */\n    get max() {\n        return this.#max;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.maxSize} (read-only)\n     */\n    get maxSize() {\n        return this.#maxSize;\n    }\n    /**\n     * The total computed size of items in the cache (read-only)\n     */\n    get calculatedSize() {\n        return this.#calculatedSize;\n    }\n    /**\n     * The number of items stored in the cache (read-only)\n     */\n    get size() {\n        return this.#size;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.fetchMethod} (read-only)\n     */\n    get fetchMethod() {\n        return this.#fetchMethod;\n    }\n    get memoMethod() {\n        return this.#memoMethod;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.dispose} (read-only)\n     */\n    get dispose() {\n        return this.#dispose;\n    }\n    /**\n     * {@link LRUCache.OptionsBase.disposeAfter} (read-only)\n     */\n    get disposeAfter() {\n        return this.#disposeAfter;\n    }\n    constructor(options) {\n        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort, } = options;\n        if (max !== 0 && !isPosInt(max)) {\n            throw new TypeError('max option must be a nonnegative integer');\n        }\n        const UintArray = max ? getUintArray(max) : Array;\n        if (!UintArray) {\n            throw new Error('invalid max value: ' + max);\n        }\n        this.#max = max;\n        this.#maxSize = maxSize;\n        this.maxEntrySize = maxEntrySize || this.#maxSize;\n        this.sizeCalculation = sizeCalculation;\n        if (this.sizeCalculation) {\n            if (!this.#maxSize && !this.maxEntrySize) {\n                throw new TypeError('cannot set sizeCalculation without setting maxSize or maxEntrySize');\n            }\n            if (typeof this.sizeCalculation !== 'function') {\n                throw new TypeError('sizeCalculation set to non-function');\n            }\n        }\n        if (memoMethod !== undefined &&\n            typeof memoMethod !== 'function') {\n            throw new TypeError('memoMethod must be a function if defined');\n        }\n        this.#memoMethod = memoMethod;\n        if (fetchMethod !== undefined &&\n            typeof fetchMethod !== 'function') {\n            throw new TypeError('fetchMethod must be a function if specified');\n        }\n        this.#fetchMethod = fetchMethod;\n        this.#hasFetchMethod = !!fetchMethod;\n        this.#keyMap = new Map();\n        this.#keyList = new Array(max).fill(undefined);\n        this.#valList = new Array(max).fill(undefined);\n        this.#next = new UintArray(max);\n        this.#prev = new UintArray(max);\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free = Stack.create(max);\n        this.#size = 0;\n        this.#calculatedSize = 0;\n        if (typeof dispose === 'function') {\n            this.#dispose = dispose;\n        }\n        if (typeof disposeAfter === 'function') {\n            this.#disposeAfter = disposeAfter;\n            this.#disposed = [];\n        }\n        else {\n            this.#disposeAfter = undefined;\n            this.#disposed = undefined;\n        }\n        this.#hasDispose = !!this.#dispose;\n        this.#hasDisposeAfter = !!this.#disposeAfter;\n        this.noDisposeOnSet = !!noDisposeOnSet;\n        this.noUpdateTTL = !!noUpdateTTL;\n        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;\n        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;\n        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;\n        this.ignoreFetchAbort = !!ignoreFetchAbort;\n        // NB: maxEntrySize is set to maxSize if it's set\n        if (this.maxEntrySize !== 0) {\n            if (this.#maxSize !== 0) {\n                if (!isPosInt(this.#maxSize)) {\n                    throw new TypeError('maxSize must be a positive integer if specified');\n                }\n            }\n            if (!isPosInt(this.maxEntrySize)) {\n                throw new TypeError('maxEntrySize must be a positive integer if specified');\n            }\n            this.#initializeSizeTracking();\n        }\n        this.allowStale = !!allowStale;\n        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;\n        this.updateAgeOnGet = !!updateAgeOnGet;\n        this.updateAgeOnHas = !!updateAgeOnHas;\n        this.ttlResolution =\n            isPosInt(ttlResolution) || ttlResolution === 0\n                ? ttlResolution\n                : 1;\n        this.ttlAutopurge = !!ttlAutopurge;\n        this.ttl = ttl || 0;\n        if (this.ttl) {\n            if (!isPosInt(this.ttl)) {\n                throw new TypeError('ttl must be a positive integer if specified');\n            }\n            this.#initializeTTLTracking();\n        }\n        // do not allow completely unbounded caches\n        if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {\n            throw new TypeError('At least one of max, maxSize, or ttl is required');\n        }\n        if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {\n            const code = 'LRU_CACHE_UNBOUNDED';\n            if (shouldWarn(code)) {\n                warned.add(code);\n                const msg = 'TTL caching without ttlAutopurge, max, or maxSize can ' +\n                    'result in unbounded memory consumption.';\n                emitWarning(msg, 'UnboundedCacheWarning', code, LRUCache);\n            }\n        }\n    }\n    /**\n     * Return the number of ms left in the item's TTL. If item is not in cache,\n     * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.\n     */\n    getRemainingTTL(key) {\n        return this.#keyMap.has(key) ? Infinity : 0;\n    }\n    #initializeTTLTracking() {\n        const ttls = new ZeroArray(this.#max);\n        const starts = new ZeroArray(this.#max);\n        this.#ttls = ttls;\n        this.#starts = starts;\n        this.#setItemTTL = (index, ttl, start = perf.now()) => {\n            starts[index] = ttl !== 0 ? start : 0;\n            ttls[index] = ttl;\n            if (ttl !== 0 && this.ttlAutopurge) {\n                const t = setTimeout(() => {\n                    if (this.#isStale(index)) {\n                        this.#delete(this.#keyList[index], 'expire');\n                    }\n                }, ttl + 1);\n                // unref() not supported on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n        };\n        this.#updateItemAge = index => {\n            starts[index] = ttls[index] !== 0 ? perf.now() : 0;\n        };\n        this.#statusTTL = (status, index) => {\n            if (ttls[index]) {\n                const ttl = ttls[index];\n                const start = starts[index];\n                /* c8 ignore next */\n                if (!ttl || !start)\n                    return;\n                status.ttl = ttl;\n                status.start = start;\n                status.now = cachedNow || getNow();\n                const age = status.now - start;\n                status.remainingTTL = ttl - age;\n            }\n        };\n        // debounce calls to perf.now() to 1s so we're not hitting\n        // that costly call repeatedly.\n        let cachedNow = 0;\n        const getNow = () => {\n            const n = perf.now();\n            if (this.ttlResolution > 0) {\n                cachedNow = n;\n                const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);\n                // not available on all platforms\n                /* c8 ignore start */\n                if (t.unref) {\n                    t.unref();\n                }\n                /* c8 ignore stop */\n            }\n            return n;\n        };\n        this.getRemainingTTL = key => {\n            const index = this.#keyMap.get(key);\n            if (index === undefined) {\n                return 0;\n            }\n            const ttl = ttls[index];\n            const start = starts[index];\n            if (!ttl || !start) {\n                return Infinity;\n            }\n            const age = (cachedNow || getNow()) - start;\n            return ttl - age;\n        };\n        this.#isStale = index => {\n            const s = starts[index];\n            const t = ttls[index];\n            return !!t && !!s && (cachedNow || getNow()) - s > t;\n        };\n    }\n    // conditionally set private methods related to TTL\n    #updateItemAge = () => { };\n    #statusTTL = () => { };\n    #setItemTTL = () => { };\n    /* c8 ignore stop */\n    #isStale = () => false;\n    #initializeSizeTracking() {\n        const sizes = new ZeroArray(this.#max);\n        this.#calculatedSize = 0;\n        this.#sizes = sizes;\n        this.#removeItemSize = index => {\n            this.#calculatedSize -= sizes[index];\n            sizes[index] = 0;\n        };\n        this.#requireSize = (k, v, size, sizeCalculation) => {\n            // provisionally accept background fetches.\n            // actual value size will be checked when they return.\n            if (this.#isBackgroundFetch(v)) {\n                return 0;\n            }\n            if (!isPosInt(size)) {\n                if (sizeCalculation) {\n                    if (typeof sizeCalculation !== 'function') {\n                        throw new TypeError('sizeCalculation must be a function');\n                    }\n                    size = sizeCalculation(v, k);\n                    if (!isPosInt(size)) {\n                        throw new TypeError('sizeCalculation return invalid (expect positive integer)');\n                    }\n                }\n                else {\n                    throw new TypeError('invalid size value (must be positive integer). ' +\n                        'When maxSize or maxEntrySize is used, sizeCalculation ' +\n                        'or size must be set.');\n                }\n            }\n            return size;\n        };\n        this.#addItemSize = (index, size, status) => {\n            sizes[index] = size;\n            if (this.#maxSize) {\n                const maxSize = this.#maxSize - sizes[index];\n                while (this.#calculatedSize > maxSize) {\n                    this.#evict(true);\n                }\n            }\n            this.#calculatedSize += sizes[index];\n            if (status) {\n                status.entrySize = size;\n                status.totalCalculatedSize = this.#calculatedSize;\n            }\n        };\n    }\n    #removeItemSize = _i => { };\n    #addItemSize = (_i, _s, _st) => { };\n    #requireSize = (_k, _v, size, sizeCalculation) => {\n        if (size || sizeCalculation) {\n            throw new TypeError('cannot set size without setting maxSize or maxEntrySize on cache');\n        }\n        return 0;\n    };\n    *#indexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#tail; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#head) {\n                    break;\n                }\n                else {\n                    i = this.#prev[i];\n                }\n            }\n        }\n    }\n    *#rindexes({ allowStale = this.allowStale } = {}) {\n        if (this.#size) {\n            for (let i = this.#head; true;) {\n                if (!this.#isValidIndex(i)) {\n                    break;\n                }\n                if (allowStale || !this.#isStale(i)) {\n                    yield i;\n                }\n                if (i === this.#tail) {\n                    break;\n                }\n                else {\n                    i = this.#next[i];\n                }\n            }\n        }\n    }\n    #isValidIndex(index) {\n        return (index !== undefined &&\n            this.#keyMap.get(this.#keyList[index]) === index);\n    }\n    /**\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from most recently used to least recently used.\n     */\n    *entries() {\n        for (const i of this.#indexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.entries}\n     *\n     * Return a generator yielding `[key, value]` pairs,\n     * in order from least recently used to most recently used.\n     */\n    *rentries() {\n        for (const i of this.#rindexes()) {\n            if (this.#valList[i] !== undefined &&\n                this.#keyList[i] !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield [this.#keyList[i], this.#valList[i]];\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the keys in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *keys() {\n        for (const i of this.#indexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.keys}\n     *\n     * Return a generator yielding the keys in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rkeys() {\n        for (const i of this.#rindexes()) {\n            const k = this.#keyList[i];\n            if (k !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield k;\n            }\n        }\n    }\n    /**\n     * Return a generator yielding the values in the cache,\n     * in order from most recently used to least recently used.\n     */\n    *values() {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Inverse order version of {@link LRUCache.values}\n     *\n     * Return a generator yielding the values in the cache,\n     * in order from least recently used to most recently used.\n     */\n    *rvalues() {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            if (v !== undefined &&\n                !this.#isBackgroundFetch(this.#valList[i])) {\n                yield this.#valList[i];\n            }\n        }\n    }\n    /**\n     * Iterating over the cache itself yields the same results as\n     * {@link LRUCache.entries}\n     */\n    [Symbol.iterator]() {\n        return this.entries();\n    }\n    /**\n     * A String value that is used in the creation of the default string\n     * description of an object. Called by the built-in method\n     * `Object.prototype.toString`.\n     */\n    [Symbol.toStringTag] = 'LRUCache';\n    /**\n     * Find a value for which the supplied fn method returns a truthy value,\n     * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.\n     */\n    find(fn, getOptions = {}) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            if (fn(value, this.#keyList[i], this)) {\n                return this.get(this.#keyList[i], getOptions);\n            }\n        }\n    }\n    /**\n     * Call the supplied function on each item in the cache, in order from most\n     * recently used to least recently used.\n     *\n     * `fn` is called as `fn(value, key, cache)`.\n     *\n     * If `thisp` is provided, function will be called in the `this`-context of\n     * the provided object, or the cache if no `thisp` object is provided.\n     *\n     * Does not update age or recenty of use, or iterate over stale values.\n     */\n    forEach(fn, thisp = this) {\n        for (const i of this.#indexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * The same as {@link LRUCache.forEach} but items are iterated over in\n     * reverse order.  (ie, less recently used items are iterated over first.)\n     */\n    rforEach(fn, thisp = this) {\n        for (const i of this.#rindexes()) {\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined)\n                continue;\n            fn.call(thisp, value, this.#keyList[i], this);\n        }\n    }\n    /**\n     * Delete any stale entries. Returns true if anything was removed,\n     * false otherwise.\n     */\n    purgeStale() {\n        let deleted = false;\n        for (const i of this.#rindexes({ allowStale: true })) {\n            if (this.#isStale(i)) {\n                this.#delete(this.#keyList[i], 'expire');\n                deleted = true;\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Get the extended info about a given entry, to get its value, size, and\n     * TTL info simultaneously. Returns `undefined` if the key is not present.\n     *\n     * Unlike {@link LRUCache#dump}, which is designed to be portable and survive\n     * serialization, the `start` value is always the current timestamp, and the\n     * `ttl` is a calculated remaining time to live (negative if expired).\n     *\n     * Always returns stale values, if their info is found in the cache, so be\n     * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})\n     * if relevant.\n     */\n    info(key) {\n        const i = this.#keyMap.get(key);\n        if (i === undefined)\n            return undefined;\n        const v = this.#valList[i];\n        const value = this.#isBackgroundFetch(v)\n            ? v.__staleWhileFetching\n            : v;\n        if (value === undefined)\n            return undefined;\n        const entry = { value };\n        if (this.#ttls && this.#starts) {\n            const ttl = this.#ttls[i];\n            const start = this.#starts[i];\n            if (ttl && start) {\n                const remain = ttl - (perf.now() - start);\n                entry.ttl = remain;\n                entry.start = Date.now();\n            }\n        }\n        if (this.#sizes) {\n            entry.size = this.#sizes[i];\n        }\n        return entry;\n    }\n    /**\n     * Return an array of [key, {@link LRUCache.Entry}] tuples which can be\n     * passed to {@link LRLUCache#load}.\n     *\n     * The `start` fields are calculated relative to a portable `Date.now()`\n     * timestamp, even if `performance.now()` is available.\n     *\n     * Stale entries are always included in the `dump`, even if\n     * {@link LRUCache.OptionsBase.allowStale} is false.\n     *\n     * Note: this returns an actual array, not a generator, so it can be more\n     * easily passed around.\n     */\n    dump() {\n        const arr = [];\n        for (const i of this.#indexes({ allowStale: true })) {\n            const key = this.#keyList[i];\n            const v = this.#valList[i];\n            const value = this.#isBackgroundFetch(v)\n                ? v.__staleWhileFetching\n                : v;\n            if (value === undefined || key === undefined)\n                continue;\n            const entry = { value };\n            if (this.#ttls && this.#starts) {\n                entry.ttl = this.#ttls[i];\n                // always dump the start relative to a portable timestamp\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = perf.now() - this.#starts[i];\n                entry.start = Math.floor(Date.now() - age);\n            }\n            if (this.#sizes) {\n                entry.size = this.#sizes[i];\n            }\n            arr.unshift([key, entry]);\n        }\n        return arr;\n    }\n    /**\n     * Reset the cache and load in the items in entries in the order listed.\n     *\n     * The shape of the resulting cache may be different if the same options are\n     * not used in both caches.\n     *\n     * The `start` fields are assumed to be calculated relative to a portable\n     * `Date.now()` timestamp, even if `performance.now()` is available.\n     */\n    load(arr) {\n        this.clear();\n        for (const [key, entry] of arr) {\n            if (entry.start) {\n                // entry.start is a portable timestamp, but we may be using\n                // node's performance.now(), so calculate the offset, so that\n                // we get the intended remaining TTL, no matter how long it's\n                // been on ice.\n                //\n                // it's ok for this to be a bit slow, it's a rare operation.\n                const age = Date.now() - entry.start;\n                entry.start = perf.now() - age;\n            }\n            this.set(key, entry.value, entry);\n        }\n    }\n    /**\n     * Add a value to the cache.\n     *\n     * Note: if `undefined` is specified as a value, this is an alias for\n     * {@link LRUCache#delete}\n     *\n     * Fields on the {@link LRUCache.SetOptions} options param will override\n     * their corresponding values in the constructor options for the scope\n     * of this single `set()` operation.\n     *\n     * If `start` is provided, then that will set the effective start\n     * time for the TTL calculation. Note that this must be a previous\n     * value of `performance.now()` if supported, or a previous value of\n     * `Date.now()` if not.\n     *\n     * Options object may also include `size`, which will prevent\n     * calling the `sizeCalculation` function and just use the specified\n     * number if it is a positive integer, and `noDisposeOnSet` which\n     * will prevent calling a `dispose` function in the case of\n     * overwrites.\n     *\n     * If the `size` (or return value of `sizeCalculation`) for a given\n     * entry is greater than `maxEntrySize`, then the item will not be\n     * added to the cache.\n     *\n     * Will update the recency of the entry.\n     *\n     * If the value is `undefined`, then this is an alias for\n     * `cache.delete(key)`. `undefined` is never stored in the cache.\n     */\n    set(k, v, setOptions = {}) {\n        if (v === undefined) {\n            this.delete(k);\n            return this;\n        }\n        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status, } = setOptions;\n        let { noUpdateTTL = this.noUpdateTTL } = setOptions;\n        const size = this.#requireSize(k, v, setOptions.size || 0, sizeCalculation);\n        // if the item doesn't fit, don't do anything\n        // NB: maxEntrySize set to maxSize by default\n        if (this.maxEntrySize && size > this.maxEntrySize) {\n            if (status) {\n                status.set = 'miss';\n                status.maxEntrySizeExceeded = true;\n            }\n            // have to delete, in case something is there already.\n            this.#delete(k, 'set');\n            return this;\n        }\n        let index = this.#size === 0 ? undefined : this.#keyMap.get(k);\n        if (index === undefined) {\n            // addition\n            index = (this.#size === 0\n                ? this.#tail\n                : this.#free.length !== 0\n                    ? this.#free.pop()\n                    : this.#size === this.#max\n                        ? this.#evict(false)\n                        : this.#size);\n            this.#keyList[index] = k;\n            this.#valList[index] = v;\n            this.#keyMap.set(k, index);\n            this.#next[this.#tail] = index;\n            this.#prev[index] = this.#tail;\n            this.#tail = index;\n            this.#size++;\n            this.#addItemSize(index, size, status);\n            if (status)\n                status.set = 'add';\n            noUpdateTTL = false;\n        }\n        else {\n            // update\n            this.#moveToTail(index);\n            const oldVal = this.#valList[index];\n            if (v !== oldVal) {\n                if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {\n                    oldVal.__abortController.abort(new Error('replaced'));\n                    const { __staleWhileFetching: s } = oldVal;\n                    if (s !== undefined && !noDisposeOnSet) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(s, k, 'set');\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([s, k, 'set']);\n                        }\n                    }\n                }\n                else if (!noDisposeOnSet) {\n                    if (this.#hasDispose) {\n                        this.#dispose?.(oldVal, k, 'set');\n                    }\n                    if (this.#hasDisposeAfter) {\n                        this.#disposed?.push([oldVal, k, 'set']);\n                    }\n                }\n                this.#removeItemSize(index);\n                this.#addItemSize(index, size, status);\n                this.#valList[index] = v;\n                if (status) {\n                    status.set = 'replace';\n                    const oldValue = oldVal && this.#isBackgroundFetch(oldVal)\n                        ? oldVal.__staleWhileFetching\n                        : oldVal;\n                    if (oldValue !== undefined)\n                        status.oldValue = oldValue;\n                }\n            }\n            else if (status) {\n                status.set = 'update';\n            }\n        }\n        if (ttl !== 0 && !this.#ttls) {\n            this.#initializeTTLTracking();\n        }\n        if (this.#ttls) {\n            if (!noUpdateTTL) {\n                this.#setItemTTL(index, ttl, start);\n            }\n            if (status)\n                this.#statusTTL(status, index);\n        }\n        if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return this;\n    }\n    /**\n     * Evict the least recently used item, returning its value or\n     * `undefined` if cache is empty.\n     */\n    pop() {\n        try {\n            while (this.#size) {\n                const val = this.#valList[this.#head];\n                this.#evict(true);\n                if (this.#isBackgroundFetch(val)) {\n                    if (val.__staleWhileFetching) {\n                        return val.__staleWhileFetching;\n                    }\n                }\n                else if (val !== undefined) {\n                    return val;\n                }\n            }\n        }\n        finally {\n            if (this.#hasDisposeAfter && this.#disposed) {\n                const dt = this.#disposed;\n                let task;\n                while ((task = dt?.shift())) {\n                    this.#disposeAfter?.(...task);\n                }\n            }\n        }\n    }\n    #evict(free) {\n        const head = this.#head;\n        const k = this.#keyList[head];\n        const v = this.#valList[head];\n        if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {\n            v.__abortController.abort(new Error('evicted'));\n        }\n        else if (this.#hasDispose || this.#hasDisposeAfter) {\n            if (this.#hasDispose) {\n                this.#dispose?.(v, k, 'evict');\n            }\n            if (this.#hasDisposeAfter) {\n                this.#disposed?.push([v, k, 'evict']);\n            }\n        }\n        this.#removeItemSize(head);\n        // if we aren't about to use the index, then null these out\n        if (free) {\n            this.#keyList[head] = undefined;\n            this.#valList[head] = undefined;\n            this.#free.push(head);\n        }\n        if (this.#size === 1) {\n            this.#head = this.#tail = 0;\n            this.#free.length = 0;\n        }\n        else {\n            this.#head = this.#next[head];\n        }\n        this.#keyMap.delete(k);\n        this.#size--;\n        return head;\n    }\n    /**\n     * Check if a key is in the cache, without updating the recency of use.\n     * Will return false if the item is stale, even though it is technically\n     * in the cache.\n     *\n     * Check if a key is in the cache, without updating the recency of\n     * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set\n     * to `true` in either the options or the constructor.\n     *\n     * Will return `false` if the item is stale, even though it is technically in\n     * the cache. The difference can be determined (if it matters) by using a\n     * `status` argument, and inspecting the `has` field.\n     *\n     * Will not update item age unless\n     * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.\n     */\n    has(k, hasOptions = {}) {\n        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v) &&\n                v.__staleWhileFetching === undefined) {\n                return false;\n            }\n            if (!this.#isStale(index)) {\n                if (updateAgeOnHas) {\n                    this.#updateItemAge(index);\n                }\n                if (status) {\n                    status.has = 'hit';\n                    this.#statusTTL(status, index);\n                }\n                return true;\n            }\n            else if (status) {\n                status.has = 'stale';\n                this.#statusTTL(status, index);\n            }\n        }\n        else if (status) {\n            status.has = 'miss';\n        }\n        return false;\n    }\n    /**\n     * Like {@link LRUCache#get} but doesn't update recency or delete stale\n     * items.\n     *\n     * Returns `undefined` if the item is stale, unless\n     * {@link LRUCache.OptionsBase.allowStale} is set.\n     */\n    peek(k, peekOptions = {}) {\n        const { allowStale = this.allowStale } = peekOptions;\n        const index = this.#keyMap.get(k);\n        if (index === undefined ||\n            (!allowStale && this.#isStale(index))) {\n            return;\n        }\n        const v = this.#valList[index];\n        // either stale and allowed, or forcing a refresh of non-stale value\n        return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;\n    }\n    #backgroundFetch(k, index, options, context) {\n        const v = index === undefined ? undefined : this.#valList[index];\n        if (this.#isBackgroundFetch(v)) {\n            return v;\n        }\n        const ac = new AC();\n        const { signal } = options;\n        // when/if our AC signals, then stop listening to theirs.\n        signal?.addEventListener('abort', () => ac.abort(signal.reason), {\n            signal: ac.signal,\n        });\n        const fetchOpts = {\n            signal: ac.signal,\n            options,\n            context,\n        };\n        const cb = (v, updateCache = false) => {\n            const { aborted } = ac.signal;\n            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;\n            if (options.status) {\n                if (aborted && !updateCache) {\n                    options.status.fetchAborted = true;\n                    options.status.fetchError = ac.signal.reason;\n                    if (ignoreAbort)\n                        options.status.fetchAbortIgnored = true;\n                }\n                else {\n                    options.status.fetchResolved = true;\n                }\n            }\n            if (aborted && !ignoreAbort && !updateCache) {\n                return fetchFail(ac.signal.reason);\n            }\n            // either we didn't abort, and are still here, or we did, and ignored\n            const bf = p;\n            if (this.#valList[index] === p) {\n                if (v === undefined) {\n                    if (bf.__staleWhileFetching) {\n                        this.#valList[index] = bf.__staleWhileFetching;\n                    }\n                    else {\n                        this.#delete(k, 'fetch');\n                    }\n                }\n                else {\n                    if (options.status)\n                        options.status.fetchUpdated = true;\n                    this.set(k, v, fetchOpts.options);\n                }\n            }\n            return v;\n        };\n        const eb = (er) => {\n            if (options.status) {\n                options.status.fetchRejected = true;\n                options.status.fetchError = er;\n            }\n            return fetchFail(er);\n        };\n        const fetchFail = (er) => {\n            const { aborted } = ac.signal;\n            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;\n            const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;\n            const noDelete = allowStale || options.noDeleteOnFetchRejection;\n            const bf = p;\n            if (this.#valList[index] === p) {\n                // if we allow stale on fetch rejections, then we need to ensure that\n                // the stale value is not removed from the cache when the fetch fails.\n                const del = !noDelete || bf.__staleWhileFetching === undefined;\n                if (del) {\n                    this.#delete(k, 'fetch');\n                }\n                else if (!allowStaleAborted) {\n                    // still replace the *promise* with the stale value,\n                    // since we are done with the promise at this point.\n                    // leave it untouched if we're still waiting for an\n                    // aborted background fetch that hasn't yet returned.\n                    this.#valList[index] = bf.__staleWhileFetching;\n                }\n            }\n            if (allowStale) {\n                if (options.status && bf.__staleWhileFetching !== undefined) {\n                    options.status.returnedStale = true;\n                }\n                return bf.__staleWhileFetching;\n            }\n            else if (bf.__returned === bf) {\n                throw er;\n            }\n        };\n        const pcall = (res, rej) => {\n            const fmp = this.#fetchMethod?.(k, v, fetchOpts);\n            if (fmp && fmp instanceof Promise) {\n                fmp.then(v => res(v === undefined ? undefined : v), rej);\n            }\n            // ignored, we go until we finish, regardless.\n            // defer check until we are actually aborting,\n            // so fetchMethod can override.\n            ac.signal.addEventListener('abort', () => {\n                if (!options.ignoreFetchAbort ||\n                    options.allowStaleOnFetchAbort) {\n                    res(undefined);\n                    // when it eventually resolves, update the cache.\n                    if (options.allowStaleOnFetchAbort) {\n                        res = v => cb(v, true);\n                    }\n                }\n            });\n        };\n        if (options.status)\n            options.status.fetchDispatched = true;\n        const p = new Promise(pcall).then(cb, eb);\n        const bf = Object.assign(p, {\n            __abortController: ac,\n            __staleWhileFetching: v,\n            __returned: undefined,\n        });\n        if (index === undefined) {\n            // internal, don't expose status.\n            this.set(k, bf, { ...fetchOpts.options, status: undefined });\n            index = this.#keyMap.get(k);\n        }\n        else {\n            this.#valList[index] = bf;\n        }\n        return bf;\n    }\n    #isBackgroundFetch(p) {\n        if (!this.#hasFetchMethod)\n            return false;\n        const b = p;\n        return (!!b &&\n            b instanceof Promise &&\n            b.hasOwnProperty('__staleWhileFetching') &&\n            b.__abortController instanceof AC);\n    }\n    async fetch(k, fetchOptions = {}) {\n        const { \n        // get options\n        allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, \n        // set options\n        ttl = this.ttl, noDisposeOnSet = this.noDisposeOnSet, size = 0, sizeCalculation = this.sizeCalculation, noUpdateTTL = this.noUpdateTTL, \n        // fetch exclusive options\n        noDeleteOnFetchRejection = this.noDeleteOnFetchRejection, allowStaleOnFetchRejection = this.allowStaleOnFetchRejection, ignoreFetchAbort = this.ignoreFetchAbort, allowStaleOnFetchAbort = this.allowStaleOnFetchAbort, context, forceRefresh = false, status, signal, } = fetchOptions;\n        if (!this.#hasFetchMethod) {\n            if (status)\n                status.fetch = 'get';\n            return this.get(k, {\n                allowStale,\n                updateAgeOnGet,\n                noDeleteOnStaleGet,\n                status,\n            });\n        }\n        const options = {\n            allowStale,\n            updateAgeOnGet,\n            noDeleteOnStaleGet,\n            ttl,\n            noDisposeOnSet,\n            size,\n            sizeCalculation,\n            noUpdateTTL,\n            noDeleteOnFetchRejection,\n            allowStaleOnFetchRejection,\n            allowStaleOnFetchAbort,\n            ignoreFetchAbort,\n            status,\n            signal,\n        };\n        let index = this.#keyMap.get(k);\n        if (index === undefined) {\n            if (status)\n                status.fetch = 'miss';\n            const p = this.#backgroundFetch(k, index, options, context);\n            return (p.__returned = p);\n        }\n        else {\n            // in cache, maybe already fetching\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                const stale = allowStale && v.__staleWhileFetching !== undefined;\n                if (status) {\n                    status.fetch = 'inflight';\n                    if (stale)\n                        status.returnedStale = true;\n                }\n                return stale ? v.__staleWhileFetching : (v.__returned = v);\n            }\n            // if we force a refresh, that means do NOT serve the cached value,\n            // unless we are already in the process of refreshing the cache.\n            const isStale = this.#isStale(index);\n            if (!forceRefresh && !isStale) {\n                if (status)\n                    status.fetch = 'hit';\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                if (status)\n                    this.#statusTTL(status, index);\n                return v;\n            }\n            // ok, it is stale or a forced refresh, and not already fetching.\n            // refresh the cache.\n            const p = this.#backgroundFetch(k, index, options, context);\n            const hasStale = p.__staleWhileFetching !== undefined;\n            const staleVal = hasStale && allowStale;\n            if (status) {\n                status.fetch = isStale ? 'stale' : 'refresh';\n                if (staleVal && isStale)\n                    status.returnedStale = true;\n            }\n            return staleVal ? p.__staleWhileFetching : (p.__returned = p);\n        }\n    }\n    async forceFetch(k, fetchOptions = {}) {\n        const v = await this.fetch(k, fetchOptions);\n        if (v === undefined)\n            throw new Error('fetch() returned undefined');\n        return v;\n    }\n    memo(k, memoOptions = {}) {\n        const memoMethod = this.#memoMethod;\n        if (!memoMethod) {\n            throw new Error('no memoMethod provided to constructor');\n        }\n        const { context, forceRefresh, ...options } = memoOptions;\n        const v = this.get(k, options);\n        if (!forceRefresh && v !== undefined)\n            return v;\n        const vv = memoMethod(k, v, {\n            options,\n            context,\n        });\n        this.set(k, vv, options);\n        return vv;\n    }\n    /**\n     * Return a value from the cache. Will update the recency of the cache\n     * entry found.\n     *\n     * If the key is not found, get() will return `undefined`.\n     */\n    get(k, getOptions = {}) {\n        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status, } = getOptions;\n        const index = this.#keyMap.get(k);\n        if (index !== undefined) {\n            const value = this.#valList[index];\n            const fetching = this.#isBackgroundFetch(value);\n            if (status)\n                this.#statusTTL(status, index);\n            if (this.#isStale(index)) {\n                if (status)\n                    status.get = 'stale';\n                // delete only if not an in-flight background fetch\n                if (!fetching) {\n                    if (!noDeleteOnStaleGet) {\n                        this.#delete(k, 'expire');\n                    }\n                    if (status && allowStale)\n                        status.returnedStale = true;\n                    return allowStale ? value : undefined;\n                }\n                else {\n                    if (status &&\n                        allowStale &&\n                        value.__staleWhileFetching !== undefined) {\n                        status.returnedStale = true;\n                    }\n                    return allowStale ? value.__staleWhileFetching : undefined;\n                }\n            }\n            else {\n                if (status)\n                    status.get = 'hit';\n                // if we're currently fetching it, we don't actually have it yet\n                // it's not stale, which means this isn't a staleWhileRefetching.\n                // If it's not stale, and fetching, AND has a __staleWhileFetching\n                // value, then that means the user fetched with {forceRefresh:true},\n                // so it's safe to return that value.\n                if (fetching) {\n                    return value.__staleWhileFetching;\n                }\n                this.#moveToTail(index);\n                if (updateAgeOnGet) {\n                    this.#updateItemAge(index);\n                }\n                return value;\n            }\n        }\n        else if (status) {\n            status.get = 'miss';\n        }\n    }\n    #connect(p, n) {\n        this.#prev[n] = p;\n        this.#next[p] = n;\n    }\n    #moveToTail(index) {\n        // if tail already, nothing to do\n        // if head, move head to next[index]\n        // else\n        //   move next[prev[index]] to next[index] (head has no prev)\n        //   move prev[next[index]] to prev[index]\n        // prev[index] = tail\n        // next[tail] = index\n        // tail = index\n        if (index !== this.#tail) {\n            if (index === this.#head) {\n                this.#head = this.#next[index];\n            }\n            else {\n                this.#connect(this.#prev[index], this.#next[index]);\n            }\n            this.#connect(this.#tail, index);\n            this.#tail = index;\n        }\n    }\n    /**\n     * Deletes a key out of the cache.\n     *\n     * Returns true if the key was deleted, false otherwise.\n     */\n    delete(k) {\n        return this.#delete(k, 'delete');\n    }\n    #delete(k, reason) {\n        let deleted = false;\n        if (this.#size !== 0) {\n            const index = this.#keyMap.get(k);\n            if (index !== undefined) {\n                deleted = true;\n                if (this.#size === 1) {\n                    this.#clear(reason);\n                }\n                else {\n                    this.#removeItemSize(index);\n                    const v = this.#valList[index];\n                    if (this.#isBackgroundFetch(v)) {\n                        v.__abortController.abort(new Error('deleted'));\n                    }\n                    else if (this.#hasDispose || this.#hasDisposeAfter) {\n                        if (this.#hasDispose) {\n                            this.#dispose?.(v, k, reason);\n                        }\n                        if (this.#hasDisposeAfter) {\n                            this.#disposed?.push([v, k, reason]);\n                        }\n                    }\n                    this.#keyMap.delete(k);\n                    this.#keyList[index] = undefined;\n                    this.#valList[index] = undefined;\n                    if (index === this.#tail) {\n                        this.#tail = this.#prev[index];\n                    }\n                    else if (index === this.#head) {\n                        this.#head = this.#next[index];\n                    }\n                    else {\n                        const pi = this.#prev[index];\n                        this.#next[pi] = this.#next[index];\n                        const ni = this.#next[index];\n                        this.#prev[ni] = this.#prev[index];\n                    }\n                    this.#size--;\n                    this.#free.push(index);\n                }\n            }\n        }\n        if (this.#hasDisposeAfter && this.#disposed?.length) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n        return deleted;\n    }\n    /**\n     * Clear the cache entirely, throwing away all values.\n     */\n    clear() {\n        return this.#clear('delete');\n    }\n    #clear(reason) {\n        for (const index of this.#rindexes({ allowStale: true })) {\n            const v = this.#valList[index];\n            if (this.#isBackgroundFetch(v)) {\n                v.__abortController.abort(new Error('deleted'));\n            }\n            else {\n                const k = this.#keyList[index];\n                if (this.#hasDispose) {\n                    this.#dispose?.(v, k, reason);\n                }\n                if (this.#hasDisposeAfter) {\n                    this.#disposed?.push([v, k, reason]);\n                }\n            }\n        }\n        this.#keyMap.clear();\n        this.#valList.fill(undefined);\n        this.#keyList.fill(undefined);\n        if (this.#ttls && this.#starts) {\n            this.#ttls.fill(0);\n            this.#starts.fill(0);\n        }\n        if (this.#sizes) {\n            this.#sizes.fill(0);\n        }\n        this.#head = 0;\n        this.#tail = 0;\n        this.#free.length = 0;\n        this.#calculatedSize = 0;\n        this.#size = 0;\n        if (this.#hasDisposeAfter && this.#disposed) {\n            const dt = this.#disposed;\n            let task;\n            while ((task = dt?.shift())) {\n                this.#disposeAfter?.(...task);\n            }\n        }\n    }\n}\nexports.LRUCache = LRUCache;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbHJ1LWNhY2hlL2Rpc3QvY29tbW9uanMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEtBQUssSUFBSSxLQUFLLElBQUksSUFBSTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQ0FBZ0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsb0NBQW9DO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHdDQUF3QztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxvQ0FBb0M7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEseUNBQXlDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsOFVBQThVO0FBQzlWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsK0JBQStCLElBQUk7QUFDbkQ7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsK0JBQStCLElBQUk7QUFDcEQ7QUFDQSxxQ0FBcUMsS0FBSztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxrQkFBa0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0JBQW9CO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlCQUF5QjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHFCQUFxQjtBQUN0RCxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLHVDQUF1QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0JBQWtCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLCtHQUErRztBQUMvSCxjQUFjLGlDQUFpQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLDBCQUEwQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkNBQTJDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyQ0FBMkM7QUFDbkQ7QUFDQSwwQkFBMEI7QUFDMUIsZ0JBQWdCLCtDQUErQztBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsb0JBQW9CO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUNBQXVDO0FBQy9DO0FBQ0EsNEJBQTRCO0FBQzVCLGdCQUFnQiwrQkFBK0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhCQUE4Qix5Q0FBeUM7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaVJBQWlSO0FBQ2pSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isb0NBQW9DO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUIsZ0JBQWdCLDRIQUE0SDtBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUUsa0JBQWtCO0FBQ25GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLGtCQUFrQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL2xydS1jYWNoZS9kaXN0L2NvbW1vbmpzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBAbW9kdWxlIExSVUNhY2hlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTFJVQ2FjaGUgPSB2b2lkIDA7XG5jb25zdCBwZXJmID0gdHlwZW9mIHBlcmZvcm1hbmNlID09PSAnb2JqZWN0JyAmJlxuICAgIHBlcmZvcm1hbmNlICYmXG4gICAgdHlwZW9mIHBlcmZvcm1hbmNlLm5vdyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gcGVyZm9ybWFuY2VcbiAgICA6IERhdGU7XG5jb25zdCB3YXJuZWQgPSBuZXcgU2V0KCk7XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IFBST0NFU1MgPSAodHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmICEhcHJvY2VzcyA/IHByb2Nlc3MgOiB7fSk7XG4vKiBjOCBpZ25vcmUgc3RhcnQgKi9cbmNvbnN0IGVtaXRXYXJuaW5nID0gKG1zZywgdHlwZSwgY29kZSwgZm4pID0+IHtcbiAgICB0eXBlb2YgUFJPQ0VTUy5lbWl0V2FybmluZyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IFBST0NFU1MuZW1pdFdhcm5pbmcobXNnLCB0eXBlLCBjb2RlLCBmbilcbiAgICAgICAgOiBjb25zb2xlLmVycm9yKGBbJHtjb2RlfV0gJHt0eXBlfTogJHttc2d9YCk7XG59O1xubGV0IEFDID0gZ2xvYmFsVGhpcy5BYm9ydENvbnRyb2xsZXI7XG5sZXQgQVMgPSBnbG9iYWxUaGlzLkFib3J0U2lnbmFsO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG5pZiAodHlwZW9mIEFDID09PSAndW5kZWZpbmVkJykge1xuICAgIC8vQHRzLWlnbm9yZVxuICAgIEFTID0gY2xhc3MgQWJvcnRTaWduYWwge1xuICAgICAgICBvbmFib3J0O1xuICAgICAgICBfb25hYm9ydCA9IFtdO1xuICAgICAgICByZWFzb247XG4gICAgICAgIGFib3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcihfLCBmbikge1xuICAgICAgICAgICAgdGhpcy5fb25hYm9ydC5wdXNoKGZuKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLy9AdHMtaWdub3JlXG4gICAgQUMgPSBjbGFzcyBBYm9ydENvbnRyb2xsZXIge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHdhcm5BQ1BvbHlmaWxsKCk7XG4gICAgICAgIH1cbiAgICAgICAgc2lnbmFsID0gbmV3IEFTKCk7XG4gICAgICAgIGFib3J0KHJlYXNvbikge1xuICAgICAgICAgICAgaWYgKHRoaXMuc2lnbmFsLmFib3J0ZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLnNpZ25hbC5yZWFzb24gPSByZWFzb247XG4gICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuc2lnbmFsLmFib3J0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgLy9AdHMtaWdub3JlXG4gICAgICAgICAgICBmb3IgKGNvbnN0IGZuIG9mIHRoaXMuc2lnbmFsLl9vbmFib3J0KSB7XG4gICAgICAgICAgICAgICAgZm4ocmVhc29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2lnbmFsLm9uYWJvcnQ/LihyZWFzb24pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBsZXQgcHJpbnRBQ1BvbHlmaWxsV2FybmluZyA9IFBST0NFU1MuZW52Py5MUlVfQ0FDSEVfSUdOT1JFX0FDX1dBUk5JTkcgIT09ICcxJztcbiAgICBjb25zdCB3YXJuQUNQb2x5ZmlsbCA9ICgpID0+IHtcbiAgICAgICAgaWYgKCFwcmludEFDUG9seWZpbGxXYXJuaW5nKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBwcmludEFDUG9seWZpbGxXYXJuaW5nID0gZmFsc2U7XG4gICAgICAgIGVtaXRXYXJuaW5nKCdBYm9ydENvbnRyb2xsZXIgaXMgbm90IGRlZmluZWQuIElmIHVzaW5nIGxydS1jYWNoZSBpbiAnICtcbiAgICAgICAgICAgICdub2RlIDE0LCBsb2FkIGFuIEFib3J0Q29udHJvbGxlciBwb2x5ZmlsbCBmcm9tIHRoZSAnICtcbiAgICAgICAgICAgICdgbm9kZS1hYm9ydC1jb250cm9sbGVyYCBwYWNrYWdlLiBBIG1pbmltYWwgcG9seWZpbGwgaXMgJyArXG4gICAgICAgICAgICAncHJvdmlkZWQgZm9yIHVzZSBieSBMUlVDYWNoZS5mZXRjaCgpLCBidXQgaXQgc2hvdWxkIG5vdCBiZSAnICtcbiAgICAgICAgICAgICdyZWxpZWQgdXBvbiBpbiBvdGhlciBjb250ZXh0cyAoZWcsIHBhc3NpbmcgaXQgdG8gb3RoZXIgQVBJcyB0aGF0ICcgK1xuICAgICAgICAgICAgJ3VzZSBBYm9ydENvbnRyb2xsZXIvQWJvcnRTaWduYWwgbWlnaHQgaGF2ZSB1bmRlc2lyYWJsZSBlZmZlY3RzKS4gJyArXG4gICAgICAgICAgICAnWW91IG1heSBkaXNhYmxlIHRoaXMgd2l0aCBMUlVfQ0FDSEVfSUdOT1JFX0FDX1dBUk5JTkc9MSBpbiB0aGUgZW52LicsICdOT19BQk9SVF9DT05UUk9MTEVSJywgJ0VOT1RTVVAnLCB3YXJuQUNQb2x5ZmlsbCk7XG4gICAgfTtcbn1cbi8qIGM4IGlnbm9yZSBzdG9wICovXG5jb25zdCBzaG91bGRXYXJuID0gKGNvZGUpID0+ICF3YXJuZWQuaGFzKGNvZGUpO1xuY29uc3QgVFlQRSA9IFN5bWJvbCgndHlwZScpO1xuY29uc3QgaXNQb3NJbnQgPSAobikgPT4gbiAmJiBuID09PSBNYXRoLmZsb29yKG4pICYmIG4gPiAwICYmIGlzRmluaXRlKG4pO1xuLyogYzggaWdub3JlIHN0YXJ0ICovXG4vLyBUaGlzIGlzIGEgbGl0dGxlIGJpdCByaWRpY3Vsb3VzLCB0YmguXG4vLyBUaGUgbWF4aW11bSBhcnJheSBsZW5ndGggaXMgMl4zMi0xIG9yIHRoZXJlYWJvdXRzIG9uIG1vc3QgSlMgaW1wbHMuXG4vLyBBbmQgd2VsbCBiZWZvcmUgdGhhdCBwb2ludCwgeW91J3JlIGNhY2hpbmcgdGhlIGVudGlyZSB3b3JsZCwgSSBtZWFuLFxuLy8gdGhhdCdzIH4zMkdCIG9mIGp1c3QgaW50ZWdlcnMgZm9yIHRoZSBuZXh0L3ByZXYgbGlua3MsIHBsdXMgd2hhdGV2ZXJcbi8vIGVsc2UgdG8gaG9sZCB0aGF0IG1hbnkga2V5cyBhbmQgdmFsdWVzLiAgSnVzdCBmaWxsaW5nIHRoZSBtZW1vcnkgd2l0aFxuLy8gemVyb2VzIGF0IGluaXQgdGltZSBpcyBicnV0YWwgd2hlbiB5b3UgZ2V0IHRoYXQgYmlnLlxuLy8gQnV0IHdoeSBub3QgYmUgY29tcGxldGU/XG4vLyBNYXliZSBpbiB0aGUgZnV0dXJlLCB0aGVzZSBsaW1pdHMgd2lsbCBoYXZlIGV4cGFuZGVkLlxuY29uc3QgZ2V0VWludEFycmF5ID0gKG1heCkgPT4gIWlzUG9zSW50KG1heClcbiAgICA/IG51bGxcbiAgICA6IG1heCA8PSBNYXRoLnBvdygyLCA4KVxuICAgICAgICA/IFVpbnQ4QXJyYXlcbiAgICAgICAgOiBtYXggPD0gTWF0aC5wb3coMiwgMTYpXG4gICAgICAgICAgICA/IFVpbnQxNkFycmF5XG4gICAgICAgICAgICA6IG1heCA8PSBNYXRoLnBvdygyLCAzMilcbiAgICAgICAgICAgICAgICA/IFVpbnQzMkFycmF5XG4gICAgICAgICAgICAgICAgOiBtYXggPD0gTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJcbiAgICAgICAgICAgICAgICAgICAgPyBaZXJvQXJyYXlcbiAgICAgICAgICAgICAgICAgICAgOiBudWxsO1xuLyogYzggaWdub3JlIHN0b3AgKi9cbmNsYXNzIFplcm9BcnJheSBleHRlbmRzIEFycmF5IHtcbiAgICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgICAgIHN1cGVyKHNpemUpO1xuICAgICAgICB0aGlzLmZpbGwoMCk7XG4gICAgfVxufVxuY2xhc3MgU3RhY2sge1xuICAgIGhlYXA7XG4gICAgbGVuZ3RoO1xuICAgIC8vIHByaXZhdGUgY29uc3RydWN0b3JcbiAgICBzdGF0aWMgI2NvbnN0cnVjdGluZyA9IGZhbHNlO1xuICAgIHN0YXRpYyBjcmVhdGUobWF4KSB7XG4gICAgICAgIGNvbnN0IEhlYXBDbHMgPSBnZXRVaW50QXJyYXkobWF4KTtcbiAgICAgICAgaWYgKCFIZWFwQ2xzKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICBTdGFjay4jY29uc3RydWN0aW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcyA9IG5ldyBTdGFjayhtYXgsIEhlYXBDbHMpO1xuICAgICAgICBTdGFjay4jY29uc3RydWN0aW5nID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBzO1xuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihtYXgsIEhlYXBDbHMpIHtcbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICghU3RhY2suI2NvbnN0cnVjdGluZykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW5zdGFudGlhdGUgU3RhY2sgdXNpbmcgU3RhY2suY3JlYXRlKG4pJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy5oZWFwID0gbmV3IEhlYXBDbHMobWF4KTtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBwdXNoKG4pIHtcbiAgICAgICAgdGhpcy5oZWFwW3RoaXMubGVuZ3RoKytdID0gbjtcbiAgICB9XG4gICAgcG9wKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5oZWFwWy0tdGhpcy5sZW5ndGhdO1xuICAgIH1cbn1cbi8qKlxuICogRGVmYXVsdCBleHBvcnQsIHRoZSB0aGluZyB5b3UncmUgdXNpbmcgdGhpcyBtb2R1bGUgdG8gZ2V0LlxuICpcbiAqIFRoZSBgS2AgYW5kIGBWYCB0eXBlcyBkZWZpbmUgdGhlIGtleSBhbmQgdmFsdWUgdHlwZXMsIHJlc3BlY3RpdmVseS4gVGhlXG4gKiBvcHRpb25hbCBgRkNgIHR5cGUgZGVmaW5lcyB0aGUgdHlwZSBvZiB0aGUgYGNvbnRleHRgIG9iamVjdCBwYXNzZWQgdG9cbiAqIGBjYWNoZS5mZXRjaCgpYCBhbmQgYGNhY2hlLm1lbW8oKWAuXG4gKlxuICogS2V5cyBhbmQgdmFsdWVzICoqbXVzdCBub3QqKiBiZSBgbnVsbGAgb3IgYHVuZGVmaW5lZGAuXG4gKlxuICogQWxsIHByb3BlcnRpZXMgZnJvbSB0aGUgb3B0aW9ucyBvYmplY3QgKHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBgbWF4YCxcbiAqIGBtYXhTaXplYCwgYGZldGNoTWV0aG9kYCwgYG1lbW9NZXRob2RgLCBgZGlzcG9zZWAgYW5kIGBkaXNwb3NlQWZ0ZXJgKSBhcmVcbiAqIGFkZGVkIGFzIG5vcm1hbCBwdWJsaWMgbWVtYmVycy4gKFRoZSBsaXN0ZWQgb3B0aW9ucyBhcmUgcmVhZC1vbmx5IGdldHRlcnMuKVxuICpcbiAqIENoYW5naW5nIGFueSBvZiB0aGVzZSB3aWxsIGFsdGVyIHRoZSBkZWZhdWx0cyBmb3Igc3Vic2VxdWVudCBtZXRob2QgY2FsbHMuXG4gKi9cbmNsYXNzIExSVUNhY2hlIHtcbiAgICAvLyBvcHRpb25zIHRoYXQgY2Fubm90IGJlIGNoYW5nZWQgd2l0aG91dCBkaXNhc3RlclxuICAgICNtYXg7XG4gICAgI21heFNpemU7XG4gICAgI2Rpc3Bvc2U7XG4gICAgI2Rpc3Bvc2VBZnRlcjtcbiAgICAjZmV0Y2hNZXRob2Q7XG4gICAgI21lbW9NZXRob2Q7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnR0bH1cbiAgICAgKi9cbiAgICB0dGw7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnR0bFJlc29sdXRpb259XG4gICAgICovXG4gICAgdHRsUmVzb2x1dGlvbjtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudHRsQXV0b3B1cmdlfVxuICAgICAqL1xuICAgIHR0bEF1dG9wdXJnZTtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UudXBkYXRlQWdlT25HZXR9XG4gICAgICovXG4gICAgdXBkYXRlQWdlT25HZXQ7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLnVwZGF0ZUFnZU9uSGFzfVxuICAgICAqL1xuICAgIHVwZGF0ZUFnZU9uSGFzO1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5hbGxvd1N0YWxlfVxuICAgICAqL1xuICAgIGFsbG93U3RhbGU7XG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm5vRGlzcG9zZU9uU2V0fVxuICAgICAqL1xuICAgIG5vRGlzcG9zZU9uU2V0O1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5ub1VwZGF0ZVRUTH1cbiAgICAgKi9cbiAgICBub1VwZGF0ZVRUTDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UubWF4RW50cnlTaXplfVxuICAgICAqL1xuICAgIG1heEVudHJ5U2l6ZTtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2Uuc2l6ZUNhbGN1bGF0aW9ufVxuICAgICAqL1xuICAgIHNpemVDYWxjdWxhdGlvbjtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2Uubm9EZWxldGVPbkZldGNoUmVqZWN0aW9ufVxuICAgICAqL1xuICAgIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbjtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2Uubm9EZWxldGVPblN0YWxlR2V0fVxuICAgICAqL1xuICAgIG5vRGVsZXRlT25TdGFsZUdldDtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydH1cbiAgICAgKi9cbiAgICBhbGxvd1N0YWxlT25GZXRjaEFib3J0O1xuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5hbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbn1cbiAgICAgKi9cbiAgICBhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbjtcbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuaWdub3JlRmV0Y2hBYm9ydH1cbiAgICAgKi9cbiAgICBpZ25vcmVGZXRjaEFib3J0O1xuICAgIC8vIGNvbXB1dGVkIHByb3BlcnRpZXNcbiAgICAjc2l6ZTtcbiAgICAjY2FsY3VsYXRlZFNpemU7XG4gICAgI2tleU1hcDtcbiAgICAja2V5TGlzdDtcbiAgICAjdmFsTGlzdDtcbiAgICAjbmV4dDtcbiAgICAjcHJldjtcbiAgICAjaGVhZDtcbiAgICAjdGFpbDtcbiAgICAjZnJlZTtcbiAgICAjZGlzcG9zZWQ7XG4gICAgI3NpemVzO1xuICAgICNzdGFydHM7XG4gICAgI3R0bHM7XG4gICAgI2hhc0Rpc3Bvc2U7XG4gICAgI2hhc0ZldGNoTWV0aG9kO1xuICAgICNoYXNEaXNwb3NlQWZ0ZXI7XG4gICAgLyoqXG4gICAgICogRG8gbm90IGNhbGwgdGhpcyBtZXRob2QgdW5sZXNzIHlvdSBuZWVkIHRvIGluc3BlY3QgdGhlXG4gICAgICogaW5uZXIgd29ya2luZ3Mgb2YgdGhlIGNhY2hlLiAgSWYgYW55dGhpbmcgcmV0dXJuZWQgYnkgdGhpc1xuICAgICAqIG9iamVjdCBpcyBtb2RpZmllZCBpbiBhbnkgd2F5LCBzdHJhbmdlIGJyZWFrYWdlIG1heSBvY2N1ci5cbiAgICAgKlxuICAgICAqIFRoZXNlIGZpZWxkcyBhcmUgcHJpdmF0ZSBmb3IgYSByZWFzb24hXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzdGF0aWMgdW5zYWZlRXhwb3NlSW50ZXJuYWxzKGMpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8vIHByb3BlcnRpZXNcbiAgICAgICAgICAgIHN0YXJ0czogYy4jc3RhcnRzLFxuICAgICAgICAgICAgdHRsczogYy4jdHRscyxcbiAgICAgICAgICAgIHNpemVzOiBjLiNzaXplcyxcbiAgICAgICAgICAgIGtleU1hcDogYy4ja2V5TWFwLFxuICAgICAgICAgICAga2V5TGlzdDogYy4ja2V5TGlzdCxcbiAgICAgICAgICAgIHZhbExpc3Q6IGMuI3ZhbExpc3QsXG4gICAgICAgICAgICBuZXh0OiBjLiNuZXh0LFxuICAgICAgICAgICAgcHJldjogYy4jcHJldixcbiAgICAgICAgICAgIGdldCBoZWFkKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjLiNoZWFkO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCB0YWlsKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjLiN0YWlsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyZWU6IGMuI2ZyZWUsXG4gICAgICAgICAgICAvLyBtZXRob2RzXG4gICAgICAgICAgICBpc0JhY2tncm91bmRGZXRjaDogKHApID0+IGMuI2lzQmFja2dyb3VuZEZldGNoKHApLFxuICAgICAgICAgICAgYmFja2dyb3VuZEZldGNoOiAoaywgaW5kZXgsIG9wdGlvbnMsIGNvbnRleHQpID0+IGMuI2JhY2tncm91bmRGZXRjaChrLCBpbmRleCwgb3B0aW9ucywgY29udGV4dCksXG4gICAgICAgICAgICBtb3ZlVG9UYWlsOiAoaW5kZXgpID0+IGMuI21vdmVUb1RhaWwoaW5kZXgpLFxuICAgICAgICAgICAgaW5kZXhlczogKG9wdGlvbnMpID0+IGMuI2luZGV4ZXMob3B0aW9ucyksXG4gICAgICAgICAgICByaW5kZXhlczogKG9wdGlvbnMpID0+IGMuI3JpbmRleGVzKG9wdGlvbnMpLFxuICAgICAgICAgICAgaXNTdGFsZTogKGluZGV4KSA9PiBjLiNpc1N0YWxlKGluZGV4KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gUHJvdGVjdGVkIHJlYWQtb25seSBtZW1iZXJzXG4gICAgLyoqXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLm1heH0gKHJlYWQtb25seSlcbiAgICAgKi9cbiAgICBnZXQgbWF4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbWF4O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UubWF4U2l6ZX0gKHJlYWQtb25seSlcbiAgICAgKi9cbiAgICBnZXQgbWF4U2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI21heFNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSB0b3RhbCBjb21wdXRlZCBzaXplIG9mIGl0ZW1zIGluIHRoZSBjYWNoZSAocmVhZC1vbmx5KVxuICAgICAqL1xuICAgIGdldCBjYWxjdWxhdGVkU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NhbGN1bGF0ZWRTaXplO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIGl0ZW1zIHN0b3JlZCBpbiB0aGUgY2FjaGUgKHJlYWQtb25seSlcbiAgICAgKi9cbiAgICBnZXQgc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI3NpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5mZXRjaE1ldGhvZH0gKHJlYWQtb25seSlcbiAgICAgKi9cbiAgICBnZXQgZmV0Y2hNZXRob2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNmZXRjaE1ldGhvZDtcbiAgICB9XG4gICAgZ2V0IG1lbW9NZXRob2QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNtZW1vTWV0aG9kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuT3B0aW9uc0Jhc2UuZGlzcG9zZX0gKHJlYWQtb25seSlcbiAgICAgKi9cbiAgICBnZXQgZGlzcG9zZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Rpc3Bvc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5kaXNwb3NlQWZ0ZXJ9IChyZWFkLW9ubHkpXG4gICAgICovXG4gICAgZ2V0IGRpc3Bvc2VBZnRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2Rpc3Bvc2VBZnRlcjtcbiAgICB9XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICBjb25zdCB7IG1heCA9IDAsIHR0bCwgdHRsUmVzb2x1dGlvbiA9IDEsIHR0bEF1dG9wdXJnZSwgdXBkYXRlQWdlT25HZXQsIHVwZGF0ZUFnZU9uSGFzLCBhbGxvd1N0YWxlLCBkaXNwb3NlLCBkaXNwb3NlQWZ0ZXIsIG5vRGlzcG9zZU9uU2V0LCBub1VwZGF0ZVRUTCwgbWF4U2l6ZSA9IDAsIG1heEVudHJ5U2l6ZSA9IDAsIHNpemVDYWxjdWxhdGlvbiwgZmV0Y2hNZXRob2QsIG1lbW9NZXRob2QsIG5vRGVsZXRlT25GZXRjaFJlamVjdGlvbiwgbm9EZWxldGVPblN0YWxlR2V0LCBhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiwgYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCwgaWdub3JlRmV0Y2hBYm9ydCwgfSA9IG9wdGlvbnM7XG4gICAgICAgIGlmIChtYXggIT09IDAgJiYgIWlzUG9zSW50KG1heCkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21heCBvcHRpb24gbXVzdCBiZSBhIG5vbm5lZ2F0aXZlIGludGVnZXInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBVaW50QXJyYXkgPSBtYXggPyBnZXRVaW50QXJyYXkobWF4KSA6IEFycmF5O1xuICAgICAgICBpZiAoIVVpbnRBcnJheSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIG1heCB2YWx1ZTogJyArIG1heCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jbWF4ID0gbWF4O1xuICAgICAgICB0aGlzLiNtYXhTaXplID0gbWF4U2l6ZTtcbiAgICAgICAgdGhpcy5tYXhFbnRyeVNpemUgPSBtYXhFbnRyeVNpemUgfHwgdGhpcy4jbWF4U2l6ZTtcbiAgICAgICAgdGhpcy5zaXplQ2FsY3VsYXRpb24gPSBzaXplQ2FsY3VsYXRpb247XG4gICAgICAgIGlmICh0aGlzLnNpemVDYWxjdWxhdGlvbikge1xuICAgICAgICAgICAgaWYgKCF0aGlzLiNtYXhTaXplICYmICF0aGlzLm1heEVudHJ5U2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBzZXQgc2l6ZUNhbGN1bGF0aW9uIHdpdGhvdXQgc2V0dGluZyBtYXhTaXplIG9yIG1heEVudHJ5U2l6ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLnNpemVDYWxjdWxhdGlvbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemVDYWxjdWxhdGlvbiBzZXQgdG8gbm9uLWZ1bmN0aW9uJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1lbW9NZXRob2QgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgdHlwZW9mIG1lbW9NZXRob2QgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21lbW9NZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIGRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNtZW1vTWV0aG9kID0gbWVtb01ldGhvZDtcbiAgICAgICAgaWYgKGZldGNoTWV0aG9kICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIHR5cGVvZiBmZXRjaE1ldGhvZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZmV0Y2hNZXRob2QgbXVzdCBiZSBhIGZ1bmN0aW9uIGlmIHNwZWNpZmllZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2ZldGNoTWV0aG9kID0gZmV0Y2hNZXRob2Q7XG4gICAgICAgIHRoaXMuI2hhc0ZldGNoTWV0aG9kID0gISFmZXRjaE1ldGhvZDtcbiAgICAgICAgdGhpcy4ja2V5TWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLiNrZXlMaXN0ID0gbmV3IEFycmF5KG1heCkuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLiN2YWxMaXN0ID0gbmV3IEFycmF5KG1heCkuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLiNuZXh0ID0gbmV3IFVpbnRBcnJheShtYXgpO1xuICAgICAgICB0aGlzLiNwcmV2ID0gbmV3IFVpbnRBcnJheShtYXgpO1xuICAgICAgICB0aGlzLiNoZWFkID0gMDtcbiAgICAgICAgdGhpcy4jdGFpbCA9IDA7XG4gICAgICAgIHRoaXMuI2ZyZWUgPSBTdGFjay5jcmVhdGUobWF4KTtcbiAgICAgICAgdGhpcy4jc2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuI2NhbGN1bGF0ZWRTaXplID0gMDtcbiAgICAgICAgaWYgKHR5cGVvZiBkaXNwb3NlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB0aGlzLiNkaXNwb3NlID0gZGlzcG9zZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRpc3Bvc2VBZnRlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyID0gZGlzcG9zZUFmdGVyO1xuICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VBZnRlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI2hhc0Rpc3Bvc2UgPSAhIXRoaXMuI2Rpc3Bvc2U7XG4gICAgICAgIHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciA9ICEhdGhpcy4jZGlzcG9zZUFmdGVyO1xuICAgICAgICB0aGlzLm5vRGlzcG9zZU9uU2V0ID0gISFub0Rpc3Bvc2VPblNldDtcbiAgICAgICAgdGhpcy5ub1VwZGF0ZVRUTCA9ICEhbm9VcGRhdGVUVEw7XG4gICAgICAgIHRoaXMubm9EZWxldGVPbkZldGNoUmVqZWN0aW9uID0gISFub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgICAgIHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb24gPSAhIWFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uO1xuICAgICAgICB0aGlzLmFsbG93U3RhbGVPbkZldGNoQWJvcnQgPSAhIWFsbG93U3RhbGVPbkZldGNoQWJvcnQ7XG4gICAgICAgIHRoaXMuaWdub3JlRmV0Y2hBYm9ydCA9ICEhaWdub3JlRmV0Y2hBYm9ydDtcbiAgICAgICAgLy8gTkI6IG1heEVudHJ5U2l6ZSBpcyBzZXQgdG8gbWF4U2l6ZSBpZiBpdCdzIHNldFxuICAgICAgICBpZiAodGhpcy5tYXhFbnRyeVNpemUgIT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNtYXhTaXplICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1Bvc0ludCh0aGlzLiNtYXhTaXplKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtYXhTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNQb3NJbnQodGhpcy5tYXhFbnRyeVNpemUpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWF4RW50cnlTaXplIG11c3QgYmUgYSBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jaW5pdGlhbGl6ZVNpemVUcmFja2luZygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWxsb3dTdGFsZSA9ICEhYWxsb3dTdGFsZTtcbiAgICAgICAgdGhpcy5ub0RlbGV0ZU9uU3RhbGVHZXQgPSAhIW5vRGVsZXRlT25TdGFsZUdldDtcbiAgICAgICAgdGhpcy51cGRhdGVBZ2VPbkdldCA9ICEhdXBkYXRlQWdlT25HZXQ7XG4gICAgICAgIHRoaXMudXBkYXRlQWdlT25IYXMgPSAhIXVwZGF0ZUFnZU9uSGFzO1xuICAgICAgICB0aGlzLnR0bFJlc29sdXRpb24gPVxuICAgICAgICAgICAgaXNQb3NJbnQodHRsUmVzb2x1dGlvbikgfHwgdHRsUmVzb2x1dGlvbiA9PT0gMFxuICAgICAgICAgICAgICAgID8gdHRsUmVzb2x1dGlvblxuICAgICAgICAgICAgICAgIDogMTtcbiAgICAgICAgdGhpcy50dGxBdXRvcHVyZ2UgPSAhIXR0bEF1dG9wdXJnZTtcbiAgICAgICAgdGhpcy50dGwgPSB0dGwgfHwgMDtcbiAgICAgICAgaWYgKHRoaXMudHRsKSB7XG4gICAgICAgICAgICBpZiAoIWlzUG9zSW50KHRoaXMudHRsKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3R0bCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciBpZiBzcGVjaWZpZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuI2luaXRpYWxpemVUVExUcmFja2luZygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvIG5vdCBhbGxvdyBjb21wbGV0ZWx5IHVuYm91bmRlZCBjYWNoZXNcbiAgICAgICAgaWYgKHRoaXMuI21heCA9PT0gMCAmJiB0aGlzLnR0bCA9PT0gMCAmJiB0aGlzLiNtYXhTaXplID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBdCBsZWFzdCBvbmUgb2YgbWF4LCBtYXhTaXplLCBvciB0dGwgaXMgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMudHRsQXV0b3B1cmdlICYmICF0aGlzLiNtYXggJiYgIXRoaXMuI21heFNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGUgPSAnTFJVX0NBQ0hFX1VOQk9VTkRFRCc7XG4gICAgICAgICAgICBpZiAoc2hvdWxkV2Fybihjb2RlKSkge1xuICAgICAgICAgICAgICAgIHdhcm5lZC5hZGQoY29kZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbXNnID0gJ1RUTCBjYWNoaW5nIHdpdGhvdXQgdHRsQXV0b3B1cmdlLCBtYXgsIG9yIG1heFNpemUgY2FuICcgK1xuICAgICAgICAgICAgICAgICAgICAncmVzdWx0IGluIHVuYm91bmRlZCBtZW1vcnkgY29uc3VtcHRpb24uJztcbiAgICAgICAgICAgICAgICBlbWl0V2FybmluZyhtc2csICdVbmJvdW5kZWRDYWNoZVdhcm5pbmcnLCBjb2RlLCBMUlVDYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgbXMgbGVmdCBpbiB0aGUgaXRlbSdzIFRUTC4gSWYgaXRlbSBpcyBub3QgaW4gY2FjaGUsXG4gICAgICogcmV0dXJucyBgMGAuIFJldHVybnMgYEluZmluaXR5YCBpZiBpdGVtIGlzIGluIGNhY2hlIHdpdGhvdXQgYSBkZWZpbmVkIFRUTC5cbiAgICAgKi9cbiAgICBnZXRSZW1haW5pbmdUVEwoa2V5KSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNrZXlNYXAuaGFzKGtleSkgPyBJbmZpbml0eSA6IDA7XG4gICAgfVxuICAgICNpbml0aWFsaXplVFRMVHJhY2tpbmcoKSB7XG4gICAgICAgIGNvbnN0IHR0bHMgPSBuZXcgWmVyb0FycmF5KHRoaXMuI21heCk7XG4gICAgICAgIGNvbnN0IHN0YXJ0cyA9IG5ldyBaZXJvQXJyYXkodGhpcy4jbWF4KTtcbiAgICAgICAgdGhpcy4jdHRscyA9IHR0bHM7XG4gICAgICAgIHRoaXMuI3N0YXJ0cyA9IHN0YXJ0cztcbiAgICAgICAgdGhpcy4jc2V0SXRlbVRUTCA9IChpbmRleCwgdHRsLCBzdGFydCA9IHBlcmYubm93KCkpID0+IHtcbiAgICAgICAgICAgIHN0YXJ0c1tpbmRleF0gPSB0dGwgIT09IDAgPyBzdGFydCA6IDA7XG4gICAgICAgICAgICB0dGxzW2luZGV4XSA9IHR0bDtcbiAgICAgICAgICAgIGlmICh0dGwgIT09IDAgJiYgdGhpcy50dGxBdXRvcHVyZ2UpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNpc1N0YWxlKGluZGV4KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGVsZXRlKHRoaXMuI2tleUxpc3RbaW5kZXhdLCAnZXhwaXJlJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB0dGwgKyAxKTtcbiAgICAgICAgICAgICAgICAvLyB1bnJlZigpIG5vdCBzdXBwb3J0ZWQgb24gYWxsIHBsYXRmb3Jtc1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGlmICh0LnVucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgIHQudW5yZWYoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jdXBkYXRlSXRlbUFnZSA9IGluZGV4ID0+IHtcbiAgICAgICAgICAgIHN0YXJ0c1tpbmRleF0gPSB0dGxzW2luZGV4XSAhPT0gMCA/IHBlcmYubm93KCkgOiAwO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLiNzdGF0dXNUVEwgPSAoc3RhdHVzLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKHR0bHNbaW5kZXhdKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdHRsID0gdHRsc1tpbmRleF07XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBzdGFydHNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBuZXh0ICovXG4gICAgICAgICAgICAgICAgaWYgKCF0dGwgfHwgIXN0YXJ0KVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgc3RhdHVzLnR0bCA9IHR0bDtcbiAgICAgICAgICAgICAgICBzdGF0dXMuc3RhcnQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICBzdGF0dXMubm93ID0gY2FjaGVkTm93IHx8IGdldE5vdygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFnZSA9IHN0YXR1cy5ub3cgLSBzdGFydDtcbiAgICAgICAgICAgICAgICBzdGF0dXMucmVtYWluaW5nVFRMID0gdHRsIC0gYWdlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICAvLyBkZWJvdW5jZSBjYWxscyB0byBwZXJmLm5vdygpIHRvIDFzIHNvIHdlJ3JlIG5vdCBoaXR0aW5nXG4gICAgICAgIC8vIHRoYXQgY29zdGx5IGNhbGwgcmVwZWF0ZWRseS5cbiAgICAgICAgbGV0IGNhY2hlZE5vdyA9IDA7XG4gICAgICAgIGNvbnN0IGdldE5vdyA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBwZXJmLm5vdygpO1xuICAgICAgICAgICAgaWYgKHRoaXMudHRsUmVzb2x1dGlvbiA+IDApIHtcbiAgICAgICAgICAgICAgICBjYWNoZWROb3cgPSBuO1xuICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBzZXRUaW1lb3V0KCgpID0+IChjYWNoZWROb3cgPSAwKSwgdGhpcy50dGxSZXNvbHV0aW9uKTtcbiAgICAgICAgICAgICAgICAvLyBub3QgYXZhaWxhYmxlIG9uIGFsbCBwbGF0Zm9ybXNcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBpZiAodC51bnJlZikge1xuICAgICAgICAgICAgICAgICAgICB0LnVucmVmKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5nZXRSZW1haW5pbmdUVEwgPSBrZXkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGtleSk7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHRsID0gdHRsc1tpbmRleF07XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHN0YXJ0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIXR0bCB8fCAhc3RhcnQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gSW5maW5pdHk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhZ2UgPSAoY2FjaGVkTm93IHx8IGdldE5vdygpKSAtIHN0YXJ0O1xuICAgICAgICAgICAgcmV0dXJuIHR0bCAtIGFnZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jaXNTdGFsZSA9IGluZGV4ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHMgPSBzdGFydHNbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3QgdCA9IHR0bHNbaW5kZXhdO1xuICAgICAgICAgICAgcmV0dXJuICEhdCAmJiAhIXMgJiYgKGNhY2hlZE5vdyB8fCBnZXROb3coKSkgLSBzID4gdDtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gY29uZGl0aW9uYWxseSBzZXQgcHJpdmF0ZSBtZXRob2RzIHJlbGF0ZWQgdG8gVFRMXG4gICAgI3VwZGF0ZUl0ZW1BZ2UgPSAoKSA9PiB7IH07XG4gICAgI3N0YXR1c1RUTCA9ICgpID0+IHsgfTtcbiAgICAjc2V0SXRlbVRUTCA9ICgpID0+IHsgfTtcbiAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICNpc1N0YWxlID0gKCkgPT4gZmFsc2U7XG4gICAgI2luaXRpYWxpemVTaXplVHJhY2tpbmcoKSB7XG4gICAgICAgIGNvbnN0IHNpemVzID0gbmV3IFplcm9BcnJheSh0aGlzLiNtYXgpO1xuICAgICAgICB0aGlzLiNjYWxjdWxhdGVkU2l6ZSA9IDA7XG4gICAgICAgIHRoaXMuI3NpemVzID0gc2l6ZXM7XG4gICAgICAgIHRoaXMuI3JlbW92ZUl0ZW1TaXplID0gaW5kZXggPT4ge1xuICAgICAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgLT0gc2l6ZXNbaW5kZXhdO1xuICAgICAgICAgICAgc2l6ZXNbaW5kZXhdID0gMDtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy4jcmVxdWlyZVNpemUgPSAoaywgdiwgc2l6ZSwgc2l6ZUNhbGN1bGF0aW9uKSA9PiB7XG4gICAgICAgICAgICAvLyBwcm92aXNpb25hbGx5IGFjY2VwdCBiYWNrZ3JvdW5kIGZldGNoZXMuXG4gICAgICAgICAgICAvLyBhY3R1YWwgdmFsdWUgc2l6ZSB3aWxsIGJlIGNoZWNrZWQgd2hlbiB0aGV5IHJldHVybi5cbiAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpc1Bvc0ludChzaXplKSkge1xuICAgICAgICAgICAgICAgIGlmIChzaXplQ2FsY3VsYXRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzaXplQ2FsY3VsYXRpb24gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3NpemVDYWxjdWxhdGlvbiBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzaXplID0gc2l6ZUNhbGN1bGF0aW9uKHYsIGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUG9zSW50KHNpemUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdzaXplQ2FsY3VsYXRpb24gcmV0dXJuIGludmFsaWQgKGV4cGVjdCBwb3NpdGl2ZSBpbnRlZ2VyKScpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHNpemUgdmFsdWUgKG11c3QgYmUgcG9zaXRpdmUgaW50ZWdlcikuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1doZW4gbWF4U2l6ZSBvciBtYXhFbnRyeVNpemUgaXMgdXNlZCwgc2l6ZUNhbGN1bGF0aW9uICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ29yIHNpemUgbXVzdCBiZSBzZXQuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuI2FkZEl0ZW1TaXplID0gKGluZGV4LCBzaXplLCBzdGF0dXMpID0+IHtcbiAgICAgICAgICAgIHNpemVzW2luZGV4XSA9IHNpemU7XG4gICAgICAgICAgICBpZiAodGhpcy4jbWF4U2l6ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1heFNpemUgPSB0aGlzLiNtYXhTaXplIC0gc2l6ZXNbaW5kZXhdO1xuICAgICAgICAgICAgICAgIHdoaWxlICh0aGlzLiNjYWxjdWxhdGVkU2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZXZpY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgKz0gc2l6ZXNbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5lbnRyeVNpemUgPSBzaXplO1xuICAgICAgICAgICAgICAgIHN0YXR1cy50b3RhbENhbGN1bGF0ZWRTaXplID0gdGhpcy4jY2FsY3VsYXRlZFNpemU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgICNyZW1vdmVJdGVtU2l6ZSA9IF9pID0+IHsgfTtcbiAgICAjYWRkSXRlbVNpemUgPSAoX2ksIF9zLCBfc3QpID0+IHsgfTtcbiAgICAjcmVxdWlyZVNpemUgPSAoX2ssIF92LCBzaXplLCBzaXplQ2FsY3VsYXRpb24pID0+IHtcbiAgICAgICAgaWYgKHNpemUgfHwgc2l6ZUNhbGN1bGF0aW9uKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3Qgc2V0IHNpemUgd2l0aG91dCBzZXR0aW5nIG1heFNpemUgb3IgbWF4RW50cnlTaXplIG9uIGNhY2hlJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfTtcbiAgICAqI2luZGV4ZXMoeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgICAgICBpZiAodGhpcy4jc2l6ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuI3RhaWw7IHRydWU7KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLiNpc1ZhbGlkSW5kZXgoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbGxvd1N0YWxlIHx8ICF0aGlzLiNpc1N0YWxlKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSB0aGlzLiNoZWFkKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRoaXMuI3ByZXZbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICojcmluZGV4ZXMoeyBhbGxvd1N0YWxlID0gdGhpcy5hbGxvd1N0YWxlIH0gPSB7fSkge1xuICAgICAgICBpZiAodGhpcy4jc2l6ZSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuI2hlYWQ7IHRydWU7KSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLiNpc1ZhbGlkSW5kZXgoaSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChhbGxvd1N0YWxlIHx8ICF0aGlzLiNpc1N0YWxlKGkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChpID09PSB0aGlzLiN0YWlsKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IHRoaXMuI25leHRbaV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICNpc1ZhbGlkSW5kZXgoaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIChpbmRleCAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICB0aGlzLiNrZXlNYXAuZ2V0KHRoaXMuI2tleUxpc3RbaW5kZXhdKSA9PT0gaW5kZXgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgYFtrZXksIHZhbHVlXWAgcGFpcnMsXG4gICAgICogaW4gb3JkZXIgZnJvbSBtb3N0IHJlY2VudGx5IHVzZWQgdG8gbGVhc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqZW50cmllcygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoKSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuI3ZhbExpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaV0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICF0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh0aGlzLiN2YWxMaXN0W2ldKSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIFt0aGlzLiNrZXlMaXN0W2ldLCB0aGlzLiN2YWxMaXN0W2ldXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIG9yZGVyIHZlcnNpb24gb2Yge0BsaW5rIExSVUNhY2hlLmVudHJpZXN9XG4gICAgICpcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgYFtrZXksIHZhbHVlXWAgcGFpcnMsXG4gICAgICogaW4gb3JkZXIgZnJvbSBsZWFzdCByZWNlbnRseSB1c2VkIHRvIG1vc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqcmVudHJpZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNyaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jdmFsTGlzdFtpXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgdGhpcy4ja2V5TGlzdFtpXSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgW3RoaXMuI2tleUxpc3RbaV0sIHRoaXMuI3ZhbExpc3RbaV1dO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBhIGdlbmVyYXRvciB5aWVsZGluZyB0aGUga2V5cyBpbiB0aGUgY2FjaGUsXG4gICAgICogaW4gb3JkZXIgZnJvbSBtb3N0IHJlY2VudGx5IHVzZWQgdG8gbGVhc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqa2V5cygpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgayA9IHRoaXMuI2tleUxpc3RbaV07XG4gICAgICAgICAgICBpZiAoayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZlcnNlIG9yZGVyIHZlcnNpb24gb2Yge0BsaW5rIExSVUNhY2hlLmtleXN9XG4gICAgICpcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgdGhlIGtleXMgaW4gdGhlIGNhY2hlLFxuICAgICAqIGluIG9yZGVyIGZyb20gbGVhc3QgcmVjZW50bHkgdXNlZCB0byBtb3N0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKnJrZXlzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jcmluZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgayA9IHRoaXMuI2tleUxpc3RbaV07XG4gICAgICAgICAgICBpZiAoayAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHRoaXMuI3ZhbExpc3RbaV0pKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSBnZW5lcmF0b3IgeWllbGRpbmcgdGhlIHZhbHVlcyBpbiB0aGUgY2FjaGUsXG4gICAgICogaW4gb3JkZXIgZnJvbSBtb3N0IHJlY2VudGx5IHVzZWQgdG8gbGVhc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKi9cbiAgICAqdmFsdWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmVyc2Ugb3JkZXIgdmVyc2lvbiBvZiB7QGxpbmsgTFJVQ2FjaGUudmFsdWVzfVxuICAgICAqXG4gICAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIHlpZWxkaW5nIHRoZSB2YWx1ZXMgaW4gdGhlIGNhY2hlLFxuICAgICAqIGluIG9yZGVyIGZyb20gbGVhc3QgcmVjZW50bHkgdXNlZCB0byBtb3N0IHJlY2VudGx5IHVzZWQuXG4gICAgICovXG4gICAgKnJ2YWx1ZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNyaW5kZXhlcygpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godGhpcy4jdmFsTGlzdFtpXSkpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLiN2YWxMaXN0W2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGluZyBvdmVyIHRoZSBjYWNoZSBpdHNlbGYgeWllbGRzIHRoZSBzYW1lIHJlc3VsdHMgYXNcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUuZW50cmllc31cbiAgICAgKi9cbiAgICBbU3ltYm9sLml0ZXJhdG9yXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW50cmllcygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIFN0cmluZyB2YWx1ZSB0aGF0IGlzIHVzZWQgaW4gdGhlIGNyZWF0aW9uIG9mIHRoZSBkZWZhdWx0IHN0cmluZ1xuICAgICAqIGRlc2NyaXB0aW9uIG9mIGFuIG9iamVjdC4gQ2FsbGVkIGJ5IHRoZSBidWlsdC1pbiBtZXRob2RcbiAgICAgKiBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAgICovXG4gICAgW1N5bWJvbC50b1N0cmluZ1RhZ10gPSAnTFJVQ2FjaGUnO1xuICAgIC8qKlxuICAgICAqIEZpbmQgYSB2YWx1ZSBmb3Igd2hpY2ggdGhlIHN1cHBsaWVkIGZuIG1ldGhvZCByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlLFxuICAgICAqIHNpbWlsYXIgdG8gYEFycmF5LmZpbmQoKWAuIGZuIGlzIGNhbGxlZCBhcyBgZm4odmFsdWUsIGtleSwgY2FjaGUpYC5cbiAgICAgKi9cbiAgICBmaW5kKGZuLCBnZXRPcHRpb25zID0ge30pIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpXG4gICAgICAgICAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICAgICAgOiB2O1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoZm4odmFsdWUsIHRoaXMuI2tleUxpc3RbaV0sIHRoaXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHRoaXMuI2tleUxpc3RbaV0sIGdldE9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGwgdGhlIHN1cHBsaWVkIGZ1bmN0aW9uIG9uIGVhY2ggaXRlbSBpbiB0aGUgY2FjaGUsIGluIG9yZGVyIGZyb20gbW9zdFxuICAgICAqIHJlY2VudGx5IHVzZWQgdG8gbGVhc3QgcmVjZW50bHkgdXNlZC5cbiAgICAgKlxuICAgICAqIGBmbmAgaXMgY2FsbGVkIGFzIGBmbih2YWx1ZSwga2V5LCBjYWNoZSlgLlxuICAgICAqXG4gICAgICogSWYgYHRoaXNwYCBpcyBwcm92aWRlZCwgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgaW4gdGhlIGB0aGlzYC1jb250ZXh0IG9mXG4gICAgICogdGhlIHByb3ZpZGVkIG9iamVjdCwgb3IgdGhlIGNhY2hlIGlmIG5vIGB0aGlzcGAgb2JqZWN0IGlzIHByb3ZpZGVkLlxuICAgICAqXG4gICAgICogRG9lcyBub3QgdXBkYXRlIGFnZSBvciByZWNlbnR5IG9mIHVzZSwgb3IgaXRlcmF0ZSBvdmVyIHN0YWxlIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmb3JFYWNoKGZuLCB0aGlzcCA9IHRoaXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuI2luZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpXG4gICAgICAgICAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICAgICAgOiB2O1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXNwLCB2YWx1ZSwgdGhpcy4ja2V5TGlzdFtpXSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIHNhbWUgYXMge0BsaW5rIExSVUNhY2hlLmZvckVhY2h9IGJ1dCBpdGVtcyBhcmUgaXRlcmF0ZWQgb3ZlciBpblxuICAgICAqIHJldmVyc2Ugb3JkZXIuICAoaWUsIGxlc3MgcmVjZW50bHkgdXNlZCBpdGVtcyBhcmUgaXRlcmF0ZWQgb3ZlciBmaXJzdC4pXG4gICAgICovXG4gICAgcmZvckVhY2goZm4sIHRoaXNwID0gdGhpcykge1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jcmluZGV4ZXMoKSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpXG4gICAgICAgICAgICAgICAgPyB2Ll9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICAgICAgOiB2O1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBmbi5jYWxsKHRoaXNwLCB2YWx1ZSwgdGhpcy4ja2V5TGlzdFtpXSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFueSBzdGFsZSBlbnRyaWVzLiBSZXR1cm5zIHRydWUgaWYgYW55dGhpbmcgd2FzIHJlbW92ZWQsXG4gICAgICogZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHB1cmdlU3RhbGUoKSB7XG4gICAgICAgIGxldCBkZWxldGVkID0gZmFsc2U7XG4gICAgICAgIGZvciAoY29uc3QgaSBvZiB0aGlzLiNyaW5kZXhlcyh7IGFsbG93U3RhbGU6IHRydWUgfSkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNpc1N0YWxlKGkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGVsZXRlKHRoaXMuI2tleUxpc3RbaV0sICdleHBpcmUnKTtcbiAgICAgICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVsZXRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBleHRlbmRlZCBpbmZvIGFib3V0IGEgZ2l2ZW4gZW50cnksIHRvIGdldCBpdHMgdmFsdWUsIHNpemUsIGFuZFxuICAgICAqIFRUTCBpbmZvIHNpbXVsdGFuZW91c2x5LiBSZXR1cm5zIGB1bmRlZmluZWRgIGlmIHRoZSBrZXkgaXMgbm90IHByZXNlbnQuXG4gICAgICpcbiAgICAgKiBVbmxpa2Uge0BsaW5rIExSVUNhY2hlI2R1bXB9LCB3aGljaCBpcyBkZXNpZ25lZCB0byBiZSBwb3J0YWJsZSBhbmQgc3Vydml2ZVxuICAgICAqIHNlcmlhbGl6YXRpb24sIHRoZSBgc3RhcnRgIHZhbHVlIGlzIGFsd2F5cyB0aGUgY3VycmVudCB0aW1lc3RhbXAsIGFuZCB0aGVcbiAgICAgKiBgdHRsYCBpcyBhIGNhbGN1bGF0ZWQgcmVtYWluaW5nIHRpbWUgdG8gbGl2ZSAobmVnYXRpdmUgaWYgZXhwaXJlZCkuXG4gICAgICpcbiAgICAgKiBBbHdheXMgcmV0dXJucyBzdGFsZSB2YWx1ZXMsIGlmIHRoZWlyIGluZm8gaXMgZm91bmQgaW4gdGhlIGNhY2hlLCBzbyBiZVxuICAgICAqIHN1cmUgdG8gY2hlY2sgZm9yIGV4cGlyYXRpb25zIChpZSwgYSBuZWdhdGl2ZSB7QGxpbmsgTFJVQ2FjaGUuRW50cnkjdHRsfSlcbiAgICAgKiBpZiByZWxldmFudC5cbiAgICAgKi9cbiAgICBpbmZvKGtleSkge1xuICAgICAgICBjb25zdCBpID0gdGhpcy4ja2V5TWFwLmdldChrZXkpO1xuICAgICAgICBpZiAoaSA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaV07XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgICAgID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZ1xuICAgICAgICAgICAgOiB2O1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0geyB2YWx1ZSB9O1xuICAgICAgICBpZiAodGhpcy4jdHRscyAmJiB0aGlzLiNzdGFydHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHR0bCA9IHRoaXMuI3R0bHNbaV07XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IHRoaXMuI3N0YXJ0c1tpXTtcbiAgICAgICAgICAgIGlmICh0dGwgJiYgc3RhcnQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW4gPSB0dGwgLSAocGVyZi5ub3coKSAtIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBlbnRyeS50dGwgPSByZW1haW47XG4gICAgICAgICAgICAgICAgZW50cnkuc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNzaXplcykge1xuICAgICAgICAgICAgZW50cnkuc2l6ZSA9IHRoaXMuI3NpemVzW2ldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIGFuIGFycmF5IG9mIFtrZXksIHtAbGluayBMUlVDYWNoZS5FbnRyeX1dIHR1cGxlcyB3aGljaCBjYW4gYmVcbiAgICAgKiBwYXNzZWQgdG8ge0BsaW5rIExSTFVDYWNoZSNsb2FkfS5cbiAgICAgKlxuICAgICAqIFRoZSBgc3RhcnRgIGZpZWxkcyBhcmUgY2FsY3VsYXRlZCByZWxhdGl2ZSB0byBhIHBvcnRhYmxlIGBEYXRlLm5vdygpYFxuICAgICAqIHRpbWVzdGFtcCwgZXZlbiBpZiBgcGVyZm9ybWFuY2Uubm93KClgIGlzIGF2YWlsYWJsZS5cbiAgICAgKlxuICAgICAqIFN0YWxlIGVudHJpZXMgYXJlIGFsd2F5cyBpbmNsdWRlZCBpbiB0aGUgYGR1bXBgLCBldmVuIGlmXG4gICAgICoge0BsaW5rIExSVUNhY2hlLk9wdGlvbnNCYXNlLmFsbG93U3RhbGV9IGlzIGZhbHNlLlxuICAgICAqXG4gICAgICogTm90ZTogdGhpcyByZXR1cm5zIGFuIGFjdHVhbCBhcnJheSwgbm90IGEgZ2VuZXJhdG9yLCBzbyBpdCBjYW4gYmUgbW9yZVxuICAgICAqIGVhc2lseSBwYXNzZWQgYXJvdW5kLlxuICAgICAqL1xuICAgIGR1bXAoKSB7XG4gICAgICAgIGNvbnN0IGFyciA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IGkgb2YgdGhpcy4jaW5kZXhlcyh7IGFsbG93U3RhbGU6IHRydWUgfSkpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuI2tleUxpc3RbaV07XG4gICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpXTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2godilcbiAgICAgICAgICAgICAgICA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICA6IHY7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCB8fCBrZXkgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5ID0geyB2YWx1ZSB9O1xuICAgICAgICAgICAgaWYgKHRoaXMuI3R0bHMgJiYgdGhpcy4jc3RhcnRzKSB7XG4gICAgICAgICAgICAgICAgZW50cnkudHRsID0gdGhpcy4jdHRsc1tpXTtcbiAgICAgICAgICAgICAgICAvLyBhbHdheXMgZHVtcCB0aGUgc3RhcnQgcmVsYXRpdmUgdG8gYSBwb3J0YWJsZSB0aW1lc3RhbXBcbiAgICAgICAgICAgICAgICAvLyBpdCdzIG9rIGZvciB0aGlzIHRvIGJlIGEgYml0IHNsb3csIGl0J3MgYSByYXJlIG9wZXJhdGlvbi5cbiAgICAgICAgICAgICAgICBjb25zdCBhZ2UgPSBwZXJmLm5vdygpIC0gdGhpcy4jc3RhcnRzW2ldO1xuICAgICAgICAgICAgICAgIGVudHJ5LnN0YXJ0ID0gTWF0aC5mbG9vcihEYXRlLm5vdygpIC0gYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLiNzaXplcykge1xuICAgICAgICAgICAgICAgIGVudHJ5LnNpemUgPSB0aGlzLiNzaXplc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFyci51bnNoaWZ0KFtrZXksIGVudHJ5XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFycjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzZXQgdGhlIGNhY2hlIGFuZCBsb2FkIGluIHRoZSBpdGVtcyBpbiBlbnRyaWVzIGluIHRoZSBvcmRlciBsaXN0ZWQuXG4gICAgICpcbiAgICAgKiBUaGUgc2hhcGUgb2YgdGhlIHJlc3VsdGluZyBjYWNoZSBtYXkgYmUgZGlmZmVyZW50IGlmIHRoZSBzYW1lIG9wdGlvbnMgYXJlXG4gICAgICogbm90IHVzZWQgaW4gYm90aCBjYWNoZXMuXG4gICAgICpcbiAgICAgKiBUaGUgYHN0YXJ0YCBmaWVsZHMgYXJlIGFzc3VtZWQgdG8gYmUgY2FsY3VsYXRlZCByZWxhdGl2ZSB0byBhIHBvcnRhYmxlXG4gICAgICogYERhdGUubm93KClgIHRpbWVzdGFtcCwgZXZlbiBpZiBgcGVyZm9ybWFuY2Uubm93KClgIGlzIGF2YWlsYWJsZS5cbiAgICAgKi9cbiAgICBsb2FkKGFycikge1xuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgZW50cnldIG9mIGFycikge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnN0YXJ0KSB7XG4gICAgICAgICAgICAgICAgLy8gZW50cnkuc3RhcnQgaXMgYSBwb3J0YWJsZSB0aW1lc3RhbXAsIGJ1dCB3ZSBtYXkgYmUgdXNpbmdcbiAgICAgICAgICAgICAgICAvLyBub2RlJ3MgcGVyZm9ybWFuY2Uubm93KCksIHNvIGNhbGN1bGF0ZSB0aGUgb2Zmc2V0LCBzbyB0aGF0XG4gICAgICAgICAgICAgICAgLy8gd2UgZ2V0IHRoZSBpbnRlbmRlZCByZW1haW5pbmcgVFRMLCBubyBtYXR0ZXIgaG93IGxvbmcgaXQnc1xuICAgICAgICAgICAgICAgIC8vIGJlZW4gb24gaWNlLlxuICAgICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgLy8gaXQncyBvayBmb3IgdGhpcyB0byBiZSBhIGJpdCBzbG93LCBpdCdzIGEgcmFyZSBvcGVyYXRpb24uXG4gICAgICAgICAgICAgICAgY29uc3QgYWdlID0gRGF0ZS5ub3coKSAtIGVudHJ5LnN0YXJ0O1xuICAgICAgICAgICAgICAgIGVudHJ5LnN0YXJ0ID0gcGVyZi5ub3coKSAtIGFnZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc2V0KGtleSwgZW50cnkudmFsdWUsIGVudHJ5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSB2YWx1ZSB0byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBOb3RlOiBpZiBgdW5kZWZpbmVkYCBpcyBzcGVjaWZpZWQgYXMgYSB2YWx1ZSwgdGhpcyBpcyBhbiBhbGlhcyBmb3JcbiAgICAgKiB7QGxpbmsgTFJVQ2FjaGUjZGVsZXRlfVxuICAgICAqXG4gICAgICogRmllbGRzIG9uIHRoZSB7QGxpbmsgTFJVQ2FjaGUuU2V0T3B0aW9uc30gb3B0aW9ucyBwYXJhbSB3aWxsIG92ZXJyaWRlXG4gICAgICogdGhlaXIgY29ycmVzcG9uZGluZyB2YWx1ZXMgaW4gdGhlIGNvbnN0cnVjdG9yIG9wdGlvbnMgZm9yIHRoZSBzY29wZVxuICAgICAqIG9mIHRoaXMgc2luZ2xlIGBzZXQoKWAgb3BlcmF0aW9uLlxuICAgICAqXG4gICAgICogSWYgYHN0YXJ0YCBpcyBwcm92aWRlZCwgdGhlbiB0aGF0IHdpbGwgc2V0IHRoZSBlZmZlY3RpdmUgc3RhcnRcbiAgICAgKiB0aW1lIGZvciB0aGUgVFRMIGNhbGN1bGF0aW9uLiBOb3RlIHRoYXQgdGhpcyBtdXN0IGJlIGEgcHJldmlvdXNcbiAgICAgKiB2YWx1ZSBvZiBgcGVyZm9ybWFuY2Uubm93KClgIGlmIHN1cHBvcnRlZCwgb3IgYSBwcmV2aW91cyB2YWx1ZSBvZlxuICAgICAqIGBEYXRlLm5vdygpYCBpZiBub3QuXG4gICAgICpcbiAgICAgKiBPcHRpb25zIG9iamVjdCBtYXkgYWxzbyBpbmNsdWRlIGBzaXplYCwgd2hpY2ggd2lsbCBwcmV2ZW50XG4gICAgICogY2FsbGluZyB0aGUgYHNpemVDYWxjdWxhdGlvbmAgZnVuY3Rpb24gYW5kIGp1c3QgdXNlIHRoZSBzcGVjaWZpZWRcbiAgICAgKiBudW1iZXIgaWYgaXQgaXMgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBhbmQgYG5vRGlzcG9zZU9uU2V0YCB3aGljaFxuICAgICAqIHdpbGwgcHJldmVudCBjYWxsaW5nIGEgYGRpc3Bvc2VgIGZ1bmN0aW9uIGluIHRoZSBjYXNlIG9mXG4gICAgICogb3ZlcndyaXRlcy5cbiAgICAgKlxuICAgICAqIElmIHRoZSBgc2l6ZWAgKG9yIHJldHVybiB2YWx1ZSBvZiBgc2l6ZUNhbGN1bGF0aW9uYCkgZm9yIGEgZ2l2ZW5cbiAgICAgKiBlbnRyeSBpcyBncmVhdGVyIHRoYW4gYG1heEVudHJ5U2l6ZWAsIHRoZW4gdGhlIGl0ZW0gd2lsbCBub3QgYmVcbiAgICAgKiBhZGRlZCB0byB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBXaWxsIHVwZGF0ZSB0aGUgcmVjZW5jeSBvZiB0aGUgZW50cnkuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgdmFsdWUgaXMgYHVuZGVmaW5lZGAsIHRoZW4gdGhpcyBpcyBhbiBhbGlhcyBmb3JcbiAgICAgKiBgY2FjaGUuZGVsZXRlKGtleSlgLiBgdW5kZWZpbmVkYCBpcyBuZXZlciBzdG9yZWQgaW4gdGhlIGNhY2hlLlxuICAgICAqL1xuICAgIHNldChrLCB2LCBzZXRPcHRpb25zID0ge30pIHtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5kZWxldGUoayk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHR0bCA9IHRoaXMudHRsLCBzdGFydCwgbm9EaXNwb3NlT25TZXQgPSB0aGlzLm5vRGlzcG9zZU9uU2V0LCBzaXplQ2FsY3VsYXRpb24gPSB0aGlzLnNpemVDYWxjdWxhdGlvbiwgc3RhdHVzLCB9ID0gc2V0T3B0aW9ucztcbiAgICAgICAgbGV0IHsgbm9VcGRhdGVUVEwgPSB0aGlzLm5vVXBkYXRlVFRMIH0gPSBzZXRPcHRpb25zO1xuICAgICAgICBjb25zdCBzaXplID0gdGhpcy4jcmVxdWlyZVNpemUoaywgdiwgc2V0T3B0aW9ucy5zaXplIHx8IDAsIHNpemVDYWxjdWxhdGlvbik7XG4gICAgICAgIC8vIGlmIHRoZSBpdGVtIGRvZXNuJ3QgZml0LCBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAvLyBOQjogbWF4RW50cnlTaXplIHNldCB0byBtYXhTaXplIGJ5IGRlZmF1bHRcbiAgICAgICAgaWYgKHRoaXMubWF4RW50cnlTaXplICYmIHNpemUgPiB0aGlzLm1heEVudHJ5U2l6ZSkge1xuICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQgPSAnbWlzcyc7XG4gICAgICAgICAgICAgICAgc3RhdHVzLm1heEVudHJ5U2l6ZUV4Y2VlZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGhhdmUgdG8gZGVsZXRlLCBpbiBjYXNlIHNvbWV0aGluZyBpcyB0aGVyZSBhbHJlYWR5LlxuICAgICAgICAgICAgdGhpcy4jZGVsZXRlKGssICdzZXQnKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpbmRleCA9IHRoaXMuI3NpemUgPT09IDAgPyB1bmRlZmluZWQgOiB0aGlzLiNrZXlNYXAuZ2V0KGspO1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gYWRkaXRpb25cbiAgICAgICAgICAgIGluZGV4ID0gKHRoaXMuI3NpemUgPT09IDBcbiAgICAgICAgICAgICAgICA/IHRoaXMuI3RhaWxcbiAgICAgICAgICAgICAgICA6IHRoaXMuI2ZyZWUubGVuZ3RoICE9PSAwXG4gICAgICAgICAgICAgICAgICAgID8gdGhpcy4jZnJlZS5wb3AoKVxuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuI3NpemUgPT09IHRoaXMuI21heFxuICAgICAgICAgICAgICAgICAgICAgICAgPyB0aGlzLiNldmljdChmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy4jc2l6ZSk7XG4gICAgICAgICAgICB0aGlzLiNrZXlMaXN0W2luZGV4XSA9IGs7XG4gICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IHY7XG4gICAgICAgICAgICB0aGlzLiNrZXlNYXAuc2V0KGssIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuI25leHRbdGhpcy4jdGFpbF0gPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuI3ByZXZbaW5kZXhdID0gdGhpcy4jdGFpbDtcbiAgICAgICAgICAgIHRoaXMuI3RhaWwgPSBpbmRleDtcbiAgICAgICAgICAgIHRoaXMuI3NpemUrKztcbiAgICAgICAgICAgIHRoaXMuI2FkZEl0ZW1TaXplKGluZGV4LCBzaXplLCBzdGF0dXMpO1xuICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICBzdGF0dXMuc2V0ID0gJ2FkZCc7XG4gICAgICAgICAgICBub1VwZGF0ZVRUTCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gdXBkYXRlXG4gICAgICAgICAgICB0aGlzLiNtb3ZlVG9UYWlsKGluZGV4KTtcbiAgICAgICAgICAgIGNvbnN0IG9sZFZhbCA9IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHYgIT09IG9sZFZhbCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNGZXRjaE1ldGhvZCAmJiB0aGlzLiNpc0JhY2tncm91bmRGZXRjaChvbGRWYWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIG9sZFZhbC5fX2Fib3J0Q29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoJ3JlcGxhY2VkJykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB7IF9fc3RhbGVXaGlsZUZldGNoaW5nOiBzIH0gPSBvbGRWYWw7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzICE9PSB1bmRlZmluZWQgJiYgIW5vRGlzcG9zZU9uU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2U/LihzLCBrLCAnc2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQ/LnB1c2goW3MsIGssICdzZXQnXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIW5vRGlzcG9zZU9uU2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNkaXNwb3NlPy4ob2xkVmFsLCBrLCAnc2V0Jyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQ/LnB1c2goW29sZFZhbCwgaywgJ3NldCddKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNyZW1vdmVJdGVtU2l6ZShpbmRleCk7XG4gICAgICAgICAgICAgICAgdGhpcy4jYWRkSXRlbVNpemUoaW5kZXgsIHNpemUsIHN0YXR1cyk7XG4gICAgICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSB2O1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLnNldCA9ICdyZXBsYWNlJztcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2xkVmFsdWUgPSBvbGRWYWwgJiYgdGhpcy4jaXNCYWNrZ3JvdW5kRmV0Y2gob2xkVmFsKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBvbGRWYWwuX19zdGFsZVdoaWxlRmV0Y2hpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIDogb2xkVmFsO1xuICAgICAgICAgICAgICAgICAgICBpZiAob2xkVmFsdWUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5vbGRWYWx1ZSA9IG9sZFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5zZXQgPSAndXBkYXRlJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHRsICE9PSAwICYmICF0aGlzLiN0dGxzKSB7XG4gICAgICAgICAgICB0aGlzLiNpbml0aWFsaXplVFRMVHJhY2tpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jdHRscykge1xuICAgICAgICAgICAgaWYgKCFub1VwZGF0ZVRUTCkge1xuICAgICAgICAgICAgICAgIHRoaXMuI3NldEl0ZW1UVEwoaW5kZXgsIHR0bCwgc3RhcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICB0aGlzLiNzdGF0dXNUVEwoc3RhdHVzLCBpbmRleCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFub0Rpc3Bvc2VPblNldCAmJiB0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIgJiYgdGhpcy4jZGlzcG9zZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGR0ID0gdGhpcy4jZGlzcG9zZWQ7XG4gICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgIHdoaWxlICgodGFzayA9IGR0Py5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VBZnRlcj8uKC4uLnRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFdmljdCB0aGUgbGVhc3QgcmVjZW50bHkgdXNlZCBpdGVtLCByZXR1cm5pbmcgaXRzIHZhbHVlIG9yXG4gICAgICogYHVuZGVmaW5lZGAgaWYgY2FjaGUgaXMgZW1wdHkuXG4gICAgICovXG4gICAgcG9wKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUgKHRoaXMuI3NpemUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSB0aGlzLiN2YWxMaXN0W3RoaXMuI2hlYWRdO1xuICAgICAgICAgICAgICAgIHRoaXMuI2V2aWN0KHRydWUpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwuX19zdGFsZVdoaWxlRmV0Y2hpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWwuX19zdGFsZVdoaWxlRmV0Y2hpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyICYmIHRoaXMuI2Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZHQgPSB0aGlzLiNkaXNwb3NlZDtcbiAgICAgICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgICAgICB3aGlsZSAoKHRhc2sgPSBkdD8uc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyPy4oLi4udGFzayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICNldmljdChmcmVlKSB7XG4gICAgICAgIGNvbnN0IGhlYWQgPSB0aGlzLiNoZWFkO1xuICAgICAgICBjb25zdCBrID0gdGhpcy4ja2V5TGlzdFtoZWFkXTtcbiAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaGVhZF07XG4gICAgICAgIGlmICh0aGlzLiNoYXNGZXRjaE1ldGhvZCAmJiB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgdi5fX2Fib3J0Q29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoJ2V2aWN0ZWQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy4jaGFzRGlzcG9zZSB8fCB0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZT8uKHYsIGssICdldmljdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VkPy5wdXNoKFt2LCBrLCAnZXZpY3QnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4jcmVtb3ZlSXRlbVNpemUoaGVhZCk7XG4gICAgICAgIC8vIGlmIHdlIGFyZW4ndCBhYm91dCB0byB1c2UgdGhlIGluZGV4LCB0aGVuIG51bGwgdGhlc2Ugb3V0XG4gICAgICAgIGlmIChmcmVlKSB7XG4gICAgICAgICAgICB0aGlzLiNrZXlMaXN0W2hlYWRdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtoZWFkXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHRoaXMuI2ZyZWUucHVzaChoZWFkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgdGhpcy4jaGVhZCA9IHRoaXMuI3RhaWwgPSAwO1xuICAgICAgICAgICAgdGhpcy4jZnJlZS5sZW5ndGggPSAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy4jaGVhZCA9IHRoaXMuI25leHRbaGVhZF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy4ja2V5TWFwLmRlbGV0ZShrKTtcbiAgICAgICAgdGhpcy4jc2l6ZS0tO1xuICAgICAgICByZXR1cm4gaGVhZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgYSBrZXkgaXMgaW4gdGhlIGNhY2hlLCB3aXRob3V0IHVwZGF0aW5nIHRoZSByZWNlbmN5IG9mIHVzZS5cbiAgICAgKiBXaWxsIHJldHVybiBmYWxzZSBpZiB0aGUgaXRlbSBpcyBzdGFsZSwgZXZlbiB0aG91Z2ggaXQgaXMgdGVjaG5pY2FsbHlcbiAgICAgKiBpbiB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBDaGVjayBpZiBhIGtleSBpcyBpbiB0aGUgY2FjaGUsIHdpdGhvdXQgdXBkYXRpbmcgdGhlIHJlY2VuY3kgb2ZcbiAgICAgKiB1c2UuIEFnZSBpcyB1cGRhdGVkIGlmIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS51cGRhdGVBZ2VPbkhhc30gaXMgc2V0XG4gICAgICogdG8gYHRydWVgIGluIGVpdGhlciB0aGUgb3B0aW9ucyBvciB0aGUgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBXaWxsIHJldHVybiBgZmFsc2VgIGlmIHRoZSBpdGVtIGlzIHN0YWxlLCBldmVuIHRob3VnaCBpdCBpcyB0ZWNobmljYWxseSBpblxuICAgICAqIHRoZSBjYWNoZS4gVGhlIGRpZmZlcmVuY2UgY2FuIGJlIGRldGVybWluZWQgKGlmIGl0IG1hdHRlcnMpIGJ5IHVzaW5nIGFcbiAgICAgKiBgc3RhdHVzYCBhcmd1bWVudCwgYW5kIGluc3BlY3RpbmcgdGhlIGBoYXNgIGZpZWxkLlxuICAgICAqXG4gICAgICogV2lsbCBub3QgdXBkYXRlIGl0ZW0gYWdlIHVubGVzc1xuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS51cGRhdGVBZ2VPbkhhc30gaXMgc2V0LlxuICAgICAqL1xuICAgIGhhcyhrLCBoYXNPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyB1cGRhdGVBZ2VPbkhhcyA9IHRoaXMudXBkYXRlQWdlT25IYXMsIHN0YXR1cyB9ID0gaGFzT3B0aW9ucztcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGspO1xuICAgICAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpICYmXG4gICAgICAgICAgICAgICAgdi5fX3N0YWxlV2hpbGVGZXRjaGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLiNpc1N0YWxlKGluZGV4KSkge1xuICAgICAgICAgICAgICAgIGlmICh1cGRhdGVBZ2VPbkhhcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiN1cGRhdGVJdGVtQWdlKGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuaGFzID0gJ2hpdCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3N0YXR1c1RUTChzdGF0dXMsIGluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChzdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0dXMuaGFzID0gJ3N0YWxlJztcbiAgICAgICAgICAgICAgICB0aGlzLiNzdGF0dXNUVEwoc3RhdHVzLCBpbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICBzdGF0dXMuaGFzID0gJ21pc3MnO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlrZSB7QGxpbmsgTFJVQ2FjaGUjZ2V0fSBidXQgZG9lc24ndCB1cGRhdGUgcmVjZW5jeSBvciBkZWxldGUgc3RhbGVcbiAgICAgKiBpdGVtcy5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHVuZGVmaW5lZGAgaWYgdGhlIGl0ZW0gaXMgc3RhbGUsIHVubGVzc1xuICAgICAqIHtAbGluayBMUlVDYWNoZS5PcHRpb25zQmFzZS5hbGxvd1N0YWxlfSBpcyBzZXQuXG4gICAgICovXG4gICAgcGVlayhrLCBwZWVrT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSB9ID0gcGVla09wdGlvbnM7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgaWYgKGluZGV4ID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICghYWxsb3dTdGFsZSAmJiB0aGlzLiNpc1N0YWxlKGluZGV4KSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgIC8vIGVpdGhlciBzdGFsZSBhbmQgYWxsb3dlZCwgb3IgZm9yY2luZyBhIHJlZnJlc2ggb2Ygbm9uLXN0YWxlIHZhbHVlXG4gICAgICAgIHJldHVybiB0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSA/IHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgOiB2O1xuICAgIH1cbiAgICAjYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zLCBjb250ZXh0KSB7XG4gICAgICAgIGNvbnN0IHYgPSBpbmRleCA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkIDogdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYWMgPSBuZXcgQUMoKTtcbiAgICAgICAgY29uc3QgeyBzaWduYWwgfSA9IG9wdGlvbnM7XG4gICAgICAgIC8vIHdoZW4vaWYgb3VyIEFDIHNpZ25hbHMsIHRoZW4gc3RvcCBsaXN0ZW5pbmcgdG8gdGhlaXJzLlxuICAgICAgICBzaWduYWw/LmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4gYWMuYWJvcnQoc2lnbmFsLnJlYXNvbiksIHtcbiAgICAgICAgICAgIHNpZ25hbDogYWMuc2lnbmFsLFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZmV0Y2hPcHRzID0ge1xuICAgICAgICAgICAgc2lnbmFsOiBhYy5zaWduYWwsXG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2IgPSAodiwgdXBkYXRlQ2FjaGUgPSBmYWxzZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhYm9ydGVkIH0gPSBhYy5zaWduYWw7XG4gICAgICAgICAgICBjb25zdCBpZ25vcmVBYm9ydCA9IG9wdGlvbnMuaWdub3JlRmV0Y2hBYm9ydCAmJiB2ICE9PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoYWJvcnRlZCAmJiAhdXBkYXRlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hBYm9ydGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hFcnJvciA9IGFjLnNpZ25hbC5yZWFzb247XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZ25vcmVBYm9ydClcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoQWJvcnRJZ25vcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhYm9ydGVkICYmICFpZ25vcmVBYm9ydCAmJiAhdXBkYXRlQ2FjaGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hGYWlsKGFjLnNpZ25hbC5yZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZWl0aGVyIHdlIGRpZG4ndCBhYm9ydCwgYW5kIGFyZSBzdGlsbCBoZXJlLCBvciB3ZSBkaWQsIGFuZCBpZ25vcmVkXG4gICAgICAgICAgICBjb25zdCBiZiA9IHA7XG4gICAgICAgICAgICBpZiAodGhpcy4jdmFsTGlzdFtpbmRleF0gPT09IHApIHtcbiAgICAgICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChiZi5fX3N0YWxlV2hpbGVGZXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jdmFsTGlzdFtpbmRleF0gPSBiZi5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2RlbGV0ZShrLCAnZmV0Y2gnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZXQoaywgdiwgZmV0Y2hPcHRzLm9wdGlvbnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBlYiA9IChlcikgPT4ge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hSZWplY3RlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zdGF0dXMuZmV0Y2hFcnJvciA9IGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZldGNoRmFpbChlcik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGZldGNoRmFpbCA9IChlcikgPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBhYm9ydGVkIH0gPSBhYy5zaWduYWw7XG4gICAgICAgICAgICBjb25zdCBhbGxvd1N0YWxlQWJvcnRlZCA9IGFib3J0ZWQgJiYgb3B0aW9ucy5hbGxvd1N0YWxlT25GZXRjaEFib3J0O1xuICAgICAgICAgICAgY29uc3QgYWxsb3dTdGFsZSA9IGFsbG93U3RhbGVBYm9ydGVkIHx8IG9wdGlvbnMuYWxsb3dTdGFsZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgICAgICAgICBjb25zdCBub0RlbGV0ZSA9IGFsbG93U3RhbGUgfHwgb3B0aW9ucy5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb247XG4gICAgICAgICAgICBjb25zdCBiZiA9IHA7XG4gICAgICAgICAgICBpZiAodGhpcy4jdmFsTGlzdFtpbmRleF0gPT09IHApIHtcbiAgICAgICAgICAgICAgICAvLyBpZiB3ZSBhbGxvdyBzdGFsZSBvbiBmZXRjaCByZWplY3Rpb25zLCB0aGVuIHdlIG5lZWQgdG8gZW5zdXJlIHRoYXRcbiAgICAgICAgICAgICAgICAvLyB0aGUgc3RhbGUgdmFsdWUgaXMgbm90IHJlbW92ZWQgZnJvbSB0aGUgY2FjaGUgd2hlbiB0aGUgZmV0Y2ggZmFpbHMuXG4gICAgICAgICAgICAgICAgY29uc3QgZGVsID0gIW5vRGVsZXRlIHx8IGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgaWYgKGRlbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNkZWxldGUoaywgJ2ZldGNoJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCFhbGxvd1N0YWxlQWJvcnRlZCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBzdGlsbCByZXBsYWNlIHRoZSAqcHJvbWlzZSogd2l0aCB0aGUgc3RhbGUgdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHdlIGFyZSBkb25lIHdpdGggdGhlIHByb21pc2UgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgICAgICAgICAgLy8gbGVhdmUgaXQgdW50b3VjaGVkIGlmIHdlJ3JlIHN0aWxsIHdhaXRpbmcgZm9yIGFuXG4gICAgICAgICAgICAgICAgICAgIC8vIGFib3J0ZWQgYmFja2dyb3VuZCBmZXRjaCB0aGF0IGhhc24ndCB5ZXQgcmV0dXJuZWQuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3ZhbExpc3RbaW5kZXhdID0gYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFsbG93U3RhbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5zdGF0dXMgJiYgYmYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLnN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJmLl9fc3RhbGVXaGlsZUZldGNoaW5nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYmYuX19yZXR1cm5lZCA9PT0gYmYpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcGNhbGwgPSAocmVzLCByZWopID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZtcCA9IHRoaXMuI2ZldGNoTWV0aG9kPy4oaywgdiwgZmV0Y2hPcHRzKTtcbiAgICAgICAgICAgIGlmIChmbXAgJiYgZm1wIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICAgICAgICAgIGZtcC50aGVuKHYgPT4gcmVzKHYgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IHYpLCByZWopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWdub3JlZCwgd2UgZ28gdW50aWwgd2UgZmluaXNoLCByZWdhcmRsZXNzLlxuICAgICAgICAgICAgLy8gZGVmZXIgY2hlY2sgdW50aWwgd2UgYXJlIGFjdHVhbGx5IGFib3J0aW5nLFxuICAgICAgICAgICAgLy8gc28gZmV0Y2hNZXRob2QgY2FuIG92ZXJyaWRlLlxuICAgICAgICAgICAgYWMuc2lnbmFsLmFkZEV2ZW50TGlzdGVuZXIoJ2Fib3J0JywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5pZ25vcmVGZXRjaEFib3J0IHx8XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCkge1xuICAgICAgICAgICAgICAgICAgICByZXModW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBpdCBldmVudHVhbGx5IHJlc29sdmVzLCB1cGRhdGUgdGhlIGNhY2hlLlxuICAgICAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5hbGxvd1N0YWxlT25GZXRjaEFib3J0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMgPSB2ID0+IGNiKHYsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIGlmIChvcHRpb25zLnN0YXR1cylcbiAgICAgICAgICAgIG9wdGlvbnMuc3RhdHVzLmZldGNoRGlzcGF0Y2hlZCA9IHRydWU7XG4gICAgICAgIGNvbnN0IHAgPSBuZXcgUHJvbWlzZShwY2FsbCkudGhlbihjYiwgZWIpO1xuICAgICAgICBjb25zdCBiZiA9IE9iamVjdC5hc3NpZ24ocCwge1xuICAgICAgICAgICAgX19hYm9ydENvbnRyb2xsZXI6IGFjLFxuICAgICAgICAgICAgX19zdGFsZVdoaWxlRmV0Y2hpbmc6IHYsXG4gICAgICAgICAgICBfX3JldHVybmVkOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gaW50ZXJuYWwsIGRvbid0IGV4cG9zZSBzdGF0dXMuXG4gICAgICAgICAgICB0aGlzLnNldChrLCBiZiwgeyAuLi5mZXRjaE9wdHMub3B0aW9ucywgc3RhdHVzOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICBpbmRleCA9IHRoaXMuI2tleU1hcC5nZXQoayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IGJmO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiZjtcbiAgICB9XG4gICAgI2lzQmFja2dyb3VuZEZldGNoKHApIHtcbiAgICAgICAgaWYgKCF0aGlzLiNoYXNGZXRjaE1ldGhvZClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgYiA9IHA7XG4gICAgICAgIHJldHVybiAoISFiICYmXG4gICAgICAgICAgICBiIGluc3RhbmNlb2YgUHJvbWlzZSAmJlxuICAgICAgICAgICAgYi5oYXNPd25Qcm9wZXJ0eSgnX19zdGFsZVdoaWxlRmV0Y2hpbmcnKSAmJlxuICAgICAgICAgICAgYi5fX2Fib3J0Q29udHJvbGxlciBpbnN0YW5jZW9mIEFDKTtcbiAgICB9XG4gICAgYXN5bmMgZmV0Y2goaywgZmV0Y2hPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBcbiAgICAgICAgLy8gZ2V0IG9wdGlvbnNcbiAgICAgICAgYWxsb3dTdGFsZSA9IHRoaXMuYWxsb3dTdGFsZSwgdXBkYXRlQWdlT25HZXQgPSB0aGlzLnVwZGF0ZUFnZU9uR2V0LCBub0RlbGV0ZU9uU3RhbGVHZXQgPSB0aGlzLm5vRGVsZXRlT25TdGFsZUdldCwgXG4gICAgICAgIC8vIHNldCBvcHRpb25zXG4gICAgICAgIHR0bCA9IHRoaXMudHRsLCBub0Rpc3Bvc2VPblNldCA9IHRoaXMubm9EaXNwb3NlT25TZXQsIHNpemUgPSAwLCBzaXplQ2FsY3VsYXRpb24gPSB0aGlzLnNpemVDYWxjdWxhdGlvbiwgbm9VcGRhdGVUVEwgPSB0aGlzLm5vVXBkYXRlVFRMLCBcbiAgICAgICAgLy8gZmV0Y2ggZXhjbHVzaXZlIG9wdGlvbnNcbiAgICAgICAgbm9EZWxldGVPbkZldGNoUmVqZWN0aW9uID0gdGhpcy5ub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24sIGFsbG93U3RhbGVPbkZldGNoUmVqZWN0aW9uID0gdGhpcy5hbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbiwgaWdub3JlRmV0Y2hBYm9ydCA9IHRoaXMuaWdub3JlRmV0Y2hBYm9ydCwgYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCA9IHRoaXMuYWxsb3dTdGFsZU9uRmV0Y2hBYm9ydCwgY29udGV4dCwgZm9yY2VSZWZyZXNoID0gZmFsc2UsIHN0YXR1cywgc2lnbmFsLCB9ID0gZmV0Y2hPcHRpb25zO1xuICAgICAgICBpZiAoIXRoaXMuI2hhc0ZldGNoTWV0aG9kKSB7XG4gICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgIHN0YXR1cy5mZXRjaCA9ICdnZXQnO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGssIHtcbiAgICAgICAgICAgICAgICBhbGxvd1N0YWxlLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUFnZU9uR2V0LFxuICAgICAgICAgICAgICAgIG5vRGVsZXRlT25TdGFsZUdldCxcbiAgICAgICAgICAgICAgICBzdGF0dXMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgYWxsb3dTdGFsZSxcbiAgICAgICAgICAgIHVwZGF0ZUFnZU9uR2V0LFxuICAgICAgICAgICAgbm9EZWxldGVPblN0YWxlR2V0LFxuICAgICAgICAgICAgdHRsLFxuICAgICAgICAgICAgbm9EaXNwb3NlT25TZXQsXG4gICAgICAgICAgICBzaXplLFxuICAgICAgICAgICAgc2l6ZUNhbGN1bGF0aW9uLFxuICAgICAgICAgICAgbm9VcGRhdGVUVEwsXG4gICAgICAgICAgICBub0RlbGV0ZU9uRmV0Y2hSZWplY3Rpb24sXG4gICAgICAgICAgICBhbGxvd1N0YWxlT25GZXRjaFJlamVjdGlvbixcbiAgICAgICAgICAgIGFsbG93U3RhbGVPbkZldGNoQWJvcnQsXG4gICAgICAgICAgICBpZ25vcmVGZXRjaEFib3J0LFxuICAgICAgICAgICAgc3RhdHVzLFxuICAgICAgICAgICAgc2lnbmFsLFxuICAgICAgICB9O1xuICAgICAgICBsZXQgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGspO1xuICAgICAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICBzdGF0dXMuZmV0Y2ggPSAnbWlzcyc7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy4jYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgICAgIHJldHVybiAocC5fX3JldHVybmVkID0gcCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBjYWNoZSwgbWF5YmUgYWxyZWFkeSBmZXRjaGluZ1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhbGUgPSBhbGxvd1N0YWxlICYmIHYuX19zdGFsZVdoaWxlRmV0Y2hpbmcgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXR1cy5mZXRjaCA9ICdpbmZsaWdodCc7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGFsZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1cy5yZXR1cm5lZFN0YWxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWxlID8gdi5fX3N0YWxlV2hpbGVGZXRjaGluZyA6ICh2Ll9fcmV0dXJuZWQgPSB2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIHdlIGZvcmNlIGEgcmVmcmVzaCwgdGhhdCBtZWFucyBkbyBOT1Qgc2VydmUgdGhlIGNhY2hlZCB2YWx1ZSxcbiAgICAgICAgICAgIC8vIHVubGVzcyB3ZSBhcmUgYWxyZWFkeSBpbiB0aGUgcHJvY2VzcyBvZiByZWZyZXNoaW5nIHRoZSBjYWNoZS5cbiAgICAgICAgICAgIGNvbnN0IGlzU3RhbGUgPSB0aGlzLiNpc1N0YWxlKGluZGV4KTtcbiAgICAgICAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmICFpc1N0YWxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmZldGNoID0gJ2hpdCc7XG4gICAgICAgICAgICAgICAgdGhpcy4jbW92ZVRvVGFpbChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUFnZU9uR2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3VwZGF0ZUl0ZW1BZ2UoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLiNzdGF0dXNUVEwoc3RhdHVzLCBpbmRleCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBvaywgaXQgaXMgc3RhbGUgb3IgYSBmb3JjZWQgcmVmcmVzaCwgYW5kIG5vdCBhbHJlYWR5IGZldGNoaW5nLlxuICAgICAgICAgICAgLy8gcmVmcmVzaCB0aGUgY2FjaGUuXG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy4jYmFja2dyb3VuZEZldGNoKGssIGluZGV4LCBvcHRpb25zLCBjb250ZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGhhc1N0YWxlID0gcC5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY29uc3Qgc3RhbGVWYWwgPSBoYXNTdGFsZSAmJiBhbGxvd1N0YWxlO1xuICAgICAgICAgICAgaWYgKHN0YXR1cykge1xuICAgICAgICAgICAgICAgIHN0YXR1cy5mZXRjaCA9IGlzU3RhbGUgPyAnc3RhbGUnIDogJ3JlZnJlc2gnO1xuICAgICAgICAgICAgICAgIGlmIChzdGFsZVZhbCAmJiBpc1N0YWxlKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMucmV0dXJuZWRTdGFsZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RhbGVWYWwgPyBwLl9fc3RhbGVXaGlsZUZldGNoaW5nIDogKHAuX19yZXR1cm5lZCA9IHApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGZvcmNlRmV0Y2goaywgZmV0Y2hPcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgdiA9IGF3YWl0IHRoaXMuZmV0Y2goaywgZmV0Y2hPcHRpb25zKTtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignZmV0Y2goKSByZXR1cm5lZCB1bmRlZmluZWQnKTtcbiAgICAgICAgcmV0dXJuIHY7XG4gICAgfVxuICAgIG1lbW8oaywgbWVtb09wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCBtZW1vTWV0aG9kID0gdGhpcy4jbWVtb01ldGhvZDtcbiAgICAgICAgaWYgKCFtZW1vTWV0aG9kKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIG1lbW9NZXRob2QgcHJvdmlkZWQgdG8gY29uc3RydWN0b3InKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGNvbnRleHQsIGZvcmNlUmVmcmVzaCwgLi4ub3B0aW9ucyB9ID0gbWVtb09wdGlvbnM7XG4gICAgICAgIGNvbnN0IHYgPSB0aGlzLmdldChrLCBvcHRpb25zKTtcbiAgICAgICAgaWYgKCFmb3JjZVJlZnJlc2ggJiYgdiAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgIGNvbnN0IHZ2ID0gbWVtb01ldGhvZChrLCB2LCB7XG4gICAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0KGssIHZ2LCBvcHRpb25zKTtcbiAgICAgICAgcmV0dXJuIHZ2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYSB2YWx1ZSBmcm9tIHRoZSBjYWNoZS4gV2lsbCB1cGRhdGUgdGhlIHJlY2VuY3kgb2YgdGhlIGNhY2hlXG4gICAgICogZW50cnkgZm91bmQuXG4gICAgICpcbiAgICAgKiBJZiB0aGUga2V5IGlzIG5vdCBmb3VuZCwgZ2V0KCkgd2lsbCByZXR1cm4gYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZ2V0KGssIGdldE9wdGlvbnMgPSB7fSkge1xuICAgICAgICBjb25zdCB7IGFsbG93U3RhbGUgPSB0aGlzLmFsbG93U3RhbGUsIHVwZGF0ZUFnZU9uR2V0ID0gdGhpcy51cGRhdGVBZ2VPbkdldCwgbm9EZWxldGVPblN0YWxlR2V0ID0gdGhpcy5ub0RlbGV0ZU9uU3RhbGVHZXQsIHN0YXR1cywgfSA9IGdldE9wdGlvbnM7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy4ja2V5TWFwLmdldChrKTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICBjb25zdCBmZXRjaGluZyA9IHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChzdGF0dXMpXG4gICAgICAgICAgICAgICAgdGhpcy4jc3RhdHVzVFRMKHN0YXR1cywgaW5kZXgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzU3RhbGUoaW5kZXgpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXR1cylcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzLmdldCA9ICdzdGFsZSc7XG4gICAgICAgICAgICAgICAgLy8gZGVsZXRlIG9ubHkgaWYgbm90IGFuIGluLWZsaWdodCBiYWNrZ3JvdW5kIGZldGNoXG4gICAgICAgICAgICAgICAgaWYgKCFmZXRjaGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW5vRGVsZXRlT25TdGFsZUdldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGVsZXRlKGssICdleHBpcmUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICYmIGFsbG93U3RhbGUpXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMucmV0dXJuZWRTdGFsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhbGxvd1N0YWxlID8gdmFsdWUgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhdHVzICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd1N0YWxlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZS5fX3N0YWxlV2hpbGVGZXRjaGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMucmV0dXJuZWRTdGFsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFsbG93U3RhbGUgPyB2YWx1ZS5fX3N0YWxlV2hpbGVGZXRjaGluZyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICBzdGF0dXMuZ2V0ID0gJ2hpdCc7XG4gICAgICAgICAgICAgICAgLy8gaWYgd2UncmUgY3VycmVudGx5IGZldGNoaW5nIGl0LCB3ZSBkb24ndCBhY3R1YWxseSBoYXZlIGl0IHlldFxuICAgICAgICAgICAgICAgIC8vIGl0J3Mgbm90IHN0YWxlLCB3aGljaCBtZWFucyB0aGlzIGlzbid0IGEgc3RhbGVXaGlsZVJlZmV0Y2hpbmcuXG4gICAgICAgICAgICAgICAgLy8gSWYgaXQncyBub3Qgc3RhbGUsIGFuZCBmZXRjaGluZywgQU5EIGhhcyBhIF9fc3RhbGVXaGlsZUZldGNoaW5nXG4gICAgICAgICAgICAgICAgLy8gdmFsdWUsIHRoZW4gdGhhdCBtZWFucyB0aGUgdXNlciBmZXRjaGVkIHdpdGgge2ZvcmNlUmVmcmVzaDp0cnVlfSxcbiAgICAgICAgICAgICAgICAvLyBzbyBpdCdzIHNhZmUgdG8gcmV0dXJuIHRoYXQgdmFsdWUuXG4gICAgICAgICAgICAgICAgaWYgKGZldGNoaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5fX3N0YWxlV2hpbGVGZXRjaGluZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jbW92ZVRvVGFpbChpbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKHVwZGF0ZUFnZU9uR2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI3VwZGF0ZUl0ZW1BZ2UoaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3RhdHVzKSB7XG4gICAgICAgICAgICBzdGF0dXMuZ2V0ID0gJ21pc3MnO1xuICAgICAgICB9XG4gICAgfVxuICAgICNjb25uZWN0KHAsIG4pIHtcbiAgICAgICAgdGhpcy4jcHJldltuXSA9IHA7XG4gICAgICAgIHRoaXMuI25leHRbcF0gPSBuO1xuICAgIH1cbiAgICAjbW92ZVRvVGFpbChpbmRleCkge1xuICAgICAgICAvLyBpZiB0YWlsIGFscmVhZHksIG5vdGhpbmcgdG8gZG9cbiAgICAgICAgLy8gaWYgaGVhZCwgbW92ZSBoZWFkIHRvIG5leHRbaW5kZXhdXG4gICAgICAgIC8vIGVsc2VcbiAgICAgICAgLy8gICBtb3ZlIG5leHRbcHJldltpbmRleF1dIHRvIG5leHRbaW5kZXhdIChoZWFkIGhhcyBubyBwcmV2KVxuICAgICAgICAvLyAgIG1vdmUgcHJldltuZXh0W2luZGV4XV0gdG8gcHJldltpbmRleF1cbiAgICAgICAgLy8gcHJldltpbmRleF0gPSB0YWlsXG4gICAgICAgIC8vIG5leHRbdGFpbF0gPSBpbmRleFxuICAgICAgICAvLyB0YWlsID0gaW5kZXhcbiAgICAgICAgaWYgKGluZGV4ICE9PSB0aGlzLiN0YWlsKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggPT09IHRoaXMuI2hlYWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNoZWFkID0gdGhpcy4jbmV4dFtpbmRleF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNjb25uZWN0KHRoaXMuI3ByZXZbaW5kZXhdLCB0aGlzLiNuZXh0W2luZGV4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjb25uZWN0KHRoaXMuI3RhaWwsIGluZGV4KTtcbiAgICAgICAgICAgIHRoaXMuI3RhaWwgPSBpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWxldGVzIGEga2V5IG91dCBvZiB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGtleSB3YXMgZGVsZXRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIGRlbGV0ZShrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNkZWxldGUoaywgJ2RlbGV0ZScpO1xuICAgIH1cbiAgICAjZGVsZXRlKGssIHJlYXNvbikge1xuICAgICAgICBsZXQgZGVsZXRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy4jc2l6ZSAhPT0gMCkge1xuICAgICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLiNrZXlNYXAuZ2V0KGspO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBkZWxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy4jc2l6ZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNjbGVhcihyZWFzb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcmVtb3ZlSXRlbVNpemUoaW5kZXgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2ID0gdGhpcy4jdmFsTGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNpc0JhY2tncm91bmRGZXRjaCh2KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdi5fX2Fib3J0Q29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoJ2RlbGV0ZWQnKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy4jaGFzRGlzcG9zZSB8fCB0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZT8uKHYsIGssIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQ/LnB1c2goW3YsIGssIHJlYXNvbl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2tleU1hcC5kZWxldGUoayk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuI2tleUxpc3RbaW5kZXhdID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiN2YWxMaXN0W2luZGV4XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4ID09PSB0aGlzLiN0YWlsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiN0YWlsID0gdGhpcy4jcHJldltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoaW5kZXggPT09IHRoaXMuI2hlYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI2hlYWQgPSB0aGlzLiNuZXh0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBpID0gdGhpcy4jcHJldltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLiNuZXh0W3BpXSA9IHRoaXMuI25leHRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmkgPSB0aGlzLiNuZXh0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuI3ByZXZbbmldID0gdGhpcy4jcHJldltpbmRleF07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jc2l6ZS0tO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNmcmVlLnB1c2goaW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy4jaGFzRGlzcG9zZUFmdGVyICYmIHRoaXMuI2Rpc3Bvc2VkPy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGR0ID0gdGhpcy4jZGlzcG9zZWQ7XG4gICAgICAgICAgICBsZXQgdGFzaztcbiAgICAgICAgICAgIHdoaWxlICgodGFzayA9IGR0Py5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuI2Rpc3Bvc2VBZnRlcj8uKC4uLnRhc2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkZWxldGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhciB0aGUgY2FjaGUgZW50aXJlbHksIHRocm93aW5nIGF3YXkgYWxsIHZhbHVlcy5cbiAgICAgKi9cbiAgICBjbGVhcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NsZWFyKCdkZWxldGUnKTtcbiAgICB9XG4gICAgI2NsZWFyKHJlYXNvbikge1xuICAgICAgICBmb3IgKGNvbnN0IGluZGV4IG9mIHRoaXMuI3JpbmRleGVzKHsgYWxsb3dTdGFsZTogdHJ1ZSB9KSkge1xuICAgICAgICAgICAgY29uc3QgdiA9IHRoaXMuI3ZhbExpc3RbaW5kZXhdO1xuICAgICAgICAgICAgaWYgKHRoaXMuI2lzQmFja2dyb3VuZEZldGNoKHYpKSB7XG4gICAgICAgICAgICAgICAgdi5fX2Fib3J0Q29udHJvbGxlci5hYm9ydChuZXcgRXJyb3IoJ2RlbGV0ZWQnKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBrID0gdGhpcy4ja2V5TGlzdFtpbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZT8uKHYsIGssIHJlYXNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLiNoYXNEaXNwb3NlQWZ0ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZWQ/LnB1c2goW3YsIGssIHJlYXNvbl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNrZXlNYXAuY2xlYXIoKTtcbiAgICAgICAgdGhpcy4jdmFsTGlzdC5maWxsKHVuZGVmaW5lZCk7XG4gICAgICAgIHRoaXMuI2tleUxpc3QuZmlsbCh1bmRlZmluZWQpO1xuICAgICAgICBpZiAodGhpcy4jdHRscyAmJiB0aGlzLiNzdGFydHMpIHtcbiAgICAgICAgICAgIHRoaXMuI3R0bHMuZmlsbCgwKTtcbiAgICAgICAgICAgIHRoaXMuI3N0YXJ0cy5maWxsKDApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLiNzaXplcykge1xuICAgICAgICAgICAgdGhpcy4jc2l6ZXMuZmlsbCgwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNoZWFkID0gMDtcbiAgICAgICAgdGhpcy4jdGFpbCA9IDA7XG4gICAgICAgIHRoaXMuI2ZyZWUubGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy4jY2FsY3VsYXRlZFNpemUgPSAwO1xuICAgICAgICB0aGlzLiNzaXplID0gMDtcbiAgICAgICAgaWYgKHRoaXMuI2hhc0Rpc3Bvc2VBZnRlciAmJiB0aGlzLiNkaXNwb3NlZCkge1xuICAgICAgICAgICAgY29uc3QgZHQgPSB0aGlzLiNkaXNwb3NlZDtcbiAgICAgICAgICAgIGxldCB0YXNrO1xuICAgICAgICAgICAgd2hpbGUgKCh0YXNrID0gZHQ/LnNoaWZ0KCkpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jZGlzcG9zZUFmdGVyPy4oLi4udGFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkxSVUNhY2hlID0gTFJVQ2FjaGU7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/lru-cache/dist/commonjs/index.js\n");

/***/ })

};
;