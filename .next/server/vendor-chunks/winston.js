"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/winston";
exports.ids = ["vendor-chunks/winston"];
exports.modules = {

/***/ "(rsc)/./node_modules/winston/lib/winston.js":
/*!*********************************************!*\
  !*** ./node_modules/winston/lib/winston.js ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * winston.js: Top-level include defining Winston.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst logform = __webpack_require__(/*! logform */ \"(rsc)/./node_modules/logform/index.js\");\nconst { warn } = __webpack_require__(/*! ./winston/common */ \"(rsc)/./node_modules/winston/lib/winston/common.js\");\n\n/**\n * Expose version. Use `require` method for `webpack` support.\n * @type {string}\n */\nexports.version = __webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/winston/package.json\").version;\n/**\n * Include transports defined by default by winston\n * @type {Array}\n */\nexports.transports = __webpack_require__(/*! ./winston/transports */ \"(rsc)/./node_modules/winston/lib/winston/transports/index.js\");\n/**\n * Expose utility methods\n * @type {Object}\n */\nexports.config = __webpack_require__(/*! ./winston/config */ \"(rsc)/./node_modules/winston/lib/winston/config/index.js\");\n/**\n * Hoist format-related functionality from logform.\n * @type {Object}\n */\nexports.addColors = logform.levels;\n/**\n * Hoist format-related functionality from logform.\n * @type {Object}\n */\nexports.format = logform.format;\n/**\n * Expose core Logging-related prototypes.\n * @type {function}\n */\nexports.createLogger = __webpack_require__(/*! ./winston/create-logger */ \"(rsc)/./node_modules/winston/lib/winston/create-logger.js\");\n/**\n * Expose core Logging-related prototypes.\n * @type {function}\n */\nexports.Logger = __webpack_require__(/*! ./winston/logger */ \"(rsc)/./node_modules/winston/lib/winston/logger.js\");\n/**\n * Expose core Logging-related prototypes.\n * @type {Object}\n */\nexports.ExceptionHandler = __webpack_require__(/*! ./winston/exception-handler */ \"(rsc)/./node_modules/winston/lib/winston/exception-handler.js\");\n/**\n * Expose core Logging-related prototypes.\n * @type {Object}\n */\nexports.RejectionHandler = __webpack_require__(/*! ./winston/rejection-handler */ \"(rsc)/./node_modules/winston/lib/winston/rejection-handler.js\");\n/**\n * Expose core Logging-related prototypes.\n * @type {Container}\n */\nexports.Container = __webpack_require__(/*! ./winston/container */ \"(rsc)/./node_modules/winston/lib/winston/container.js\");\n/**\n * Expose core Logging-related prototypes.\n * @type {Object}\n */\nexports.Transport = __webpack_require__(/*! winston-transport */ \"(rsc)/./node_modules/winston-transport/index.js\");\n/**\n * We create and expose a default `Container` to `winston.loggers` so that the\n * programmer may manage multiple `winston.Logger` instances without any\n * additional overhead.\n * @example\n *   // some-file1.js\n *   const logger = require('winston').loggers.get('something');\n *\n *   // some-file2.js\n *   const logger = require('winston').loggers.get('something');\n */\nexports.loggers = new exports.Container();\n\n/**\n * We create and expose a 'defaultLogger' so that the programmer may do the\n * following without the need to create an instance of winston.Logger directly:\n * @example\n *   const winston = require('winston');\n *   winston.log('info', 'some message');\n *   winston.error('some error');\n */\nconst defaultLogger = exports.createLogger();\n\n// Pass through the target methods onto `winston.\nObject.keys(exports.config.npm.levels)\n  .concat([\n    'log',\n    'query',\n    'stream',\n    'add',\n    'remove',\n    'clear',\n    'profile',\n    'startTimer',\n    'handleExceptions',\n    'unhandleExceptions',\n    'handleRejections',\n    'unhandleRejections',\n    'configure',\n    'child'\n  ])\n  .forEach(\n    method => (exports[method] = (...args) => defaultLogger[method](...args))\n  );\n\n/**\n * Define getter / setter for the default logger level which need to be exposed\n * by winston.\n * @type {string}\n */\nObject.defineProperty(exports, \"level\", ({\n  get() {\n    return defaultLogger.level;\n  },\n  set(val) {\n    defaultLogger.level = val;\n  }\n}));\n\n/**\n * Define getter for `exceptions` which replaces `handleExceptions` and\n * `unhandleExceptions`.\n * @type {Object}\n */\nObject.defineProperty(exports, \"exceptions\", ({\n  get() {\n    return defaultLogger.exceptions;\n  }\n}));\n\n/**\n * Define getter for `rejections` which replaces `handleRejections` and\n * `unhandleRejections`.\n * @type {Object}\n */\nObject.defineProperty(exports, \"rejections\", ({\n  get() {\n    return defaultLogger.rejections;\n  }\n}));\n\n/**\n * Define getters / setters for appropriate properties of the default logger\n * which need to be exposed by winston.\n * @type {Logger}\n */\n['exitOnError'].forEach(prop => {\n  Object.defineProperty(exports, prop, {\n    get() {\n      return defaultLogger[prop];\n    },\n    set(val) {\n      defaultLogger[prop] = val;\n    }\n  });\n});\n\n/**\n * The default transports and exceptionHandlers for the default winston logger.\n * @type {Object}\n */\nObject.defineProperty(exports, \"default\", ({\n  get() {\n    return {\n      exceptionHandlers: defaultLogger.exceptionHandlers,\n      rejectionHandlers: defaultLogger.rejectionHandlers,\n      transports: defaultLogger.transports\n    };\n  }\n}));\n\n// Have friendlier breakage notices for properties that were exposed by default\n// on winston < 3.0.\nwarn.deprecated(exports, 'setLevels');\nwarn.forFunctions(exports, 'useFormat', ['cli']);\nwarn.forProperties(exports, 'useFormat', ['padLevels', 'stripColors']);\nwarn.forFunctions(exports, 'deprecated', [\n  'addRewriter',\n  'addFilter',\n  'clone',\n  'extend'\n]);\nwarn.forProperties(exports, 'deprecated', ['emitErrs', 'levelLength']);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsc0RBQVM7QUFDakMsUUFBUSxPQUFPLEVBQUUsbUJBQU8sQ0FBQyw0RUFBa0I7O0FBRTNDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxpSEFBb0Q7QUFDcEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLG9JQUFvRDtBQUNwRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esd0hBQTRDO0FBQzVDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esc0lBQXlEO0FBQ3pEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxrSEFBNEM7QUFDNUM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLGtKQUFpRTtBQUNqRTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esa0pBQWlFO0FBQ2pFO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSwySEFBa0Q7QUFDbEQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLG1IQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTs7QUFFZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLHlDQUF3QztBQUN4QztBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSw4Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOztBQUVGO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDhDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQSxDQUFDLEVBQUM7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUM7O0FBRUQ7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDJDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIHdpbnN0b24uanM6IFRvcC1sZXZlbCBpbmNsdWRlIGRlZmluaW5nIFdpbnN0b24uXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgbG9nZm9ybSA9IHJlcXVpcmUoJ2xvZ2Zvcm0nKTtcbmNvbnN0IHsgd2FybiB9ID0gcmVxdWlyZSgnLi93aW5zdG9uL2NvbW1vbicpO1xuXG4vKipcbiAqIEV4cG9zZSB2ZXJzaW9uLiBVc2UgYHJlcXVpcmVgIG1ldGhvZCBmb3IgYHdlYnBhY2tgIHN1cHBvcnQuXG4gKiBAdHlwZSB7c3RyaW5nfVxuICovXG5leHBvcnRzLnZlcnNpb24gPSByZXF1aXJlKCcuLi9wYWNrYWdlLmpzb24nKS52ZXJzaW9uO1xuLyoqXG4gKiBJbmNsdWRlIHRyYW5zcG9ydHMgZGVmaW5lZCBieSBkZWZhdWx0IGJ5IHdpbnN0b25cbiAqIEB0eXBlIHtBcnJheX1cbiAqL1xuZXhwb3J0cy50cmFuc3BvcnRzID0gcmVxdWlyZSgnLi93aW5zdG9uL3RyYW5zcG9ydHMnKTtcbi8qKlxuICogRXhwb3NlIHV0aWxpdHkgbWV0aG9kc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5jb25maWcgPSByZXF1aXJlKCcuL3dpbnN0b24vY29uZmlnJyk7XG4vKipcbiAqIEhvaXN0IGZvcm1hdC1yZWxhdGVkIGZ1bmN0aW9uYWxpdHkgZnJvbSBsb2dmb3JtLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5hZGRDb2xvcnMgPSBsb2dmb3JtLmxldmVscztcbi8qKlxuICogSG9pc3QgZm9ybWF0LXJlbGF0ZWQgZnVuY3Rpb25hbGl0eSBmcm9tIGxvZ2Zvcm0uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLmZvcm1hdCA9IGxvZ2Zvcm0uZm9ybWF0O1xuLyoqXG4gKiBFeHBvc2UgY29yZSBMb2dnaW5nLXJlbGF0ZWQgcHJvdG90eXBlcy5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5jcmVhdGVMb2dnZXIgPSByZXF1aXJlKCcuL3dpbnN0b24vY3JlYXRlLWxvZ2dlcicpO1xuLyoqXG4gKiBFeHBvc2UgY29yZSBMb2dnaW5nLXJlbGF0ZWQgcHJvdG90eXBlcy5cbiAqIEB0eXBlIHtmdW5jdGlvbn1cbiAqL1xuZXhwb3J0cy5Mb2dnZXIgPSByZXF1aXJlKCcuL3dpbnN0b24vbG9nZ2VyJyk7XG4vKipcbiAqIEV4cG9zZSBjb3JlIExvZ2dpbmctcmVsYXRlZCBwcm90b3R5cGVzLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5FeGNlcHRpb25IYW5kbGVyID0gcmVxdWlyZSgnLi93aW5zdG9uL2V4Y2VwdGlvbi1oYW5kbGVyJyk7XG4vKipcbiAqIEV4cG9zZSBjb3JlIExvZ2dpbmctcmVsYXRlZCBwcm90b3R5cGVzLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5SZWplY3Rpb25IYW5kbGVyID0gcmVxdWlyZSgnLi93aW5zdG9uL3JlamVjdGlvbi1oYW5kbGVyJyk7XG4vKipcbiAqIEV4cG9zZSBjb3JlIExvZ2dpbmctcmVsYXRlZCBwcm90b3R5cGVzLlxuICogQHR5cGUge0NvbnRhaW5lcn1cbiAqL1xuZXhwb3J0cy5Db250YWluZXIgPSByZXF1aXJlKCcuL3dpbnN0b24vY29udGFpbmVyJyk7XG4vKipcbiAqIEV4cG9zZSBjb3JlIExvZ2dpbmctcmVsYXRlZCBwcm90b3R5cGVzLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5UcmFuc3BvcnQgPSByZXF1aXJlKCd3aW5zdG9uLXRyYW5zcG9ydCcpO1xuLyoqXG4gKiBXZSBjcmVhdGUgYW5kIGV4cG9zZSBhIGRlZmF1bHQgYENvbnRhaW5lcmAgdG8gYHdpbnN0b24ubG9nZ2Vyc2Agc28gdGhhdCB0aGVcbiAqIHByb2dyYW1tZXIgbWF5IG1hbmFnZSBtdWx0aXBsZSBgd2luc3Rvbi5Mb2dnZXJgIGluc3RhbmNlcyB3aXRob3V0IGFueVxuICogYWRkaXRpb25hbCBvdmVyaGVhZC5cbiAqIEBleGFtcGxlXG4gKiAgIC8vIHNvbWUtZmlsZTEuanNcbiAqICAgY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnd2luc3RvbicpLmxvZ2dlcnMuZ2V0KCdzb21ldGhpbmcnKTtcbiAqXG4gKiAgIC8vIHNvbWUtZmlsZTIuanNcbiAqICAgY29uc3QgbG9nZ2VyID0gcmVxdWlyZSgnd2luc3RvbicpLmxvZ2dlcnMuZ2V0KCdzb21ldGhpbmcnKTtcbiAqL1xuZXhwb3J0cy5sb2dnZXJzID0gbmV3IGV4cG9ydHMuQ29udGFpbmVyKCk7XG5cbi8qKlxuICogV2UgY3JlYXRlIGFuZCBleHBvc2UgYSAnZGVmYXVsdExvZ2dlcicgc28gdGhhdCB0aGUgcHJvZ3JhbW1lciBtYXkgZG8gdGhlXG4gKiBmb2xsb3dpbmcgd2l0aG91dCB0aGUgbmVlZCB0byBjcmVhdGUgYW4gaW5zdGFuY2Ugb2Ygd2luc3Rvbi5Mb2dnZXIgZGlyZWN0bHk6XG4gKiBAZXhhbXBsZVxuICogICBjb25zdCB3aW5zdG9uID0gcmVxdWlyZSgnd2luc3RvbicpO1xuICogICB3aW5zdG9uLmxvZygnaW5mbycsICdzb21lIG1lc3NhZ2UnKTtcbiAqICAgd2luc3Rvbi5lcnJvcignc29tZSBlcnJvcicpO1xuICovXG5jb25zdCBkZWZhdWx0TG9nZ2VyID0gZXhwb3J0cy5jcmVhdGVMb2dnZXIoKTtcblxuLy8gUGFzcyB0aHJvdWdoIHRoZSB0YXJnZXQgbWV0aG9kcyBvbnRvIGB3aW5zdG9uLlxuT2JqZWN0LmtleXMoZXhwb3J0cy5jb25maWcubnBtLmxldmVscylcbiAgLmNvbmNhdChbXG4gICAgJ2xvZycsXG4gICAgJ3F1ZXJ5JyxcbiAgICAnc3RyZWFtJyxcbiAgICAnYWRkJyxcbiAgICAncmVtb3ZlJyxcbiAgICAnY2xlYXInLFxuICAgICdwcm9maWxlJyxcbiAgICAnc3RhcnRUaW1lcicsXG4gICAgJ2hhbmRsZUV4Y2VwdGlvbnMnLFxuICAgICd1bmhhbmRsZUV4Y2VwdGlvbnMnLFxuICAgICdoYW5kbGVSZWplY3Rpb25zJyxcbiAgICAndW5oYW5kbGVSZWplY3Rpb25zJyxcbiAgICAnY29uZmlndXJlJyxcbiAgICAnY2hpbGQnXG4gIF0pXG4gIC5mb3JFYWNoKFxuICAgIG1ldGhvZCA9PiAoZXhwb3J0c1ttZXRob2RdID0gKC4uLmFyZ3MpID0+IGRlZmF1bHRMb2dnZXJbbWV0aG9kXSguLi5hcmdzKSlcbiAgKTtcblxuLyoqXG4gKiBEZWZpbmUgZ2V0dGVyIC8gc2V0dGVyIGZvciB0aGUgZGVmYXVsdCBsb2dnZXIgbGV2ZWwgd2hpY2ggbmVlZCB0byBiZSBleHBvc2VkXG4gKiBieSB3aW5zdG9uLlxuICogQHR5cGUge3N0cmluZ31cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdsZXZlbCcsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiBkZWZhdWx0TG9nZ2VyLmxldmVsO1xuICB9LFxuICBzZXQodmFsKSB7XG4gICAgZGVmYXVsdExvZ2dlci5sZXZlbCA9IHZhbDtcbiAgfVxufSk7XG5cbi8qKlxuICogRGVmaW5lIGdldHRlciBmb3IgYGV4Y2VwdGlvbnNgIHdoaWNoIHJlcGxhY2VzIGBoYW5kbGVFeGNlcHRpb25zYCBhbmRcbiAqIGB1bmhhbmRsZUV4Y2VwdGlvbnNgLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdleGNlcHRpb25zJywge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXIuZXhjZXB0aW9ucztcbiAgfVxufSk7XG5cbi8qKlxuICogRGVmaW5lIGdldHRlciBmb3IgYHJlamVjdGlvbnNgIHdoaWNoIHJlcGxhY2VzIGBoYW5kbGVSZWplY3Rpb25zYCBhbmRcbiAqIGB1bmhhbmRsZVJlamVjdGlvbnNgLlxuICogQHR5cGUge09iamVjdH1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdyZWplY3Rpb25zJywge1xuICBnZXQoKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRMb2dnZXIucmVqZWN0aW9ucztcbiAgfVxufSk7XG5cbi8qKlxuICogRGVmaW5lIGdldHRlcnMgLyBzZXR0ZXJzIGZvciBhcHByb3ByaWF0ZSBwcm9wZXJ0aWVzIG9mIHRoZSBkZWZhdWx0IGxvZ2dlclxuICogd2hpY2ggbmVlZCB0byBiZSBleHBvc2VkIGJ5IHdpbnN0b24uXG4gKiBAdHlwZSB7TG9nZ2VyfVxuICovXG5bJ2V4aXRPbkVycm9yJ10uZm9yRWFjaChwcm9wID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIHByb3AsIHtcbiAgICBnZXQoKSB7XG4gICAgICByZXR1cm4gZGVmYXVsdExvZ2dlcltwcm9wXTtcbiAgICB9LFxuICAgIHNldCh2YWwpIHtcbiAgICAgIGRlZmF1bHRMb2dnZXJbcHJvcF0gPSB2YWw7XG4gICAgfVxuICB9KTtcbn0pO1xuXG4vKipcbiAqIFRoZSBkZWZhdWx0IHRyYW5zcG9ydHMgYW5kIGV4Y2VwdGlvbkhhbmRsZXJzIGZvciB0aGUgZGVmYXVsdCB3aW5zdG9uIGxvZ2dlci5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnZGVmYXVsdCcsIHtcbiAgZ2V0KCkge1xuICAgIHJldHVybiB7XG4gICAgICBleGNlcHRpb25IYW5kbGVyczogZGVmYXVsdExvZ2dlci5leGNlcHRpb25IYW5kbGVycyxcbiAgICAgIHJlamVjdGlvbkhhbmRsZXJzOiBkZWZhdWx0TG9nZ2VyLnJlamVjdGlvbkhhbmRsZXJzLFxuICAgICAgdHJhbnNwb3J0czogZGVmYXVsdExvZ2dlci50cmFuc3BvcnRzXG4gICAgfTtcbiAgfVxufSk7XG5cbi8vIEhhdmUgZnJpZW5kbGllciBicmVha2FnZSBub3RpY2VzIGZvciBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBleHBvc2VkIGJ5IGRlZmF1bHRcbi8vIG9uIHdpbnN0b24gPCAzLjAuXG53YXJuLmRlcHJlY2F0ZWQoZXhwb3J0cywgJ3NldExldmVscycpO1xud2Fybi5mb3JGdW5jdGlvbnMoZXhwb3J0cywgJ3VzZUZvcm1hdCcsIFsnY2xpJ10pO1xud2Fybi5mb3JQcm9wZXJ0aWVzKGV4cG9ydHMsICd1c2VGb3JtYXQnLCBbJ3BhZExldmVscycsICdzdHJpcENvbG9ycyddKTtcbndhcm4uZm9yRnVuY3Rpb25zKGV4cG9ydHMsICdkZXByZWNhdGVkJywgW1xuICAnYWRkUmV3cml0ZXInLFxuICAnYWRkRmlsdGVyJyxcbiAgJ2Nsb25lJyxcbiAgJ2V4dGVuZCdcbl0pO1xud2Fybi5mb3JQcm9wZXJ0aWVzKGV4cG9ydHMsICdkZXByZWNhdGVkJywgWydlbWl0RXJycycsICdsZXZlbExlbmd0aCddKTtcblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/common.js":
/*!****************************************************!*\
  !*** ./node_modules/winston/lib/winston/common.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * common.js: Internal helper and utility functions for winston.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst { format } = __webpack_require__(/*! util */ \"util\");\n\n/**\n * Set of simple deprecation notices and a way to expose them for a set of\n * properties.\n * @type {Object}\n * @private\n */\nexports.warn = {\n  deprecated(prop) {\n    return () => {\n      throw new Error(format('{ %s } was removed in winston@3.0.0.', prop));\n    };\n  },\n  useFormat(prop) {\n    return () => {\n      throw new Error([\n        format('{ %s } was removed in winston@3.0.0.', prop),\n        'Use a custom winston.format = winston.format(function) instead.'\n      ].join('\\n'));\n    };\n  },\n  forFunctions(obj, type, props) {\n    props.forEach(prop => {\n      obj[prop] = exports.warn[type](prop);\n    });\n  },\n  forProperties(obj, type, props) {\n    props.forEach(prop => {\n      const notice = exports.warn[type](prop);\n      Object.defineProperty(obj, prop, {\n        get: notice,\n        set: notice\n      });\n    });\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9jb21tb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsa0JBQU07O0FBRWpDO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsS0FBSztBQUN2QjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9jb21tb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBjb21tb24uanM6IEludGVybmFsIGhlbHBlciBhbmQgdXRpbGl0eSBmdW5jdGlvbnMgZm9yIHdpbnN0b24uXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBmb3JtYXQgfSA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuLyoqXG4gKiBTZXQgb2Ygc2ltcGxlIGRlcHJlY2F0aW9uIG5vdGljZXMgYW5kIGEgd2F5IHRvIGV4cG9zZSB0aGVtIGZvciBhIHNldCBvZlxuICogcHJvcGVydGllcy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnRzLndhcm4gPSB7XG4gIGRlcHJlY2F0ZWQocHJvcCkge1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZm9ybWF0KCd7ICVzIH0gd2FzIHJlbW92ZWQgaW4gd2luc3RvbkAzLjAuMC4nLCBwcm9wKSk7XG4gICAgfTtcbiAgfSxcbiAgdXNlRm9ybWF0KHByb3ApIHtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFtcbiAgICAgICAgZm9ybWF0KCd7ICVzIH0gd2FzIHJlbW92ZWQgaW4gd2luc3RvbkAzLjAuMC4nLCBwcm9wKSxcbiAgICAgICAgJ1VzZSBhIGN1c3RvbSB3aW5zdG9uLmZvcm1hdCA9IHdpbnN0b24uZm9ybWF0KGZ1bmN0aW9uKSBpbnN0ZWFkLidcbiAgICAgIF0uam9pbignXFxuJykpO1xuICAgIH07XG4gIH0sXG4gIGZvckZ1bmN0aW9ucyhvYmosIHR5cGUsIHByb3BzKSB7XG4gICAgcHJvcHMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIG9ialtwcm9wXSA9IGV4cG9ydHMud2Fyblt0eXBlXShwcm9wKTtcbiAgICB9KTtcbiAgfSxcbiAgZm9yUHJvcGVydGllcyhvYmosIHR5cGUsIHByb3BzKSB7XG4gICAgcHJvcHMuZm9yRWFjaChwcm9wID0+IHtcbiAgICAgIGNvbnN0IG5vdGljZSA9IGV4cG9ydHMud2Fyblt0eXBlXShwcm9wKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIHByb3AsIHtcbiAgICAgICAgZ2V0OiBub3RpY2UsXG4gICAgICAgIHNldDogbm90aWNlXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/common.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/config/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/winston/lib/winston/config/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * index.js: Default settings for all levels that winston knows about.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst logform = __webpack_require__(/*! logform */ \"(rsc)/./node_modules/logform/index.js\");\nconst { configs } = __webpack_require__(/*! triple-beam */ \"(rsc)/./node_modules/triple-beam/index.js\");\n\n/**\n * Export config set for the CLI.\n * @type {Object}\n */\nexports.cli = logform.levels(configs.cli);\n\n/**\n * Export config set for npm.\n * @type {Object}\n */\nexports.npm = logform.levels(configs.npm);\n\n/**\n * Export config set for the syslog.\n * @type {Object}\n */\nexports.syslog = logform.levels(configs.syslog);\n\n/**\n * Hoist addColors from logform where it was refactored into in winston@3.\n * @type {Object}\n */\nexports.addColors = logform.levels;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9jb25maWcvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLHNEQUFTO0FBQ2pDLFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsOERBQWE7O0FBRXpDO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9jb25maWcvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBpbmRleC5qczogRGVmYXVsdCBzZXR0aW5ncyBmb3IgYWxsIGxldmVscyB0aGF0IHdpbnN0b24ga25vd3MgYWJvdXQuXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgbG9nZm9ybSA9IHJlcXVpcmUoJ2xvZ2Zvcm0nKTtcbmNvbnN0IHsgY29uZmlncyB9ID0gcmVxdWlyZSgndHJpcGxlLWJlYW0nKTtcblxuLyoqXG4gKiBFeHBvcnQgY29uZmlnIHNldCBmb3IgdGhlIENMSS5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuY2xpID0gbG9nZm9ybS5sZXZlbHMoY29uZmlncy5jbGkpO1xuXG4vKipcbiAqIEV4cG9ydCBjb25maWcgc2V0IGZvciBucG0uXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLm5wbSA9IGxvZ2Zvcm0ubGV2ZWxzKGNvbmZpZ3MubnBtKTtcblxuLyoqXG4gKiBFeHBvcnQgY29uZmlnIHNldCBmb3IgdGhlIHN5c2xvZy5cbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuc3lzbG9nID0gbG9nZm9ybS5sZXZlbHMoY29uZmlncy5zeXNsb2cpO1xuXG4vKipcbiAqIEhvaXN0IGFkZENvbG9ycyBmcm9tIGxvZ2Zvcm0gd2hlcmUgaXQgd2FzIHJlZmFjdG9yZWQgaW50byBpbiB3aW5zdG9uQDMuXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLmFkZENvbG9ycyA9IGxvZ2Zvcm0ubGV2ZWxzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/config/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/container.js":
/*!*******************************************************!*\
  !*** ./node_modules/winston/lib/winston/container.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * container.js: Inversion of control container for winston logger instances.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst createLogger = __webpack_require__(/*! ./create-logger */ \"(rsc)/./node_modules/winston/lib/winston/create-logger.js\");\n\n/**\n * Inversion of control container for winston logger instances.\n * @type {Container}\n */\nmodule.exports = class Container {\n  /**\n   * Constructor function for the Container object responsible for managing a\n   * set of `winston.Logger` instances based on string ids.\n   * @param {!Object} [options={}] - Default pass-thru options for Loggers.\n   */\n  constructor(options = {}) {\n    this.loggers = new Map();\n    this.options = options;\n  }\n\n  /**\n   * Retrieves a `winston.Logger` instance for the specified `id`. If an\n   * instance does not exist, one is created.\n   * @param {!string} id - The id of the Logger to get.\n   * @param {?Object} [options] - Options for the Logger instance.\n   * @returns {Logger} - A configured Logger instance with a specified id.\n   */\n  add(id, options) {\n    if (!this.loggers.has(id)) {\n      // Remark: Simple shallow clone for configuration options in case we pass\n      // in instantiated protoypal objects\n      options = Object.assign({}, options || this.options);\n      const existing = options.transports || this.options.transports;\n\n      // Remark: Make sure if we have an array of transports we slice it to\n      // make copies of those references.\n      if (existing) {\n        options.transports = Array.isArray(existing) ? existing.slice() : [existing];\n      } else {\n        options.transports = [];\n      }\n\n      const logger = createLogger(options);\n      logger.on('close', () => this._delete(id));\n      this.loggers.set(id, logger);\n    }\n\n    return this.loggers.get(id);\n  }\n\n  /**\n   * Retreives a `winston.Logger` instance for the specified `id`. If\n   * an instance does not exist, one is created.\n   * @param {!string} id - The id of the Logger to get.\n   * @param {?Object} [options] - Options for the Logger instance.\n   * @returns {Logger} - A configured Logger instance with a specified id.\n   */\n  get(id, options) {\n    return this.add(id, options);\n  }\n\n  /**\n   * Check if the container has a logger with the id.\n   * @param {?string} id - The id of the Logger instance to find.\n   * @returns {boolean} - Boolean value indicating if this instance has a\n   * logger with the specified `id`.\n   */\n  has(id) {\n    return !!this.loggers.has(id);\n  }\n\n  /**\n   * Closes a `Logger` instance with the specified `id` if it exists.\n   * If no `id` is supplied then all Loggers are closed.\n   * @param {?string} id - The id of the Logger instance to close.\n   * @returns {undefined}\n   */\n  close(id) {\n    if (id) {\n      return this._removeLogger(id);\n    }\n\n    this.loggers.forEach((val, key) => this._removeLogger(key));\n  }\n\n  /**\n   * Remove a logger based on the id.\n   * @param {!string} id - The id of the logger to remove.\n   * @returns {undefined}\n   * @private\n   */\n  _removeLogger(id) {\n    if (!this.loggers.has(id)) {\n      return;\n    }\n\n    const logger = this.loggers.get(id);\n    logger.close();\n    this._delete(id);\n  }\n\n  /**\n   * Deletes a `Logger` instance with the specified `id`.\n   * @param {!string} id - The id of the Logger instance to delete from\n   * container.\n   * @returns {undefined}\n   * @private\n   */\n  _delete(id) {\n    this.loggers.delete(id);\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9jb250YWluZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLHFCQUFxQixtQkFBTyxDQUFDLGtGQUFpQjs7QUFFOUM7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLFdBQVc7QUFDakM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFNBQVM7QUFDdEIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3dpbnN0b24vbGliL3dpbnN0b24vY29udGFpbmVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogY29udGFpbmVyLmpzOiBJbnZlcnNpb24gb2YgY29udHJvbCBjb250YWluZXIgZm9yIHdpbnN0b24gbG9nZ2VyIGluc3RhbmNlcy5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBjcmVhdGVMb2dnZXIgPSByZXF1aXJlKCcuL2NyZWF0ZS1sb2dnZXInKTtcblxuLyoqXG4gKiBJbnZlcnNpb24gb2YgY29udHJvbCBjb250YWluZXIgZm9yIHdpbnN0b24gbG9nZ2VyIGluc3RhbmNlcy5cbiAqIEB0eXBlIHtDb250YWluZXJ9XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ29udGFpbmVyIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgQ29udGFpbmVyIG9iamVjdCByZXNwb25zaWJsZSBmb3IgbWFuYWdpbmcgYVxuICAgKiBzZXQgb2YgYHdpbnN0b24uTG9nZ2VyYCBpbnN0YW5jZXMgYmFzZWQgb24gc3RyaW5nIGlkcy5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBbb3B0aW9ucz17fV0gLSBEZWZhdWx0IHBhc3MtdGhydSBvcHRpb25zIGZvciBMb2dnZXJzLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgdGhpcy5sb2dnZXJzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIGEgYHdpbnN0b24uTG9nZ2VyYCBpbnN0YW5jZSBmb3IgdGhlIHNwZWNpZmllZCBgaWRgLiBJZiBhblxuICAgKiBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCwgb25lIGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIExvZ2dlciB0byBnZXQuXG4gICAqIEBwYXJhbSB7P09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge0xvZ2dlcn0gLSBBIGNvbmZpZ3VyZWQgTG9nZ2VyIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpZWQgaWQuXG4gICAqL1xuICBhZGQoaWQsIG9wdGlvbnMpIHtcbiAgICBpZiAoIXRoaXMubG9nZ2Vycy5oYXMoaWQpKSB7XG4gICAgICAvLyBSZW1hcms6IFNpbXBsZSBzaGFsbG93IGNsb25lIGZvciBjb25maWd1cmF0aW9uIG9wdGlvbnMgaW4gY2FzZSB3ZSBwYXNzXG4gICAgICAvLyBpbiBpbnN0YW50aWF0ZWQgcHJvdG95cGFsIG9iamVjdHNcbiAgICAgIG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zIHx8IHRoaXMub3B0aW9ucyk7XG4gICAgICBjb25zdCBleGlzdGluZyA9IG9wdGlvbnMudHJhbnNwb3J0cyB8fCB0aGlzLm9wdGlvbnMudHJhbnNwb3J0cztcblxuICAgICAgLy8gUmVtYXJrOiBNYWtlIHN1cmUgaWYgd2UgaGF2ZSBhbiBhcnJheSBvZiB0cmFuc3BvcnRzIHdlIHNsaWNlIGl0IHRvXG4gICAgICAvLyBtYWtlIGNvcGllcyBvZiB0aG9zZSByZWZlcmVuY2VzLlxuICAgICAgaWYgKGV4aXN0aW5nKSB7XG4gICAgICAgIG9wdGlvbnMudHJhbnNwb3J0cyA9IEFycmF5LmlzQXJyYXkoZXhpc3RpbmcpID8gZXhpc3Rpbmcuc2xpY2UoKSA6IFtleGlzdGluZ107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRpb25zLnRyYW5zcG9ydHMgPSBbXTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgbG9nZ2VyID0gY3JlYXRlTG9nZ2VyKG9wdGlvbnMpO1xuICAgICAgbG9nZ2VyLm9uKCdjbG9zZScsICgpID0+IHRoaXMuX2RlbGV0ZShpZCkpO1xuICAgICAgdGhpcy5sb2dnZXJzLnNldChpZCwgbG9nZ2VyKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5sb2dnZXJzLmdldChpZCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0cmVpdmVzIGEgYHdpbnN0b24uTG9nZ2VyYCBpbnN0YW5jZSBmb3IgdGhlIHNwZWNpZmllZCBgaWRgLiBJZlxuICAgKiBhbiBpbnN0YW5jZSBkb2VzIG5vdCBleGlzdCwgb25lIGlzIGNyZWF0ZWQuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIExvZ2dlciB0byBnZXQuXG4gICAqIEBwYXJhbSB7P09iamVjdH0gW29wdGlvbnNdIC0gT3B0aW9ucyBmb3IgdGhlIExvZ2dlciBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge0xvZ2dlcn0gLSBBIGNvbmZpZ3VyZWQgTG9nZ2VyIGluc3RhbmNlIHdpdGggYSBzcGVjaWZpZWQgaWQuXG4gICAqL1xuICBnZXQoaWQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5hZGQoaWQsIG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIHRoZSBjb250YWluZXIgaGFzIGEgbG9nZ2VyIHdpdGggdGhlIGlkLlxuICAgKiBAcGFyYW0gez9zdHJpbmd9IGlkIC0gVGhlIGlkIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2UgdG8gZmluZC5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gQm9vbGVhbiB2YWx1ZSBpbmRpY2F0aW5nIGlmIHRoaXMgaW5zdGFuY2UgaGFzIGFcbiAgICogbG9nZ2VyIHdpdGggdGhlIHNwZWNpZmllZCBgaWRgLlxuICAgKi9cbiAgaGFzKGlkKSB7XG4gICAgcmV0dXJuICEhdGhpcy5sb2dnZXJzLmhhcyhpZCk7XG4gIH1cblxuICAvKipcbiAgICogQ2xvc2VzIGEgYExvZ2dlcmAgaW5zdGFuY2Ugd2l0aCB0aGUgc3BlY2lmaWVkIGBpZGAgaWYgaXQgZXhpc3RzLlxuICAgKiBJZiBubyBgaWRgIGlzIHN1cHBsaWVkIHRoZW4gYWxsIExvZ2dlcnMgYXJlIGNsb3NlZC5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBpZCAtIFRoZSBpZCBvZiB0aGUgTG9nZ2VyIGluc3RhbmNlIHRvIGNsb3NlLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgY2xvc2UoaWQpIHtcbiAgICBpZiAoaWQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZW1vdmVMb2dnZXIoaWQpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2Vycy5mb3JFYWNoKCh2YWwsIGtleSkgPT4gdGhpcy5fcmVtb3ZlTG9nZ2VyKGtleSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhIGxvZ2dlciBiYXNlZCBvbiB0aGUgaWQuXG4gICAqIEBwYXJhbSB7IXN0cmluZ30gaWQgLSBUaGUgaWQgb2YgdGhlIGxvZ2dlciB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfcmVtb3ZlTG9nZ2VyKGlkKSB7XG4gICAgaWYgKCF0aGlzLmxvZ2dlcnMuaGFzKGlkKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGxvZ2dlciA9IHRoaXMubG9nZ2Vycy5nZXQoaWQpO1xuICAgIGxvZ2dlci5jbG9zZSgpO1xuICAgIHRoaXMuX2RlbGV0ZShpZCk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlcyBhIGBMb2dnZXJgIGluc3RhbmNlIHdpdGggdGhlIHNwZWNpZmllZCBgaWRgLlxuICAgKiBAcGFyYW0geyFzdHJpbmd9IGlkIC0gVGhlIGlkIG9mIHRoZSBMb2dnZXIgaW5zdGFuY2UgdG8gZGVsZXRlIGZyb21cbiAgICogY29udGFpbmVyLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlbGV0ZShpZCkge1xuICAgIHRoaXMubG9nZ2Vycy5kZWxldGUoaWQpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/container.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/create-logger.js":
/*!***********************************************************!*\
  !*** ./node_modules/winston/lib/winston/create-logger.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * create-logger.js: Logger factory for winston logger instances.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst { LEVEL } = __webpack_require__(/*! triple-beam */ \"(rsc)/./node_modules/triple-beam/index.js\");\nconst config = __webpack_require__(/*! ./config */ \"(rsc)/./node_modules/winston/lib/winston/config/index.js\");\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/winston/lib/winston/logger.js\");\nconst debug = __webpack_require__(/*! @dabh/diagnostics */ \"(rsc)/./node_modules/@dabh/diagnostics/node/index.js\")('winston:create-logger');\n\nfunction isLevelEnabledFunctionName(level) {\n  return 'is' + level.charAt(0).toUpperCase() + level.slice(1) + 'Enabled';\n}\n\n/**\n * Create a new instance of a winston Logger. Creates a new\n * prototype for each instance.\n * @param {!Object} opts - Options for the created logger.\n * @returns {Logger} - A newly created logger instance.\n */\nmodule.exports = function (opts = {}) {\n  //\n  // Default levels: npm\n  //\n  opts.levels = opts.levels || config.npm.levels;\n\n  /**\n   * DerivedLogger to attach the logs level methods.\n   * @type {DerivedLogger}\n   * @extends {Logger}\n   */\n  class DerivedLogger extends Logger {\n    /**\n     * Create a new class derived logger for which the levels can be attached to\n     * the prototype of. This is a V8 optimization that is well know to increase\n     * performance of prototype functions.\n     * @param {!Object} options - Options for the created logger.\n     */\n    constructor(options) {\n      super(options);\n    }\n  }\n\n  const logger = new DerivedLogger(opts);\n\n  //\n  // Create the log level methods for the derived logger.\n  //\n  Object.keys(opts.levels).forEach(function (level) {\n    debug('Define prototype method for \"%s\"', level);\n    if (level === 'log') {\n      // eslint-disable-next-line no-console\n      console.warn('Level \"log\" not defined: conflicts with the method \"log\". Use a different level name.');\n      return;\n    }\n\n    //\n    // Define prototype methods for each log level e.g.:\n    // logger.log('info', msg) implies these methods are defined:\n    // - logger.info(msg)\n    // - logger.isInfoEnabled()\n    //\n    // Remark: to support logger.child this **MUST** be a function\n    // so it'll always be called on the instance instead of a fixed\n    // place in the prototype chain.\n    //\n    DerivedLogger.prototype[level] = function (...args) {\n      // Prefer any instance scope, but default to \"root\" logger\n      const self = this || logger;\n\n      // Optimize the hot-path which is the single object.\n      if (args.length === 1) {\n        const [msg] = args;\n        const info = msg && msg.message && msg || { message: msg };\n        info.level = info[LEVEL] = level;\n        self._addDefaultMeta(info);\n        self.write(info);\n        return (this || logger);\n      }\n\n      // When provided nothing assume the empty string\n      if (args.length === 0) {\n        self.log(level, '');\n        return self;\n      }\n\n      // Otherwise build argument list which could potentially conform to\n      // either:\n      // . v3 API: log(obj)\n      // 2. v1/v2 API: log(level, msg, ... [string interpolate], [{metadata}], [callback])\n      return self.log(level, ...args);\n    };\n\n    DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function () {\n      return (this || logger).isLevelEnabled(level);\n    };\n  });\n\n  return logger;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9jcmVhdGUtbG9nZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixRQUFRLFFBQVEsRUFBRSxtQkFBTyxDQUFDLDhEQUFhO0FBQ3ZDLGVBQWUsbUJBQU8sQ0FBQywwRUFBVTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsb0VBQVU7QUFDakMsY0FBYyxtQkFBTyxDQUFDLCtFQUFtQjs7QUFFekM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixhQUFhLFFBQVE7QUFDckI7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUUsU0FBUztBQUM1RTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL2NyZWF0ZS1sb2dnZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBjcmVhdGUtbG9nZ2VyLmpzOiBMb2dnZXIgZmFjdG9yeSBmb3Igd2luc3RvbiBsb2dnZXIgaW5zdGFuY2VzLlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgTEVWRUwgfSA9IHJlcXVpcmUoJ3RyaXBsZS1iZWFtJyk7XG5jb25zdCBjb25maWcgPSByZXF1aXJlKCcuL2NvbmZpZycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnQGRhYmgvZGlhZ25vc3RpY3MnKSgnd2luc3RvbjpjcmVhdGUtbG9nZ2VyJyk7XG5cbmZ1bmN0aW9uIGlzTGV2ZWxFbmFibGVkRnVuY3Rpb25OYW1lKGxldmVsKSB7XG4gIHJldHVybiAnaXMnICsgbGV2ZWwuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBsZXZlbC5zbGljZSgxKSArICdFbmFibGVkJztcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugb2YgYSB3aW5zdG9uIExvZ2dlci4gQ3JlYXRlcyBhIG5ld1xuICogcHJvdG90eXBlIGZvciBlYWNoIGluc3RhbmNlLlxuICogQHBhcmFtIHshT2JqZWN0fSBvcHRzIC0gT3B0aW9ucyBmb3IgdGhlIGNyZWF0ZWQgbG9nZ2VyLlxuICogQHJldHVybnMge0xvZ2dlcn0gLSBBIG5ld2x5IGNyZWF0ZWQgbG9nZ2VyIGluc3RhbmNlLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvcHRzID0ge30pIHtcbiAgLy9cbiAgLy8gRGVmYXVsdCBsZXZlbHM6IG5wbVxuICAvL1xuICBvcHRzLmxldmVscyA9IG9wdHMubGV2ZWxzIHx8IGNvbmZpZy5ucG0ubGV2ZWxzO1xuXG4gIC8qKlxuICAgKiBEZXJpdmVkTG9nZ2VyIHRvIGF0dGFjaCB0aGUgbG9ncyBsZXZlbCBtZXRob2RzLlxuICAgKiBAdHlwZSB7RGVyaXZlZExvZ2dlcn1cbiAgICogQGV4dGVuZHMge0xvZ2dlcn1cbiAgICovXG4gIGNsYXNzIERlcml2ZWRMb2dnZXIgZXh0ZW5kcyBMb2dnZXIge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIG5ldyBjbGFzcyBkZXJpdmVkIGxvZ2dlciBmb3Igd2hpY2ggdGhlIGxldmVscyBjYW4gYmUgYXR0YWNoZWQgdG9cbiAgICAgKiB0aGUgcHJvdG90eXBlIG9mLiBUaGlzIGlzIGEgVjggb3B0aW1pemF0aW9uIHRoYXQgaXMgd2VsbCBrbm93IHRvIGluY3JlYXNlXG4gICAgICogcGVyZm9ybWFuY2Ugb2YgcHJvdG90eXBlIGZ1bmN0aW9ucy5cbiAgICAgKiBAcGFyYW0geyFPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgY3JlYXRlZCBsb2dnZXIuXG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbG9nZ2VyID0gbmV3IERlcml2ZWRMb2dnZXIob3B0cyk7XG5cbiAgLy9cbiAgLy8gQ3JlYXRlIHRoZSBsb2cgbGV2ZWwgbWV0aG9kcyBmb3IgdGhlIGRlcml2ZWQgbG9nZ2VyLlxuICAvL1xuICBPYmplY3Qua2V5cyhvcHRzLmxldmVscykuZm9yRWFjaChmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICBkZWJ1ZygnRGVmaW5lIHByb3RvdHlwZSBtZXRob2QgZm9yIFwiJXNcIicsIGxldmVsKTtcbiAgICBpZiAobGV2ZWwgPT09ICdsb2cnKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKCdMZXZlbCBcImxvZ1wiIG5vdCBkZWZpbmVkOiBjb25mbGljdHMgd2l0aCB0aGUgbWV0aG9kIFwibG9nXCIuIFVzZSBhIGRpZmZlcmVudCBsZXZlbCBuYW1lLicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gRGVmaW5lIHByb3RvdHlwZSBtZXRob2RzIGZvciBlYWNoIGxvZyBsZXZlbCBlLmcuOlxuICAgIC8vIGxvZ2dlci5sb2coJ2luZm8nLCBtc2cpIGltcGxpZXMgdGhlc2UgbWV0aG9kcyBhcmUgZGVmaW5lZDpcbiAgICAvLyAtIGxvZ2dlci5pbmZvKG1zZylcbiAgICAvLyAtIGxvZ2dlci5pc0luZm9FbmFibGVkKClcbiAgICAvL1xuICAgIC8vIFJlbWFyazogdG8gc3VwcG9ydCBsb2dnZXIuY2hpbGQgdGhpcyAqKk1VU1QqKiBiZSBhIGZ1bmN0aW9uXG4gICAgLy8gc28gaXQnbGwgYWx3YXlzIGJlIGNhbGxlZCBvbiB0aGUgaW5zdGFuY2UgaW5zdGVhZCBvZiBhIGZpeGVkXG4gICAgLy8gcGxhY2UgaW4gdGhlIHByb3RvdHlwZSBjaGFpbi5cbiAgICAvL1xuICAgIERlcml2ZWRMb2dnZXIucHJvdG90eXBlW2xldmVsXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAvLyBQcmVmZXIgYW55IGluc3RhbmNlIHNjb3BlLCBidXQgZGVmYXVsdCB0byBcInJvb3RcIiBsb2dnZXJcbiAgICAgIGNvbnN0IHNlbGYgPSB0aGlzIHx8IGxvZ2dlcjtcblxuICAgICAgLy8gT3B0aW1pemUgdGhlIGhvdC1wYXRoIHdoaWNoIGlzIHRoZSBzaW5nbGUgb2JqZWN0LlxuICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGNvbnN0IFttc2ddID0gYXJncztcbiAgICAgICAgY29uc3QgaW5mbyA9IG1zZyAmJiBtc2cubWVzc2FnZSAmJiBtc2cgfHwgeyBtZXNzYWdlOiBtc2cgfTtcbiAgICAgICAgaW5mby5sZXZlbCA9IGluZm9bTEVWRUxdID0gbGV2ZWw7XG4gICAgICAgIHNlbGYuX2FkZERlZmF1bHRNZXRhKGluZm8pO1xuICAgICAgICBzZWxmLndyaXRlKGluZm8pO1xuICAgICAgICByZXR1cm4gKHRoaXMgfHwgbG9nZ2VyKTtcbiAgICAgIH1cblxuICAgICAgLy8gV2hlbiBwcm92aWRlZCBub3RoaW5nIGFzc3VtZSB0aGUgZW1wdHkgc3RyaW5nXG4gICAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgc2VsZi5sb2cobGV2ZWwsICcnKTtcbiAgICAgICAgcmV0dXJuIHNlbGY7XG4gICAgICB9XG5cbiAgICAgIC8vIE90aGVyd2lzZSBidWlsZCBhcmd1bWVudCBsaXN0IHdoaWNoIGNvdWxkIHBvdGVudGlhbGx5IGNvbmZvcm0gdG9cbiAgICAgIC8vIGVpdGhlcjpcbiAgICAgIC8vIC4gdjMgQVBJOiBsb2cob2JqKVxuICAgICAgLy8gMi4gdjEvdjIgQVBJOiBsb2cobGV2ZWwsIG1zZywgLi4uIFtzdHJpbmcgaW50ZXJwb2xhdGVdLCBbe21ldGFkYXRhfV0sIFtjYWxsYmFja10pXG4gICAgICByZXR1cm4gc2VsZi5sb2cobGV2ZWwsIC4uLmFyZ3MpO1xuICAgIH07XG5cbiAgICBEZXJpdmVkTG9nZ2VyLnByb3RvdHlwZVtpc0xldmVsRW5hYmxlZEZ1bmN0aW9uTmFtZShsZXZlbCldID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuICh0aGlzIHx8IGxvZ2dlcikuaXNMZXZlbEVuYWJsZWQobGV2ZWwpO1xuICAgIH07XG4gIH0pO1xuXG4gIHJldHVybiBsb2dnZXI7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/create-logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/exception-handler.js":
/*!***************************************************************!*\
  !*** ./node_modules/winston/lib/winston/exception-handler.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * exception-handler.js: Object for handling uncaughtException events.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst os = __webpack_require__(/*! os */ \"os\");\nconst asyncForEach = __webpack_require__(/*! async/forEach */ \"(rsc)/./node_modules/async/forEach.js\");\nconst debug = __webpack_require__(/*! @dabh/diagnostics */ \"(rsc)/./node_modules/@dabh/diagnostics/node/index.js\")('winston:exception');\nconst once = __webpack_require__(/*! one-time */ \"(rsc)/./node_modules/one-time/index.js\");\nconst stackTrace = __webpack_require__(/*! stack-trace */ \"(rsc)/./node_modules/stack-trace/lib/stack-trace.js\");\nconst ExceptionStream = __webpack_require__(/*! ./exception-stream */ \"(rsc)/./node_modules/winston/lib/winston/exception-stream.js\");\n\n/**\n * Object for handling uncaughtException events.\n * @type {ExceptionHandler}\n */\nmodule.exports = class ExceptionHandler {\n  /**\n   * TODO: add contructor description\n   * @param {!Logger} logger - TODO: add param description\n   */\n  constructor(logger) {\n    if (!logger) {\n      throw new Error('Logger is required to handle exceptions');\n    }\n\n    this.logger = logger;\n    this.handlers = new Map();\n  }\n\n  /**\n   * Handles `uncaughtException` events for the current process by adding any\n   * handlers passed in.\n   * @returns {undefined}\n   */\n  handle(...args) {\n    args.forEach(arg => {\n      if (Array.isArray(arg)) {\n        return arg.forEach(handler => this._addHandler(handler));\n      }\n\n      this._addHandler(arg);\n    });\n\n    if (!this.catcher) {\n      this.catcher = this._uncaughtException.bind(this);\n      process.on('uncaughtException', this.catcher);\n    }\n  }\n\n  /**\n   * Removes any handlers to `uncaughtException` events for the current\n   * process. This does not modify the state of the `this.handlers` set.\n   * @returns {undefined}\n   */\n  unhandle() {\n    if (this.catcher) {\n      process.removeListener('uncaughtException', this.catcher);\n      this.catcher = false;\n\n      Array.from(this.handlers.values())\n        .forEach(wrapper => this.logger.unpipe(wrapper));\n    }\n  }\n\n  /**\n   * TODO: add method description\n   * @param {Error} err - Error to get information about.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getAllInfo(err) {\n    let message = null;\n    if (err) {\n      message = typeof err === 'string' ? err : err.message;\n    }\n\n    return {\n      error: err,\n      // TODO (indexzero): how do we configure this?\n      level: 'error',\n      message: [\n        `uncaughtException: ${(message || '(no error message)')}`,\n        err && err.stack || '  No stack trace'\n      ].join('\\n'),\n      stack: err && err.stack,\n      exception: true,\n      date: new Date().toString(),\n      process: this.getProcessInfo(),\n      os: this.getOsInfo(),\n      trace: this.getTrace(err)\n    };\n  }\n\n  /**\n   * Gets all relevant process information for the currently running process.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getProcessInfo() {\n    return {\n      pid: process.pid,\n      uid: process.getuid ? process.getuid() : null,\n      gid: process.getgid ? process.getgid() : null,\n      cwd: process.cwd(),\n      execPath: process.execPath,\n      version: process.version,\n      argv: process.argv,\n      memoryUsage: process.memoryUsage()\n    };\n  }\n\n  /**\n   * Gets all relevant OS information for the currently running process.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getOsInfo() {\n    return {\n      loadavg: os.loadavg(),\n      uptime: os.uptime()\n    };\n  }\n\n  /**\n   * Gets a stack trace for the specified error.\n   * @param {mixed} err - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getTrace(err) {\n    const trace = err ? stackTrace.parse(err) : stackTrace.get();\n    return trace.map(site => {\n      return {\n        column: site.getColumnNumber(),\n        file: site.getFileName(),\n        function: site.getFunctionName(),\n        line: site.getLineNumber(),\n        method: site.getMethodName(),\n        native: site.isNative()\n      };\n    });\n  }\n\n  /**\n   * Helper method to add a transport as an exception handler.\n   * @param {Transport} handler - The transport to add as an exception handler.\n   * @returns {void}\n   */\n  _addHandler(handler) {\n    if (!this.handlers.has(handler)) {\n      handler.handleExceptions = true;\n      const wrapper = new ExceptionStream(handler);\n      this.handlers.set(handler, wrapper);\n      this.logger.pipe(wrapper);\n    }\n  }\n\n  /**\n   * Logs all relevant information around the `err` and exits the current\n   * process.\n   * @param {Error} err - Error to handle\n   * @returns {mixed} - TODO: add return description.\n   * @private\n   */\n  _uncaughtException(err) {\n    const info = this.getAllInfo(err);\n    const handlers = this._getExceptionHandlers();\n    // Calculate if we should exit on this error\n    let doExit = typeof this.logger.exitOnError === 'function'\n      ? this.logger.exitOnError(err)\n      : this.logger.exitOnError;\n    let timeout;\n\n    if (!handlers.length && doExit) {\n      // eslint-disable-next-line no-console\n      console.warn('winston: exitOnError cannot be true with no exception handlers.');\n      // eslint-disable-next-line no-console\n      console.warn('winston: not exiting process.');\n      doExit = false;\n    }\n\n    function gracefulExit() {\n      debug('doExit', doExit);\n      debug('process._exiting', process._exiting);\n\n      if (doExit && !process._exiting) {\n        // Remark: Currently ignoring any exceptions from transports when\n        // catching uncaught exceptions.\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        // eslint-disable-next-line no-process-exit\n        process.exit(1);\n      }\n    }\n\n    if (!handlers || handlers.length === 0) {\n      return process.nextTick(gracefulExit);\n    }\n\n    // Log to all transports attempting to listen for when they are completed.\n    asyncForEach(handlers, (handler, next) => {\n      const done = once(next);\n      const transport = handler.transport || handler;\n\n      // Debug wrapping so that we can inspect what's going on under the covers.\n      function onDone(event) {\n        return () => {\n          debug(event);\n          done();\n        };\n      }\n\n      transport._ending = true;\n      transport.once('finish', onDone('finished'));\n      transport.once('error', onDone('error'));\n    }, () => doExit && gracefulExit());\n\n    this.logger.log(info);\n\n    // If exitOnError is true, then only allow the logging of exceptions to\n    // take up to `3000ms`.\n    if (doExit) {\n      timeout = setTimeout(gracefulExit, 3000);\n    }\n  }\n\n  /**\n   * Returns the list of transports and exceptionHandlers for this instance.\n   * @returns {Array} - List of transports and exceptionHandlers for this\n   * instance.\n   * @private\n   */\n  _getExceptionHandlers() {\n    // Remark (indexzero): since `logger.transports` returns all of the pipes\n    // from the _readableState of the stream we actually get the join of the\n    // explicit handlers and the implicit transports with\n    // `handleExceptions: true`\n    return this.logger.transports.filter(wrap => {\n      const transport = wrap.transport || wrap;\n      return transport.handleExceptions;\n    });\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9leGNlcHRpb24taGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIscUJBQXFCLG1CQUFPLENBQUMsNERBQWU7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLCtFQUFtQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsd0RBQVU7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWE7QUFDeEMsd0JBQXdCLG1CQUFPLENBQUMsd0ZBQW9COztBQUVwRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0NBQWtDO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL2V4Y2VwdGlvbi1oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZXhjZXB0aW9uLWhhbmRsZXIuanM6IE9iamVjdCBmb3IgaGFuZGxpbmcgdW5jYXVnaHRFeGNlcHRpb24gZXZlbnRzLlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGFzeW5jRm9yRWFjaCA9IHJlcXVpcmUoJ2FzeW5jL2ZvckVhY2gnKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnQGRhYmgvZGlhZ25vc3RpY3MnKSgnd2luc3RvbjpleGNlcHRpb24nKTtcbmNvbnN0IG9uY2UgPSByZXF1aXJlKCdvbmUtdGltZScpO1xuY29uc3Qgc3RhY2tUcmFjZSA9IHJlcXVpcmUoJ3N0YWNrLXRyYWNlJyk7XG5jb25zdCBFeGNlcHRpb25TdHJlYW0gPSByZXF1aXJlKCcuL2V4Y2VwdGlvbi1zdHJlYW0nKTtcblxuLyoqXG4gKiBPYmplY3QgZm9yIGhhbmRsaW5nIHVuY2F1Z2h0RXhjZXB0aW9uIGV2ZW50cy5cbiAqIEB0eXBlIHtFeGNlcHRpb25IYW5kbGVyfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIEV4Y2VwdGlvbkhhbmRsZXIge1xuICAvKipcbiAgICogVE9ETzogYWRkIGNvbnRydWN0b3IgZGVzY3JpcHRpb25cbiAgICogQHBhcmFtIHshTG9nZ2VyfSBsb2dnZXIgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb25cbiAgICovXG4gIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgIGlmICghbG9nZ2VyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvZ2dlciBpcyByZXF1aXJlZCB0byBoYW5kbGUgZXhjZXB0aW9ucycpO1xuICAgIH1cblxuICAgIHRoaXMubG9nZ2VyID0gbG9nZ2VyO1xuICAgIHRoaXMuaGFuZGxlcnMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBgdW5jYXVnaHRFeGNlcHRpb25gIGV2ZW50cyBmb3IgdGhlIGN1cnJlbnQgcHJvY2VzcyBieSBhZGRpbmcgYW55XG4gICAqIGhhbmRsZXJzIHBhc3NlZCBpbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGhhbmRsZSguLi5hcmdzKSB7XG4gICAgYXJncy5mb3JFYWNoKGFyZyA9PiB7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG4gICAgICAgIHJldHVybiBhcmcuZm9yRWFjaChoYW5kbGVyID0+IHRoaXMuX2FkZEhhbmRsZXIoaGFuZGxlcikpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9hZGRIYW5kbGVyKGFyZyk7XG4gICAgfSk7XG5cbiAgICBpZiAoIXRoaXMuY2F0Y2hlcikge1xuICAgICAgdGhpcy5jYXRjaGVyID0gdGhpcy5fdW5jYXVnaHRFeGNlcHRpb24uYmluZCh0aGlzKTtcbiAgICAgIHByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgdGhpcy5jYXRjaGVyKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbnkgaGFuZGxlcnMgdG8gYHVuY2F1Z2h0RXhjZXB0aW9uYCBldmVudHMgZm9yIHRoZSBjdXJyZW50XG4gICAqIHByb2Nlc3MuIFRoaXMgZG9lcyBub3QgbW9kaWZ5IHRoZSBzdGF0ZSBvZiB0aGUgYHRoaXMuaGFuZGxlcnNgIHNldC5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIHVuaGFuZGxlKCkge1xuICAgIGlmICh0aGlzLmNhdGNoZXIpIHtcbiAgICAgIHByb2Nlc3MucmVtb3ZlTGlzdGVuZXIoJ3VuY2F1Z2h0RXhjZXB0aW9uJywgdGhpcy5jYXRjaGVyKTtcbiAgICAgIHRoaXMuY2F0Y2hlciA9IGZhbHNlO1xuXG4gICAgICBBcnJheS5mcm9tKHRoaXMuaGFuZGxlcnMudmFsdWVzKCkpXG4gICAgICAgIC5mb3JFYWNoKHdyYXBwZXIgPT4gdGhpcy5sb2dnZXIudW5waXBlKHdyYXBwZXIpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVE9ETzogYWRkIG1ldGhvZCBkZXNjcmlwdGlvblxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciB0byBnZXQgaW5mb3JtYXRpb24gYWJvdXQuXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgZ2V0QWxsSW5mbyhlcnIpIHtcbiAgICBsZXQgbWVzc2FnZSA9IG51bGw7XG4gICAgaWYgKGVycikge1xuICAgICAgbWVzc2FnZSA9IHR5cGVvZiBlcnIgPT09ICdzdHJpbmcnID8gZXJyIDogZXJyLm1lc3NhZ2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVycm9yOiBlcnIsXG4gICAgICAvLyBUT0RPIChpbmRleHplcm8pOiBob3cgZG8gd2UgY29uZmlndXJlIHRoaXM/XG4gICAgICBsZXZlbDogJ2Vycm9yJyxcbiAgICAgIG1lc3NhZ2U6IFtcbiAgICAgICAgYHVuY2F1Z2h0RXhjZXB0aW9uOiAkeyhtZXNzYWdlIHx8ICcobm8gZXJyb3IgbWVzc2FnZSknKX1gLFxuICAgICAgICBlcnIgJiYgZXJyLnN0YWNrIHx8ICcgIE5vIHN0YWNrIHRyYWNlJ1xuICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgIHN0YWNrOiBlcnIgJiYgZXJyLnN0YWNrLFxuICAgICAgZXhjZXB0aW9uOiB0cnVlLFxuICAgICAgZGF0ZTogbmV3IERhdGUoKS50b1N0cmluZygpLFxuICAgICAgcHJvY2VzczogdGhpcy5nZXRQcm9jZXNzSW5mbygpLFxuICAgICAgb3M6IHRoaXMuZ2V0T3NJbmZvKCksXG4gICAgICB0cmFjZTogdGhpcy5nZXRUcmFjZShlcnIpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCByZWxldmFudCBwcm9jZXNzIGluZm9ybWF0aW9uIGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgcHJvY2Vzcy5cbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBnZXRQcm9jZXNzSW5mbygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGlkOiBwcm9jZXNzLnBpZCxcbiAgICAgIHVpZDogcHJvY2Vzcy5nZXR1aWQgPyBwcm9jZXNzLmdldHVpZCgpIDogbnVsbCxcbiAgICAgIGdpZDogcHJvY2Vzcy5nZXRnaWQgPyBwcm9jZXNzLmdldGdpZCgpIDogbnVsbCxcbiAgICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICAgIGV4ZWNQYXRoOiBwcm9jZXNzLmV4ZWNQYXRoLFxuICAgICAgdmVyc2lvbjogcHJvY2Vzcy52ZXJzaW9uLFxuICAgICAgYXJndjogcHJvY2Vzcy5hcmd2LFxuICAgICAgbWVtb3J5VXNhZ2U6IHByb2Nlc3MubWVtb3J5VXNhZ2UoKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgcmVsZXZhbnQgT1MgaW5mb3JtYXRpb24gZm9yIHRoZSBjdXJyZW50bHkgcnVubmluZyBwcm9jZXNzLlxuICAgKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGdldE9zSW5mbygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9hZGF2Zzogb3MubG9hZGF2ZygpLFxuICAgICAgdXB0aW1lOiBvcy51cHRpbWUoKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHN0YWNrIHRyYWNlIGZvciB0aGUgc3BlY2lmaWVkIGVycm9yLlxuICAgKiBAcGFyYW0ge21peGVkfSBlcnIgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgZ2V0VHJhY2UoZXJyKSB7XG4gICAgY29uc3QgdHJhY2UgPSBlcnIgPyBzdGFja1RyYWNlLnBhcnNlKGVycikgOiBzdGFja1RyYWNlLmdldCgpO1xuICAgIHJldHVybiB0cmFjZS5tYXAoc2l0ZSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2x1bW46IHNpdGUuZ2V0Q29sdW1uTnVtYmVyKCksXG4gICAgICAgIGZpbGU6IHNpdGUuZ2V0RmlsZU5hbWUoKSxcbiAgICAgICAgZnVuY3Rpb246IHNpdGUuZ2V0RnVuY3Rpb25OYW1lKCksXG4gICAgICAgIGxpbmU6IHNpdGUuZ2V0TGluZU51bWJlcigpLFxuICAgICAgICBtZXRob2Q6IHNpdGUuZ2V0TWV0aG9kTmFtZSgpLFxuICAgICAgICBuYXRpdmU6IHNpdGUuaXNOYXRpdmUoKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFkZCBhIHRyYW5zcG9ydCBhcyBhbiBleGNlcHRpb24gaGFuZGxlci5cbiAgICogQHBhcmFtIHtUcmFuc3BvcnR9IGhhbmRsZXIgLSBUaGUgdHJhbnNwb3J0IHRvIGFkZCBhcyBhbiBleGNlcHRpb24gaGFuZGxlci5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfYWRkSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLmhhbmRsZXJzLmhhcyhoYW5kbGVyKSkge1xuICAgICAgaGFuZGxlci5oYW5kbGVFeGNlcHRpb25zID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgRXhjZXB0aW9uU3RyZWFtKGhhbmRsZXIpO1xuICAgICAgdGhpcy5oYW5kbGVycy5zZXQoaGFuZGxlciwgd3JhcHBlcik7XG4gICAgICB0aGlzLmxvZ2dlci5waXBlKHdyYXBwZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGFsbCByZWxldmFudCBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGBlcnJgIGFuZCBleGl0cyB0aGUgY3VycmVudFxuICAgKiBwcm9jZXNzLlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciB0byBoYW5kbGVcbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdW5jYXVnaHRFeGNlcHRpb24oZXJyKSB7XG4gICAgY29uc3QgaW5mbyA9IHRoaXMuZ2V0QWxsSW5mbyhlcnIpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0gdGhpcy5fZ2V0RXhjZXB0aW9uSGFuZGxlcnMoKTtcbiAgICAvLyBDYWxjdWxhdGUgaWYgd2Ugc2hvdWxkIGV4aXQgb24gdGhpcyBlcnJvclxuICAgIGxldCBkb0V4aXQgPSB0eXBlb2YgdGhpcy5sb2dnZXIuZXhpdE9uRXJyb3IgPT09ICdmdW5jdGlvbidcbiAgICAgID8gdGhpcy5sb2dnZXIuZXhpdE9uRXJyb3IoZXJyKVxuICAgICAgOiB0aGlzLmxvZ2dlci5leGl0T25FcnJvcjtcbiAgICBsZXQgdGltZW91dDtcblxuICAgIGlmICghaGFuZGxlcnMubGVuZ3RoICYmIGRvRXhpdCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2Fybignd2luc3RvbjogZXhpdE9uRXJyb3IgY2Fubm90IGJlIHRydWUgd2l0aCBubyBleGNlcHRpb24gaGFuZGxlcnMuJyk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKCd3aW5zdG9uOiBub3QgZXhpdGluZyBwcm9jZXNzLicpO1xuICAgICAgZG9FeGl0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ3JhY2VmdWxFeGl0KCkge1xuICAgICAgZGVidWcoJ2RvRXhpdCcsIGRvRXhpdCk7XG4gICAgICBkZWJ1ZygncHJvY2Vzcy5fZXhpdGluZycsIHByb2Nlc3MuX2V4aXRpbmcpO1xuXG4gICAgICBpZiAoZG9FeGl0ICYmICFwcm9jZXNzLl9leGl0aW5nKSB7XG4gICAgICAgIC8vIFJlbWFyazogQ3VycmVudGx5IGlnbm9yaW5nIGFueSBleGNlcHRpb25zIGZyb20gdHJhbnNwb3J0cyB3aGVuXG4gICAgICAgIC8vIGNhdGNoaW5nIHVuY2F1Z2h0IGV4Y2VwdGlvbnMuXG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm9jZXNzLWV4aXRcbiAgICAgICAgcHJvY2Vzcy5leGl0KDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghaGFuZGxlcnMgfHwgaGFuZGxlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhncmFjZWZ1bEV4aXQpO1xuICAgIH1cblxuICAgIC8vIExvZyB0byBhbGwgdHJhbnNwb3J0cyBhdHRlbXB0aW5nIHRvIGxpc3RlbiBmb3Igd2hlbiB0aGV5IGFyZSBjb21wbGV0ZWQuXG4gICAgYXN5bmNGb3JFYWNoKGhhbmRsZXJzLCAoaGFuZGxlciwgbmV4dCkgPT4ge1xuICAgICAgY29uc3QgZG9uZSA9IG9uY2UobmV4dCk7XG4gICAgICBjb25zdCB0cmFuc3BvcnQgPSBoYW5kbGVyLnRyYW5zcG9ydCB8fCBoYW5kbGVyO1xuXG4gICAgICAvLyBEZWJ1ZyB3cmFwcGluZyBzbyB0aGF0IHdlIGNhbiBpbnNwZWN0IHdoYXQncyBnb2luZyBvbiB1bmRlciB0aGUgY292ZXJzLlxuICAgICAgZnVuY3Rpb24gb25Eb25lKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgZGVidWcoZXZlbnQpO1xuICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgdHJhbnNwb3J0Ll9lbmRpbmcgPSB0cnVlO1xuICAgICAgdHJhbnNwb3J0Lm9uY2UoJ2ZpbmlzaCcsIG9uRG9uZSgnZmluaXNoZWQnKSk7XG4gICAgICB0cmFuc3BvcnQub25jZSgnZXJyb3InLCBvbkRvbmUoJ2Vycm9yJykpO1xuICAgIH0sICgpID0+IGRvRXhpdCAmJiBncmFjZWZ1bEV4aXQoKSk7XG5cbiAgICB0aGlzLmxvZ2dlci5sb2coaW5mbyk7XG5cbiAgICAvLyBJZiBleGl0T25FcnJvciBpcyB0cnVlLCB0aGVuIG9ubHkgYWxsb3cgdGhlIGxvZ2dpbmcgb2YgZXhjZXB0aW9ucyB0b1xuICAgIC8vIHRha2UgdXAgdG8gYDMwMDBtc2AuXG4gICAgaWYgKGRvRXhpdCkge1xuICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQoZ3JhY2VmdWxFeGl0LCAzMDAwKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbGlzdCBvZiB0cmFuc3BvcnRzIGFuZCBleGNlcHRpb25IYW5kbGVycyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge0FycmF5fSAtIExpc3Qgb2YgdHJhbnNwb3J0cyBhbmQgZXhjZXB0aW9uSGFuZGxlcnMgZm9yIHRoaXNcbiAgICogaW5zdGFuY2UuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0RXhjZXB0aW9uSGFuZGxlcnMoKSB7XG4gICAgLy8gUmVtYXJrIChpbmRleHplcm8pOiBzaW5jZSBgbG9nZ2VyLnRyYW5zcG9ydHNgIHJldHVybnMgYWxsIG9mIHRoZSBwaXBlc1xuICAgIC8vIGZyb20gdGhlIF9yZWFkYWJsZVN0YXRlIG9mIHRoZSBzdHJlYW0gd2UgYWN0dWFsbHkgZ2V0IHRoZSBqb2luIG9mIHRoZVxuICAgIC8vIGV4cGxpY2l0IGhhbmRsZXJzIGFuZCB0aGUgaW1wbGljaXQgdHJhbnNwb3J0cyB3aXRoXG4gICAgLy8gYGhhbmRsZUV4Y2VwdGlvbnM6IHRydWVgXG4gICAgcmV0dXJuIHRoaXMubG9nZ2VyLnRyYW5zcG9ydHMuZmlsdGVyKHdyYXAgPT4ge1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gd3JhcC50cmFuc3BvcnQgfHwgd3JhcDtcbiAgICAgIHJldHVybiB0cmFuc3BvcnQuaGFuZGxlRXhjZXB0aW9ucztcbiAgICB9KTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/exception-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/exception-stream.js":
/*!**************************************************************!*\
  !*** ./node_modules/winston/lib/winston/exception-stream.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * exception-stream.js: TODO: add file header handler.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst { Writable } = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\");\n\n/**\n * TODO: add class description.\n * @type {ExceptionStream}\n * @extends {Writable}\n */\nmodule.exports = class ExceptionStream extends Writable {\n  /**\n   * Constructor function for the ExceptionStream responsible for wrapping a\n   * TransportStream; only allowing writes of `info` objects with\n   * `info.exception` set to true.\n   * @param {!TransportStream} transport - Stream to filter to exceptions\n   */\n  constructor(transport) {\n    super({ objectMode: true });\n\n    if (!transport) {\n      throw new Error('ExceptionStream requires a TransportStream instance.');\n    }\n\n    // Remark (indexzero): we set `handleExceptions` here because it's the\n    // predicate checked in ExceptionHandler.prototype.__getExceptionHandlers\n    this.handleExceptions = true;\n    this.transport = transport;\n  }\n\n  /**\n   * Writes the info object to our transport instance if (and only if) the\n   * `exception` property is set on the info.\n   * @param {mixed} info - TODO: add param description.\n   * @param {mixed} enc - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   * @private\n   */\n  _write(info, enc, callback) {\n    if (info.exception) {\n      return this.transport.log(info, callback);\n    }\n\n    callback();\n    return true;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9leGNlcHRpb24tc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLHlFQUFpQjs7QUFFOUM7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9leGNlcHRpb24tc3RyZWFtLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZXhjZXB0aW9uLXN0cmVhbS5qczogVE9ETzogYWRkIGZpbGUgaGVhZGVyIGhhbmRsZXIuXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyk7XG5cbi8qKlxuICogVE9ETzogYWRkIGNsYXNzIGRlc2NyaXB0aW9uLlxuICogQHR5cGUge0V4Y2VwdGlvblN0cmVhbX1cbiAqIEBleHRlbmRzIHtXcml0YWJsZX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBFeGNlcHRpb25TdHJlYW0gZXh0ZW5kcyBXcml0YWJsZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIEV4Y2VwdGlvblN0cmVhbSByZXNwb25zaWJsZSBmb3Igd3JhcHBpbmcgYVxuICAgKiBUcmFuc3BvcnRTdHJlYW07IG9ubHkgYWxsb3dpbmcgd3JpdGVzIG9mIGBpbmZvYCBvYmplY3RzIHdpdGhcbiAgICogYGluZm8uZXhjZXB0aW9uYCBzZXQgdG8gdHJ1ZS5cbiAgICogQHBhcmFtIHshVHJhbnNwb3J0U3RyZWFtfSB0cmFuc3BvcnQgLSBTdHJlYW0gdG8gZmlsdGVyIHRvIGV4Y2VwdGlvbnNcbiAgICovXG4gIGNvbnN0cnVjdG9yKHRyYW5zcG9ydCkge1xuICAgIHN1cGVyKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcblxuICAgIGlmICghdHJhbnNwb3J0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V4Y2VwdGlvblN0cmVhbSByZXF1aXJlcyBhIFRyYW5zcG9ydFN0cmVhbSBpbnN0YW5jZS4nKTtcbiAgICB9XG5cbiAgICAvLyBSZW1hcmsgKGluZGV4emVybyk6IHdlIHNldCBgaGFuZGxlRXhjZXB0aW9uc2AgaGVyZSBiZWNhdXNlIGl0J3MgdGhlXG4gICAgLy8gcHJlZGljYXRlIGNoZWNrZWQgaW4gRXhjZXB0aW9uSGFuZGxlci5wcm90b3R5cGUuX19nZXRFeGNlcHRpb25IYW5kbGVyc1xuICAgIHRoaXMuaGFuZGxlRXhjZXB0aW9ucyA9IHRydWU7XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIHRoZSBpbmZvIG9iamVjdCB0byBvdXIgdHJhbnNwb3J0IGluc3RhbmNlIGlmIChhbmQgb25seSBpZikgdGhlXG4gICAqIGBleGNlcHRpb25gIHByb3BlcnR5IGlzIHNldCBvbiB0aGUgaW5mby5cbiAgICogQHBhcmFtIHttaXhlZH0gaW5mbyAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHttaXhlZH0gZW5jIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge21peGVkfSBjYWxsYmFjayAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGUoaW5mbywgZW5jLCBjYWxsYmFjaykge1xuICAgIGlmIChpbmZvLmV4Y2VwdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmxvZyhpbmZvLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/exception-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/logger.js":
/*!****************************************************!*\
  !*** ./node_modules/winston/lib/winston/logger.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * logger.js: TODO: add file header description.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst { Stream, Transform } = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\");\nconst asyncForEach = __webpack_require__(/*! async/forEach */ \"(rsc)/./node_modules/async/forEach.js\");\nconst { LEVEL, SPLAT } = __webpack_require__(/*! triple-beam */ \"(rsc)/./node_modules/triple-beam/index.js\");\nconst isStream = __webpack_require__(/*! is-stream */ \"(rsc)/./node_modules/is-stream/index.js\");\nconst ExceptionHandler = __webpack_require__(/*! ./exception-handler */ \"(rsc)/./node_modules/winston/lib/winston/exception-handler.js\");\nconst RejectionHandler = __webpack_require__(/*! ./rejection-handler */ \"(rsc)/./node_modules/winston/lib/winston/rejection-handler.js\");\nconst LegacyTransportStream = __webpack_require__(/*! winston-transport/legacy */ \"(rsc)/./node_modules/winston-transport/legacy.js\");\nconst Profiler = __webpack_require__(/*! ./profiler */ \"(rsc)/./node_modules/winston/lib/winston/profiler.js\");\nconst { warn } = __webpack_require__(/*! ./common */ \"(rsc)/./node_modules/winston/lib/winston/common.js\");\nconst config = __webpack_require__(/*! ./config */ \"(rsc)/./node_modules/winston/lib/winston/config/index.js\");\n\n/**\n * Captures the number of format (i.e. %s strings) in a given string.\n * Based on `util.format`, see Node.js source:\n * https://github.com/nodejs/node/blob/b1c8f15c5f169e021f7c46eb7b219de95fe97603/lib/util.js#L201-L230\n * @type {RegExp}\n */\nconst formatRegExp = /%[scdjifoO%]/g;\n\n/**\n * TODO: add class description.\n * @type {Logger}\n * @extends {Transform}\n */\nclass Logger extends Transform {\n  /**\n   * Constructor function for the Logger object responsible for persisting log\n   * messages and metadata to one or more transports.\n   * @param {!Object} options - foo\n   */\n  constructor(options) {\n    super({ objectMode: true });\n    this.configure(options);\n  }\n\n  child(defaultRequestMetadata) {\n    const logger = this;\n    return Object.create(logger, {\n      write: {\n        value: function (info) {\n          const infoClone = Object.assign(\n            {},\n            defaultRequestMetadata,\n            info\n          );\n\n          // Object.assign doesn't copy inherited Error\n          // properties so we have to do that explicitly\n          //\n          // Remark (indexzero): we should remove this\n          // since the errors format will handle this case.\n          //\n          if (info instanceof Error) {\n            infoClone.stack = info.stack;\n            infoClone.message = info.message;\n          }\n\n          logger.write(infoClone);\n        }\n      }\n    });\n  }\n\n  /**\n   * This will wholesale reconfigure this instance by:\n   * 1. Resetting all transports. Older transports will be removed implicitly.\n   * 2. Set all other options including levels, colors, rewriters, filters,\n   *    exceptionHandlers, etc.\n   * @param {!Object} options - TODO: add param description.\n   * @returns {undefined}\n   */\n  configure({\n    silent,\n    format,\n    defaultMeta,\n    levels,\n    level = 'info',\n    exitOnError = true,\n    transports,\n    colors,\n    emitErrs,\n    formatters,\n    padLevels,\n    rewriters,\n    stripColors,\n    exceptionHandlers,\n    rejectionHandlers\n  } = {}) {\n    // Reset transports if we already have them\n    if (this.transports.length) {\n      this.clear();\n    }\n\n    this.silent = silent;\n    this.format = format || this.format || __webpack_require__(/*! logform/json */ \"(rsc)/./node_modules/logform/json.js\")();\n\n    this.defaultMeta = defaultMeta || null;\n    // Hoist other options onto this instance.\n    this.levels = levels || this.levels || config.npm.levels;\n    this.level = level;\n    if (this.exceptions) {\n      this.exceptions.unhandle();\n    }\n    if (this.rejections) {\n      this.rejections.unhandle();\n    }\n    this.exceptions = new ExceptionHandler(this);\n    this.rejections = new RejectionHandler(this);\n    this.profilers = {};\n    this.exitOnError = exitOnError;\n\n    // Add all transports we have been provided.\n    if (transports) {\n      transports = Array.isArray(transports) ? transports : [transports];\n      transports.forEach(transport => this.add(transport));\n    }\n\n    if (\n      colors ||\n      emitErrs ||\n      formatters ||\n      padLevels ||\n      rewriters ||\n      stripColors\n    ) {\n      throw new Error(\n        [\n          '{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.',\n          'Use a custom winston.format(function) instead.',\n          'See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md'\n        ].join('\\n')\n      );\n    }\n\n    if (exceptionHandlers) {\n      this.exceptions.handle(exceptionHandlers);\n    }\n    if (rejectionHandlers) {\n      this.rejections.handle(rejectionHandlers);\n    }\n  }\n\n  isLevelEnabled(level) {\n    const givenLevelValue = getLevelValue(this.levels, level);\n    if (givenLevelValue === null) {\n      return false;\n    }\n\n    const configuredLevelValue = getLevelValue(this.levels, this.level);\n    if (configuredLevelValue === null) {\n      return false;\n    }\n\n    if (!this.transports || this.transports.length === 0) {\n      return configuredLevelValue >= givenLevelValue;\n    }\n\n    const index = this.transports.findIndex(transport => {\n      let transportLevelValue = getLevelValue(this.levels, transport.level);\n      if (transportLevelValue === null) {\n        transportLevelValue = configuredLevelValue;\n      }\n      return transportLevelValue >= givenLevelValue;\n    });\n    return index !== -1;\n  }\n\n  /* eslint-disable valid-jsdoc */\n  /**\n   * Ensure backwards compatibility with a `log` method\n   * @param {mixed} level - Level the log message is written at.\n   * @param {mixed} msg - TODO: add param description.\n   * @param {mixed} meta - TODO: add param description.\n   * @returns {Logger} - TODO: add return description.\n   *\n   * @example\n   *    // Supports the existing API:\n   *    logger.log('info', 'Hello world', { custom: true });\n   *    logger.log('info', new Error('Yo, it\\'s on fire'));\n   *\n   *    // Requires winston.format.splat()\n   *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });\n   *\n   *    // And the new API with a single JSON literal:\n   *    logger.log({ level: 'info', message: 'Hello world', custom: true });\n   *    logger.log({ level: 'info', message: new Error('Yo, it\\'s on fire') });\n   *\n   *    // Also requires winston.format.splat()\n   *    logger.log({\n   *      level: 'info',\n   *      message: '%s %d%%',\n   *      [SPLAT]: ['A string', 50],\n   *      meta: { thisIsMeta: true }\n   *    });\n   *\n   */\n  /* eslint-enable valid-jsdoc */\n  log(level, msg, ...splat) {\n    // eslint-disable-line max-params\n    // Optimize for the hotpath of logging JSON literals\n    if (arguments.length === 1) {\n      // Yo dawg, I heard you like levels ... seriously ...\n      // In this context the LHS `level` here is actually the `info` so read\n      // this as: info[LEVEL] = info.level;\n      level[LEVEL] = level.level;\n      this._addDefaultMeta(level);\n      this.write(level);\n      return this;\n    }\n\n    // Slightly less hotpath, but worth optimizing for.\n    if (arguments.length === 2) {\n      if (msg && typeof msg === 'object') {\n        msg[LEVEL] = msg.level = level;\n        this._addDefaultMeta(msg);\n        this.write(msg);\n        return this;\n      }\n\n      msg = { [LEVEL]: level, level, message: msg };\n      this._addDefaultMeta(msg);\n      this.write(msg);\n      return this;\n    }\n\n    const [meta] = splat;\n    if (typeof meta === 'object' && meta !== null) {\n      // Extract tokens, if none available default to empty array to\n      // ensure consistancy in expected results\n      const tokens = msg && msg.match && msg.match(formatRegExp);\n\n      if (!tokens) {\n        const info = Object.assign({}, this.defaultMeta, meta, {\n          [LEVEL]: level,\n          [SPLAT]: splat,\n          level,\n          message: msg\n        });\n\n        if (meta.message) info.message = `${info.message} ${meta.message}`;\n        if (meta.stack) info.stack = meta.stack;\n        if (meta.cause) info.cause = meta.cause;\n\n        this.write(info);\n        return this;\n      }\n    }\n\n    this.write(Object.assign({}, this.defaultMeta, {\n      [LEVEL]: level,\n      [SPLAT]: splat,\n      level,\n      message: msg\n    }));\n\n    return this;\n  }\n\n  /**\n   * Pushes data so that it can be picked up by all of our pipe targets.\n   * @param {mixed} info - TODO: add param description.\n   * @param {mixed} enc - TODO: add param description.\n   * @param {mixed} callback - Continues stream processing.\n   * @returns {undefined}\n   * @private\n   */\n  _transform(info, enc, callback) {\n    if (this.silent) {\n      return callback();\n    }\n\n    // [LEVEL] is only soft guaranteed to be set here since we are a proper\n    // stream. It is likely that `info` came in through `.log(info)` or\n    // `.info(info)`. If it is not defined, however, define it.\n    // This LEVEL symbol is provided by `triple-beam` and also used in:\n    // - logform\n    // - winston-transport\n    // - abstract-winston-transport\n    if (!info[LEVEL]) {\n      info[LEVEL] = info.level;\n    }\n\n    // Remark: really not sure what to do here, but this has been reported as\n    // very confusing by pre winston@2.0.0 users as quite confusing when using\n    // custom levels.\n    if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {\n      // eslint-disable-next-line no-console\n      console.error('[winston] Unknown logger level: %s', info[LEVEL]);\n    }\n\n    // Remark: not sure if we should simply error here.\n    if (!this._readableState.pipes) {\n      // eslint-disable-next-line no-console\n      console.error(\n        '[winston] Attempt to write logs with no transports, which can increase memory usage: %j',\n        info\n      );\n    }\n\n    // Here we write to the `format` pipe-chain, which on `readable` above will\n    // push the formatted `info` Object onto the buffer for this instance. We trap\n    // (and re-throw) any errors generated by the user-provided format, but also\n    // guarantee that the streams callback is invoked so that we can continue flowing.\n    try {\n      this.push(this.format.transform(info, this.format.options));\n    } finally {\n      this._writableState.sync = false;\n      // eslint-disable-next-line callback-return\n      callback();\n    }\n  }\n\n  /**\n   * Delays the 'finish' event until all transport pipe targets have\n   * also emitted 'finish' or are already finished.\n   * @param {mixed} callback - Continues stream processing.\n   */\n  _final(callback) {\n    const transports = this.transports.slice();\n    asyncForEach(\n      transports,\n      (transport, next) => {\n        if (!transport || transport.finished) return setImmediate(next);\n        transport.once('finish', next);\n        transport.end();\n      },\n      callback\n    );\n  }\n\n  /**\n   * Adds the transport to this logger instance by piping to it.\n   * @param {mixed} transport - TODO: add param description.\n   * @returns {Logger} - TODO: add return description.\n   */\n  add(transport) {\n    // Support backwards compatibility with all existing `winston < 3.x.x`\n    // transports which meet one of two criteria:\n    // 1. They inherit from winston.Transport in  < 3.x.x which is NOT a stream.\n    // 2. They expose a log method which has a length greater than 2 (i.e. more then\n    //    just `log(info, callback)`.\n    const target =\n      !isStream(transport) || transport.log.length > 2\n        ? new LegacyTransportStream({ transport })\n        : transport;\n\n    if (!target._writableState || !target._writableState.objectMode) {\n      throw new Error(\n        'Transports must WritableStreams in objectMode. Set { objectMode: true }.'\n      );\n    }\n\n    // Listen for the `error` event and the `warn` event on the new Transport.\n    this._onEvent('error', target);\n    this._onEvent('warn', target);\n    this.pipe(target);\n\n    if (transport.handleExceptions) {\n      this.exceptions.handle();\n    }\n\n    if (transport.handleRejections) {\n      this.rejections.handle();\n    }\n\n    return this;\n  }\n\n  /**\n   * Removes the transport from this logger instance by unpiping from it.\n   * @param {mixed} transport - TODO: add param description.\n   * @returns {Logger} - TODO: add return description.\n   */\n  remove(transport) {\n    if (!transport) return this;\n    let target = transport;\n    if (!isStream(transport) || transport.log.length > 2) {\n      target = this.transports.filter(\n        match => match.transport === transport\n      )[0];\n    }\n\n    if (target) {\n      this.unpipe(target);\n    }\n    return this;\n  }\n\n  /**\n   * Removes all transports from this logger instance.\n   * @returns {Logger} - TODO: add return description.\n   */\n  clear() {\n    this.unpipe();\n    return this;\n  }\n\n  /**\n   * Cleans up resources (streams, event listeners) for all transports\n   * associated with this instance (if necessary).\n   * @returns {Logger} - TODO: add return description.\n   */\n  close() {\n    this.exceptions.unhandle();\n    this.rejections.unhandle();\n    this.clear();\n    this.emit('close');\n    return this;\n  }\n\n  /**\n   * Sets the `target` levels specified on this instance.\n   * @param {Object} Target levels to use on this instance.\n   */\n  setLevels() {\n    warn.deprecated('setLevels');\n  }\n\n  /**\n   * Queries the all transports for this instance with the specified `options`.\n   * This will aggregate each transport's results into one object containing\n   * a property per transport.\n   * @param {Object} options - Query options for this instance.\n   * @param {function} callback - Continuation to respond to when complete.\n   */\n  query(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = options || {};\n    const results = {};\n    const queryObject = Object.assign({}, options.query || {});\n\n    // Helper function to query a single transport\n    function queryTransport(transport, next) {\n      if (options.query && typeof transport.formatQuery === 'function') {\n        options.query = transport.formatQuery(queryObject);\n      }\n\n      transport.query(options, (err, res) => {\n        if (err) {\n          return next(err);\n        }\n\n        if (typeof transport.formatResults === 'function') {\n          res = transport.formatResults(res, options.format);\n        }\n\n        next(null, res);\n      });\n    }\n\n    // Helper function to accumulate the results from `queryTransport` into\n    // the `results`.\n    function addResults(transport, next) {\n      queryTransport(transport, (err, result) => {\n        // queryTransport could potentially invoke the callback multiple times\n        // since Transport code can be unpredictable.\n        if (next) {\n          result = err || result;\n          if (result) {\n            results[transport.name] = result;\n          }\n\n          // eslint-disable-next-line callback-return\n          next();\n        }\n\n        next = null;\n      });\n    }\n\n    // Iterate over the transports in parallel setting the appropriate key in\n    // the `results`.\n    asyncForEach(\n      this.transports.filter(transport => !!transport.query),\n      addResults,\n      () => callback(null, results)\n    );\n  }\n\n  /**\n   * Returns a log stream for all transports. Options object is optional.\n   * @param{Object} options={} - Stream options for this instance.\n   * @returns {Stream} - TODO: add return description.\n   */\n  stream(options = {}) {\n    const out = new Stream();\n    const streams = [];\n\n    out._streams = streams;\n    out.destroy = () => {\n      let i = streams.length;\n      while (i--) {\n        streams[i].destroy();\n      }\n    };\n\n    // Create a list of all transports for this instance.\n    this.transports\n      .filter(transport => !!transport.stream)\n      .forEach(transport => {\n        const str = transport.stream(options);\n        if (!str) {\n          return;\n        }\n\n        streams.push(str);\n\n        str.on('log', log => {\n          log.transport = log.transport || [];\n          log.transport.push(transport.name);\n          out.emit('log', log);\n        });\n\n        str.on('error', err => {\n          err.transport = err.transport || [];\n          err.transport.push(transport.name);\n          out.emit('error', err);\n        });\n      });\n\n    return out;\n  }\n\n  /**\n   * Returns an object corresponding to a specific timing. When done is called\n   * the timer will finish and log the duration. e.g.:\n   * @returns {Profile} - TODO: add return description.\n   * @example\n   *    const timer = winston.startTimer()\n   *    setTimeout(() => {\n   *      timer.done({\n   *        message: 'Logging message'\n   *      });\n   *    }, 1000);\n   */\n  startTimer() {\n    return new Profiler(this);\n  }\n\n  /**\n   * Tracks the time inbetween subsequent calls to this method with the same\n   * `id` parameter. The second call to this method will log the difference in\n   * milliseconds along with the message.\n   * @param {string} id Unique id of the profiler\n   * @returns {Logger} - TODO: add return description.\n   */\n  profile(id, ...args) {\n    const time = Date.now();\n    if (this.profilers[id]) {\n      const timeEnd = this.profilers[id];\n      delete this.profilers[id];\n\n      // Attempt to be kind to users if they are still using older APIs.\n      if (typeof args[args.length - 2] === 'function') {\n        // eslint-disable-next-line no-console\n        console.warn(\n          'Callback function no longer supported as of winston@3.0.0'\n        );\n        args.pop();\n      }\n\n      // Set the duration property of the metadata\n      const info = typeof args[args.length - 1] === 'object' ? args.pop() : {};\n      info.level = info.level || 'info';\n      info.durationMs = time - timeEnd;\n      info.message = info.message || id;\n      return this.write(info);\n    }\n\n    this.profilers[id] = time;\n    return this;\n  }\n\n  /**\n   * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.\n   * @returns {undefined}\n   * @deprecated\n   */\n  handleExceptions(...args) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()'\n    );\n    this.exceptions.handle(...args);\n  }\n\n  /**\n   * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.\n   * @returns {undefined}\n   * @deprecated\n   */\n  unhandleExceptions(...args) {\n    // eslint-disable-next-line no-console\n    console.warn(\n      'Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()'\n    );\n    this.exceptions.unhandle(...args);\n  }\n\n  /**\n   * Throw a more meaningful deprecation notice\n   * @throws {Error} - TODO: add throws description.\n   */\n  cli() {\n    throw new Error(\n      [\n        'Logger.cli() was removed in winston@3.0.0',\n        'Use a custom winston.formats.cli() instead.',\n        'See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md'\n      ].join('\\n')\n    );\n  }\n\n  /**\n   * Bubbles the `event` that occured on the specified `transport` up\n   * from this instance.\n   * @param {string} event - The event that occured\n   * @param {Object} transport - Transport on which the event occured\n   * @private\n   */\n  _onEvent(event, transport) {\n    function transportEvent(err) {\n      // https://github.com/winstonjs/winston/issues/1364\n      if (event === 'error' && !this.transports.includes(transport)) {\n        this.add(transport);\n      }\n      this.emit(event, err, transport);\n    }\n\n    if (!transport['__winston' + event]) {\n      transport['__winston' + event] = transportEvent.bind(this);\n      transport.on(event, transport['__winston' + event]);\n    }\n  }\n\n  _addDefaultMeta(msg) {\n    if (this.defaultMeta) {\n      Object.assign(msg, this.defaultMeta);\n    }\n  }\n}\n\nfunction getLevelValue(levels, level) {\n  const value = levels[level];\n  if (!value && value !== 0) {\n    return null;\n  }\n  return value;\n}\n\n/**\n * Represents the current readableState pipe targets for this Logger instance.\n * @type {Array|Object}\n */\nObject.defineProperty(Logger.prototype, 'transports', {\n  configurable: false,\n  enumerable: true,\n  get() {\n    const { pipes } = this._readableState;\n    return !Array.isArray(pipes) ? [pipes].filter(Boolean) : pipes;\n  }\n});\n\nmodule.exports = Logger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9sb2dnZXIuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLFFBQVEsb0JBQW9CLEVBQUUsbUJBQU8sQ0FBQyx5RUFBaUI7QUFDdkQscUJBQXFCLG1CQUFPLENBQUMsNERBQWU7QUFDNUMsUUFBUSxlQUFlLEVBQUUsbUJBQU8sQ0FBQyw4REFBYTtBQUM5QyxpQkFBaUIsbUJBQU8sQ0FBQywwREFBVztBQUNwQyx5QkFBeUIsbUJBQU8sQ0FBQywwRkFBcUI7QUFDdEQseUJBQXlCLG1CQUFPLENBQUMsMEZBQXFCO0FBQ3RELDhCQUE4QixtQkFBTyxDQUFDLGtGQUEwQjtBQUNoRSxpQkFBaUIsbUJBQU8sQ0FBQyx3RUFBWTtBQUNyQyxRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLG9FQUFVO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQywwRUFBVTs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxZQUFZLGtCQUFrQjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQUk7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxtQkFBTyxDQUFDLDBEQUFjOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtFQUFrRTtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsY0FBYztBQUMxRDtBQUNBO0FBQ0E7QUFDQSx3REFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0E7QUFDQSxxQkFBcUIscURBQXFEO0FBQzFFLHFCQUFxQix3REFBd0Q7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQsNENBQTRDLGNBQWMsRUFBRSxhQUFhO0FBQ3pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFdBQVc7QUFDakQ7O0FBRUE7QUFDQTtBQUNBLDhEQUE4RCxrQkFBa0I7QUFDaEY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLHFCQUFxQjs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRLFdBQVc7QUFDL0IsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxjQUFjLE9BQU87QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQTtBQUNBLENBQUM7O0FBRUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9sb2dnZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBsb2dnZXIuanM6IFRPRE86IGFkZCBmaWxlIGhlYWRlciBkZXNjcmlwdGlvbi5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFN0cmVhbSwgVHJhbnNmb3JtIH0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKTtcbmNvbnN0IGFzeW5jRm9yRWFjaCA9IHJlcXVpcmUoJ2FzeW5jL2ZvckVhY2gnKTtcbmNvbnN0IHsgTEVWRUwsIFNQTEFUIH0gPSByZXF1aXJlKCd0cmlwbGUtYmVhbScpO1xuY29uc3QgaXNTdHJlYW0gPSByZXF1aXJlKCdpcy1zdHJlYW0nKTtcbmNvbnN0IEV4Y2VwdGlvbkhhbmRsZXIgPSByZXF1aXJlKCcuL2V4Y2VwdGlvbi1oYW5kbGVyJyk7XG5jb25zdCBSZWplY3Rpb25IYW5kbGVyID0gcmVxdWlyZSgnLi9yZWplY3Rpb24taGFuZGxlcicpO1xuY29uc3QgTGVnYWN5VHJhbnNwb3J0U3RyZWFtID0gcmVxdWlyZSgnd2luc3Rvbi10cmFuc3BvcnQvbGVnYWN5Jyk7XG5jb25zdCBQcm9maWxlciA9IHJlcXVpcmUoJy4vcHJvZmlsZXInKTtcbmNvbnN0IHsgd2FybiB9ID0gcmVxdWlyZSgnLi9jb21tb24nKTtcbmNvbnN0IGNvbmZpZyA9IHJlcXVpcmUoJy4vY29uZmlnJyk7XG5cbi8qKlxuICogQ2FwdHVyZXMgdGhlIG51bWJlciBvZiBmb3JtYXQgKGkuZS4gJXMgc3RyaW5ncykgaW4gYSBnaXZlbiBzdHJpbmcuXG4gKiBCYXNlZCBvbiBgdXRpbC5mb3JtYXRgLCBzZWUgTm9kZS5qcyBzb3VyY2U6XG4gKiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi9iMWM4ZjE1YzVmMTY5ZTAyMWY3YzQ2ZWI3YjIxOWRlOTVmZTk3NjAzL2xpYi91dGlsLmpzI0wyMDEtTDIzMFxuICogQHR5cGUge1JlZ0V4cH1cbiAqL1xuY29uc3QgZm9ybWF0UmVnRXhwID0gLyVbc2Nkamlmb08lXS9nO1xuXG4vKipcbiAqIFRPRE86IGFkZCBjbGFzcyBkZXNjcmlwdGlvbi5cbiAqIEB0eXBlIHtMb2dnZXJ9XG4gKiBAZXh0ZW5kcyB7VHJhbnNmb3JtfVxuICovXG5jbGFzcyBMb2dnZXIgZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBMb2dnZXIgb2JqZWN0IHJlc3BvbnNpYmxlIGZvciBwZXJzaXN0aW5nIGxvZ1xuICAgKiBtZXNzYWdlcyBhbmQgbWV0YWRhdGEgdG8gb25lIG9yIG1vcmUgdHJhbnNwb3J0cy5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBvcHRpb25zIC0gZm9vXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuICAgIHRoaXMuY29uZmlndXJlKG9wdGlvbnMpO1xuICB9XG5cbiAgY2hpbGQoZGVmYXVsdFJlcXVlc3RNZXRhZGF0YSkge1xuICAgIGNvbnN0IGxvZ2dlciA9IHRoaXM7XG4gICAgcmV0dXJuIE9iamVjdC5jcmVhdGUobG9nZ2VyLCB7XG4gICAgICB3cml0ZToge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKGluZm8pIHtcbiAgICAgICAgICBjb25zdCBpbmZvQ2xvbmUgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAge30sXG4gICAgICAgICAgICBkZWZhdWx0UmVxdWVzdE1ldGFkYXRhLFxuICAgICAgICAgICAgaW5mb1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICAvLyBPYmplY3QuYXNzaWduIGRvZXNuJ3QgY29weSBpbmhlcml0ZWQgRXJyb3JcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzIHNvIHdlIGhhdmUgdG8gZG8gdGhhdCBleHBsaWNpdGx5XG4gICAgICAgICAgLy9cbiAgICAgICAgICAvLyBSZW1hcmsgKGluZGV4emVybyk6IHdlIHNob3VsZCByZW1vdmUgdGhpc1xuICAgICAgICAgIC8vIHNpbmNlIHRoZSBlcnJvcnMgZm9ybWF0IHdpbGwgaGFuZGxlIHRoaXMgY2FzZS5cbiAgICAgICAgICAvL1xuICAgICAgICAgIGlmIChpbmZvIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIGluZm9DbG9uZS5zdGFjayA9IGluZm8uc3RhY2s7XG4gICAgICAgICAgICBpbmZvQ2xvbmUubWVzc2FnZSA9IGluZm8ubWVzc2FnZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBsb2dnZXIud3JpdGUoaW5mb0Nsb25lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgd2lsbCB3aG9sZXNhbGUgcmVjb25maWd1cmUgdGhpcyBpbnN0YW5jZSBieTpcbiAgICogMS4gUmVzZXR0aW5nIGFsbCB0cmFuc3BvcnRzLiBPbGRlciB0cmFuc3BvcnRzIHdpbGwgYmUgcmVtb3ZlZCBpbXBsaWNpdGx5LlxuICAgKiAyLiBTZXQgYWxsIG90aGVyIG9wdGlvbnMgaW5jbHVkaW5nIGxldmVscywgY29sb3JzLCByZXdyaXRlcnMsIGZpbHRlcnMsXG4gICAqICAgIGV4Y2VwdGlvbkhhbmRsZXJzLCBldGMuXG4gICAqIEBwYXJhbSB7IU9iamVjdH0gb3B0aW9ucyAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAgICovXG4gIGNvbmZpZ3VyZSh7XG4gICAgc2lsZW50LFxuICAgIGZvcm1hdCxcbiAgICBkZWZhdWx0TWV0YSxcbiAgICBsZXZlbHMsXG4gICAgbGV2ZWwgPSAnaW5mbycsXG4gICAgZXhpdE9uRXJyb3IgPSB0cnVlLFxuICAgIHRyYW5zcG9ydHMsXG4gICAgY29sb3JzLFxuICAgIGVtaXRFcnJzLFxuICAgIGZvcm1hdHRlcnMsXG4gICAgcGFkTGV2ZWxzLFxuICAgIHJld3JpdGVycyxcbiAgICBzdHJpcENvbG9ycyxcbiAgICBleGNlcHRpb25IYW5kbGVycyxcbiAgICByZWplY3Rpb25IYW5kbGVyc1xuICB9ID0ge30pIHtcbiAgICAvLyBSZXNldCB0cmFuc3BvcnRzIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGVtXG4gICAgaWYgKHRoaXMudHJhbnNwb3J0cy5sZW5ndGgpIHtcbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICB9XG5cbiAgICB0aGlzLnNpbGVudCA9IHNpbGVudDtcbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdCB8fCB0aGlzLmZvcm1hdCB8fCByZXF1aXJlKCdsb2dmb3JtL2pzb24nKSgpO1xuXG4gICAgdGhpcy5kZWZhdWx0TWV0YSA9IGRlZmF1bHRNZXRhIHx8IG51bGw7XG4gICAgLy8gSG9pc3Qgb3RoZXIgb3B0aW9ucyBvbnRvIHRoaXMgaW5zdGFuY2UuXG4gICAgdGhpcy5sZXZlbHMgPSBsZXZlbHMgfHwgdGhpcy5sZXZlbHMgfHwgY29uZmlnLm5wbS5sZXZlbHM7XG4gICAgdGhpcy5sZXZlbCA9IGxldmVsO1xuICAgIGlmICh0aGlzLmV4Y2VwdGlvbnMpIHtcbiAgICAgIHRoaXMuZXhjZXB0aW9ucy51bmhhbmRsZSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5yZWplY3Rpb25zKSB7XG4gICAgICB0aGlzLnJlamVjdGlvbnMudW5oYW5kbGUoKTtcbiAgICB9XG4gICAgdGhpcy5leGNlcHRpb25zID0gbmV3IEV4Y2VwdGlvbkhhbmRsZXIodGhpcyk7XG4gICAgdGhpcy5yZWplY3Rpb25zID0gbmV3IFJlamVjdGlvbkhhbmRsZXIodGhpcyk7XG4gICAgdGhpcy5wcm9maWxlcnMgPSB7fTtcbiAgICB0aGlzLmV4aXRPbkVycm9yID0gZXhpdE9uRXJyb3I7XG5cbiAgICAvLyBBZGQgYWxsIHRyYW5zcG9ydHMgd2UgaGF2ZSBiZWVuIHByb3ZpZGVkLlxuICAgIGlmICh0cmFuc3BvcnRzKSB7XG4gICAgICB0cmFuc3BvcnRzID0gQXJyYXkuaXNBcnJheSh0cmFuc3BvcnRzKSA/IHRyYW5zcG9ydHMgOiBbdHJhbnNwb3J0c107XG4gICAgICB0cmFuc3BvcnRzLmZvckVhY2godHJhbnNwb3J0ID0+IHRoaXMuYWRkKHRyYW5zcG9ydCkpO1xuICAgIH1cblxuICAgIGlmIChcbiAgICAgIGNvbG9ycyB8fFxuICAgICAgZW1pdEVycnMgfHxcbiAgICAgIGZvcm1hdHRlcnMgfHxcbiAgICAgIHBhZExldmVscyB8fFxuICAgICAgcmV3cml0ZXJzIHx8XG4gICAgICBzdHJpcENvbG9yc1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBbXG4gICAgICAgICAgJ3sgY29sb3JzLCBlbWl0RXJycywgZm9ybWF0dGVycywgcGFkTGV2ZWxzLCByZXdyaXRlcnMsIHN0cmlwQ29sb3JzIH0gd2VyZSByZW1vdmVkIGluIHdpbnN0b25AMy4wLjAuJyxcbiAgICAgICAgICAnVXNlIGEgY3VzdG9tIHdpbnN0b24uZm9ybWF0KGZ1bmN0aW9uKSBpbnN0ZWFkLicsXG4gICAgICAgICAgJ1NlZTogaHR0cHM6Ly9naXRodWIuY29tL3dpbnN0b25qcy93aW5zdG9uL3RyZWUvbWFzdGVyL1VQR1JBREUtMy4wLm1kJ1xuICAgICAgICBdLmpvaW4oJ1xcbicpXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmIChleGNlcHRpb25IYW5kbGVycykge1xuICAgICAgdGhpcy5leGNlcHRpb25zLmhhbmRsZShleGNlcHRpb25IYW5kbGVycyk7XG4gICAgfVxuICAgIGlmIChyZWplY3Rpb25IYW5kbGVycykge1xuICAgICAgdGhpcy5yZWplY3Rpb25zLmhhbmRsZShyZWplY3Rpb25IYW5kbGVycyk7XG4gICAgfVxuICB9XG5cbiAgaXNMZXZlbEVuYWJsZWQobGV2ZWwpIHtcbiAgICBjb25zdCBnaXZlbkxldmVsVmFsdWUgPSBnZXRMZXZlbFZhbHVlKHRoaXMubGV2ZWxzLCBsZXZlbCk7XG4gICAgaWYgKGdpdmVuTGV2ZWxWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbmZpZ3VyZWRMZXZlbFZhbHVlID0gZ2V0TGV2ZWxWYWx1ZSh0aGlzLmxldmVscywgdGhpcy5sZXZlbCk7XG4gICAgaWYgKGNvbmZpZ3VyZWRMZXZlbFZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnRyYW5zcG9ydHMgfHwgdGhpcy50cmFuc3BvcnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGNvbmZpZ3VyZWRMZXZlbFZhbHVlID49IGdpdmVuTGV2ZWxWYWx1ZTtcbiAgICB9XG5cbiAgICBjb25zdCBpbmRleCA9IHRoaXMudHJhbnNwb3J0cy5maW5kSW5kZXgodHJhbnNwb3J0ID0+IHtcbiAgICAgIGxldCB0cmFuc3BvcnRMZXZlbFZhbHVlID0gZ2V0TGV2ZWxWYWx1ZSh0aGlzLmxldmVscywgdHJhbnNwb3J0LmxldmVsKTtcbiAgICAgIGlmICh0cmFuc3BvcnRMZXZlbFZhbHVlID09PSBudWxsKSB7XG4gICAgICAgIHRyYW5zcG9ydExldmVsVmFsdWUgPSBjb25maWd1cmVkTGV2ZWxWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFuc3BvcnRMZXZlbFZhbHVlID49IGdpdmVuTGV2ZWxWYWx1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gaW5kZXggIT09IC0xO1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgdmFsaWQtanNkb2MgKi9cbiAgLyoqXG4gICAqIEVuc3VyZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGEgYGxvZ2AgbWV0aG9kXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGxldmVsIC0gTGV2ZWwgdGhlIGxvZyBtZXNzYWdlIGlzIHdyaXR0ZW4gYXQuXG4gICAqIEBwYXJhbSB7bWl4ZWR9IG1zZyAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHttaXhlZH0gbWV0YSAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge0xvZ2dlcn0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKlxuICAgKiBAZXhhbXBsZVxuICAgKiAgICAvLyBTdXBwb3J0cyB0aGUgZXhpc3RpbmcgQVBJOlxuICAgKiAgICBsb2dnZXIubG9nKCdpbmZvJywgJ0hlbGxvIHdvcmxkJywgeyBjdXN0b206IHRydWUgfSk7XG4gICAqICAgIGxvZ2dlci5sb2coJ2luZm8nLCBuZXcgRXJyb3IoJ1lvLCBpdFxcJ3Mgb24gZmlyZScpKTtcbiAgICpcbiAgICogICAgLy8gUmVxdWlyZXMgd2luc3Rvbi5mb3JtYXQuc3BsYXQoKVxuICAgKiAgICBsb2dnZXIubG9nKCdpbmZvJywgJyVzICVkJSUnLCAnQSBzdHJpbmcnLCA1MCwgeyB0aGlzSXNNZXRhOiB0cnVlIH0pO1xuICAgKlxuICAgKiAgICAvLyBBbmQgdGhlIG5ldyBBUEkgd2l0aCBhIHNpbmdsZSBKU09OIGxpdGVyYWw6XG4gICAqICAgIGxvZ2dlci5sb2coeyBsZXZlbDogJ2luZm8nLCBtZXNzYWdlOiAnSGVsbG8gd29ybGQnLCBjdXN0b206IHRydWUgfSk7XG4gICAqICAgIGxvZ2dlci5sb2coeyBsZXZlbDogJ2luZm8nLCBtZXNzYWdlOiBuZXcgRXJyb3IoJ1lvLCBpdFxcJ3Mgb24gZmlyZScpIH0pO1xuICAgKlxuICAgKiAgICAvLyBBbHNvIHJlcXVpcmVzIHdpbnN0b24uZm9ybWF0LnNwbGF0KClcbiAgICogICAgbG9nZ2VyLmxvZyh7XG4gICAqICAgICAgbGV2ZWw6ICdpbmZvJyxcbiAgICogICAgICBtZXNzYWdlOiAnJXMgJWQlJScsXG4gICAqICAgICAgW1NQTEFUXTogWydBIHN0cmluZycsIDUwXSxcbiAgICogICAgICBtZXRhOiB7IHRoaXNJc01ldGE6IHRydWUgfVxuICAgKiAgICB9KTtcbiAgICpcbiAgICovXG4gIC8qIGVzbGludC1lbmFibGUgdmFsaWQtanNkb2MgKi9cbiAgbG9nKGxldmVsLCBtc2csIC4uLnNwbGF0KSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBtYXgtcGFyYW1zXG4gICAgLy8gT3B0aW1pemUgZm9yIHRoZSBob3RwYXRoIG9mIGxvZ2dpbmcgSlNPTiBsaXRlcmFsc1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAvLyBZbyBkYXdnLCBJIGhlYXJkIHlvdSBsaWtlIGxldmVscyAuLi4gc2VyaW91c2x5IC4uLlxuICAgICAgLy8gSW4gdGhpcyBjb250ZXh0IHRoZSBMSFMgYGxldmVsYCBoZXJlIGlzIGFjdHVhbGx5IHRoZSBgaW5mb2Agc28gcmVhZFxuICAgICAgLy8gdGhpcyBhczogaW5mb1tMRVZFTF0gPSBpbmZvLmxldmVsO1xuICAgICAgbGV2ZWxbTEVWRUxdID0gbGV2ZWwubGV2ZWw7XG4gICAgICB0aGlzLl9hZGREZWZhdWx0TWV0YShsZXZlbCk7XG4gICAgICB0aGlzLndyaXRlKGxldmVsKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIFNsaWdodGx5IGxlc3MgaG90cGF0aCwgYnV0IHdvcnRoIG9wdGltaXppbmcgZm9yLlxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAyKSB7XG4gICAgICBpZiAobXNnICYmIHR5cGVvZiBtc2cgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIG1zZ1tMRVZFTF0gPSBtc2cubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgdGhpcy5fYWRkRGVmYXVsdE1ldGEobXNnKTtcbiAgICAgICAgdGhpcy53cml0ZShtc2cpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgbXNnID0geyBbTEVWRUxdOiBsZXZlbCwgbGV2ZWwsIG1lc3NhZ2U6IG1zZyB9O1xuICAgICAgdGhpcy5fYWRkRGVmYXVsdE1ldGEobXNnKTtcbiAgICAgIHRoaXMud3JpdGUobXNnKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIGNvbnN0IFttZXRhXSA9IHNwbGF0O1xuICAgIGlmICh0eXBlb2YgbWV0YSA9PT0gJ29iamVjdCcgJiYgbWV0YSAhPT0gbnVsbCkge1xuICAgICAgLy8gRXh0cmFjdCB0b2tlbnMsIGlmIG5vbmUgYXZhaWxhYmxlIGRlZmF1bHQgdG8gZW1wdHkgYXJyYXkgdG9cbiAgICAgIC8vIGVuc3VyZSBjb25zaXN0YW5jeSBpbiBleHBlY3RlZCByZXN1bHRzXG4gICAgICBjb25zdCB0b2tlbnMgPSBtc2cgJiYgbXNnLm1hdGNoICYmIG1zZy5tYXRjaChmb3JtYXRSZWdFeHApO1xuXG4gICAgICBpZiAoIXRva2Vucykge1xuICAgICAgICBjb25zdCBpbmZvID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0TWV0YSwgbWV0YSwge1xuICAgICAgICAgIFtMRVZFTF06IGxldmVsLFxuICAgICAgICAgIFtTUExBVF06IHNwbGF0LFxuICAgICAgICAgIGxldmVsLFxuICAgICAgICAgIG1lc3NhZ2U6IG1zZ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAobWV0YS5tZXNzYWdlKSBpbmZvLm1lc3NhZ2UgPSBgJHtpbmZvLm1lc3NhZ2V9ICR7bWV0YS5tZXNzYWdlfWA7XG4gICAgICAgIGlmIChtZXRhLnN0YWNrKSBpbmZvLnN0YWNrID0gbWV0YS5zdGFjaztcbiAgICAgICAgaWYgKG1ldGEuY2F1c2UpIGluZm8uY2F1c2UgPSBtZXRhLmNhdXNlO1xuXG4gICAgICAgIHRoaXMud3JpdGUoaW5mbyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMud3JpdGUoT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5kZWZhdWx0TWV0YSwge1xuICAgICAgW0xFVkVMXTogbGV2ZWwsXG4gICAgICBbU1BMQVRdOiBzcGxhdCxcbiAgICAgIGxldmVsLFxuICAgICAgbWVzc2FnZTogbXNnXG4gICAgfSkpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUHVzaGVzIGRhdGEgc28gdGhhdCBpdCBjYW4gYmUgcGlja2VkIHVwIGJ5IGFsbCBvZiBvdXIgcGlwZSB0YXJnZXRzLlxuICAgKiBAcGFyYW0ge21peGVkfSBpbmZvIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge21peGVkfSBlbmMgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGNhbGxiYWNrIC0gQ29udGludWVzIHN0cmVhbSBwcm9jZXNzaW5nLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3RyYW5zZm9ybShpbmZvLCBlbmMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuc2lsZW50KSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICB9XG5cbiAgICAvLyBbTEVWRUxdIGlzIG9ubHkgc29mdCBndWFyYW50ZWVkIHRvIGJlIHNldCBoZXJlIHNpbmNlIHdlIGFyZSBhIHByb3BlclxuICAgIC8vIHN0cmVhbS4gSXQgaXMgbGlrZWx5IHRoYXQgYGluZm9gIGNhbWUgaW4gdGhyb3VnaCBgLmxvZyhpbmZvKWAgb3JcbiAgICAvLyBgLmluZm8oaW5mbylgLiBJZiBpdCBpcyBub3QgZGVmaW5lZCwgaG93ZXZlciwgZGVmaW5lIGl0LlxuICAgIC8vIFRoaXMgTEVWRUwgc3ltYm9sIGlzIHByb3ZpZGVkIGJ5IGB0cmlwbGUtYmVhbWAgYW5kIGFsc28gdXNlZCBpbjpcbiAgICAvLyAtIGxvZ2Zvcm1cbiAgICAvLyAtIHdpbnN0b24tdHJhbnNwb3J0XG4gICAgLy8gLSBhYnN0cmFjdC13aW5zdG9uLXRyYW5zcG9ydFxuICAgIGlmICghaW5mb1tMRVZFTF0pIHtcbiAgICAgIGluZm9bTEVWRUxdID0gaW5mby5sZXZlbDtcbiAgICB9XG5cbiAgICAvLyBSZW1hcms6IHJlYWxseSBub3Qgc3VyZSB3aGF0IHRvIGRvIGhlcmUsIGJ1dCB0aGlzIGhhcyBiZWVuIHJlcG9ydGVkIGFzXG4gICAgLy8gdmVyeSBjb25mdXNpbmcgYnkgcHJlIHdpbnN0b25AMi4wLjAgdXNlcnMgYXMgcXVpdGUgY29uZnVzaW5nIHdoZW4gdXNpbmdcbiAgICAvLyBjdXN0b20gbGV2ZWxzLlxuICAgIGlmICghdGhpcy5sZXZlbHNbaW5mb1tMRVZFTF1dICYmIHRoaXMubGV2ZWxzW2luZm9bTEVWRUxdXSAhPT0gMCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1t3aW5zdG9uXSBVbmtub3duIGxvZ2dlciBsZXZlbDogJXMnLCBpbmZvW0xFVkVMXSk7XG4gICAgfVxuXG4gICAgLy8gUmVtYXJrOiBub3Qgc3VyZSBpZiB3ZSBzaG91bGQgc2ltcGx5IGVycm9yIGhlcmUuXG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlLnBpcGVzKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS5lcnJvcihcbiAgICAgICAgJ1t3aW5zdG9uXSBBdHRlbXB0IHRvIHdyaXRlIGxvZ3Mgd2l0aCBubyB0cmFuc3BvcnRzLCB3aGljaCBjYW4gaW5jcmVhc2UgbWVtb3J5IHVzYWdlOiAlaicsXG4gICAgICAgIGluZm9cbiAgICAgICk7XG4gICAgfVxuXG4gICAgLy8gSGVyZSB3ZSB3cml0ZSB0byB0aGUgYGZvcm1hdGAgcGlwZS1jaGFpbiwgd2hpY2ggb24gYHJlYWRhYmxlYCBhYm92ZSB3aWxsXG4gICAgLy8gcHVzaCB0aGUgZm9ybWF0dGVkIGBpbmZvYCBPYmplY3Qgb250byB0aGUgYnVmZmVyIGZvciB0aGlzIGluc3RhbmNlLiBXZSB0cmFwXG4gICAgLy8gKGFuZCByZS10aHJvdykgYW55IGVycm9ycyBnZW5lcmF0ZWQgYnkgdGhlIHVzZXItcHJvdmlkZWQgZm9ybWF0LCBidXQgYWxzb1xuICAgIC8vIGd1YXJhbnRlZSB0aGF0IHRoZSBzdHJlYW1zIGNhbGxiYWNrIGlzIGludm9rZWQgc28gdGhhdCB3ZSBjYW4gY29udGludWUgZmxvd2luZy5cbiAgICB0cnkge1xuICAgICAgdGhpcy5wdXNoKHRoaXMuZm9ybWF0LnRyYW5zZm9ybShpbmZvLCB0aGlzLmZvcm1hdC5vcHRpb25zKSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNhbGxiYWNrLXJldHVyblxuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGVsYXlzIHRoZSAnZmluaXNoJyBldmVudCB1bnRpbCBhbGwgdHJhbnNwb3J0IHBpcGUgdGFyZ2V0cyBoYXZlXG4gICAqIGFsc28gZW1pdHRlZCAnZmluaXNoJyBvciBhcmUgYWxyZWFkeSBmaW5pc2hlZC5cbiAgICogQHBhcmFtIHttaXhlZH0gY2FsbGJhY2sgLSBDb250aW51ZXMgc3RyZWFtIHByb2Nlc3NpbmcuXG4gICAqL1xuICBfZmluYWwoY2FsbGJhY2spIHtcbiAgICBjb25zdCB0cmFuc3BvcnRzID0gdGhpcy50cmFuc3BvcnRzLnNsaWNlKCk7XG4gICAgYXN5bmNGb3JFYWNoKFxuICAgICAgdHJhbnNwb3J0cyxcbiAgICAgICh0cmFuc3BvcnQsIG5leHQpID0+IHtcbiAgICAgICAgaWYgKCF0cmFuc3BvcnQgfHwgdHJhbnNwb3J0LmZpbmlzaGVkKSByZXR1cm4gc2V0SW1tZWRpYXRlKG5leHQpO1xuICAgICAgICB0cmFuc3BvcnQub25jZSgnZmluaXNoJywgbmV4dCk7XG4gICAgICAgIHRyYW5zcG9ydC5lbmQoKTtcbiAgICAgIH0sXG4gICAgICBjYWxsYmFja1xuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyB0aGUgdHJhbnNwb3J0IHRvIHRoaXMgbG9nZ2VyIGluc3RhbmNlIGJ5IHBpcGluZyB0byBpdC5cbiAgICogQHBhcmFtIHttaXhlZH0gdHJhbnNwb3J0IC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7TG9nZ2VyfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBhZGQodHJhbnNwb3J0KSB7XG4gICAgLy8gU3VwcG9ydCBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIGFsbCBleGlzdGluZyBgd2luc3RvbiA8IDMueC54YFxuICAgIC8vIHRyYW5zcG9ydHMgd2hpY2ggbWVldCBvbmUgb2YgdHdvIGNyaXRlcmlhOlxuICAgIC8vIDEuIFRoZXkgaW5oZXJpdCBmcm9tIHdpbnN0b24uVHJhbnNwb3J0IGluICA8IDMueC54IHdoaWNoIGlzIE5PVCBhIHN0cmVhbS5cbiAgICAvLyAyLiBUaGV5IGV4cG9zZSBhIGxvZyBtZXRob2Qgd2hpY2ggaGFzIGEgbGVuZ3RoIGdyZWF0ZXIgdGhhbiAyIChpLmUuIG1vcmUgdGhlblxuICAgIC8vICAgIGp1c3QgYGxvZyhpbmZvLCBjYWxsYmFjaylgLlxuICAgIGNvbnN0IHRhcmdldCA9XG4gICAgICAhaXNTdHJlYW0odHJhbnNwb3J0KSB8fCB0cmFuc3BvcnQubG9nLmxlbmd0aCA+IDJcbiAgICAgICAgPyBuZXcgTGVnYWN5VHJhbnNwb3J0U3RyZWFtKHsgdHJhbnNwb3J0IH0pXG4gICAgICAgIDogdHJhbnNwb3J0O1xuXG4gICAgaWYgKCF0YXJnZXQuX3dyaXRhYmxlU3RhdGUgfHwgIXRhcmdldC5fd3JpdGFibGVTdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdUcmFuc3BvcnRzIG11c3QgV3JpdGFibGVTdHJlYW1zIGluIG9iamVjdE1vZGUuIFNldCB7IG9iamVjdE1vZGU6IHRydWUgfS4nXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIExpc3RlbiBmb3IgdGhlIGBlcnJvcmAgZXZlbnQgYW5kIHRoZSBgd2FybmAgZXZlbnQgb24gdGhlIG5ldyBUcmFuc3BvcnQuXG4gICAgdGhpcy5fb25FdmVudCgnZXJyb3InLCB0YXJnZXQpO1xuICAgIHRoaXMuX29uRXZlbnQoJ3dhcm4nLCB0YXJnZXQpO1xuICAgIHRoaXMucGlwZSh0YXJnZXQpO1xuXG4gICAgaWYgKHRyYW5zcG9ydC5oYW5kbGVFeGNlcHRpb25zKSB7XG4gICAgICB0aGlzLmV4Y2VwdGlvbnMuaGFuZGxlKCk7XG4gICAgfVxuXG4gICAgaWYgKHRyYW5zcG9ydC5oYW5kbGVSZWplY3Rpb25zKSB7XG4gICAgICB0aGlzLnJlamVjdGlvbnMuaGFuZGxlKCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgdHJhbnNwb3J0IGZyb20gdGhpcyBsb2dnZXIgaW5zdGFuY2UgYnkgdW5waXBpbmcgZnJvbSBpdC5cbiAgICogQHBhcmFtIHttaXhlZH0gdHJhbnNwb3J0IC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7TG9nZ2VyfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICByZW1vdmUodHJhbnNwb3J0KSB7XG4gICAgaWYgKCF0cmFuc3BvcnQpIHJldHVybiB0aGlzO1xuICAgIGxldCB0YXJnZXQgPSB0cmFuc3BvcnQ7XG4gICAgaWYgKCFpc1N0cmVhbSh0cmFuc3BvcnQpIHx8IHRyYW5zcG9ydC5sb2cubGVuZ3RoID4gMikge1xuICAgICAgdGFyZ2V0ID0gdGhpcy50cmFuc3BvcnRzLmZpbHRlcihcbiAgICAgICAgbWF0Y2ggPT4gbWF0Y2gudHJhbnNwb3J0ID09PSB0cmFuc3BvcnRcbiAgICAgIClbMF07XG4gICAgfVxuXG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy51bnBpcGUodGFyZ2V0KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhbGwgdHJhbnNwb3J0cyBmcm9tIHRoaXMgbG9nZ2VyIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyB7TG9nZ2VyfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBjbGVhcigpIHtcbiAgICB0aGlzLnVucGlwZSgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFucyB1cCByZXNvdXJjZXMgKHN0cmVhbXMsIGV2ZW50IGxpc3RlbmVycykgZm9yIGFsbCB0cmFuc3BvcnRzXG4gICAqIGFzc29jaWF0ZWQgd2l0aCB0aGlzIGluc3RhbmNlIChpZiBuZWNlc3NhcnkpLlxuICAgKiBAcmV0dXJucyB7TG9nZ2VyfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBjbG9zZSgpIHtcbiAgICB0aGlzLmV4Y2VwdGlvbnMudW5oYW5kbGUoKTtcbiAgICB0aGlzLnJlamVjdGlvbnMudW5oYW5kbGUoKTtcbiAgICB0aGlzLmNsZWFyKCk7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIGB0YXJnZXRgIGxldmVscyBzcGVjaWZpZWQgb24gdGhpcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IFRhcmdldCBsZXZlbHMgdG8gdXNlIG9uIHRoaXMgaW5zdGFuY2UuXG4gICAqL1xuICBzZXRMZXZlbHMoKSB7XG4gICAgd2Fybi5kZXByZWNhdGVkKCdzZXRMZXZlbHMnKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyaWVzIHRoZSBhbGwgdHJhbnNwb3J0cyBmb3IgdGhpcyBpbnN0YW5jZSB3aXRoIHRoZSBzcGVjaWZpZWQgYG9wdGlvbnNgLlxuICAgKiBUaGlzIHdpbGwgYWdncmVnYXRlIGVhY2ggdHJhbnNwb3J0J3MgcmVzdWx0cyBpbnRvIG9uZSBvYmplY3QgY29udGFpbmluZ1xuICAgKiBhIHByb3BlcnR5IHBlciB0cmFuc3BvcnQuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gUXVlcnkgb3B0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDb250aW51YXRpb24gdG8gcmVzcG9uZCB0byB3aGVuIGNvbXBsZXRlLlxuICAgKi9cbiAgcXVlcnkob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb25zdCByZXN1bHRzID0ge307XG4gICAgY29uc3QgcXVlcnlPYmplY3QgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLnF1ZXJ5IHx8IHt9KTtcblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBxdWVyeSBhIHNpbmdsZSB0cmFuc3BvcnRcbiAgICBmdW5jdGlvbiBxdWVyeVRyYW5zcG9ydCh0cmFuc3BvcnQsIG5leHQpIHtcbiAgICAgIGlmIChvcHRpb25zLnF1ZXJ5ICYmIHR5cGVvZiB0cmFuc3BvcnQuZm9ybWF0UXVlcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0aW9ucy5xdWVyeSA9IHRyYW5zcG9ydC5mb3JtYXRRdWVyeShxdWVyeU9iamVjdCk7XG4gICAgICB9XG5cbiAgICAgIHRyYW5zcG9ydC5xdWVyeShvcHRpb25zLCAoZXJyLCByZXMpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJldHVybiBuZXh0KGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zcG9ydC5mb3JtYXRSZXN1bHRzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgcmVzID0gdHJhbnNwb3J0LmZvcm1hdFJlc3VsdHMocmVzLCBvcHRpb25zLmZvcm1hdCk7XG4gICAgICAgIH1cblxuICAgICAgICBuZXh0KG51bGwsIHJlcyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gYWNjdW11bGF0ZSB0aGUgcmVzdWx0cyBmcm9tIGBxdWVyeVRyYW5zcG9ydGAgaW50b1xuICAgIC8vIHRoZSBgcmVzdWx0c2AuXG4gICAgZnVuY3Rpb24gYWRkUmVzdWx0cyh0cmFuc3BvcnQsIG5leHQpIHtcbiAgICAgIHF1ZXJ5VHJhbnNwb3J0KHRyYW5zcG9ydCwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIC8vIHF1ZXJ5VHJhbnNwb3J0IGNvdWxkIHBvdGVudGlhbGx5IGludm9rZSB0aGUgY2FsbGJhY2sgbXVsdGlwbGUgdGltZXNcbiAgICAgICAgLy8gc2luY2UgVHJhbnNwb3J0IGNvZGUgY2FuIGJlIHVucHJlZGljdGFibGUuXG4gICAgICAgIGlmIChuZXh0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gZXJyIHx8IHJlc3VsdDtcbiAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICByZXN1bHRzW3RyYW5zcG9ydC5uYW1lXSA9IHJlc3VsdDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgbmV4dCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIHRyYW5zcG9ydHMgaW4gcGFyYWxsZWwgc2V0dGluZyB0aGUgYXBwcm9wcmlhdGUga2V5IGluXG4gICAgLy8gdGhlIGByZXN1bHRzYC5cbiAgICBhc3luY0ZvckVhY2goXG4gICAgICB0aGlzLnRyYW5zcG9ydHMuZmlsdGVyKHRyYW5zcG9ydCA9PiAhIXRyYW5zcG9ydC5xdWVyeSksXG4gICAgICBhZGRSZXN1bHRzLFxuICAgICAgKCkgPT4gY2FsbGJhY2sobnVsbCwgcmVzdWx0cylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2cgc3RyZWFtIGZvciBhbGwgdHJhbnNwb3J0cy4gT3B0aW9ucyBvYmplY3QgaXMgb3B0aW9uYWwuXG4gICAqIEBwYXJhbXtPYmplY3R9IG9wdGlvbnM9e30gLSBTdHJlYW0gb3B0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge1N0cmVhbX0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgc3RyZWFtKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IG91dCA9IG5ldyBTdHJlYW0oKTtcbiAgICBjb25zdCBzdHJlYW1zID0gW107XG5cbiAgICBvdXQuX3N0cmVhbXMgPSBzdHJlYW1zO1xuICAgIG91dC5kZXN0cm95ID0gKCkgPT4ge1xuICAgICAgbGV0IGkgPSBzdHJlYW1zLmxlbmd0aDtcbiAgICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgc3RyZWFtc1tpXS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIENyZWF0ZSBhIGxpc3Qgb2YgYWxsIHRyYW5zcG9ydHMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAgdGhpcy50cmFuc3BvcnRzXG4gICAgICAuZmlsdGVyKHRyYW5zcG9ydCA9PiAhIXRyYW5zcG9ydC5zdHJlYW0pXG4gICAgICAuZm9yRWFjaCh0cmFuc3BvcnQgPT4ge1xuICAgICAgICBjb25zdCBzdHIgPSB0cmFuc3BvcnQuc3RyZWFtKG9wdGlvbnMpO1xuICAgICAgICBpZiAoIXN0cikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0cmVhbXMucHVzaChzdHIpO1xuXG4gICAgICAgIHN0ci5vbignbG9nJywgbG9nID0+IHtcbiAgICAgICAgICBsb2cudHJhbnNwb3J0ID0gbG9nLnRyYW5zcG9ydCB8fCBbXTtcbiAgICAgICAgICBsb2cudHJhbnNwb3J0LnB1c2godHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICAgIG91dC5lbWl0KCdsb2cnLCBsb2cpO1xuICAgICAgICB9KTtcblxuICAgICAgICBzdHIub24oJ2Vycm9yJywgZXJyID0+IHtcbiAgICAgICAgICBlcnIudHJhbnNwb3J0ID0gZXJyLnRyYW5zcG9ydCB8fCBbXTtcbiAgICAgICAgICBlcnIudHJhbnNwb3J0LnB1c2godHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICAgIG91dC5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICByZXR1cm4gb3V0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYW4gb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gYSBzcGVjaWZpYyB0aW1pbmcuIFdoZW4gZG9uZSBpcyBjYWxsZWRcbiAgICogdGhlIHRpbWVyIHdpbGwgZmluaXNoIGFuZCBsb2cgdGhlIGR1cmF0aW9uLiBlLmcuOlxuICAgKiBAcmV0dXJucyB7UHJvZmlsZX0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKiAgICBjb25zdCB0aW1lciA9IHdpbnN0b24uc3RhcnRUaW1lcigpXG4gICAqICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgKiAgICAgIHRpbWVyLmRvbmUoe1xuICAgKiAgICAgICAgbWVzc2FnZTogJ0xvZ2dpbmcgbWVzc2FnZSdcbiAgICogICAgICB9KTtcbiAgICogICAgfSwgMTAwMCk7XG4gICAqL1xuICBzdGFydFRpbWVyKCkge1xuICAgIHJldHVybiBuZXcgUHJvZmlsZXIodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogVHJhY2tzIHRoZSB0aW1lIGluYmV0d2VlbiBzdWJzZXF1ZW50IGNhbGxzIHRvIHRoaXMgbWV0aG9kIHdpdGggdGhlIHNhbWVcbiAgICogYGlkYCBwYXJhbWV0ZXIuIFRoZSBzZWNvbmQgY2FsbCB0byB0aGlzIG1ldGhvZCB3aWxsIGxvZyB0aGUgZGlmZmVyZW5jZSBpblxuICAgKiBtaWxsaXNlY29uZHMgYWxvbmcgd2l0aCB0aGUgbWVzc2FnZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGlkIFVuaXF1ZSBpZCBvZiB0aGUgcHJvZmlsZXJcbiAgICogQHJldHVybnMge0xvZ2dlcn0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgcHJvZmlsZShpZCwgLi4uYXJncykge1xuICAgIGNvbnN0IHRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGlmICh0aGlzLnByb2ZpbGVyc1tpZF0pIHtcbiAgICAgIGNvbnN0IHRpbWVFbmQgPSB0aGlzLnByb2ZpbGVyc1tpZF07XG4gICAgICBkZWxldGUgdGhpcy5wcm9maWxlcnNbaWRdO1xuXG4gICAgICAvLyBBdHRlbXB0IHRvIGJlIGtpbmQgdG8gdXNlcnMgaWYgdGhleSBhcmUgc3RpbGwgdXNpbmcgb2xkZXIgQVBJcy5cbiAgICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDJdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnQ2FsbGJhY2sgZnVuY3Rpb24gbm8gbG9uZ2VyIHN1cHBvcnRlZCBhcyBvZiB3aW5zdG9uQDMuMC4wJ1xuICAgICAgICApO1xuICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdGhlIGR1cmF0aW9uIHByb3BlcnR5IG9mIHRoZSBtZXRhZGF0YVxuICAgICAgY29uc3QgaW5mbyA9IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdvYmplY3QnID8gYXJncy5wb3AoKSA6IHt9O1xuICAgICAgaW5mby5sZXZlbCA9IGluZm8ubGV2ZWwgfHwgJ2luZm8nO1xuICAgICAgaW5mby5kdXJhdGlvbk1zID0gdGltZSAtIHRpbWVFbmQ7XG4gICAgICBpbmZvLm1lc3NhZ2UgPSBpbmZvLm1lc3NhZ2UgfHwgaWQ7XG4gICAgICByZXR1cm4gdGhpcy53cml0ZShpbmZvKTtcbiAgICB9XG5cbiAgICB0aGlzLnByb2ZpbGVyc1tpZF0gPSB0aW1lO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRvIGBleGNlcHRpb25zLmhhbmRsZWAgaW4gd2luc3RvbiA8IDMuMC4wLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgaGFuZGxlRXhjZXB0aW9ucyguLi5hcmdzKSB7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICBjb25zb2xlLndhcm4oXG4gICAgICAnRGVwcmVjYXRlZDogLmhhbmRsZUV4Y2VwdGlvbnMoKSB3aWxsIGJlIHJlbW92ZWQgaW4gd2luc3RvbkA0LiBVc2UgLmV4Y2VwdGlvbnMuaGFuZGxlKCknXG4gICAgKTtcbiAgICB0aGlzLmV4Y2VwdGlvbnMuaGFuZGxlKC4uLmFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHRvIGBleGNlcHRpb25zLmhhbmRsZWAgaW4gd2luc3RvbiA8IDMuMC4wLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAZGVwcmVjYXRlZFxuICAgKi9cbiAgdW5oYW5kbGVFeGNlcHRpb25zKC4uLmFyZ3MpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUud2FybihcbiAgICAgICdEZXByZWNhdGVkOiAudW5oYW5kbGVFeGNlcHRpb25zKCkgd2lsbCBiZSByZW1vdmVkIGluIHdpbnN0b25ANC4gVXNlIC5leGNlcHRpb25zLnVuaGFuZGxlKCknXG4gICAgKTtcbiAgICB0aGlzLmV4Y2VwdGlvbnMudW5oYW5kbGUoLi4uYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogVGhyb3cgYSBtb3JlIG1lYW5pbmdmdWwgZGVwcmVjYXRpb24gbm90aWNlXG4gICAqIEB0aHJvd3Mge0Vycm9yfSAtIFRPRE86IGFkZCB0aHJvd3MgZGVzY3JpcHRpb24uXG4gICAqL1xuICBjbGkoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgW1xuICAgICAgICAnTG9nZ2VyLmNsaSgpIHdhcyByZW1vdmVkIGluIHdpbnN0b25AMy4wLjAnLFxuICAgICAgICAnVXNlIGEgY3VzdG9tIHdpbnN0b24uZm9ybWF0cy5jbGkoKSBpbnN0ZWFkLicsXG4gICAgICAgICdTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS93aW5zdG9uanMvd2luc3Rvbi90cmVlL21hc3Rlci9VUEdSQURFLTMuMC5tZCdcbiAgICAgIF0uam9pbignXFxuJylcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIEJ1YmJsZXMgdGhlIGBldmVudGAgdGhhdCBvY2N1cmVkIG9uIHRoZSBzcGVjaWZpZWQgYHRyYW5zcG9ydGAgdXBcbiAgICogZnJvbSB0aGlzIGluc3RhbmNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZlbnQgLSBUaGUgZXZlbnQgdGhhdCBvY2N1cmVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSB0cmFuc3BvcnQgLSBUcmFuc3BvcnQgb24gd2hpY2ggdGhlIGV2ZW50IG9jY3VyZWRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9vbkV2ZW50KGV2ZW50LCB0cmFuc3BvcnQpIHtcbiAgICBmdW5jdGlvbiB0cmFuc3BvcnRFdmVudChlcnIpIHtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS93aW5zdG9uanMvd2luc3Rvbi9pc3N1ZXMvMTM2NFxuICAgICAgaWYgKGV2ZW50ID09PSAnZXJyb3InICYmICF0aGlzLnRyYW5zcG9ydHMuaW5jbHVkZXModHJhbnNwb3J0KSkge1xuICAgICAgICB0aGlzLmFkZCh0cmFuc3BvcnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5lbWl0KGV2ZW50LCBlcnIsIHRyYW5zcG9ydCk7XG4gICAgfVxuXG4gICAgaWYgKCF0cmFuc3BvcnRbJ19fd2luc3RvbicgKyBldmVudF0pIHtcbiAgICAgIHRyYW5zcG9ydFsnX193aW5zdG9uJyArIGV2ZW50XSA9IHRyYW5zcG9ydEV2ZW50LmJpbmQodGhpcyk7XG4gICAgICB0cmFuc3BvcnQub24oZXZlbnQsIHRyYW5zcG9ydFsnX193aW5zdG9uJyArIGV2ZW50XSk7XG4gICAgfVxuICB9XG5cbiAgX2FkZERlZmF1bHRNZXRhKG1zZykge1xuICAgIGlmICh0aGlzLmRlZmF1bHRNZXRhKSB7XG4gICAgICBPYmplY3QuYXNzaWduKG1zZywgdGhpcy5kZWZhdWx0TWV0YSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGdldExldmVsVmFsdWUobGV2ZWxzLCBsZXZlbCkge1xuICBjb25zdCB2YWx1ZSA9IGxldmVsc1tsZXZlbF07XG4gIGlmICghdmFsdWUgJiYgdmFsdWUgIT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogUmVwcmVzZW50cyB0aGUgY3VycmVudCByZWFkYWJsZVN0YXRlIHBpcGUgdGFyZ2V0cyBmb3IgdGhpcyBMb2dnZXIgaW5zdGFuY2UuXG4gKiBAdHlwZSB7QXJyYXl8T2JqZWN0fVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoTG9nZ2VyLnByb3RvdHlwZSwgJ3RyYW5zcG9ydHMnLCB7XG4gIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldCgpIHtcbiAgICBjb25zdCB7IHBpcGVzIH0gPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIHJldHVybiAhQXJyYXkuaXNBcnJheShwaXBlcykgPyBbcGlwZXNdLmZpbHRlcihCb29sZWFuKSA6IHBpcGVzO1xuICB9XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBMb2dnZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/profiler.js":
/*!******************************************************!*\
  !*** ./node_modules/winston/lib/winston/profiler.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * profiler.js: TODO: add file header description.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n/**\n * TODO: add class description.\n * @type {Profiler}\n * @private\n */\nclass Profiler {\n  /**\n   * Constructor function for the Profiler instance used by\n   * `Logger.prototype.startTimer`. When done is called the timer will finish\n   * and log the duration.\n   * @param {!Logger} logger - TODO: add param description.\n   * @private\n   */\n  constructor(logger) {\n    const Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/winston/lib/winston/logger.js\");\n    if (typeof logger !== 'object' || Array.isArray(logger) || !(logger instanceof Logger)) {\n      throw new Error('Logger is required for profiling');\n    } else {\n      this.logger = logger;\n      this.start = Date.now();\n    }\n  }\n\n  /**\n   * Ends the current timer (i.e. Profiler) instance and logs the `msg` along\n   * with the duration since creation.\n   * @returns {mixed} - TODO: add return description.\n   * @private\n   */\n  done(...args) {\n    if (typeof args[args.length - 1] === 'function') {\n      // eslint-disable-next-line no-console\n      console.warn('Callback function no longer supported as of winston@3.0.0');\n      args.pop();\n    }\n\n    const info = typeof args[args.length - 1] === 'object' ? args.pop() : {};\n    info.level = info.level || 'info';\n    info.durationMs = (Date.now()) - this.start;\n\n    return this.logger.write(info);\n  }\n};\n\nmodule.exports = Profiler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9wcm9maWxlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7QUFDYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLG9FQUFVO0FBQ3JDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL3Byb2ZpbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogcHJvZmlsZXIuanM6IFRPRE86IGFkZCBmaWxlIGhlYWRlciBkZXNjcmlwdGlvbi5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyoqXG4gKiBUT0RPOiBhZGQgY2xhc3MgZGVzY3JpcHRpb24uXG4gKiBAdHlwZSB7UHJvZmlsZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBQcm9maWxlciB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIFByb2ZpbGVyIGluc3RhbmNlIHVzZWQgYnlcbiAgICogYExvZ2dlci5wcm90b3R5cGUuc3RhcnRUaW1lcmAuIFdoZW4gZG9uZSBpcyBjYWxsZWQgdGhlIHRpbWVyIHdpbGwgZmluaXNoXG4gICAqIGFuZCBsb2cgdGhlIGR1cmF0aW9uLlxuICAgKiBAcGFyYW0geyFMb2dnZXJ9IGxvZ2dlciAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN0cnVjdG9yKGxvZ2dlcikge1xuICAgIGNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4vbG9nZ2VyJyk7XG4gICAgaWYgKHR5cGVvZiBsb2dnZXIgIT09ICdvYmplY3QnIHx8IEFycmF5LmlzQXJyYXkobG9nZ2VyKSB8fCAhKGxvZ2dlciBpbnN0YW5jZW9mIExvZ2dlcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTG9nZ2VyIGlzIHJlcXVpcmVkIGZvciBwcm9maWxpbmcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5sb2dnZXIgPSBsb2dnZXI7XG4gICAgICB0aGlzLnN0YXJ0ID0gRGF0ZS5ub3coKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRW5kcyB0aGUgY3VycmVudCB0aW1lciAoaS5lLiBQcm9maWxlcikgaW5zdGFuY2UgYW5kIGxvZ3MgdGhlIGBtc2dgIGFsb25nXG4gICAqIHdpdGggdGhlIGR1cmF0aW9uIHNpbmNlIGNyZWF0aW9uLlxuICAgKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvbmUoLi4uYXJncykge1xuICAgIGlmICh0eXBlb2YgYXJnc1thcmdzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKCdDYWxsYmFjayBmdW5jdGlvbiBubyBsb25nZXIgc3VwcG9ydGVkIGFzIG9mIHdpbnN0b25AMy4wLjAnKTtcbiAgICAgIGFyZ3MucG9wKCk7XG4gICAgfVxuXG4gICAgY29uc3QgaW5mbyA9IHR5cGVvZiBhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT09ICdvYmplY3QnID8gYXJncy5wb3AoKSA6IHt9O1xuICAgIGluZm8ubGV2ZWwgPSBpbmZvLmxldmVsIHx8ICdpbmZvJztcbiAgICBpbmZvLmR1cmF0aW9uTXMgPSAoRGF0ZS5ub3coKSkgLSB0aGlzLnN0YXJ0O1xuXG4gICAgcmV0dXJuIHRoaXMubG9nZ2VyLndyaXRlKGluZm8pO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFByb2ZpbGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/profiler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/rejection-handler.js":
/*!***************************************************************!*\
  !*** ./node_modules/winston/lib/winston/rejection-handler.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * exception-handler.js: Object for handling uncaughtException events.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst os = __webpack_require__(/*! os */ \"os\");\nconst asyncForEach = __webpack_require__(/*! async/forEach */ \"(rsc)/./node_modules/async/forEach.js\");\nconst debug = __webpack_require__(/*! @dabh/diagnostics */ \"(rsc)/./node_modules/@dabh/diagnostics/node/index.js\")('winston:rejection');\nconst once = __webpack_require__(/*! one-time */ \"(rsc)/./node_modules/one-time/index.js\");\nconst stackTrace = __webpack_require__(/*! stack-trace */ \"(rsc)/./node_modules/stack-trace/lib/stack-trace.js\");\nconst RejectionStream = __webpack_require__(/*! ./rejection-stream */ \"(rsc)/./node_modules/winston/lib/winston/rejection-stream.js\");\n\n/**\n * Object for handling unhandledRejection events.\n * @type {RejectionHandler}\n */\nmodule.exports = class RejectionHandler {\n  /**\n   * TODO: add contructor description\n   * @param {!Logger} logger - TODO: add param description\n   */\n  constructor(logger) {\n    if (!logger) {\n      throw new Error('Logger is required to handle rejections');\n    }\n\n    this.logger = logger;\n    this.handlers = new Map();\n  }\n\n  /**\n   * Handles `unhandledRejection` events for the current process by adding any\n   * handlers passed in.\n   * @returns {undefined}\n   */\n  handle(...args) {\n    args.forEach(arg => {\n      if (Array.isArray(arg)) {\n        return arg.forEach(handler => this._addHandler(handler));\n      }\n\n      this._addHandler(arg);\n    });\n\n    if (!this.catcher) {\n      this.catcher = this._unhandledRejection.bind(this);\n      process.on('unhandledRejection', this.catcher);\n    }\n  }\n\n  /**\n   * Removes any handlers to `unhandledRejection` events for the current\n   * process. This does not modify the state of the `this.handlers` set.\n   * @returns {undefined}\n   */\n  unhandle() {\n    if (this.catcher) {\n      process.removeListener('unhandledRejection', this.catcher);\n      this.catcher = false;\n\n      Array.from(this.handlers.values()).forEach(wrapper =>\n        this.logger.unpipe(wrapper)\n      );\n    }\n  }\n\n  /**\n   * TODO: add method description\n   * @param {Error} err - Error to get information about.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getAllInfo(err) {\n    let message = null;\n    if (err) {\n      message = typeof err === 'string' ? err : err.message;\n    }\n\n    return {\n      error: err,\n      // TODO (indexzero): how do we configure this?\n      level: 'error',\n      message: [\n        `unhandledRejection: ${message || '(no error message)'}`,\n        err && err.stack || '  No stack trace'\n      ].join('\\n'),\n      stack: err && err.stack,\n      rejection: true,\n      date: new Date().toString(),\n      process: this.getProcessInfo(),\n      os: this.getOsInfo(),\n      trace: this.getTrace(err)\n    };\n  }\n\n  /**\n   * Gets all relevant process information for the currently running process.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getProcessInfo() {\n    return {\n      pid: process.pid,\n      uid: process.getuid ? process.getuid() : null,\n      gid: process.getgid ? process.getgid() : null,\n      cwd: process.cwd(),\n      execPath: process.execPath,\n      version: process.version,\n      argv: process.argv,\n      memoryUsage: process.memoryUsage()\n    };\n  }\n\n  /**\n   * Gets all relevant OS information for the currently running process.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getOsInfo() {\n    return {\n      loadavg: os.loadavg(),\n      uptime: os.uptime()\n    };\n  }\n\n  /**\n   * Gets a stack trace for the specified error.\n   * @param {mixed} err - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  getTrace(err) {\n    const trace = err ? stackTrace.parse(err) : stackTrace.get();\n    return trace.map(site => {\n      return {\n        column: site.getColumnNumber(),\n        file: site.getFileName(),\n        function: site.getFunctionName(),\n        line: site.getLineNumber(),\n        method: site.getMethodName(),\n        native: site.isNative()\n      };\n    });\n  }\n\n  /**\n   * Helper method to add a transport as an exception handler.\n   * @param {Transport} handler - The transport to add as an exception handler.\n   * @returns {void}\n   */\n  _addHandler(handler) {\n    if (!this.handlers.has(handler)) {\n      handler.handleRejections = true;\n      const wrapper = new RejectionStream(handler);\n      this.handlers.set(handler, wrapper);\n      this.logger.pipe(wrapper);\n    }\n  }\n\n  /**\n   * Logs all relevant information around the `err` and exits the current\n   * process.\n   * @param {Error} err - Error to handle\n   * @returns {mixed} - TODO: add return description.\n   * @private\n   */\n  _unhandledRejection(err) {\n    const info = this.getAllInfo(err);\n    const handlers = this._getRejectionHandlers();\n    // Calculate if we should exit on this error\n    let doExit =\n      typeof this.logger.exitOnError === 'function'\n        ? this.logger.exitOnError(err)\n        : this.logger.exitOnError;\n    let timeout;\n\n    if (!handlers.length && doExit) {\n      // eslint-disable-next-line no-console\n      console.warn('winston: exitOnError cannot be true with no rejection handlers.');\n      // eslint-disable-next-line no-console\n      console.warn('winston: not exiting process.');\n      doExit = false;\n    }\n\n    function gracefulExit() {\n      debug('doExit', doExit);\n      debug('process._exiting', process._exiting);\n\n      if (doExit && !process._exiting) {\n        // Remark: Currently ignoring any rejections from transports when\n        // catching unhandled rejections.\n        if (timeout) {\n          clearTimeout(timeout);\n        }\n        // eslint-disable-next-line no-process-exit\n        process.exit(1);\n      }\n    }\n\n    if (!handlers || handlers.length === 0) {\n      return process.nextTick(gracefulExit);\n    }\n\n    // Log to all transports attempting to listen for when they are completed.\n    asyncForEach(\n      handlers,\n      (handler, next) => {\n        const done = once(next);\n        const transport = handler.transport || handler;\n\n        // Debug wrapping so that we can inspect what's going on under the covers.\n        function onDone(event) {\n          return () => {\n            debug(event);\n            done();\n          };\n        }\n\n        transport._ending = true;\n        transport.once('finish', onDone('finished'));\n        transport.once('error', onDone('error'));\n      },\n      () => doExit && gracefulExit()\n    );\n\n    this.logger.log(info);\n\n    // If exitOnError is true, then only allow the logging of exceptions to\n    // take up to `3000ms`.\n    if (doExit) {\n      timeout = setTimeout(gracefulExit, 3000);\n    }\n  }\n\n  /**\n   * Returns the list of transports and exceptionHandlers for this instance.\n   * @returns {Array} - List of transports and exceptionHandlers for this\n   * instance.\n   * @private\n   */\n  _getRejectionHandlers() {\n    // Remark (indexzero): since `logger.transports` returns all of the pipes\n    // from the _readableState of the stream we actually get the join of the\n    // explicit handlers and the implicit transports with\n    // `handleRejections: true`\n    return this.logger.transports.filter(wrap => {\n      const transport = wrap.transport || wrap;\n      return transport.handleRejections;\n    });\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9yZWplY3Rpb24taGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIscUJBQXFCLG1CQUFPLENBQUMsNERBQWU7QUFDNUMsY0FBYyxtQkFBTyxDQUFDLCtFQUFtQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsd0RBQVU7QUFDL0IsbUJBQW1CLG1CQUFPLENBQUMsd0VBQWE7QUFDeEMsd0JBQXdCLG1CQUFPLENBQUMsd0ZBQW9COztBQUVwRDtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixnQ0FBZ0M7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxXQUFXO0FBQ3hCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL3JlamVjdGlvbi1oYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogZXhjZXB0aW9uLWhhbmRsZXIuanM6IE9iamVjdCBmb3IgaGFuZGxpbmcgdW5jYXVnaHRFeGNlcHRpb24gZXZlbnRzLlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IGFzeW5jRm9yRWFjaCA9IHJlcXVpcmUoJ2FzeW5jL2ZvckVhY2gnKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZSgnQGRhYmgvZGlhZ25vc3RpY3MnKSgnd2luc3RvbjpyZWplY3Rpb24nKTtcbmNvbnN0IG9uY2UgPSByZXF1aXJlKCdvbmUtdGltZScpO1xuY29uc3Qgc3RhY2tUcmFjZSA9IHJlcXVpcmUoJ3N0YWNrLXRyYWNlJyk7XG5jb25zdCBSZWplY3Rpb25TdHJlYW0gPSByZXF1aXJlKCcuL3JlamVjdGlvbi1zdHJlYW0nKTtcblxuLyoqXG4gKiBPYmplY3QgZm9yIGhhbmRsaW5nIHVuaGFuZGxlZFJlamVjdGlvbiBldmVudHMuXG4gKiBAdHlwZSB7UmVqZWN0aW9uSGFuZGxlcn1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBSZWplY3Rpb25IYW5kbGVyIHtcbiAgLyoqXG4gICAqIFRPRE86IGFkZCBjb250cnVjdG9yIGRlc2NyaXB0aW9uXG4gICAqIEBwYXJhbSB7IUxvZ2dlcn0gbG9nZ2VyIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICBpZiAoIWxvZ2dlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2dnZXIgaXMgcmVxdWlyZWQgdG8gaGFuZGxlIHJlamVjdGlvbnMnKTtcbiAgICB9XG5cbiAgICB0aGlzLmxvZ2dlciA9IGxvZ2dlcjtcbiAgICB0aGlzLmhhbmRsZXJzID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEhhbmRsZXMgYHVuaGFuZGxlZFJlamVjdGlvbmAgZXZlbnRzIGZvciB0aGUgY3VycmVudCBwcm9jZXNzIGJ5IGFkZGluZyBhbnlcbiAgICogaGFuZGxlcnMgcGFzc2VkIGluLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgaGFuZGxlKC4uLmFyZ3MpIHtcbiAgICBhcmdzLmZvckVhY2goYXJnID0+IHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgcmV0dXJuIGFyZy5mb3JFYWNoKGhhbmRsZXIgPT4gdGhpcy5fYWRkSGFuZGxlcihoYW5kbGVyKSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2FkZEhhbmRsZXIoYXJnKTtcbiAgICB9KTtcblxuICAgIGlmICghdGhpcy5jYXRjaGVyKSB7XG4gICAgICB0aGlzLmNhdGNoZXIgPSB0aGlzLl91bmhhbmRsZWRSZWplY3Rpb24uYmluZCh0aGlzKTtcbiAgICAgIHByb2Nlc3Mub24oJ3VuaGFuZGxlZFJlamVjdGlvbicsIHRoaXMuY2F0Y2hlcik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYW55IGhhbmRsZXJzIHRvIGB1bmhhbmRsZWRSZWplY3Rpb25gIGV2ZW50cyBmb3IgdGhlIGN1cnJlbnRcbiAgICogcHJvY2Vzcy4gVGhpcyBkb2VzIG5vdCBtb2RpZnkgdGhlIHN0YXRlIG9mIHRoZSBgdGhpcy5oYW5kbGVyc2Agc2V0LlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgdW5oYW5kbGUoKSB7XG4gICAgaWYgKHRoaXMuY2F0Y2hlcikge1xuICAgICAgcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcigndW5oYW5kbGVkUmVqZWN0aW9uJywgdGhpcy5jYXRjaGVyKTtcbiAgICAgIHRoaXMuY2F0Y2hlciA9IGZhbHNlO1xuXG4gICAgICBBcnJheS5mcm9tKHRoaXMuaGFuZGxlcnMudmFsdWVzKCkpLmZvckVhY2god3JhcHBlciA9PlxuICAgICAgICB0aGlzLmxvZ2dlci51bnBpcGUod3JhcHBlcilcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86IGFkZCBtZXRob2QgZGVzY3JpcHRpb25cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gRXJyb3IgdG8gZ2V0IGluZm9ybWF0aW9uIGFib3V0LlxuICAgKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGdldEFsbEluZm8oZXJyKSB7XG4gICAgbGV0IG1lc3NhZ2UgPSBudWxsO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIG1lc3NhZ2UgPSB0eXBlb2YgZXJyID09PSAnc3RyaW5nJyA/IGVyciA6IGVyci5tZXNzYWdlO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBlcnJvcjogZXJyLFxuICAgICAgLy8gVE9ETyAoaW5kZXh6ZXJvKTogaG93IGRvIHdlIGNvbmZpZ3VyZSB0aGlzP1xuICAgICAgbGV2ZWw6ICdlcnJvcicsXG4gICAgICBtZXNzYWdlOiBbXG4gICAgICAgIGB1bmhhbmRsZWRSZWplY3Rpb246ICR7bWVzc2FnZSB8fCAnKG5vIGVycm9yIG1lc3NhZ2UpJ31gLFxuICAgICAgICBlcnIgJiYgZXJyLnN0YWNrIHx8ICcgIE5vIHN0YWNrIHRyYWNlJ1xuICAgICAgXS5qb2luKCdcXG4nKSxcbiAgICAgIHN0YWNrOiBlcnIgJiYgZXJyLnN0YWNrLFxuICAgICAgcmVqZWN0aW9uOiB0cnVlLFxuICAgICAgZGF0ZTogbmV3IERhdGUoKS50b1N0cmluZygpLFxuICAgICAgcHJvY2VzczogdGhpcy5nZXRQcm9jZXNzSW5mbygpLFxuICAgICAgb3M6IHRoaXMuZ2V0T3NJbmZvKCksXG4gICAgICB0cmFjZTogdGhpcy5nZXRUcmFjZShlcnIpXG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCByZWxldmFudCBwcm9jZXNzIGluZm9ybWF0aW9uIGZvciB0aGUgY3VycmVudGx5IHJ1bm5pbmcgcHJvY2Vzcy5cbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBnZXRQcm9jZXNzSW5mbygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcGlkOiBwcm9jZXNzLnBpZCxcbiAgICAgIHVpZDogcHJvY2Vzcy5nZXR1aWQgPyBwcm9jZXNzLmdldHVpZCgpIDogbnVsbCxcbiAgICAgIGdpZDogcHJvY2Vzcy5nZXRnaWQgPyBwcm9jZXNzLmdldGdpZCgpIDogbnVsbCxcbiAgICAgIGN3ZDogcHJvY2Vzcy5jd2QoKSxcbiAgICAgIGV4ZWNQYXRoOiBwcm9jZXNzLmV4ZWNQYXRoLFxuICAgICAgdmVyc2lvbjogcHJvY2Vzcy52ZXJzaW9uLFxuICAgICAgYXJndjogcHJvY2Vzcy5hcmd2LFxuICAgICAgbWVtb3J5VXNhZ2U6IHByb2Nlc3MubWVtb3J5VXNhZ2UoKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhbGwgcmVsZXZhbnQgT1MgaW5mb3JtYXRpb24gZm9yIHRoZSBjdXJyZW50bHkgcnVubmluZyBwcm9jZXNzLlxuICAgKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIGdldE9zSW5mbygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbG9hZGF2Zzogb3MubG9hZGF2ZygpLFxuICAgICAgdXB0aW1lOiBvcy51cHRpbWUoKVxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBhIHN0YWNrIHRyYWNlIGZvciB0aGUgc3BlY2lmaWVkIGVycm9yLlxuICAgKiBAcGFyYW0ge21peGVkfSBlcnIgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKi9cbiAgZ2V0VHJhY2UoZXJyKSB7XG4gICAgY29uc3QgdHJhY2UgPSBlcnIgPyBzdGFja1RyYWNlLnBhcnNlKGVycikgOiBzdGFja1RyYWNlLmdldCgpO1xuICAgIHJldHVybiB0cmFjZS5tYXAoc2l0ZSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBjb2x1bW46IHNpdGUuZ2V0Q29sdW1uTnVtYmVyKCksXG4gICAgICAgIGZpbGU6IHNpdGUuZ2V0RmlsZU5hbWUoKSxcbiAgICAgICAgZnVuY3Rpb246IHNpdGUuZ2V0RnVuY3Rpb25OYW1lKCksXG4gICAgICAgIGxpbmU6IHNpdGUuZ2V0TGluZU51bWJlcigpLFxuICAgICAgICBtZXRob2Q6IHNpdGUuZ2V0TWV0aG9kTmFtZSgpLFxuICAgICAgICBuYXRpdmU6IHNpdGUuaXNOYXRpdmUoKVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIZWxwZXIgbWV0aG9kIHRvIGFkZCBhIHRyYW5zcG9ydCBhcyBhbiBleGNlcHRpb24gaGFuZGxlci5cbiAgICogQHBhcmFtIHtUcmFuc3BvcnR9IGhhbmRsZXIgLSBUaGUgdHJhbnNwb3J0IHRvIGFkZCBhcyBhbiBleGNlcHRpb24gaGFuZGxlci5cbiAgICogQHJldHVybnMge3ZvaWR9XG4gICAqL1xuICBfYWRkSGFuZGxlcihoYW5kbGVyKSB7XG4gICAgaWYgKCF0aGlzLmhhbmRsZXJzLmhhcyhoYW5kbGVyKSkge1xuICAgICAgaGFuZGxlci5oYW5kbGVSZWplY3Rpb25zID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHdyYXBwZXIgPSBuZXcgUmVqZWN0aW9uU3RyZWFtKGhhbmRsZXIpO1xuICAgICAgdGhpcy5oYW5kbGVycy5zZXQoaGFuZGxlciwgd3JhcHBlcik7XG4gICAgICB0aGlzLmxvZ2dlci5waXBlKHdyYXBwZXIpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dzIGFsbCByZWxldmFudCBpbmZvcm1hdGlvbiBhcm91bmQgdGhlIGBlcnJgIGFuZCBleGl0cyB0aGUgY3VycmVudFxuICAgKiBwcm9jZXNzLlxuICAgKiBAcGFyYW0ge0Vycm9yfSBlcnIgLSBFcnJvciB0byBoYW5kbGVcbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfdW5oYW5kbGVkUmVqZWN0aW9uKGVycikge1xuICAgIGNvbnN0IGluZm8gPSB0aGlzLmdldEFsbEluZm8oZXJyKTtcbiAgICBjb25zdCBoYW5kbGVycyA9IHRoaXMuX2dldFJlamVjdGlvbkhhbmRsZXJzKCk7XG4gICAgLy8gQ2FsY3VsYXRlIGlmIHdlIHNob3VsZCBleGl0IG9uIHRoaXMgZXJyb3JcbiAgICBsZXQgZG9FeGl0ID1cbiAgICAgIHR5cGVvZiB0aGlzLmxvZ2dlci5leGl0T25FcnJvciA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IHRoaXMubG9nZ2VyLmV4aXRPbkVycm9yKGVycilcbiAgICAgICAgOiB0aGlzLmxvZ2dlci5leGl0T25FcnJvcjtcbiAgICBsZXQgdGltZW91dDtcblxuICAgIGlmICghaGFuZGxlcnMubGVuZ3RoICYmIGRvRXhpdCkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2Fybignd2luc3RvbjogZXhpdE9uRXJyb3IgY2Fubm90IGJlIHRydWUgd2l0aCBubyByZWplY3Rpb24gaGFuZGxlcnMuJyk7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxuICAgICAgY29uc29sZS53YXJuKCd3aW5zdG9uOiBub3QgZXhpdGluZyBwcm9jZXNzLicpO1xuICAgICAgZG9FeGl0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ3JhY2VmdWxFeGl0KCkge1xuICAgICAgZGVidWcoJ2RvRXhpdCcsIGRvRXhpdCk7XG4gICAgICBkZWJ1ZygncHJvY2Vzcy5fZXhpdGluZycsIHByb2Nlc3MuX2V4aXRpbmcpO1xuXG4gICAgICBpZiAoZG9FeGl0ICYmICFwcm9jZXNzLl9leGl0aW5nKSB7XG4gICAgICAgIC8vIFJlbWFyazogQ3VycmVudGx5IGlnbm9yaW5nIGFueSByZWplY3Rpb25zIGZyb20gdHJhbnNwb3J0cyB3aGVuXG4gICAgICAgIC8vIGNhdGNoaW5nIHVuaGFuZGxlZCByZWplY3Rpb25zLlxuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcHJvY2Vzcy1leGl0XG4gICAgICAgIHByb2Nlc3MuZXhpdCgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIWhhbmRsZXJzIHx8IGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZ3JhY2VmdWxFeGl0KTtcbiAgICB9XG5cbiAgICAvLyBMb2cgdG8gYWxsIHRyYW5zcG9ydHMgYXR0ZW1wdGluZyB0byBsaXN0ZW4gZm9yIHdoZW4gdGhleSBhcmUgY29tcGxldGVkLlxuICAgIGFzeW5jRm9yRWFjaChcbiAgICAgIGhhbmRsZXJzLFxuICAgICAgKGhhbmRsZXIsIG5leHQpID0+IHtcbiAgICAgICAgY29uc3QgZG9uZSA9IG9uY2UobmV4dCk7XG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IGhhbmRsZXIudHJhbnNwb3J0IHx8IGhhbmRsZXI7XG5cbiAgICAgICAgLy8gRGVidWcgd3JhcHBpbmcgc28gdGhhdCB3ZSBjYW4gaW5zcGVjdCB3aGF0J3MgZ29pbmcgb24gdW5kZXIgdGhlIGNvdmVycy5cbiAgICAgICAgZnVuY3Rpb24gb25Eb25lKGV2ZW50KSB7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKGV2ZW50KTtcbiAgICAgICAgICAgIGRvbmUoKTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgdHJhbnNwb3J0Ll9lbmRpbmcgPSB0cnVlO1xuICAgICAgICB0cmFuc3BvcnQub25jZSgnZmluaXNoJywgb25Eb25lKCdmaW5pc2hlZCcpKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uY2UoJ2Vycm9yJywgb25Eb25lKCdlcnJvcicpKTtcbiAgICAgIH0sXG4gICAgICAoKSA9PiBkb0V4aXQgJiYgZ3JhY2VmdWxFeGl0KClcbiAgICApO1xuXG4gICAgdGhpcy5sb2dnZXIubG9nKGluZm8pO1xuXG4gICAgLy8gSWYgZXhpdE9uRXJyb3IgaXMgdHJ1ZSwgdGhlbiBvbmx5IGFsbG93IHRoZSBsb2dnaW5nIG9mIGV4Y2VwdGlvbnMgdG9cbiAgICAvLyB0YWtlIHVwIHRvIGAzMDAwbXNgLlxuICAgIGlmIChkb0V4aXQpIHtcbiAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGdyYWNlZnVsRXhpdCwgMzAwMCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxpc3Qgb2YgdHJhbnNwb3J0cyBhbmQgZXhjZXB0aW9uSGFuZGxlcnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gLSBMaXN0IG9mIHRyYW5zcG9ydHMgYW5kIGV4Y2VwdGlvbkhhbmRsZXJzIGZvciB0aGlzXG4gICAqIGluc3RhbmNlLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldFJlamVjdGlvbkhhbmRsZXJzKCkge1xuICAgIC8vIFJlbWFyayAoaW5kZXh6ZXJvKTogc2luY2UgYGxvZ2dlci50cmFuc3BvcnRzYCByZXR1cm5zIGFsbCBvZiB0aGUgcGlwZXNcbiAgICAvLyBmcm9tIHRoZSBfcmVhZGFibGVTdGF0ZSBvZiB0aGUgc3RyZWFtIHdlIGFjdHVhbGx5IGdldCB0aGUgam9pbiBvZiB0aGVcbiAgICAvLyBleHBsaWNpdCBoYW5kbGVycyBhbmQgdGhlIGltcGxpY2l0IHRyYW5zcG9ydHMgd2l0aFxuICAgIC8vIGBoYW5kbGVSZWplY3Rpb25zOiB0cnVlYFxuICAgIHJldHVybiB0aGlzLmxvZ2dlci50cmFuc3BvcnRzLmZpbHRlcih3cmFwID0+IHtcbiAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHdyYXAudHJhbnNwb3J0IHx8IHdyYXA7XG4gICAgICByZXR1cm4gdHJhbnNwb3J0LmhhbmRsZVJlamVjdGlvbnM7XG4gICAgfSk7XG4gIH1cbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/rejection-handler.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/rejection-stream.js":
/*!**************************************************************!*\
  !*** ./node_modules/winston/lib/winston/rejection-stream.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * rejection-stream.js: TODO: add file header handler.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst { Writable } = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\");\n\n/**\n * TODO: add class description.\n * @type {RejectionStream}\n * @extends {Writable}\n */\nmodule.exports = class RejectionStream extends Writable {\n  /**\n   * Constructor function for the RejectionStream responsible for wrapping a\n   * TransportStream; only allowing writes of `info` objects with\n   * `info.rejection` set to true.\n   * @param {!TransportStream} transport - Stream to filter to rejections\n   */\n  constructor(transport) {\n    super({ objectMode: true });\n\n    if (!transport) {\n      throw new Error('RejectionStream requires a TransportStream instance.');\n    }\n\n    this.handleRejections = true;\n    this.transport = transport;\n  }\n\n  /**\n   * Writes the info object to our transport instance if (and only if) the\n   * `rejection` property is set on the info.\n   * @param {mixed} info - TODO: add param description.\n   * @param {mixed} enc - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   * @private\n   */\n  _write(info, enc, callback) {\n    if (info.rejection) {\n      return this.transport.log(info, callback);\n    }\n\n    callback();\n    return true;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi9yZWplY3Rpb24tc3RyZWFtLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixRQUFRLFdBQVcsRUFBRSxtQkFBTyxDQUFDLHlFQUFpQjs7QUFFOUM7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZSxPQUFPO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL3JlamVjdGlvbi1zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiByZWplY3Rpb24tc3RyZWFtLmpzOiBUT0RPOiBhZGQgZmlsZSBoZWFkZXIgaGFuZGxlci5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKTtcblxuLyoqXG4gKiBUT0RPOiBhZGQgY2xhc3MgZGVzY3JpcHRpb24uXG4gKiBAdHlwZSB7UmVqZWN0aW9uU3RyZWFtfVxuICogQGV4dGVuZHMge1dyaXRhYmxlfVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIFJlamVjdGlvblN0cmVhbSBleHRlbmRzIFdyaXRhYmxlIHtcbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIGZ1bmN0aW9uIGZvciB0aGUgUmVqZWN0aW9uU3RyZWFtIHJlc3BvbnNpYmxlIGZvciB3cmFwcGluZyBhXG4gICAqIFRyYW5zcG9ydFN0cmVhbTsgb25seSBhbGxvd2luZyB3cml0ZXMgb2YgYGluZm9gIG9iamVjdHMgd2l0aFxuICAgKiBgaW5mby5yZWplY3Rpb25gIHNldCB0byB0cnVlLlxuICAgKiBAcGFyYW0geyFUcmFuc3BvcnRTdHJlYW19IHRyYW5zcG9ydCAtIFN0cmVhbSB0byBmaWx0ZXIgdG8gcmVqZWN0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IodHJhbnNwb3J0KSB7XG4gICAgc3VwZXIoeyBvYmplY3RNb2RlOiB0cnVlIH0pO1xuXG4gICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVqZWN0aW9uU3RyZWFtIHJlcXVpcmVzIGEgVHJhbnNwb3J0U3RyZWFtIGluc3RhbmNlLicpO1xuICAgIH1cblxuICAgIHRoaXMuaGFuZGxlUmVqZWN0aW9ucyA9IHRydWU7XG4gICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gIH1cblxuICAvKipcbiAgICogV3JpdGVzIHRoZSBpbmZvIG9iamVjdCB0byBvdXIgdHJhbnNwb3J0IGluc3RhbmNlIGlmIChhbmQgb25seSBpZikgdGhlXG4gICAqIGByZWplY3Rpb25gIHByb3BlcnR5IGlzIHNldCBvbiB0aGUgaW5mby5cbiAgICogQHBhcmFtIHttaXhlZH0gaW5mbyAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHttaXhlZH0gZW5jIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge21peGVkfSBjYWxsYmFjayAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfd3JpdGUoaW5mbywgZW5jLCBjYWxsYmFjaykge1xuICAgIGlmIChpbmZvLnJlamVjdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0LmxvZyhpbmZvLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgY2FsbGJhY2soKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/rejection-stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/tail-file.js":
/*!*******************************************************!*\
  !*** ./node_modules/winston/lib/winston/tail-file.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * tail-file.js: TODO: add file header description.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { StringDecoder } = __webpack_require__(/*! string_decoder */ \"string_decoder\");\nconst { Stream } = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\");\n\n/**\n * Simple no-op function.\n * @returns {undefined}\n */\nfunction noop() {}\n\n/**\n * TODO: add function description.\n * @param {Object} options - Options for tail.\n * @param {function} iter - Iterator function to execute on every line.\n* `tail -f` a file. Options must include file.\n * @returns {mixed} - TODO: add return description.\n */\nmodule.exports = (options, iter) => {\n  const buffer = Buffer.alloc(64 * 1024);\n  const decode = new StringDecoder('utf8');\n  const stream = new Stream();\n  let buff = '';\n  let pos = 0;\n  let row = 0;\n\n  if (options.start === -1) {\n    delete options.start;\n  }\n\n  stream.readable = true;\n  stream.destroy = () => {\n    stream.destroyed = true;\n    stream.emit('end');\n    stream.emit('close');\n  };\n\n  fs.open(options.file, 'a+', '0644', (err, fd) => {\n    if (err) {\n      if (!iter) {\n        stream.emit('error', err);\n      } else {\n        iter(err);\n      }\n      stream.destroy();\n      return;\n    }\n\n    (function read() {\n      if (stream.destroyed) {\n        fs.close(fd, noop);\n        return;\n      }\n\n      return fs.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {\n        if (error) {\n          if (!iter) {\n            stream.emit('error', error);\n          } else {\n            iter(error);\n          }\n          stream.destroy();\n          return;\n        }\n\n        if (!bytes) {\n          if (buff) {\n            // eslint-disable-next-line eqeqeq\n            if (options.start == null || row > options.start) {\n              if (!iter) {\n                stream.emit('line', buff);\n              } else {\n                iter(null, buff);\n              }\n            }\n            row++;\n            buff = '';\n          }\n          return setTimeout(read, 1000);\n        }\n\n        let data = decode.write(buffer.slice(0, bytes));\n        if (!iter) {\n          stream.emit('data', data);\n        }\n\n        data = (buff + data).split(/\\n+/);\n\n        const l = data.length - 1;\n        let i = 0;\n\n        for (; i < l; i++) {\n          // eslint-disable-next-line eqeqeq\n          if (options.start == null || row > options.start) {\n            if (!iter) {\n              stream.emit('line', data[i]);\n            } else {\n              iter(null, data[i]);\n            }\n          }\n          row++;\n        }\n\n        buff = data[l];\n        pos += bytes;\n        return read();\n      });\n    }());\n  });\n\n  if (!iter) {\n    return stream;\n  }\n\n  return stream.destroy;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90YWlsLWZpbGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyxzQ0FBZ0I7QUFDbEQsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyx5RUFBaUI7O0FBRTVDO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsVUFBVTtBQUNyQjtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90YWlsLWZpbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB0YWlsLWZpbGUuanM6IFRPRE86IGFkZCBmaWxlIGhlYWRlciBkZXNjcmlwdGlvbi5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IFN0cmluZ0RlY29kZXIgfSA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJyk7XG5jb25zdCB7IFN0cmVhbSB9ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyk7XG5cbi8qKlxuICogU2ltcGxlIG5vLW9wIGZ1bmN0aW9uLlxuICogQHJldHVybnMge3VuZGVmaW5lZH1cbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8qKlxuICogVE9ETzogYWRkIGZ1bmN0aW9uIGRlc2NyaXB0aW9uLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0YWlsLlxuICogQHBhcmFtIHtmdW5jdGlvbn0gaXRlciAtIEl0ZXJhdG9yIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgb24gZXZlcnkgbGluZS5cbiogYHRhaWwgLWZgIGEgZmlsZS4gT3B0aW9ucyBtdXN0IGluY2x1ZGUgZmlsZS5cbiAqIEByZXR1cm5zIHttaXhlZH0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IChvcHRpb25zLCBpdGVyKSA9PiB7XG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyg2NCAqIDEwMjQpO1xuICBjb25zdCBkZWNvZGUgPSBuZXcgU3RyaW5nRGVjb2RlcigndXRmOCcpO1xuICBjb25zdCBzdHJlYW0gPSBuZXcgU3RyZWFtKCk7XG4gIGxldCBidWZmID0gJyc7XG4gIGxldCBwb3MgPSAwO1xuICBsZXQgcm93ID0gMDtcblxuICBpZiAob3B0aW9ucy5zdGFydCA9PT0gLTEpIHtcbiAgICBkZWxldGUgb3B0aW9ucy5zdGFydDtcbiAgfVxuXG4gIHN0cmVhbS5yZWFkYWJsZSA9IHRydWU7XG4gIHN0cmVhbS5kZXN0cm95ID0gKCkgPT4ge1xuICAgIHN0cmVhbS5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICBzdHJlYW0uZW1pdCgnY2xvc2UnKTtcbiAgfTtcblxuICBmcy5vcGVuKG9wdGlvbnMuZmlsZSwgJ2ErJywgJzA2NDQnLCAoZXJyLCBmZCkgPT4ge1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmICghaXRlcikge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcihlcnIpO1xuICAgICAgfVxuICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAoZnVuY3Rpb24gcmVhZCgpIHtcbiAgICAgIGlmIChzdHJlYW0uZGVzdHJveWVkKSB7XG4gICAgICAgIGZzLmNsb3NlKGZkLCBub29wKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gZnMucmVhZChmZCwgYnVmZmVyLCAwLCBidWZmZXIubGVuZ3RoLCBwb3MsIChlcnJvciwgYnl0ZXMpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgaWYgKCFpdGVyKSB7XG4gICAgICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGl0ZXIoZXJyb3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghYnl0ZXMpIHtcbiAgICAgICAgICBpZiAoYnVmZikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuc3RhcnQgPT0gbnVsbCB8fCByb3cgPiBvcHRpb25zLnN0YXJ0KSB7XG4gICAgICAgICAgICAgIGlmICghaXRlcikge1xuICAgICAgICAgICAgICAgIHN0cmVhbS5lbWl0KCdsaW5lJywgYnVmZik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaXRlcihudWxsLCBidWZmKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcm93Kys7XG4gICAgICAgICAgICBidWZmID0gJyc7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KHJlYWQsIDEwMDApO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRhdGEgPSBkZWNvZGUud3JpdGUoYnVmZmVyLnNsaWNlKDAsIGJ5dGVzKSk7XG4gICAgICAgIGlmICghaXRlcikge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgZGF0YSk7XG4gICAgICAgIH1cblxuICAgICAgICBkYXRhID0gKGJ1ZmYgKyBkYXRhKS5zcGxpdCgvXFxuKy8pO1xuXG4gICAgICAgIGNvbnN0IGwgPSBkYXRhLmxlbmd0aCAtIDE7XG4gICAgICAgIGxldCBpID0gMDtcblxuICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcbiAgICAgICAgICBpZiAob3B0aW9ucy5zdGFydCA9PSBudWxsIHx8IHJvdyA+IG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgICAgIGlmICghaXRlcikge1xuICAgICAgICAgICAgICBzdHJlYW0uZW1pdCgnbGluZScsIGRhdGFbaV0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaXRlcihudWxsLCBkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcm93Kys7XG4gICAgICAgIH1cblxuICAgICAgICBidWZmID0gZGF0YVtsXTtcbiAgICAgICAgcG9zICs9IGJ5dGVzO1xuICAgICAgICByZXR1cm4gcmVhZCgpO1xuICAgICAgfSk7XG4gICAgfSgpKTtcbiAgfSk7XG5cbiAgaWYgKCFpdGVyKSB7XG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIHJldHVybiBzdHJlYW0uZGVzdHJveTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/tail-file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/transports/console.js":
/*!****************************************************************!*\
  !*** ./node_modules/winston/lib/winston/transports/console.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable no-console */\n/*\n * console.js: Transport for outputting to the console.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst os = __webpack_require__(/*! os */ \"os\");\nconst { LEVEL, MESSAGE } = __webpack_require__(/*! triple-beam */ \"(rsc)/./node_modules/triple-beam/index.js\");\nconst TransportStream = __webpack_require__(/*! winston-transport */ \"(rsc)/./node_modules/winston-transport/index.js\");\n\n/**\n * Transport for outputting to the console.\n * @type {Console}\n * @extends {TransportStream}\n */\nmodule.exports = class Console extends TransportStream {\n  /**\n   * Constructor function for the Console transport object responsible for\n   * persisting log messages and metadata to a terminal or TTY.\n   * @param {!Object} [options={}] - Options for this instance.\n   */\n  constructor(options = {}) {\n    super(options);\n\n    // Expose the name of this Transport on the prototype\n    this.name = options.name || 'console';\n    this.stderrLevels = this._stringArrayToSet(options.stderrLevels);\n    this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);\n    this.eol = typeof options.eol === 'string' ? options.eol : os.EOL;\n    this.forceConsole = options.forceConsole || false;\n\n    // Keep a reference to the log, warn, and error console methods\n    // in case they get redirected to this transport after the logger is\n    // instantiated. This prevents a circular reference issue.\n    this._consoleLog = console.log.bind(console);\n    this._consoleWarn = console.warn.bind(console);\n    this._consoleError = console.error.bind(console);\n\n    this.setMaxListeners(30);\n  }\n\n  /**\n   * Core logging method exposed to Winston.\n   * @param {Object} info - TODO: add param description.\n   * @param {Function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  log(info, callback) {\n    setImmediate(() => this.emit('logged', info));\n\n    // Remark: what if there is no raw...?\n    if (this.stderrLevels[info[LEVEL]]) {\n      if (console._stderr && !this.forceConsole) {\n        // Node.js maps `process.stderr` to `console._stderr`.\n        console._stderr.write(`${info[MESSAGE]}${this.eol}`);\n      } else {\n        // console.error adds a newline\n        this._consoleError(info[MESSAGE]);\n      }\n\n      if (callback) {\n        callback(); // eslint-disable-line callback-return\n      }\n      return;\n    } else if (this.consoleWarnLevels[info[LEVEL]]) {\n      if (console._stderr && !this.forceConsole) {\n        // Node.js maps `process.stderr` to `console._stderr`.\n        // in Node.js console.warn is an alias for console.error\n        console._stderr.write(`${info[MESSAGE]}${this.eol}`);\n      } else {\n        // console.warn adds a newline\n        this._consoleWarn(info[MESSAGE]);\n      }\n\n      if (callback) {\n        callback(); // eslint-disable-line callback-return\n      }\n      return;\n    }\n\n    if (console._stdout && !this.forceConsole) {\n      // Node.js maps `process.stdout` to `console._stdout`.\n      console._stdout.write(`${info[MESSAGE]}${this.eol}`);\n    } else {\n      // console.log adds a newline.\n      this._consoleLog(info[MESSAGE]);\n    }\n\n    if (callback) {\n      callback(); // eslint-disable-line callback-return\n    }\n  }\n\n  /**\n   * Returns a Set-like object with strArray's elements as keys (each with the\n   * value true).\n   * @param {Array} strArray - Array of Set-elements as strings.\n   * @param {?string} [errMsg] - Custom error message thrown on invalid input.\n   * @returns {Object} - TODO: add return description.\n   * @private\n   */\n  _stringArrayToSet(strArray, errMsg) {\n    if (!strArray) return {};\n\n    errMsg =\n      errMsg || 'Cannot make set from type other than Array of string elements';\n\n    if (!Array.isArray(strArray)) {\n      throw new Error(errMsg);\n    }\n\n    return strArray.reduce((set, el) => {\n      if (typeof el !== 'string') {\n        throw new Error(errMsg);\n      }\n      set[el] = true;\n\n      return set;\n    }, {});\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90cmFuc3BvcnRzL2NvbnNvbGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSxpQkFBaUIsRUFBRSxtQkFBTyxDQUFDLDhEQUFhO0FBQ2hELHdCQUF3QixtQkFBTyxDQUFDLDBFQUFtQjs7QUFFbkQ7QUFDQTtBQUNBLFVBQVU7QUFDVixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUyxXQUFXO0FBQ2pDO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QixlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGNBQWMsRUFBRSxTQUFTO0FBQzFELFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsY0FBYyxFQUFFLFNBQVM7QUFDMUQsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQixjQUFjLEVBQUUsU0FBUztBQUN4RCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsU0FBUztBQUN0QixlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90cmFuc3BvcnRzL2NvbnNvbGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuLypcbiAqIGNvbnNvbGUuanM6IFRyYW5zcG9ydCBmb3Igb3V0cHV0dGluZyB0byB0aGUgY29uc29sZS5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCB7IExFVkVMLCBNRVNTQUdFIH0gPSByZXF1aXJlKCd0cmlwbGUtYmVhbScpO1xuY29uc3QgVHJhbnNwb3J0U3RyZWFtID0gcmVxdWlyZSgnd2luc3Rvbi10cmFuc3BvcnQnKTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgZm9yIG91dHB1dHRpbmcgdG8gdGhlIGNvbnNvbGUuXG4gKiBAdHlwZSB7Q29uc29sZX1cbiAqIEBleHRlbmRzIHtUcmFuc3BvcnRTdHJlYW19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgQ29uc29sZSBleHRlbmRzIFRyYW5zcG9ydFN0cmVhbSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIENvbnNvbGUgdHJhbnNwb3J0IG9iamVjdCByZXNwb25zaWJsZSBmb3JcbiAgICogcGVyc2lzdGluZyBsb2cgbWVzc2FnZXMgYW5kIG1ldGFkYXRhIHRvIGEgdGVybWluYWwgb3IgVFRZLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IFtvcHRpb25zPXt9XSAtIE9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIC8vIEV4cG9zZSB0aGUgbmFtZSBvZiB0aGlzIFRyYW5zcG9ydCBvbiB0aGUgcHJvdG90eXBlXG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lIHx8ICdjb25zb2xlJztcbiAgICB0aGlzLnN0ZGVyckxldmVscyA9IHRoaXMuX3N0cmluZ0FycmF5VG9TZXQob3B0aW9ucy5zdGRlcnJMZXZlbHMpO1xuICAgIHRoaXMuY29uc29sZVdhcm5MZXZlbHMgPSB0aGlzLl9zdHJpbmdBcnJheVRvU2V0KG9wdGlvbnMuY29uc29sZVdhcm5MZXZlbHMpO1xuICAgIHRoaXMuZW9sID0gdHlwZW9mIG9wdGlvbnMuZW9sID09PSAnc3RyaW5nJyA/IG9wdGlvbnMuZW9sIDogb3MuRU9MO1xuICAgIHRoaXMuZm9yY2VDb25zb2xlID0gb3B0aW9ucy5mb3JjZUNvbnNvbGUgfHwgZmFsc2U7XG5cbiAgICAvLyBLZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBsb2csIHdhcm4sIGFuZCBlcnJvciBjb25zb2xlIG1ldGhvZHNcbiAgICAvLyBpbiBjYXNlIHRoZXkgZ2V0IHJlZGlyZWN0ZWQgdG8gdGhpcyB0cmFuc3BvcnQgYWZ0ZXIgdGhlIGxvZ2dlciBpc1xuICAgIC8vIGluc3RhbnRpYXRlZC4gVGhpcyBwcmV2ZW50cyBhIGNpcmN1bGFyIHJlZmVyZW5jZSBpc3N1ZS5cbiAgICB0aGlzLl9jb25zb2xlTG9nID0gY29uc29sZS5sb2cuYmluZChjb25zb2xlKTtcbiAgICB0aGlzLl9jb25zb2xlV2FybiA9IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuICAgIHRoaXMuX2NvbnNvbGVFcnJvciA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcblxuICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKDMwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb3JlIGxvZ2dpbmcgbWV0aG9kIGV4cG9zZWQgdG8gV2luc3Rvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGluZm8gLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgbG9nKGluZm8sIGNhbGxiYWNrKSB7XG4gICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuZW1pdCgnbG9nZ2VkJywgaW5mbykpO1xuXG4gICAgLy8gUmVtYXJrOiB3aGF0IGlmIHRoZXJlIGlzIG5vIHJhdy4uLj9cbiAgICBpZiAodGhpcy5zdGRlcnJMZXZlbHNbaW5mb1tMRVZFTF1dKSB7XG4gICAgICBpZiAoY29uc29sZS5fc3RkZXJyICYmICF0aGlzLmZvcmNlQ29uc29sZSkge1xuICAgICAgICAvLyBOb2RlLmpzIG1hcHMgYHByb2Nlc3Muc3RkZXJyYCB0byBgY29uc29sZS5fc3RkZXJyYC5cbiAgICAgICAgY29uc29sZS5fc3RkZXJyLndyaXRlKGAke2luZm9bTUVTU0FHRV19JHt0aGlzLmVvbH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUuZXJyb3IgYWRkcyBhIG5ld2xpbmVcbiAgICAgICAgdGhpcy5fY29uc29sZUVycm9yKGluZm9bTUVTU0FHRV0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY29uc29sZVdhcm5MZXZlbHNbaW5mb1tMRVZFTF1dKSB7XG4gICAgICBpZiAoY29uc29sZS5fc3RkZXJyICYmICF0aGlzLmZvcmNlQ29uc29sZSkge1xuICAgICAgICAvLyBOb2RlLmpzIG1hcHMgYHByb2Nlc3Muc3RkZXJyYCB0byBgY29uc29sZS5fc3RkZXJyYC5cbiAgICAgICAgLy8gaW4gTm9kZS5qcyBjb25zb2xlLndhcm4gaXMgYW4gYWxpYXMgZm9yIGNvbnNvbGUuZXJyb3JcbiAgICAgICAgY29uc29sZS5fc3RkZXJyLndyaXRlKGAke2luZm9bTUVTU0FHRV19JHt0aGlzLmVvbH1gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGNvbnNvbGUud2FybiBhZGRzIGEgbmV3bGluZVxuICAgICAgICB0aGlzLl9jb25zb2xlV2FybihpbmZvW01FU1NBR0VdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNvbnNvbGUuX3N0ZG91dCAmJiAhdGhpcy5mb3JjZUNvbnNvbGUpIHtcbiAgICAgIC8vIE5vZGUuanMgbWFwcyBgcHJvY2Vzcy5zdGRvdXRgIHRvIGBjb25zb2xlLl9zdGRvdXRgLlxuICAgICAgY29uc29sZS5fc3Rkb3V0LndyaXRlKGAke2luZm9bTUVTU0FHRV19JHt0aGlzLmVvbH1gKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gY29uc29sZS5sb2cgYWRkcyBhIG5ld2xpbmUuXG4gICAgICB0aGlzLl9jb25zb2xlTG9nKGluZm9bTUVTU0FHRV0pO1xuICAgIH1cblxuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIFNldC1saWtlIG9iamVjdCB3aXRoIHN0ckFycmF5J3MgZWxlbWVudHMgYXMga2V5cyAoZWFjaCB3aXRoIHRoZVxuICAgKiB2YWx1ZSB0cnVlKS5cbiAgICogQHBhcmFtIHtBcnJheX0gc3RyQXJyYXkgLSBBcnJheSBvZiBTZXQtZWxlbWVudHMgYXMgc3RyaW5ncy5cbiAgICogQHBhcmFtIHs/c3RyaW5nfSBbZXJyTXNnXSAtIEN1c3RvbSBlcnJvciBtZXNzYWdlIHRocm93biBvbiBpbnZhbGlkIGlucHV0LlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfc3RyaW5nQXJyYXlUb1NldChzdHJBcnJheSwgZXJyTXNnKSB7XG4gICAgaWYgKCFzdHJBcnJheSkgcmV0dXJuIHt9O1xuXG4gICAgZXJyTXNnID1cbiAgICAgIGVyck1zZyB8fCAnQ2Fubm90IG1ha2Ugc2V0IGZyb20gdHlwZSBvdGhlciB0aGFuIEFycmF5IG9mIHN0cmluZyBlbGVtZW50cyc7XG5cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RyQXJyYXkpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RyQXJyYXkucmVkdWNlKChzZXQsIGVsKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGVsICE9PSAnc3RyaW5nJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyTXNnKTtcbiAgICAgIH1cbiAgICAgIHNldFtlbF0gPSB0cnVlO1xuXG4gICAgICByZXR1cm4gc2V0O1xuICAgIH0sIHt9KTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/transports/console.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/transports/file.js":
/*!*************************************************************!*\
  !*** ./node_modules/winston/lib/winston/transports/file.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint-disable complexity,max-statements */\n/**\n * file.js: Transport for outputting to a local log file.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst asyncSeries = __webpack_require__(/*! async/series */ \"(rsc)/./node_modules/async/series.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst { MESSAGE } = __webpack_require__(/*! triple-beam */ \"(rsc)/./node_modules/triple-beam/index.js\");\nconst { Stream, PassThrough } = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\");\nconst TransportStream = __webpack_require__(/*! winston-transport */ \"(rsc)/./node_modules/winston-transport/index.js\");\nconst debug = __webpack_require__(/*! @dabh/diagnostics */ \"(rsc)/./node_modules/@dabh/diagnostics/node/index.js\")('winston:file');\nconst os = __webpack_require__(/*! os */ \"os\");\nconst tailFile = __webpack_require__(/*! ../tail-file */ \"(rsc)/./node_modules/winston/lib/winston/tail-file.js\");\n\n/**\n * Transport for outputting to a local log file.\n * @type {File}\n * @extends {TransportStream}\n */\nmodule.exports = class File extends TransportStream {\n  /**\n   * Constructor function for the File transport object responsible for\n   * persisting log messages and metadata to one or more files.\n   * @param {Object} options - Options for this instance.\n   */\n  constructor(options = {}) {\n    super(options);\n\n    // Expose the name of this Transport on the prototype.\n    this.name = options.name || 'file';\n\n    // Helper function which throws an `Error` in the event that any of the\n    // rest of the arguments is present in `options`.\n    function throwIf(target, ...args) {\n      args.slice(1).forEach(name => {\n        if (options[name]) {\n          throw new Error(`Cannot set ${name} and ${target} together`);\n        }\n      });\n    }\n\n    // Setup the base stream that always gets piped to to handle buffering.\n    this._stream = new PassThrough();\n    this._stream.setMaxListeners(30);\n\n    // Bind this context for listener methods.\n    this._onError = this._onError.bind(this);\n\n    if (options.filename || options.dirname) {\n      throwIf('filename or dirname', 'stream');\n      this._basename = this.filename = options.filename\n        ? path.basename(options.filename)\n        : 'winston.log';\n\n      this.dirname = options.dirname || path.dirname(options.filename);\n      this.options = options.options || { flags: 'a' };\n    } else if (options.stream) {\n      // eslint-disable-next-line no-console\n      console.warn('options.stream will be removed in winston@4. Use winston.transports.Stream');\n      throwIf('stream', 'filename', 'maxsize');\n      this._dest = this._stream.pipe(this._setupStream(options.stream));\n      this.dirname = path.dirname(this._dest.path);\n      // We need to listen for drain events when write() returns false. This\n      // can make node mad at times.\n    } else {\n      throw new Error('Cannot log to file without filename or stream.');\n    }\n\n    this.maxsize = options.maxsize || null;\n    this.rotationFormat = options.rotationFormat || false;\n    this.zippedArchive = options.zippedArchive || false;\n    this.maxFiles = options.maxFiles || null;\n    this.eol = (typeof options.eol === 'string') ? options.eol : os.EOL;\n    this.tailable = options.tailable || false;\n    this.lazy = options.lazy || false;\n\n    // Internal state variables representing the number of files this instance\n    // has created and the current size (in bytes) of the current logfile.\n    this._size = 0;\n    this._pendingSize = 0;\n    this._created = 0;\n    this._drain = false;\n    this._opening = false;\n    this._ending = false;\n    this._fileExist = false;\n\n    if (this.dirname) this._createLogDirIfNotExist(this.dirname);\n    if (!this.lazy) this.open();\n  }\n\n  finishIfEnding() {\n    if (this._ending) {\n      if (this._opening) {\n        this.once('open', () => {\n          this._stream.once('finish', () => this.emit('finish'));\n          setImmediate(() => this._stream.end());\n        });\n      } else {\n        this._stream.once('finish', () => this.emit('finish'));\n        setImmediate(() => this._stream.end());\n      }\n    }\n  }\n\n  /**\n   * Core logging method exposed to Winston. Metadata is optional.\n   * @param {Object} info - TODO: add param description.\n   * @param {Function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  log(info, callback = () => { }) {\n    // Remark: (jcrugzz) What is necessary about this callback(null, true) now\n    // when thinking about 3.x? Should silent be handled in the base\n    // TransportStream _write method?\n    if (this.silent) {\n      callback();\n      return true;\n    }\n\n\n    // Output stream buffer is full and has asked us to wait for the drain event\n    if (this._drain) {\n      this._stream.once('drain', () => {\n        this._drain = false;\n        this.log(info, callback);\n      });\n      return;\n    }\n    if (this._rotate) {\n      this._stream.once('rotate', () => {\n        this._rotate = false;\n        this.log(info, callback);\n      });\n      return;\n    }\n    if (this.lazy) {\n      if (!this._fileExist) {\n        if (!this._opening) {\n          this.open();\n        }\n        this.once('open', () => {\n          this._fileExist = true;\n          this.log(info, callback);\n          return;\n        });\n        return;\n      }\n      if (this._needsNewFile(this._pendingSize)) {\n        this._dest.once('close', () => {\n          if (!this._opening) {\n            this.open();\n          }\n          this.once('open', () => {\n            this.log(info, callback);\n            return;\n          });\n          return;\n        });\n        return;\n      }\n    }\n\n    // Grab the raw string and append the expected EOL.\n    const output = `${info[MESSAGE]}${this.eol}`;\n    const bytes = Buffer.byteLength(output);\n\n    // After we have written to the PassThrough check to see if we need\n    // to rotate to the next file.\n    //\n    // Remark: This gets called too early and does not depict when data\n    // has been actually flushed to disk.\n    function logged() {\n      this._size += bytes;\n      this._pendingSize -= bytes;\n\n      debug('logged %s %s', this._size, output);\n      this.emit('logged', info);\n\n      // Do not attempt to rotate files while rotating\n      if (this._rotate) {\n        return;\n      }\n\n      // Do not attempt to rotate files while opening\n      if (this._opening) {\n        return;\n      }\n\n      // Check to see if we need to end the stream and create a new one.\n      if (!this._needsNewFile()) {\n        return;\n      }\n      if (this.lazy) {\n        this._endStream(() => {this.emit('fileclosed');});\n        return;\n      }\n\n      // End the current stream, ensure it flushes and create a new one.\n      // This could potentially be optimized to not run a stat call but its\n      // the safest way since we are supporting `maxFiles`.\n      this._rotate = true;\n      this._endStream(() => this._rotateFile());\n    }\n\n    // Keep track of the pending bytes being written while files are opening\n    // in order to properly rotate the PassThrough this._stream when the file\n    // eventually does open.\n    this._pendingSize += bytes;\n    if (this._opening\n      && !this.rotatedWhileOpening\n      && this._needsNewFile(this._size + this._pendingSize)) {\n      this.rotatedWhileOpening = true;\n    }\n\n    const written = this._stream.write(output, logged.bind(this));\n    if (!written) {\n      this._drain = true;\n      this._stream.once('drain', () => {\n        this._drain = false;\n        callback();\n      });\n    } else {\n      callback(); // eslint-disable-line callback-return\n    }\n\n    debug('written', written, this._drain);\n\n    this.finishIfEnding();\n\n    return written;\n  }\n\n  /**\n   * Query the transport. Options object is optional.\n   * @param {Object} options - Loggly-like query options for this instance.\n   * @param {function} callback - Continuation to respond to when complete.\n   * TODO: Refactor me.\n   */\n  query(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = normalizeQuery(options);\n    const file = path.join(this.dirname, this.filename);\n    let buff = '';\n    let results = [];\n    let row = 0;\n\n    const stream = fs.createReadStream(file, {\n      encoding: 'utf8'\n    });\n\n    stream.on('error', err => {\n      if (stream.readable) {\n        stream.destroy();\n      }\n      if (!callback) {\n        return;\n      }\n\n      return err.code !== 'ENOENT' ? callback(err) : callback(null, results);\n    });\n\n    stream.on('data', data => {\n      data = (buff + data).split(/\\n+/);\n      const l = data.length - 1;\n      let i = 0;\n\n      for (; i < l; i++) {\n        if (!options.start || row >= options.start) {\n          add(data[i]);\n        }\n        row++;\n      }\n\n      buff = data[l];\n    });\n\n    stream.on('close', () => {\n      if (buff) {\n        add(buff, true);\n      }\n      if (options.order === 'desc') {\n        results = results.reverse();\n      }\n\n      // eslint-disable-next-line callback-return\n      if (callback) callback(null, results);\n    });\n\n    function add(buff, attempt) {\n      try {\n        const log = JSON.parse(buff);\n        if (check(log)) {\n          push(log);\n        }\n      } catch (e) {\n        if (!attempt) {\n          stream.emit('error', e);\n        }\n      }\n    }\n\n    function push(log) {\n      if (\n        options.rows &&\n        results.length >= options.rows &&\n        options.order !== 'desc'\n      ) {\n        if (stream.readable) {\n          stream.destroy();\n        }\n        return;\n      }\n\n      if (options.fields) {\n        log = options.fields.reduce((obj, key) => {\n          obj[key] = log[key];\n          return obj;\n        }, {});\n      }\n\n      if (options.order === 'desc') {\n        if (results.length >= options.rows) {\n          results.shift();\n        }\n      }\n      results.push(log);\n    }\n\n    function check(log) {\n      if (!log) {\n        return;\n      }\n\n      if (typeof log !== 'object') {\n        return;\n      }\n\n      const time = new Date(log.timestamp);\n      if (\n        (options.from && time < options.from) ||\n        (options.until && time > options.until) ||\n        (options.level && options.level !== log.level)\n      ) {\n        return;\n      }\n\n      return true;\n    }\n\n    function normalizeQuery(options) {\n      options = options || {};\n\n      // limit\n      options.rows = options.rows || options.limit || 10;\n\n      // starting row offset\n      options.start = options.start || 0;\n\n      // now\n      options.until = options.until || new Date();\n      if (typeof options.until !== 'object') {\n        options.until = new Date(options.until);\n      }\n\n      // now - 24\n      options.from = options.from || (options.until - (24 * 60 * 60 * 1000));\n      if (typeof options.from !== 'object') {\n        options.from = new Date(options.from);\n      }\n\n      // 'asc' or 'desc'\n      options.order = options.order || 'desc';\n\n      return options;\n    }\n  }\n\n  /**\n   * Returns a log stream for this transport. Options object is optional.\n   * @param {Object} options - Stream options for this instance.\n   * @returns {Stream} - TODO: add return description.\n   * TODO: Refactor me.\n   */\n  stream(options = {}) {\n    const file = path.join(this.dirname, this.filename);\n    const stream = new Stream();\n    const tail = {\n      file,\n      start: options.start\n    };\n\n    stream.destroy = tailFile(tail, (err, line) => {\n      if (err) {\n        return stream.emit('error', err);\n      }\n\n      try {\n        stream.emit('data', line);\n        line = JSON.parse(line);\n        stream.emit('log', line);\n      } catch (e) {\n        stream.emit('error', e);\n      }\n    });\n\n    return stream;\n  }\n\n  /**\n   * Checks to see the filesize of.\n   * @returns {undefined}\n   */\n  open() {\n    // If we do not have a filename then we were passed a stream and\n    // don't need to keep track of size.\n    if (!this.filename) return;\n    if (this._opening) return;\n\n    this._opening = true;\n\n    // Stat the target file to get the size and create the stream.\n    this.stat((err, size) => {\n      if (err) {\n        return this.emit('error', err);\n      }\n      debug('stat done: %s { size: %s }', this.filename, size);\n      this._size = size;\n      this._dest = this._createStream(this._stream);\n      this._opening = false;\n      this.once('open', () => {\n        if (!this._stream.emit('rotate')) {\n          this._rotate = false;\n        }\n      });\n    });\n  }\n\n  /**\n   * Stat the file and assess information in order to create the proper stream.\n   * @param {function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  stat(callback) {\n    const target = this._getFile();\n    const fullpath = path.join(this.dirname, target);\n\n    fs.stat(fullpath, (err, stat) => {\n      if (err && err.code === 'ENOENT') {\n        debug('ENOENT ok', fullpath);\n        // Update internally tracked filename with the new target name.\n        this.filename = target;\n        return callback(null, 0);\n      }\n\n      if (err) {\n        debug(`err ${err.code} ${fullpath}`);\n        return callback(err);\n      }\n\n      if (!stat || this._needsNewFile(stat.size)) {\n        // If `stats.size` is greater than the `maxsize` for this\n        // instance then try again.\n        return this._incFile(() => this.stat(callback));\n      }\n\n      // Once we have figured out what the filename is, set it\n      // and return the size.\n      this.filename = target;\n      callback(null, stat.size);\n    });\n  }\n\n  /**\n   * Closes the stream associated with this instance.\n   * @param {function} cb - TODO: add param description.\n   * @returns {undefined}\n   */\n  close(cb) {\n    if (!this._stream) {\n      return;\n    }\n\n    this._stream.end(() => {\n      if (cb) {\n        cb(); // eslint-disable-line callback-return\n      }\n      this.emit('flush');\n      this.emit('closed');\n    });\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {number} size - TODO: add param description.\n   * @returns {undefined}\n   */\n  _needsNewFile(size) {\n    size = size || this._size;\n    return this.maxsize && size >= this.maxsize;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Error} err - TODO: add param description.\n   * @returns {undefined}\n   */\n  _onError(err) {\n    this.emit('error', err);\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Stream} stream - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  _setupStream(stream) {\n    stream.on('error', this._onError);\n\n    return stream;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {Stream} stream - TODO: add param description.\n   * @returns {mixed} - TODO: add return description.\n   */\n  _cleanupStream(stream) {\n    stream.removeListener('error', this._onError);\n    stream.destroy();\n    return stream;\n  }\n\n  /**\n   * TODO: add method description.\n   */\n  _rotateFile() {\n    this._incFile(() => this.open());\n  }\n\n  /**\n   * Unpipe from the stream that has been marked as full and end it so it\n   * flushes to disk.\n   *\n   * @param {function} callback - Callback for when the current file has closed.\n   * @private\n   */\n  _endStream(callback = () => { }) {\n    if (this._dest) {\n      this._stream.unpipe(this._dest);\n      this._dest.end(() => {\n        this._cleanupStream(this._dest);\n        callback();\n      });\n    } else {\n      callback(); // eslint-disable-line callback-return\n    }\n  }\n\n  /**\n   * Returns the WritableStream for the active file on this instance. If we\n   * should gzip the file then a zlib stream is returned.\n   *\n   * @param {ReadableStream} source –PassThrough to pipe to the file when open.\n   * @returns {WritableStream} Stream that writes to disk for the active file.\n   */\n  _createStream(source) {\n    const fullpath = path.join(this.dirname, this.filename);\n\n    debug('create stream start', fullpath, this.options);\n    const dest = fs.createWriteStream(fullpath, this.options)\n      // TODO: What should we do with errors here?\n      .on('error', err => debug(err))\n      .on('close', () => debug('close', dest.path, dest.bytesWritten))\n      .on('open', () => {\n        debug('file open ok', fullpath);\n        this.emit('open', fullpath);\n        source.pipe(dest);\n\n        // If rotation occured during the open operation then we immediately\n        // start writing to a new PassThrough, begin opening the next file\n        // and cleanup the previous source and dest once the source has drained.\n        if (this.rotatedWhileOpening) {\n          this._stream = new PassThrough();\n          this._stream.setMaxListeners(30);\n          this._rotateFile();\n          this.rotatedWhileOpening = false;\n          this._cleanupStream(dest);\n          source.end();\n        }\n      });\n\n    debug('create stream ok', fullpath);\n    return dest;\n  }\n\n  /**\n   * TODO: add method description.\n   * @param {function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  _incFile(callback) {\n    debug('_incFile', this.filename);\n    const ext = path.extname(this._basename);\n    const basename = path.basename(this._basename, ext);\n    const tasks = [];\n\n    if (this.zippedArchive) {\n      tasks.push(\n        function (cb) {\n          const num = this._created > 0 && !this.tailable ? this._created : '';\n          this._compressFile(\n            path.join(this.dirname, `${basename}${num}${ext}`),\n            path.join(this.dirname, `${basename}${num}${ext}.gz`),\n            cb\n          );\n        }.bind(this)\n      );\n    }\n\n    tasks.push(\n      function (cb) {\n        if (!this.tailable) {\n          this._created += 1;\n          this._checkMaxFilesIncrementing(ext, basename, cb);\n        } else {\n          this._checkMaxFilesTailable(ext, basename, cb);\n        }\n      }.bind(this)\n    );\n\n    asyncSeries(tasks, callback);\n  }\n\n  /**\n   * Gets the next filename to use for this instance in the case that log\n   * filesizes are being capped.\n   * @returns {string} - TODO: add return description.\n   * @private\n   */\n  _getFile() {\n    const ext = path.extname(this._basename);\n    const basename = path.basename(this._basename, ext);\n    const isRotation = this.rotationFormat\n      ? this.rotationFormat()\n      : this._created;\n\n    // Caveat emptor (indexzero): rotationFormat() was broken by design When\n    // combined with max files because the set of files to unlink is never\n    // stored.\n    return !this.tailable && this._created\n      ? `${basename}${isRotation}${ext}`\n      : `${basename}${ext}`;\n  }\n\n  /**\n   * Increment the number of files created or checked by this instance.\n   * @param {mixed} ext - TODO: add param description.\n   * @param {mixed} basename - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {undefined}\n   * @private\n   */\n  _checkMaxFilesIncrementing(ext, basename, callback) {\n    // Check for maxFiles option and delete file.\n    if (!this.maxFiles || this._created < this.maxFiles) {\n      return setImmediate(callback);\n    }\n\n    const oldest = this._created - this.maxFiles;\n    const isOldest = oldest !== 0 ? oldest : '';\n    const isZipped = this.zippedArchive ? '.gz' : '';\n    const filePath = `${basename}${isOldest}${ext}${isZipped}`;\n    const target = path.join(this.dirname, filePath);\n\n    fs.unlink(target, callback);\n  }\n\n  /**\n   * Roll files forward based on integer, up to maxFiles. e.g. if base if\n   * file.log and it becomes oversized, roll to file1.log, and allow file.log\n   * to be re-used. If file is oversized again, roll file1.log to file2.log,\n   * roll file.log to file1.log, and so on.\n   * @param {mixed} ext - TODO: add param description.\n   * @param {mixed} basename - TODO: add param description.\n   * @param {mixed} callback - TODO: add param description.\n   * @returns {undefined}\n   * @private\n   */\n  _checkMaxFilesTailable(ext, basename, callback) {\n    const tasks = [];\n    if (!this.maxFiles) {\n      return;\n    }\n\n    // const isZipped = this.zippedArchive ? '.gz' : '';\n    const isZipped = this.zippedArchive ? '.gz' : '';\n    for (let x = this.maxFiles - 1; x > 1; x--) {\n      tasks.push(function (i, cb) {\n        let fileName = `${basename}${(i - 1)}${ext}${isZipped}`;\n        const tmppath = path.join(this.dirname, fileName);\n\n        fs.exists(tmppath, exists => {\n          if (!exists) {\n            return cb(null);\n          }\n\n          fileName = `${basename}${i}${ext}${isZipped}`;\n          fs.rename(tmppath, path.join(this.dirname, fileName), cb);\n        });\n      }.bind(this, x));\n    }\n\n    asyncSeries(tasks, () => {\n      fs.rename(\n        path.join(this.dirname, `${basename}${ext}${isZipped}`),\n        path.join(this.dirname, `${basename}1${ext}${isZipped}`),\n        callback\n      );\n    });\n  }\n\n  /**\n   * Compresses src to dest with gzip and unlinks src\n   * @param {string} src - path to source file.\n   * @param {string} dest - path to zipped destination file.\n   * @param {Function} callback - callback called after file has been compressed.\n   * @returns {undefined}\n   * @private\n   */\n  _compressFile(src, dest, callback) {\n    fs.access(src, fs.F_OK, (err) => {\n      if (err) {\n        return callback();\n      }\n      var gzip = zlib.createGzip();\n      var inp = fs.createReadStream(src);\n      var out = fs.createWriteStream(dest);\n      out.on('finish', () => {\n        fs.unlink(src, callback);\n      });\n      inp.pipe(gzip).pipe(out);\n    });\n  }\n\n  _createLogDirIfNotExist(dirPath) {\n    /* eslint-disable no-sync */\n    if (!fs.existsSync(dirPath)) {\n      fs.mkdirSync(dirPath, { recursive: true });\n    }\n    /* eslint-enable no-sync */\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90cmFuc3BvcnRzL2ZpbGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLG9CQUFvQixtQkFBTyxDQUFDLDBEQUFjO0FBQzFDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixRQUFRLFVBQVUsRUFBRSxtQkFBTyxDQUFDLDhEQUFhO0FBQ3pDLFFBQVEsc0JBQXNCLEVBQUUsbUJBQU8sQ0FBQyx5RUFBaUI7QUFDekQsd0JBQXdCLG1CQUFPLENBQUMsMEVBQW1CO0FBQ25ELGNBQWMsbUJBQU8sQ0FBQywrRUFBbUI7QUFDekMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsaUJBQWlCLG1CQUFPLENBQUMsMkVBQWM7O0FBRXZDO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE1BQU0sTUFBTSxRQUFRO0FBQzVEO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwwQ0FBMEM7QUFDMUMsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNCQUFzQixjQUFjLEVBQUUsU0FBUztBQUMvQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5QkFBeUI7QUFDeEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sa0JBQWtCO0FBQ2xCOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsVUFBVTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxxQkFBcUIsVUFBVSxFQUFFLFNBQVM7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ04sa0JBQWtCO0FBQ2xCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxTQUFTLEVBQUUsSUFBSSxFQUFFLElBQUk7QUFDNUQsdUNBQXVDLFNBQVMsRUFBRSxJQUFJLEVBQUUsSUFBSTtBQUM1RDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVMsRUFBRSxXQUFXLEVBQUUsSUFBSTtBQUN2QyxXQUFXLFNBQVMsRUFBRSxJQUFJO0FBQzFCOztBQUVBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVMsRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLFNBQVM7QUFDN0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsT0FBTztBQUMzQztBQUNBLDBCQUEwQixTQUFTLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxTQUFTO0FBQzlEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixTQUFTLEVBQUUsRUFBRSxFQUFFLElBQUksRUFBRSxTQUFTO0FBQ3REO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DLFNBQVMsRUFBRSxJQUFJLEVBQUUsU0FBUztBQUM3RCxtQ0FBbUMsU0FBUyxHQUFHLElBQUksRUFBRSxTQUFTO0FBQzlEO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL3RyYW5zcG9ydHMvZmlsZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZGlzYWJsZSBjb21wbGV4aXR5LG1heC1zdGF0ZW1lbnRzICovXG4vKipcbiAqIGZpbGUuanM6IFRyYW5zcG9ydCBmb3Igb3V0cHV0dGluZyB0byBhIGxvY2FsIGxvZyBmaWxlLlxuICpcbiAqIChDKSAyMDEwIENoYXJsaWUgUm9iYmluc1xuICogTUlUIExJQ0VOQ0VcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBhc3luY1NlcmllcyA9IHJlcXVpcmUoJ2FzeW5jL3NlcmllcycpO1xuY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcbmNvbnN0IHsgTUVTU0FHRSB9ID0gcmVxdWlyZSgndHJpcGxlLWJlYW0nKTtcbmNvbnN0IHsgU3RyZWFtLCBQYXNzVGhyb3VnaCB9ID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtJyk7XG5jb25zdCBUcmFuc3BvcnRTdHJlYW0gPSByZXF1aXJlKCd3aW5zdG9uLXRyYW5zcG9ydCcpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKCdAZGFiaC9kaWFnbm9zdGljcycpKCd3aW5zdG9uOmZpbGUnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHRhaWxGaWxlID0gcmVxdWlyZSgnLi4vdGFpbC1maWxlJyk7XG5cbi8qKlxuICogVHJhbnNwb3J0IGZvciBvdXRwdXR0aW5nIHRvIGEgbG9jYWwgbG9nIGZpbGUuXG4gKiBAdHlwZSB7RmlsZX1cbiAqIEBleHRlbmRzIHtUcmFuc3BvcnRTdHJlYW19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgRmlsZSBleHRlbmRzIFRyYW5zcG9ydFN0cmVhbSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIEZpbGUgdHJhbnNwb3J0IG9iamVjdCByZXNwb25zaWJsZSBmb3JcbiAgICogcGVyc2lzdGluZyBsb2cgbWVzc2FnZXMgYW5kIG1ldGFkYXRhIHRvIG9uZSBvciBtb3JlIGZpbGVzLlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcihvcHRpb25zKTtcblxuICAgIC8vIEV4cG9zZSB0aGUgbmFtZSBvZiB0aGlzIFRyYW5zcG9ydCBvbiB0aGUgcHJvdG90eXBlLlxuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCAnZmlsZSc7XG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gd2hpY2ggdGhyb3dzIGFuIGBFcnJvcmAgaW4gdGhlIGV2ZW50IHRoYXQgYW55IG9mIHRoZVxuICAgIC8vIHJlc3Qgb2YgdGhlIGFyZ3VtZW50cyBpcyBwcmVzZW50IGluIGBvcHRpb25zYC5cbiAgICBmdW5jdGlvbiB0aHJvd0lmKHRhcmdldCwgLi4uYXJncykge1xuICAgICAgYXJncy5zbGljZSgxKS5mb3JFYWNoKG5hbWUgPT4ge1xuICAgICAgICBpZiAob3B0aW9uc1tuYW1lXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHNldCAke25hbWV9IGFuZCAke3RhcmdldH0gdG9nZXRoZXJgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gU2V0dXAgdGhlIGJhc2Ugc3RyZWFtIHRoYXQgYWx3YXlzIGdldHMgcGlwZWQgdG8gdG8gaGFuZGxlIGJ1ZmZlcmluZy5cbiAgICB0aGlzLl9zdHJlYW0gPSBuZXcgUGFzc1Rocm91Z2goKTtcbiAgICB0aGlzLl9zdHJlYW0uc2V0TWF4TGlzdGVuZXJzKDMwKTtcblxuICAgIC8vIEJpbmQgdGhpcyBjb250ZXh0IGZvciBsaXN0ZW5lciBtZXRob2RzLlxuICAgIHRoaXMuX29uRXJyb3IgPSB0aGlzLl9vbkVycm9yLmJpbmQodGhpcyk7XG5cbiAgICBpZiAob3B0aW9ucy5maWxlbmFtZSB8fCBvcHRpb25zLmRpcm5hbWUpIHtcbiAgICAgIHRocm93SWYoJ2ZpbGVuYW1lIG9yIGRpcm5hbWUnLCAnc3RyZWFtJyk7XG4gICAgICB0aGlzLl9iYXNlbmFtZSA9IHRoaXMuZmlsZW5hbWUgPSBvcHRpb25zLmZpbGVuYW1lXG4gICAgICAgID8gcGF0aC5iYXNlbmFtZShvcHRpb25zLmZpbGVuYW1lKVxuICAgICAgICA6ICd3aW5zdG9uLmxvZyc7XG5cbiAgICAgIHRoaXMuZGlybmFtZSA9IG9wdGlvbnMuZGlybmFtZSB8fCBwYXRoLmRpcm5hbWUob3B0aW9ucy5maWxlbmFtZSk7XG4gICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zLm9wdGlvbnMgfHwgeyBmbGFnczogJ2EnIH07XG4gICAgfSBlbHNlIGlmIChvcHRpb25zLnN0cmVhbSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2Fybignb3B0aW9ucy5zdHJlYW0gd2lsbCBiZSByZW1vdmVkIGluIHdpbnN0b25ANC4gVXNlIHdpbnN0b24udHJhbnNwb3J0cy5TdHJlYW0nKTtcbiAgICAgIHRocm93SWYoJ3N0cmVhbScsICdmaWxlbmFtZScsICdtYXhzaXplJyk7XG4gICAgICB0aGlzLl9kZXN0ID0gdGhpcy5fc3RyZWFtLnBpcGUodGhpcy5fc2V0dXBTdHJlYW0ob3B0aW9ucy5zdHJlYW0pKTtcbiAgICAgIHRoaXMuZGlybmFtZSA9IHBhdGguZGlybmFtZSh0aGlzLl9kZXN0LnBhdGgpO1xuICAgICAgLy8gV2UgbmVlZCB0byBsaXN0ZW4gZm9yIGRyYWluIGV2ZW50cyB3aGVuIHdyaXRlKCkgcmV0dXJucyBmYWxzZS4gVGhpc1xuICAgICAgLy8gY2FuIG1ha2Ugbm9kZSBtYWQgYXQgdGltZXMuXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IGxvZyB0byBmaWxlIHdpdGhvdXQgZmlsZW5hbWUgb3Igc3RyZWFtLicpO1xuICAgIH1cblxuICAgIHRoaXMubWF4c2l6ZSA9IG9wdGlvbnMubWF4c2l6ZSB8fCBudWxsO1xuICAgIHRoaXMucm90YXRpb25Gb3JtYXQgPSBvcHRpb25zLnJvdGF0aW9uRm9ybWF0IHx8IGZhbHNlO1xuICAgIHRoaXMuemlwcGVkQXJjaGl2ZSA9IG9wdGlvbnMuemlwcGVkQXJjaGl2ZSB8fCBmYWxzZTtcbiAgICB0aGlzLm1heEZpbGVzID0gb3B0aW9ucy5tYXhGaWxlcyB8fCBudWxsO1xuICAgIHRoaXMuZW9sID0gKHR5cGVvZiBvcHRpb25zLmVvbCA9PT0gJ3N0cmluZycpID8gb3B0aW9ucy5lb2wgOiBvcy5FT0w7XG4gICAgdGhpcy50YWlsYWJsZSA9IG9wdGlvbnMudGFpbGFibGUgfHwgZmFsc2U7XG4gICAgdGhpcy5sYXp5ID0gb3B0aW9ucy5sYXp5IHx8IGZhbHNlO1xuXG4gICAgLy8gSW50ZXJuYWwgc3RhdGUgdmFyaWFibGVzIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIGZpbGVzIHRoaXMgaW5zdGFuY2VcbiAgICAvLyBoYXMgY3JlYXRlZCBhbmQgdGhlIGN1cnJlbnQgc2l6ZSAoaW4gYnl0ZXMpIG9mIHRoZSBjdXJyZW50IGxvZ2ZpbGUuXG4gICAgdGhpcy5fc2l6ZSA9IDA7XG4gICAgdGhpcy5fcGVuZGluZ1NpemUgPSAwO1xuICAgIHRoaXMuX2NyZWF0ZWQgPSAwO1xuICAgIHRoaXMuX2RyYWluID0gZmFsc2U7XG4gICAgdGhpcy5fb3BlbmluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2VuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbGVFeGlzdCA9IGZhbHNlO1xuXG4gICAgaWYgKHRoaXMuZGlybmFtZSkgdGhpcy5fY3JlYXRlTG9nRGlySWZOb3RFeGlzdCh0aGlzLmRpcm5hbWUpO1xuICAgIGlmICghdGhpcy5sYXp5KSB0aGlzLm9wZW4oKTtcbiAgfVxuXG4gIGZpbmlzaElmRW5kaW5nKCkge1xuICAgIGlmICh0aGlzLl9lbmRpbmcpIHtcbiAgICAgIGlmICh0aGlzLl9vcGVuaW5nKSB7XG4gICAgICAgIHRoaXMub25jZSgnb3BlbicsICgpID0+IHtcbiAgICAgICAgICB0aGlzLl9zdHJlYW0ub25jZSgnZmluaXNoJywgKCkgPT4gdGhpcy5lbWl0KCdmaW5pc2gnKSk7XG4gICAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHRoaXMuX3N0cmVhbS5lbmQoKSk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsICgpID0+IHRoaXMuZW1pdCgnZmluaXNoJykpO1xuICAgICAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5fc3RyZWFtLmVuZCgpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29yZSBsb2dnaW5nIG1ldGhvZCBleHBvc2VkIHRvIFdpbnN0b24uIE1ldGFkYXRhIGlzIG9wdGlvbmFsLlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5mbyAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBsb2coaW5mbywgY2FsbGJhY2sgPSAoKSA9PiB7IH0pIHtcbiAgICAvLyBSZW1hcms6IChqY3J1Z3p6KSBXaGF0IGlzIG5lY2Vzc2FyeSBhYm91dCB0aGlzIGNhbGxiYWNrKG51bGwsIHRydWUpIG5vd1xuICAgIC8vIHdoZW4gdGhpbmtpbmcgYWJvdXQgMy54PyBTaG91bGQgc2lsZW50IGJlIGhhbmRsZWQgaW4gdGhlIGJhc2VcbiAgICAvLyBUcmFuc3BvcnRTdHJlYW0gX3dyaXRlIG1ldGhvZD9cbiAgICBpZiAodGhpcy5zaWxlbnQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cblxuICAgIC8vIE91dHB1dCBzdHJlYW0gYnVmZmVyIGlzIGZ1bGwgYW5kIGhhcyBhc2tlZCB1cyB0byB3YWl0IGZvciB0aGUgZHJhaW4gZXZlbnRcbiAgICBpZiAodGhpcy5fZHJhaW4pIHtcbiAgICAgIHRoaXMuX3N0cmVhbS5vbmNlKCdkcmFpbicsICgpID0+IHtcbiAgICAgICAgdGhpcy5fZHJhaW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5sb2coaW5mbywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLl9yb3RhdGUpIHtcbiAgICAgIHRoaXMuX3N0cmVhbS5vbmNlKCdyb3RhdGUnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuX3JvdGF0ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLmxvZyhpbmZvLCBjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgaWYgKCF0aGlzLl9maWxlRXhpc3QpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vcGVuaW5nKSB7XG4gICAgICAgICAgdGhpcy5vcGVuKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbmNlKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2ZpbGVFeGlzdCA9IHRydWU7XG4gICAgICAgICAgdGhpcy5sb2coaW5mbywgY2FsbGJhY2spO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9uZWVkc05ld0ZpbGUodGhpcy5fcGVuZGluZ1NpemUpKSB7XG4gICAgICAgIHRoaXMuX2Rlc3Qub25jZSgnY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgaWYgKCF0aGlzLl9vcGVuaW5nKSB7XG4gICAgICAgICAgICB0aGlzLm9wZW4oKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5vbmNlKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5sb2coaW5mbywgY2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHcmFiIHRoZSByYXcgc3RyaW5nIGFuZCBhcHBlbmQgdGhlIGV4cGVjdGVkIEVPTC5cbiAgICBjb25zdCBvdXRwdXQgPSBgJHtpbmZvW01FU1NBR0VdfSR7dGhpcy5lb2x9YDtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG91dHB1dCk7XG5cbiAgICAvLyBBZnRlciB3ZSBoYXZlIHdyaXR0ZW4gdG8gdGhlIFBhc3NUaHJvdWdoIGNoZWNrIHRvIHNlZSBpZiB3ZSBuZWVkXG4gICAgLy8gdG8gcm90YXRlIHRvIHRoZSBuZXh0IGZpbGUuXG4gICAgLy9cbiAgICAvLyBSZW1hcms6IFRoaXMgZ2V0cyBjYWxsZWQgdG9vIGVhcmx5IGFuZCBkb2VzIG5vdCBkZXBpY3Qgd2hlbiBkYXRhXG4gICAgLy8gaGFzIGJlZW4gYWN0dWFsbHkgZmx1c2hlZCB0byBkaXNrLlxuICAgIGZ1bmN0aW9uIGxvZ2dlZCgpIHtcbiAgICAgIHRoaXMuX3NpemUgKz0gYnl0ZXM7XG4gICAgICB0aGlzLl9wZW5kaW5nU2l6ZSAtPSBieXRlcztcblxuICAgICAgZGVidWcoJ2xvZ2dlZCAlcyAlcycsIHRoaXMuX3NpemUsIG91dHB1dCk7XG4gICAgICB0aGlzLmVtaXQoJ2xvZ2dlZCcsIGluZm8pO1xuXG4gICAgICAvLyBEbyBub3QgYXR0ZW1wdCB0byByb3RhdGUgZmlsZXMgd2hpbGUgcm90YXRpbmdcbiAgICAgIGlmICh0aGlzLl9yb3RhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBEbyBub3QgYXR0ZW1wdCB0byByb3RhdGUgZmlsZXMgd2hpbGUgb3BlbmluZ1xuICAgICAgaWYgKHRoaXMuX29wZW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBDaGVjayB0byBzZWUgaWYgd2UgbmVlZCB0byBlbmQgdGhlIHN0cmVhbSBhbmQgY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgIGlmICghdGhpcy5fbmVlZHNOZXdGaWxlKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMubGF6eSkge1xuICAgICAgICB0aGlzLl9lbmRTdHJlYW0oKCkgPT4ge3RoaXMuZW1pdCgnZmlsZWNsb3NlZCcpO30pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIEVuZCB0aGUgY3VycmVudCBzdHJlYW0sIGVuc3VyZSBpdCBmbHVzaGVzIGFuZCBjcmVhdGUgYSBuZXcgb25lLlxuICAgICAgLy8gVGhpcyBjb3VsZCBwb3RlbnRpYWxseSBiZSBvcHRpbWl6ZWQgdG8gbm90IHJ1biBhIHN0YXQgY2FsbCBidXQgaXRzXG4gICAgICAvLyB0aGUgc2FmZXN0IHdheSBzaW5jZSB3ZSBhcmUgc3VwcG9ydGluZyBgbWF4RmlsZXNgLlxuICAgICAgdGhpcy5fcm90YXRlID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2VuZFN0cmVhbSgoKSA9PiB0aGlzLl9yb3RhdGVGaWxlKCkpO1xuICAgIH1cblxuICAgIC8vIEtlZXAgdHJhY2sgb2YgdGhlIHBlbmRpbmcgYnl0ZXMgYmVpbmcgd3JpdHRlbiB3aGlsZSBmaWxlcyBhcmUgb3BlbmluZ1xuICAgIC8vIGluIG9yZGVyIHRvIHByb3Blcmx5IHJvdGF0ZSB0aGUgUGFzc1Rocm91Z2ggdGhpcy5fc3RyZWFtIHdoZW4gdGhlIGZpbGVcbiAgICAvLyBldmVudHVhbGx5IGRvZXMgb3Blbi5cbiAgICB0aGlzLl9wZW5kaW5nU2l6ZSArPSBieXRlcztcbiAgICBpZiAodGhpcy5fb3BlbmluZ1xuICAgICAgJiYgIXRoaXMucm90YXRlZFdoaWxlT3BlbmluZ1xuICAgICAgJiYgdGhpcy5fbmVlZHNOZXdGaWxlKHRoaXMuX3NpemUgKyB0aGlzLl9wZW5kaW5nU2l6ZSkpIHtcbiAgICAgIHRoaXMucm90YXRlZFdoaWxlT3BlbmluZyA9IHRydWU7XG4gICAgfVxuXG4gICAgY29uc3Qgd3JpdHRlbiA9IHRoaXMuX3N0cmVhbS53cml0ZShvdXRwdXQsIGxvZ2dlZC5iaW5kKHRoaXMpKTtcbiAgICBpZiAoIXdyaXR0ZW4pIHtcbiAgICAgIHRoaXMuX2RyYWluID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3N0cmVhbS5vbmNlKCdkcmFpbicsICgpID0+IHtcbiAgICAgICAgdGhpcy5fZHJhaW4gPSBmYWxzZTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFjaygpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNhbGxiYWNrLXJldHVyblxuICAgIH1cblxuICAgIGRlYnVnKCd3cml0dGVuJywgd3JpdHRlbiwgdGhpcy5fZHJhaW4pO1xuXG4gICAgdGhpcy5maW5pc2hJZkVuZGluZygpO1xuXG4gICAgcmV0dXJuIHdyaXR0ZW47XG4gIH1cblxuICAvKipcbiAgICogUXVlcnkgdGhlIHRyYW5zcG9ydC4gT3B0aW9ucyBvYmplY3QgaXMgb3B0aW9uYWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gTG9nZ2x5LWxpa2UgcXVlcnkgb3B0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDb250aW51YXRpb24gdG8gcmVzcG9uZCB0byB3aGVuIGNvbXBsZXRlLlxuICAgKiBUT0RPOiBSZWZhY3RvciBtZS5cbiAgICovXG4gIHF1ZXJ5KG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgb3B0aW9ucyA9IG5vcm1hbGl6ZVF1ZXJ5KG9wdGlvbnMpO1xuICAgIGNvbnN0IGZpbGUgPSBwYXRoLmpvaW4odGhpcy5kaXJuYW1lLCB0aGlzLmZpbGVuYW1lKTtcbiAgICBsZXQgYnVmZiA9ICcnO1xuICAgIGxldCByZXN1bHRzID0gW107XG4gICAgbGV0IHJvdyA9IDA7XG5cbiAgICBjb25zdCBzdHJlYW0gPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGUsIHtcbiAgICAgIGVuY29kaW5nOiAndXRmOCdcbiAgICB9KTtcblxuICAgIHN0cmVhbS5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgaWYgKHN0cmVhbS5yZWFkYWJsZSkge1xuICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBlcnIuY29kZSAhPT0gJ0VOT0VOVCcgPyBjYWxsYmFjayhlcnIpIDogY2FsbGJhY2sobnVsbCwgcmVzdWx0cyk7XG4gICAgfSk7XG5cbiAgICBzdHJlYW0ub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgIGRhdGEgPSAoYnVmZiArIGRhdGEpLnNwbGl0KC9cXG4rLyk7XG4gICAgICBjb25zdCBsID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgbGV0IGkgPSAwO1xuXG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICBpZiAoIW9wdGlvbnMuc3RhcnQgfHwgcm93ID49IG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgICBhZGQoZGF0YVtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcm93Kys7XG4gICAgICB9XG5cbiAgICAgIGJ1ZmYgPSBkYXRhW2xdO1xuICAgIH0pO1xuXG4gICAgc3RyZWFtLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgIGlmIChidWZmKSB7XG4gICAgICAgIGFkZChidWZmLCB0cnVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcHRpb25zLm9yZGVyID09PSAnZGVzYycpIHtcbiAgICAgICAgcmVzdWx0cyA9IHJlc3VsdHMucmV2ZXJzZSgpO1xuICAgICAgfVxuXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2FsbGJhY2stcmV0dXJuXG4gICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKG51bGwsIHJlc3VsdHMpO1xuICAgIH0pO1xuXG4gICAgZnVuY3Rpb24gYWRkKGJ1ZmYsIGF0dGVtcHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGxvZyA9IEpTT04ucGFyc2UoYnVmZik7XG4gICAgICAgIGlmIChjaGVjayhsb2cpKSB7XG4gICAgICAgICAgcHVzaChsb2cpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmICghYXR0ZW1wdCkge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHVzaChsb2cpIHtcbiAgICAgIGlmIChcbiAgICAgICAgb3B0aW9ucy5yb3dzICYmXG4gICAgICAgIHJlc3VsdHMubGVuZ3RoID49IG9wdGlvbnMucm93cyAmJlxuICAgICAgICBvcHRpb25zLm9yZGVyICE9PSAnZGVzYydcbiAgICAgICkge1xuICAgICAgICBpZiAoc3RyZWFtLnJlYWRhYmxlKSB7XG4gICAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmZpZWxkcykge1xuICAgICAgICBsb2cgPSBvcHRpb25zLmZpZWxkcy5yZWR1Y2UoKG9iaiwga2V5KSA9PiB7XG4gICAgICAgICAgb2JqW2tleV0gPSBsb2dba2V5XTtcbiAgICAgICAgICByZXR1cm4gb2JqO1xuICAgICAgICB9LCB7fSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLm9yZGVyID09PSAnZGVzYycpIHtcbiAgICAgICAgaWYgKHJlc3VsdHMubGVuZ3RoID49IG9wdGlvbnMucm93cykge1xuICAgICAgICAgIHJlc3VsdHMuc2hpZnQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0cy5wdXNoKGxvZyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2hlY2sobG9nKSB7XG4gICAgICBpZiAoIWxvZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgbG9nICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHRpbWUgPSBuZXcgRGF0ZShsb2cudGltZXN0YW1wKTtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdGlvbnMuZnJvbSAmJiB0aW1lIDwgb3B0aW9ucy5mcm9tKSB8fFxuICAgICAgICAob3B0aW9ucy51bnRpbCAmJiB0aW1lID4gb3B0aW9ucy51bnRpbCkgfHxcbiAgICAgICAgKG9wdGlvbnMubGV2ZWwgJiYgb3B0aW9ucy5sZXZlbCAhPT0gbG9nLmxldmVsKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gbm9ybWFsaXplUXVlcnkob3B0aW9ucykge1xuICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICAgIC8vIGxpbWl0XG4gICAgICBvcHRpb25zLnJvd3MgPSBvcHRpb25zLnJvd3MgfHwgb3B0aW9ucy5saW1pdCB8fCAxMDtcblxuICAgICAgLy8gc3RhcnRpbmcgcm93IG9mZnNldFxuICAgICAgb3B0aW9ucy5zdGFydCA9IG9wdGlvbnMuc3RhcnQgfHwgMDtcblxuICAgICAgLy8gbm93XG4gICAgICBvcHRpb25zLnVudGlsID0gb3B0aW9ucy51bnRpbCB8fCBuZXcgRGF0ZSgpO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLnVudGlsICE9PSAnb2JqZWN0Jykge1xuICAgICAgICBvcHRpb25zLnVudGlsID0gbmV3IERhdGUob3B0aW9ucy51bnRpbCk7XG4gICAgICB9XG5cbiAgICAgIC8vIG5vdyAtIDI0XG4gICAgICBvcHRpb25zLmZyb20gPSBvcHRpb25zLmZyb20gfHwgKG9wdGlvbnMudW50aWwgLSAoMjQgKiA2MCAqIDYwICogMTAwMCkpO1xuICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmZyb20gIT09ICdvYmplY3QnKSB7XG4gICAgICAgIG9wdGlvbnMuZnJvbSA9IG5ldyBEYXRlKG9wdGlvbnMuZnJvbSk7XG4gICAgICB9XG5cbiAgICAgIC8vICdhc2MnIG9yICdkZXNjJ1xuICAgICAgb3B0aW9ucy5vcmRlciA9IG9wdGlvbnMub3JkZXIgfHwgJ2Rlc2MnO1xuXG4gICAgICByZXR1cm4gb3B0aW9ucztcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIGxvZyBzdHJlYW0gZm9yIHRoaXMgdHJhbnNwb3J0LiBPcHRpb25zIG9iamVjdCBpcyBvcHRpb25hbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBTdHJlYW0gb3B0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogQHJldHVybnMge1N0cmVhbX0gLSBUT0RPOiBhZGQgcmV0dXJuIGRlc2NyaXB0aW9uLlxuICAgKiBUT0RPOiBSZWZhY3RvciBtZS5cbiAgICovXG4gIHN0cmVhbShvcHRpb25zID0ge30pIHtcbiAgICBjb25zdCBmaWxlID0gcGF0aC5qb2luKHRoaXMuZGlybmFtZSwgdGhpcy5maWxlbmFtZSk7XG4gICAgY29uc3Qgc3RyZWFtID0gbmV3IFN0cmVhbSgpO1xuICAgIGNvbnN0IHRhaWwgPSB7XG4gICAgICBmaWxlLFxuICAgICAgc3RhcnQ6IG9wdGlvbnMuc3RhcnRcbiAgICB9O1xuXG4gICAgc3RyZWFtLmRlc3Ryb3kgPSB0YWlsRmlsZSh0YWlsLCAoZXJyLCBsaW5lKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGxpbmUpO1xuICAgICAgICBsaW5lID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2xvZycsIGxpbmUpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIHRvIHNlZSB0aGUgZmlsZXNpemUgb2YuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBvcGVuKCkge1xuICAgIC8vIElmIHdlIGRvIG5vdCBoYXZlIGEgZmlsZW5hbWUgdGhlbiB3ZSB3ZXJlIHBhc3NlZCBhIHN0cmVhbSBhbmRcbiAgICAvLyBkb24ndCBuZWVkIHRvIGtlZXAgdHJhY2sgb2Ygc2l6ZS5cbiAgICBpZiAoIXRoaXMuZmlsZW5hbWUpIHJldHVybjtcbiAgICBpZiAodGhpcy5fb3BlbmluZykgcmV0dXJuO1xuXG4gICAgdGhpcy5fb3BlbmluZyA9IHRydWU7XG5cbiAgICAvLyBTdGF0IHRoZSB0YXJnZXQgZmlsZSB0byBnZXQgdGhlIHNpemUgYW5kIGNyZWF0ZSB0aGUgc3RyZWFtLlxuICAgIHRoaXMuc3RhdCgoZXJyLCBzaXplKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICAgIH1cbiAgICAgIGRlYnVnKCdzdGF0IGRvbmU6ICVzIHsgc2l6ZTogJXMgfScsIHRoaXMuZmlsZW5hbWUsIHNpemUpO1xuICAgICAgdGhpcy5fc2l6ZSA9IHNpemU7XG4gICAgICB0aGlzLl9kZXN0ID0gdGhpcy5fY3JlYXRlU3RyZWFtKHRoaXMuX3N0cmVhbSk7XG4gICAgICB0aGlzLl9vcGVuaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLm9uY2UoJ29wZW4nLCAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5fc3RyZWFtLmVtaXQoJ3JvdGF0ZScpKSB7XG4gICAgICAgICAgdGhpcy5fcm90YXRlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXQgdGhlIGZpbGUgYW5kIGFzc2VzcyBpbmZvcm1hdGlvbiBpbiBvcmRlciB0byBjcmVhdGUgdGhlIHByb3BlciBzdHJlYW0uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgc3RhdChjYWxsYmFjaykge1xuICAgIGNvbnN0IHRhcmdldCA9IHRoaXMuX2dldEZpbGUoKTtcbiAgICBjb25zdCBmdWxscGF0aCA9IHBhdGguam9pbih0aGlzLmRpcm5hbWUsIHRhcmdldCk7XG5cbiAgICBmcy5zdGF0KGZ1bGxwYXRoLCAoZXJyLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICBkZWJ1ZygnRU5PRU5UwqBvaycsIGZ1bGxwYXRoKTtcbiAgICAgICAgLy8gVXBkYXRlIGludGVybmFsbHkgdHJhY2tlZCBmaWxlbmFtZSB3aXRoIHRoZSBuZXcgdGFyZ2V0IG5hbWUuXG4gICAgICAgIHRoaXMuZmlsZW5hbWUgPSB0YXJnZXQ7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCAwKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVycikge1xuICAgICAgICBkZWJ1ZyhgZXJyICR7ZXJyLmNvZGV9ICR7ZnVsbHBhdGh9YCk7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXN0YXQgfHwgdGhpcy5fbmVlZHNOZXdGaWxlKHN0YXQuc2l6ZSkpIHtcbiAgICAgICAgLy8gSWYgYHN0YXRzLnNpemVgIGlzIGdyZWF0ZXIgdGhhbiB0aGUgYG1heHNpemVgIGZvciB0aGlzXG4gICAgICAgIC8vIGluc3RhbmNlIHRoZW4gdHJ5IGFnYWluLlxuICAgICAgICByZXR1cm4gdGhpcy5faW5jRmlsZSgoKSA9PiB0aGlzLnN0YXQoY2FsbGJhY2spKTtcbiAgICAgIH1cblxuICAgICAgLy8gT25jZSB3ZSBoYXZlIGZpZ3VyZWQgb3V0IHdoYXQgdGhlIGZpbGVuYW1lIGlzLCBzZXQgaXRcbiAgICAgIC8vIGFuZCByZXR1cm4gdGhlIHNpemUuXG4gICAgICB0aGlzLmZpbGVuYW1lID0gdGFyZ2V0O1xuICAgICAgY2FsbGJhY2sobnVsbCwgc3RhdC5zaXplKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDbG9zZXMgdGhlIHN0cmVhbSBhc3NvY2lhdGVkIHdpdGggdGhpcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBjbG9zZShjYikge1xuICAgIGlmICghdGhpcy5fc3RyZWFtKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fc3RyZWFtLmVuZCgoKSA9PiB7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgY2IoKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdCgnZmx1c2gnKTtcbiAgICAgIHRoaXMuZW1pdCgnY2xvc2VkJyk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogVE9ETzogYWRkIG1ldGhvZCBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHtudW1iZXJ9IHNpemUgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBfbmVlZHNOZXdGaWxlKHNpemUpIHtcbiAgICBzaXplID0gc2l6ZSB8fCB0aGlzLl9zaXplO1xuICAgIHJldHVybiB0aGlzLm1heHNpemUgJiYgc2l6ZSA+PSB0aGlzLm1heHNpemU7XG4gIH1cblxuICAvKipcbiAgICogVE9ETzogYWRkIG1ldGhvZCBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgX29uRXJyb3IoZXJyKSB7XG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cblxuICAvKipcbiAgICogVE9ETzogYWRkIG1ldGhvZCBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHtTdHJlYW19IHN0cmVhbSAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHJldHVybnMge21peGVkfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqL1xuICBfc2V0dXBTdHJlYW0oc3RyZWFtKSB7XG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIHRoaXMuX29uRXJyb3IpO1xuXG4gICAgcmV0dXJuIHN0cmVhbTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUT0RPOiBhZGQgbWV0aG9kIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge1N0cmVhbX0gc3RyZWFtIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7bWl4ZWR9IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvbi5cbiAgICovXG4gIF9jbGVhbnVwU3RyZWFtKHN0cmVhbSkge1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCB0aGlzLl9vbkVycm9yKTtcbiAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgIHJldHVybiBzdHJlYW07XG4gIH1cblxuICAvKipcbiAgICogVE9ETzogYWRkIG1ldGhvZCBkZXNjcmlwdGlvbi5cbiAgICovXG4gIF9yb3RhdGVGaWxlKCkge1xuICAgIHRoaXMuX2luY0ZpbGUoKCkgPT4gdGhpcy5vcGVuKCkpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVucGlwZSBmcm9tIHRoZSBzdHJlYW0gdGhhdCBoYXMgYmVlbiBtYXJrZWQgYXMgZnVsbCBhbmQgZW5kIGl0IHNvIGl0XG4gICAqIGZsdXNoZXMgdG8gZGlzay5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayBmb3Igd2hlbiB0aGUgY3VycmVudCBmaWxlIGhhcyBjbG9zZWQuXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZW5kU3RyZWFtKGNhbGxiYWNrID0gKCkgPT4geyB9KSB7XG4gICAgaWYgKHRoaXMuX2Rlc3QpIHtcbiAgICAgIHRoaXMuX3N0cmVhbS51bnBpcGUodGhpcy5fZGVzdCk7XG4gICAgICB0aGlzLl9kZXN0LmVuZCgoKSA9PiB7XG4gICAgICAgIHRoaXMuX2NsZWFudXBTdHJlYW0odGhpcy5fZGVzdCk7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgV3JpdGFibGVTdHJlYW0gZm9yIHRoZSBhY3RpdmUgZmlsZSBvbiB0aGlzIGluc3RhbmNlLiBJZiB3ZVxuICAgKiBzaG91bGQgZ3ppcCB0aGUgZmlsZSB0aGVuIGEgemxpYiBzdHJlYW0gaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW19IHNvdXJjZSDigJNQYXNzVGhyb3VnaCB0byBwaXBlIHRvIHRoZSBmaWxlIHdoZW4gb3Blbi5cbiAgICogQHJldHVybnMge1dyaXRhYmxlU3RyZWFtfSBTdHJlYW0gdGhhdCB3cml0ZXMgdG8gZGlzayBmb3IgdGhlIGFjdGl2ZSBmaWxlLlxuICAgKi9cbiAgX2NyZWF0ZVN0cmVhbShzb3VyY2UpIHtcbiAgICBjb25zdCBmdWxscGF0aCA9IHBhdGguam9pbih0aGlzLmRpcm5hbWUsIHRoaXMuZmlsZW5hbWUpO1xuXG4gICAgZGVidWcoJ2NyZWF0ZSBzdHJlYW0gc3RhcnQnLCBmdWxscGF0aCwgdGhpcy5vcHRpb25zKTtcbiAgICBjb25zdCBkZXN0ID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZnVsbHBhdGgsIHRoaXMub3B0aW9ucylcbiAgICAgIC8vIFRPRE86IFdoYXQgc2hvdWxkIHdlIGRvIHdpdGggZXJyb3JzIGhlcmU/XG4gICAgICAub24oJ2Vycm9yJywgZXJyID0+IGRlYnVnKGVycikpXG4gICAgICAub24oJ2Nsb3NlJywgKCkgPT4gZGVidWcoJ2Nsb3NlJywgZGVzdC5wYXRoLCBkZXN0LmJ5dGVzV3JpdHRlbikpXG4gICAgICAub24oJ29wZW4nLCAoKSA9PiB7XG4gICAgICAgIGRlYnVnKCdmaWxlIG9wZW4gb2snLCBmdWxscGF0aCk7XG4gICAgICAgIHRoaXMuZW1pdCgnb3BlbicsIGZ1bGxwYXRoKTtcbiAgICAgICAgc291cmNlLnBpcGUoZGVzdCk7XG5cbiAgICAgICAgLy8gSWYgcm90YXRpb24gb2NjdXJlZCBkdXJpbmcgdGhlIG9wZW4gb3BlcmF0aW9uIHRoZW4gd2UgaW1tZWRpYXRlbHlcbiAgICAgICAgLy8gc3RhcnQgd3JpdGluZyB0byBhIG5ldyBQYXNzVGhyb3VnaCwgYmVnaW4gb3BlbmluZyB0aGUgbmV4dCBmaWxlXG4gICAgICAgIC8vIGFuZCBjbGVhbnVwIHRoZSBwcmV2aW91cyBzb3VyY2UgYW5kIGRlc3Qgb25jZSB0aGUgc291cmNlIGhhcyBkcmFpbmVkLlxuICAgICAgICBpZiAodGhpcy5yb3RhdGVkV2hpbGVPcGVuaW5nKSB7XG4gICAgICAgICAgdGhpcy5fc3RyZWFtID0gbmV3IFBhc3NUaHJvdWdoKCk7XG4gICAgICAgICAgdGhpcy5fc3RyZWFtLnNldE1heExpc3RlbmVycygzMCk7XG4gICAgICAgICAgdGhpcy5fcm90YXRlRmlsZSgpO1xuICAgICAgICAgIHRoaXMucm90YXRlZFdoaWxlT3BlbmluZyA9IGZhbHNlO1xuICAgICAgICAgIHRoaXMuX2NsZWFudXBTdHJlYW0oZGVzdCk7XG4gICAgICAgICAgc291cmNlLmVuZCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgIGRlYnVnKCdjcmVhdGUgc3RyZWFtIG9rJywgZnVsbHBhdGgpO1xuICAgIHJldHVybiBkZXN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRPRE86IGFkZCBtZXRob2QgZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgX2luY0ZpbGUoY2FsbGJhY2spIHtcbiAgICBkZWJ1ZygnX2luY0ZpbGUnLCB0aGlzLmZpbGVuYW1lKTtcbiAgICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUodGhpcy5fYmFzZW5hbWUpO1xuICAgIGNvbnN0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZSh0aGlzLl9iYXNlbmFtZSwgZXh0KTtcbiAgICBjb25zdCB0YXNrcyA9IFtdO1xuXG4gICAgaWYgKHRoaXMuemlwcGVkQXJjaGl2ZSkge1xuICAgICAgdGFza3MucHVzaChcbiAgICAgICAgZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gdGhpcy5fY3JlYXRlZCA+IDAgJiYgIXRoaXMudGFpbGFibGUgPyB0aGlzLl9jcmVhdGVkIDogJyc7XG4gICAgICAgICAgdGhpcy5fY29tcHJlc3NGaWxlKFxuICAgICAgICAgICAgcGF0aC5qb2luKHRoaXMuZGlybmFtZSwgYCR7YmFzZW5hbWV9JHtudW19JHtleHR9YCksXG4gICAgICAgICAgICBwYXRoLmpvaW4odGhpcy5kaXJuYW1lLCBgJHtiYXNlbmFtZX0ke251bX0ke2V4dH0uZ3pgKSxcbiAgICAgICAgICAgIGNiXG4gICAgICAgICAgKTtcbiAgICAgICAgfS5iaW5kKHRoaXMpXG4gICAgICApO1xuICAgIH1cblxuICAgIHRhc2tzLnB1c2goXG4gICAgICBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgaWYgKCF0aGlzLnRhaWxhYmxlKSB7XG4gICAgICAgICAgdGhpcy5fY3JlYXRlZCArPSAxO1xuICAgICAgICAgIHRoaXMuX2NoZWNrTWF4RmlsZXNJbmNyZW1lbnRpbmcoZXh0LCBiYXNlbmFtZSwgY2IpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2NoZWNrTWF4RmlsZXNUYWlsYWJsZShleHQsIGJhc2VuYW1lLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH0uYmluZCh0aGlzKVxuICAgICk7XG5cbiAgICBhc3luY1Nlcmllcyh0YXNrcywgY2FsbGJhY2spO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG5leHQgZmlsZW5hbWUgdG8gdXNlIGZvciB0aGlzIGluc3RhbmNlIGluIHRoZSBjYXNlIHRoYXQgbG9nXG4gICAqIGZpbGVzaXplcyBhcmUgYmVpbmcgY2FwcGVkLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRPRE86IGFkZCByZXR1cm4gZGVzY3JpcHRpb24uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0RmlsZSgpIHtcbiAgICBjb25zdCBleHQgPSBwYXRoLmV4dG5hbWUodGhpcy5fYmFzZW5hbWUpO1xuICAgIGNvbnN0IGJhc2VuYW1lID0gcGF0aC5iYXNlbmFtZSh0aGlzLl9iYXNlbmFtZSwgZXh0KTtcbiAgICBjb25zdCBpc1JvdGF0aW9uID0gdGhpcy5yb3RhdGlvbkZvcm1hdFxuICAgICAgPyB0aGlzLnJvdGF0aW9uRm9ybWF0KClcbiAgICAgIDogdGhpcy5fY3JlYXRlZDtcblxuICAgIC8vIENhdmVhdCBlbXB0b3IgKGluZGV4emVybyk6IHJvdGF0aW9uRm9ybWF0KCkgd2FzIGJyb2tlbiBieSBkZXNpZ24gV2hlblxuICAgIC8vIGNvbWJpbmVkIHdpdGggbWF4IGZpbGVzIGJlY2F1c2UgdGhlIHNldCBvZiBmaWxlcyB0byB1bmxpbmsgaXMgbmV2ZXJcbiAgICAvLyBzdG9yZWQuXG4gICAgcmV0dXJuICF0aGlzLnRhaWxhYmxlICYmIHRoaXMuX2NyZWF0ZWRcbiAgICAgID8gYCR7YmFzZW5hbWV9JHtpc1JvdGF0aW9ufSR7ZXh0fWBcbiAgICAgIDogYCR7YmFzZW5hbWV9JHtleHR9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbmNyZW1lbnQgdGhlIG51bWJlciBvZiBmaWxlcyBjcmVhdGVkIG9yIGNoZWNrZWQgYnkgdGhpcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHttaXhlZH0gZXh0IC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcGFyYW0ge21peGVkfSBiYXNlbmFtZSAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHttaXhlZH0gY2FsbGJhY2sgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY2hlY2tNYXhGaWxlc0luY3JlbWVudGluZyhleHQsIGJhc2VuYW1lLCBjYWxsYmFjaykge1xuICAgIC8vIENoZWNrIGZvciBtYXhGaWxlcyBvcHRpb24gYW5kIGRlbGV0ZSBmaWxlLlxuICAgIGlmICghdGhpcy5tYXhGaWxlcyB8fCB0aGlzLl9jcmVhdGVkIDwgdGhpcy5tYXhGaWxlcykge1xuICAgICAgcmV0dXJuIHNldEltbWVkaWF0ZShjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgY29uc3Qgb2xkZXN0ID0gdGhpcy5fY3JlYXRlZCAtIHRoaXMubWF4RmlsZXM7XG4gICAgY29uc3QgaXNPbGRlc3QgPSBvbGRlc3QgIT09IDAgPyBvbGRlc3QgOiAnJztcbiAgICBjb25zdCBpc1ppcHBlZCA9IHRoaXMuemlwcGVkQXJjaGl2ZSA/ICcuZ3onIDogJyc7XG4gICAgY29uc3QgZmlsZVBhdGggPSBgJHtiYXNlbmFtZX0ke2lzT2xkZXN0fSR7ZXh0fSR7aXNaaXBwZWR9YDtcbiAgICBjb25zdCB0YXJnZXQgPSBwYXRoLmpvaW4odGhpcy5kaXJuYW1lLCBmaWxlUGF0aCk7XG5cbiAgICBmcy51bmxpbmsodGFyZ2V0LCBjYWxsYmFjayk7XG4gIH1cblxuICAvKipcbiAgICogUm9sbCBmaWxlcyBmb3J3YXJkIGJhc2VkIG9uIGludGVnZXIsIHVwIHRvIG1heEZpbGVzLiBlLmcuIGlmIGJhc2UgaWZcbiAgICogZmlsZS5sb2cgYW5kIGl0IGJlY29tZXMgb3ZlcnNpemVkLCByb2xsIHRvIGZpbGUxLmxvZywgYW5kIGFsbG93IGZpbGUubG9nXG4gICAqIHRvIGJlIHJlLXVzZWQuIElmIGZpbGUgaXMgb3ZlcnNpemVkIGFnYWluLCByb2xsIGZpbGUxLmxvZyB0byBmaWxlMi5sb2csXG4gICAqIHJvbGwgZmlsZS5sb2cgdG8gZmlsZTEubG9nLCBhbmQgc28gb24uXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGV4dCAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHttaXhlZH0gYmFzZW5hbWUgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7bWl4ZWR9IGNhbGxiYWNrIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NoZWNrTWF4RmlsZXNUYWlsYWJsZShleHQsIGJhc2VuYW1lLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHRhc2tzID0gW107XG4gICAgaWYgKCF0aGlzLm1heEZpbGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gY29uc3QgaXNaaXBwZWQgPSB0aGlzLnppcHBlZEFyY2hpdmUgPyAnLmd6JyA6ICcnO1xuICAgIGNvbnN0IGlzWmlwcGVkID0gdGhpcy56aXBwZWRBcmNoaXZlID8gJy5neicgOiAnJztcbiAgICBmb3IgKGxldCB4ID0gdGhpcy5tYXhGaWxlcyAtIDE7IHggPiAxOyB4LS0pIHtcbiAgICAgIHRhc2tzLnB1c2goZnVuY3Rpb24gKGksIGNiKSB7XG4gICAgICAgIGxldCBmaWxlTmFtZSA9IGAke2Jhc2VuYW1lfSR7KGkgLSAxKX0ke2V4dH0ke2lzWmlwcGVkfWA7XG4gICAgICAgIGNvbnN0IHRtcHBhdGggPSBwYXRoLmpvaW4odGhpcy5kaXJuYW1lLCBmaWxlTmFtZSk7XG5cbiAgICAgICAgZnMuZXhpc3RzKHRtcHBhdGgsIGV4aXN0cyA9PiB7XG4gICAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICAgIHJldHVybiBjYihudWxsKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmaWxlTmFtZSA9IGAke2Jhc2VuYW1lfSR7aX0ke2V4dH0ke2lzWmlwcGVkfWA7XG4gICAgICAgICAgZnMucmVuYW1lKHRtcHBhdGgsIHBhdGguam9pbih0aGlzLmRpcm5hbWUsIGZpbGVOYW1lKSwgY2IpO1xuICAgICAgICB9KTtcbiAgICAgIH0uYmluZCh0aGlzLCB4KSk7XG4gICAgfVxuXG4gICAgYXN5bmNTZXJpZXModGFza3MsICgpID0+IHtcbiAgICAgIGZzLnJlbmFtZShcbiAgICAgICAgcGF0aC5qb2luKHRoaXMuZGlybmFtZSwgYCR7YmFzZW5hbWV9JHtleHR9JHtpc1ppcHBlZH1gKSxcbiAgICAgICAgcGF0aC5qb2luKHRoaXMuZGlybmFtZSwgYCR7YmFzZW5hbWV9MSR7ZXh0fSR7aXNaaXBwZWR9YCksXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzZXMgc3JjIHRvIGRlc3Qgd2l0aCBnemlwIGFuZCB1bmxpbmtzIHNyY1xuICAgKiBAcGFyYW0ge3N0cmluZ30gc3JjIC0gcGF0aCB0byBzb3VyY2UgZmlsZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGRlc3QgLSBwYXRoIHRvIHppcHBlZCBkZXN0aW5hdGlvbiBmaWxlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGNhbGxiYWNrIGNhbGxlZCBhZnRlciBmaWxlIGhhcyBiZWVuIGNvbXByZXNzZWQuXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcHJlc3NGaWxlKHNyYywgZGVzdCwgY2FsbGJhY2spIHtcbiAgICBmcy5hY2Nlc3Moc3JjLCBmcy5GX09LLCAoZXJyKSA9PiB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygpO1xuICAgICAgfVxuICAgICAgdmFyIGd6aXAgPSB6bGliLmNyZWF0ZUd6aXAoKTtcbiAgICAgIHZhciBpbnAgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKHNyYyk7XG4gICAgICB2YXIgb3V0ID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZGVzdCk7XG4gICAgICBvdXQub24oJ2ZpbmlzaCcsICgpID0+IHtcbiAgICAgICAgZnMudW5saW5rKHNyYywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICBpbnAucGlwZShnemlwKS5waXBlKG91dCk7XG4gICAgfSk7XG4gIH1cblxuICBfY3JlYXRlTG9nRGlySWZOb3RFeGlzdChkaXJQYXRoKSB7XG4gICAgLyogZXNsaW50LWRpc2FibGUgbm8tc3luYyAqL1xuICAgIGlmICghZnMuZXhpc3RzU3luYyhkaXJQYXRoKSkge1xuICAgICAgZnMubWtkaXJTeW5jKGRpclBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cbiAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXN5bmMgKi9cbiAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/transports/file.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/transports/http.js":
/*!*************************************************************!*\
  !*** ./node_modules/winston/lib/winston/transports/http.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * http.js: Transport for outputting to a json-rpcserver.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst { Stream } = __webpack_require__(/*! readable-stream */ \"(rsc)/./node_modules/readable-stream/readable.js\");\nconst TransportStream = __webpack_require__(/*! winston-transport */ \"(rsc)/./node_modules/winston-transport/index.js\");\nconst { configure } = __webpack_require__(/*! safe-stable-stringify */ \"(rsc)/./node_modules/safe-stable-stringify/index.js\");\n\n/**\n * Transport for outputting to a json-rpc server.\n * @type {Stream}\n * @extends {TransportStream}\n */\nmodule.exports = class Http extends TransportStream {\n  /**\n   * Constructor function for the Http transport object responsible for\n   * persisting log messages and metadata to a terminal or TTY.\n   * @param {!Object} [options={}] - Options for this instance.\n   */\n  // eslint-disable-next-line max-statements\n  constructor(options = {}) {\n    super(options);\n\n    this.options = options;\n    this.name = options.name || 'http';\n    this.ssl = !!options.ssl;\n    this.host = options.host || 'localhost';\n    this.port = options.port;\n    this.auth = options.auth;\n    this.path = options.path || '';\n    this.maximumDepth = options.maximumDepth;\n    this.agent = options.agent;\n    this.headers = options.headers || {};\n    this.headers['content-type'] = 'application/json';\n    this.batch = options.batch || false;\n    this.batchInterval = options.batchInterval || 5000;\n    this.batchCount = options.batchCount || 10;\n    this.batchOptions = [];\n    this.batchTimeoutID = -1;\n    this.batchCallback = {};\n\n    if (!this.port) {\n      this.port = this.ssl ? 443 : 80;\n    }\n  }\n\n  /**\n   * Core logging method exposed to Winston.\n   * @param {Object} info - TODO: add param description.\n   * @param {function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  log(info, callback) {\n    this._request(info, null, null, (err, res) => {\n      if (res && res.statusCode !== 200) {\n        err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);\n      }\n\n      if (err) {\n        this.emit('warn', err);\n      } else {\n        this.emit('logged', info);\n      }\n    });\n\n    // Remark: (jcrugzz) Fire and forget here so requests dont cause buffering\n    // and block more requests from happening?\n    if (callback) {\n      setImmediate(callback);\n    }\n  }\n\n  /**\n   * Query the transport. Options object is optional.\n   * @param {Object} options -  Loggly-like query options for this instance.\n   * @param {function} callback - Continuation to respond to when complete.\n   * @returns {undefined}\n   */\n  query(options, callback) {\n    if (typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n\n    options = {\n      method: 'query',\n      params: this.normalizeQuery(options)\n    };\n\n    const auth = options.params.auth || null;\n    delete options.params.auth;\n\n    const path = options.params.path || null;\n    delete options.params.path;\n\n    this._request(options, auth, path, (err, res, body) => {\n      if (res && res.statusCode !== 200) {\n        err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);\n      }\n\n      if (err) {\n        return callback(err);\n      }\n\n      if (typeof body === 'string') {\n        try {\n          body = JSON.parse(body);\n        } catch (e) {\n          return callback(e);\n        }\n      }\n\n      callback(null, body);\n    });\n  }\n\n  /**\n   * Returns a log stream for this transport. Options object is optional.\n   * @param {Object} options - Stream options for this instance.\n   * @returns {Stream} - TODO: add return description\n   */\n  stream(options = {}) {\n    const stream = new Stream();\n    options = {\n      method: 'stream',\n      params: options\n    };\n\n    const path = options.params.path || null;\n    delete options.params.path;\n\n    const auth = options.params.auth || null;\n    delete options.params.auth;\n\n    let buff = '';\n    const req = this._request(options, auth, path);\n\n    stream.destroy = () => req.destroy();\n    req.on('data', data => {\n      data = (buff + data).split(/\\n+/);\n      const l = data.length - 1;\n\n      let i = 0;\n      for (; i < l; i++) {\n        try {\n          stream.emit('log', JSON.parse(data[i]));\n        } catch (e) {\n          stream.emit('error', e);\n        }\n      }\n\n      buff = data[l];\n    });\n    req.on('error', err => stream.emit('error', err));\n\n    return stream;\n  }\n\n  /**\n   * Make a request to a winstond server or any http server which can\n   * handle json-rpc.\n   * @param {function} options - Options to sent the request.\n   * @param {Object?} auth - authentication options\n   * @param {string} path - request path\n   * @param {function} callback - Continuation to respond to when complete.\n   */\n  _request(options, auth, path, callback) {\n    options = options || {};\n\n    auth = auth || this.auth;\n    path = path || this.path || '';\n\n    if (this.batch) {\n      this._doBatch(options, callback, auth, path);\n    } else {\n      this._doRequest(options, callback, auth, path);\n    }\n  }\n\n  /**\n   * Send or memorize the options according to batch configuration\n   * @param {function} options - Options to sent the request.\n   * @param {function} callback - Continuation to respond to when complete.\n   * @param {Object?} auth - authentication options\n   * @param {string} path - request path\n   */\n  _doBatch(options, callback, auth, path) {\n    this.batchOptions.push(options);\n    if (this.batchOptions.length === 1) {\n      // First message stored, it's time to start the timeout!\n      const me = this;\n      this.batchCallback = callback;\n      this.batchTimeoutID = setTimeout(function () {\n        // timeout is reached, send all messages to endpoint\n        me.batchTimeoutID = -1;\n        me._doBatchRequest(me.batchCallback, auth, path);\n      }, this.batchInterval);\n    }\n    if (this.batchOptions.length === this.batchCount) {\n      // max batch count is reached, send all messages to endpoint\n      this._doBatchRequest(this.batchCallback, auth, path);\n    }\n  }\n\n  /**\n   * Initiate a request with the memorized batch options, stop the batch timeout\n   * @param {function} callback - Continuation to respond to when complete.\n   * @param {Object?} auth - authentication options\n   * @param {string} path - request path\n   */\n  _doBatchRequest(callback, auth, path) {\n    if (this.batchTimeoutID > 0) {\n      clearTimeout(this.batchTimeoutID);\n      this.batchTimeoutID = -1;\n    }\n    const batchOptionsCopy = this.batchOptions.slice();\n    this.batchOptions = [];\n    this._doRequest(batchOptionsCopy, callback, auth, path);\n  }\n\n  /**\n   * Make a request to a winstond server or any http server which can\n   * handle json-rpc.\n   * @param {function} options - Options to sent the request.\n   * @param {function} callback - Continuation to respond to when complete.\n   * @param {Object?} auth - authentication options\n   * @param {string} path - request path\n   */\n  _doRequest(options, callback, auth, path) {\n    // Prepare options for outgoing HTTP request\n    const headers = Object.assign({}, this.headers);\n    if (auth && auth.bearer) {\n      headers.Authorization = `Bearer ${auth.bearer}`;\n    }\n    const req = (this.ssl ? https : http).request({\n      ...this.options,\n      method: 'POST',\n      host: this.host,\n      port: this.port,\n      path: `/${path.replace(/^\\//, '')}`,\n      headers: headers,\n      auth: (auth && auth.username && auth.password) ? (`${auth.username}:${auth.password}`) : '',\n      agent: this.agent\n    });\n\n    req.on('error', callback);\n    req.on('response', res => (\n      res.on('end', () => callback(null, res)).resume()\n    ));\n    const jsonStringify = configure({\n      ...(this.maximumDepth && { maximumDepth: this.maximumDepth })\n    });\n    req.end(Buffer.from(jsonStringify(options, this.options.replacer), 'utf8'));\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90cmFuc3BvcnRzL2h0dHAuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixjQUFjLG1CQUFPLENBQUMsb0JBQU87QUFDN0IsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyx5RUFBaUI7QUFDNUMsd0JBQXdCLG1CQUFPLENBQUMsMEVBQW1CO0FBQ25ELFFBQVEsWUFBWSxFQUFFLG1CQUFPLENBQUMsa0ZBQXVCOztBQUVyRDtBQUNBO0FBQ0EsVUFBVTtBQUNWLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTLFdBQVc7QUFDakM7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxlQUFlO0FBQ3BFOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxREFBcUQsZUFBZTtBQUNwRTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFNBQVM7QUFDdEIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QixhQUFhLFVBQVU7QUFDdkIsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQSx3Q0FBd0MsWUFBWTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0JBQXdCO0FBQ3hDO0FBQ0EsMkRBQTJELGNBQWMsR0FBRyxjQUFjO0FBQzFGO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLGlDQUFpQztBQUNsRSxLQUFLO0FBQ0w7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3dpbnN0b24vbGliL3dpbnN0b24vdHJhbnNwb3J0cy9odHRwLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogaHR0cC5qczogVHJhbnNwb3J0IGZvciBvdXRwdXR0aW5nIHRvIGEganNvbi1ycGNzZXJ2ZXIuXG4gKlxuICogKEMpIDIwMTAgQ2hhcmxpZSBSb2JiaW5zXG4gKiBNSVQgTElDRU5DRVxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IHsgU3RyZWFtIH0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKTtcbmNvbnN0IFRyYW5zcG9ydFN0cmVhbSA9IHJlcXVpcmUoJ3dpbnN0b24tdHJhbnNwb3J0Jyk7XG5jb25zdCB7IGNvbmZpZ3VyZSB9ID0gcmVxdWlyZSgnc2FmZS1zdGFibGUtc3RyaW5naWZ5Jyk7XG5cbi8qKlxuICogVHJhbnNwb3J0IGZvciBvdXRwdXR0aW5nIHRvIGEganNvbi1ycGMgc2VydmVyLlxuICogQHR5cGUge1N0cmVhbX1cbiAqIEBleHRlbmRzIHtUcmFuc3BvcnRTdHJlYW19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgSHR0cCBleHRlbmRzIFRyYW5zcG9ydFN0cmVhbSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmdW5jdGlvbiBmb3IgdGhlIEh0dHAgdHJhbnNwb3J0IG9iamVjdCByZXNwb25zaWJsZSBmb3JcbiAgICogcGVyc2lzdGluZyBsb2cgbWVzc2FnZXMgYW5kIG1ldGFkYXRhIHRvIGEgdGVybWluYWwgb3IgVFRZLlxuICAgKiBAcGFyYW0geyFPYmplY3R9IFtvcHRpb25zPXt9XSAtIE9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbWF4LXN0YXRlbWVudHNcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIHRoaXMubmFtZSA9IG9wdGlvbnMubmFtZSB8fCAnaHR0cCc7XG4gICAgdGhpcy5zc2wgPSAhIW9wdGlvbnMuc3NsO1xuICAgIHRoaXMuaG9zdCA9IG9wdGlvbnMuaG9zdCB8fCAnbG9jYWxob3N0JztcbiAgICB0aGlzLnBvcnQgPSBvcHRpb25zLnBvcnQ7XG4gICAgdGhpcy5hdXRoID0gb3B0aW9ucy5hdXRoO1xuICAgIHRoaXMucGF0aCA9IG9wdGlvbnMucGF0aCB8fCAnJztcbiAgICB0aGlzLm1heGltdW1EZXB0aCA9IG9wdGlvbnMubWF4aW11bURlcHRoO1xuICAgIHRoaXMuYWdlbnQgPSBvcHRpb25zLmFnZW50O1xuICAgIHRoaXMuaGVhZGVycyA9IG9wdGlvbnMuaGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLmhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2FwcGxpY2F0aW9uL2pzb24nO1xuICAgIHRoaXMuYmF0Y2ggPSBvcHRpb25zLmJhdGNoIHx8IGZhbHNlO1xuICAgIHRoaXMuYmF0Y2hJbnRlcnZhbCA9IG9wdGlvbnMuYmF0Y2hJbnRlcnZhbCB8fCA1MDAwO1xuICAgIHRoaXMuYmF0Y2hDb3VudCA9IG9wdGlvbnMuYmF0Y2hDb3VudCB8fCAxMDtcbiAgICB0aGlzLmJhdGNoT3B0aW9ucyA9IFtdO1xuICAgIHRoaXMuYmF0Y2hUaW1lb3V0SUQgPSAtMTtcbiAgICB0aGlzLmJhdGNoQ2FsbGJhY2sgPSB7fTtcblxuICAgIGlmICghdGhpcy5wb3J0KSB7XG4gICAgICB0aGlzLnBvcnQgPSB0aGlzLnNzbCA/IDQ0MyA6IDgwO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb3JlIGxvZ2dpbmcgbWV0aG9kIGV4cG9zZWQgdG8gV2luc3Rvbi5cbiAgICogQHBhcmFtIHtPYmplY3R9IGluZm8gLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gVE9ETzogYWRkIHBhcmFtIGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgbG9nKGluZm8sIGNhbGxiYWNrKSB7XG4gICAgdGhpcy5fcmVxdWVzdChpbmZvLCBudWxsLCBudWxsLCAoZXJyLCByZXMpID0+IHtcbiAgICAgIGlmIChyZXMgJiYgcmVzLnN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgICBlcnIgPSBuZXcgRXJyb3IoYEludmFsaWQgSFRUUCBTdGF0dXMgQ29kZTogJHtyZXMuc3RhdHVzQ29kZX1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLmVtaXQoJ3dhcm4nLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5lbWl0KCdsb2dnZWQnLCBpbmZvKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIFJlbWFyazogKGpjcnVnenopIEZpcmUgYW5kIGZvcmdldCBoZXJlIHNvIHJlcXVlc3RzIGRvbnQgY2F1c2UgYnVmZmVyaW5nXG4gICAgLy8gYW5kIGJsb2NrIG1vcmUgcmVxdWVzdHMgZnJvbSBoYXBwZW5pbmc/XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoY2FsbGJhY2spO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBRdWVyeSB0aGUgdHJhbnNwb3J0LiBPcHRpb25zIG9iamVjdCBpcyBvcHRpb25hbC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSAgTG9nZ2x5LWxpa2UgcXVlcnkgb3B0aW9ucyBmb3IgdGhpcyBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDb250aW51YXRpb24gdG8gcmVzcG9uZCB0byB3aGVuIGNvbXBsZXRlLlxuICAgKiBAcmV0dXJucyB7dW5kZWZpbmVkfVxuICAgKi9cbiAgcXVlcnkob3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgbWV0aG9kOiAncXVlcnknLFxuICAgICAgcGFyYW1zOiB0aGlzLm5vcm1hbGl6ZVF1ZXJ5KG9wdGlvbnMpXG4gICAgfTtcblxuICAgIGNvbnN0IGF1dGggPSBvcHRpb25zLnBhcmFtcy5hdXRoIHx8IG51bGw7XG4gICAgZGVsZXRlIG9wdGlvbnMucGFyYW1zLmF1dGg7XG5cbiAgICBjb25zdCBwYXRoID0gb3B0aW9ucy5wYXJhbXMucGF0aCB8fCBudWxsO1xuICAgIGRlbGV0ZSBvcHRpb25zLnBhcmFtcy5wYXRoO1xuXG4gICAgdGhpcy5fcmVxdWVzdChvcHRpb25zLCBhdXRoLCBwYXRoLCAoZXJyLCByZXMsIGJvZHkpID0+IHtcbiAgICAgIGlmIChyZXMgJiYgcmVzLnN0YXR1c0NvZGUgIT09IDIwMCkge1xuICAgICAgICBlcnIgPSBuZXcgRXJyb3IoYEludmFsaWQgSFRUUCBTdGF0dXMgQ29kZTogJHtyZXMuc3RhdHVzQ29kZX1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGJvZHkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBsb2cgc3RyZWFtIGZvciB0aGlzIHRyYW5zcG9ydC4gT3B0aW9ucyBvYmplY3QgaXMgb3B0aW9uYWwuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gU3RyZWFtIG9wdGlvbnMgZm9yIHRoaXMgaW5zdGFuY2UuXG4gICAqIEByZXR1cm5zIHtTdHJlYW19IC0gVE9ETzogYWRkIHJldHVybiBkZXNjcmlwdGlvblxuICAgKi9cbiAgc3RyZWFtKG9wdGlvbnMgPSB7fSkge1xuICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBTdHJlYW0oKTtcbiAgICBvcHRpb25zID0ge1xuICAgICAgbWV0aG9kOiAnc3RyZWFtJyxcbiAgICAgIHBhcmFtczogb3B0aW9uc1xuICAgIH07XG5cbiAgICBjb25zdCBwYXRoID0gb3B0aW9ucy5wYXJhbXMucGF0aCB8fCBudWxsO1xuICAgIGRlbGV0ZSBvcHRpb25zLnBhcmFtcy5wYXRoO1xuXG4gICAgY29uc3QgYXV0aCA9IG9wdGlvbnMucGFyYW1zLmF1dGggfHwgbnVsbDtcbiAgICBkZWxldGUgb3B0aW9ucy5wYXJhbXMuYXV0aDtcblxuICAgIGxldCBidWZmID0gJyc7XG4gICAgY29uc3QgcmVxID0gdGhpcy5fcmVxdWVzdChvcHRpb25zLCBhdXRoLCBwYXRoKTtcblxuICAgIHN0cmVhbS5kZXN0cm95ID0gKCkgPT4gcmVxLmRlc3Ryb3koKTtcbiAgICByZXEub24oJ2RhdGEnLCBkYXRhID0+IHtcbiAgICAgIGRhdGEgPSAoYnVmZiArIGRhdGEpLnNwbGl0KC9cXG4rLyk7XG4gICAgICBjb25zdCBsID0gZGF0YS5sZW5ndGggLSAxO1xuXG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdsb2cnLCBKU09OLnBhcnNlKGRhdGFbaV0pKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGJ1ZmYgPSBkYXRhW2xdO1xuICAgIH0pO1xuICAgIHJlcS5vbignZXJyb3InLCBlcnIgPT4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKSk7XG5cbiAgICByZXR1cm4gc3RyZWFtO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ha2UgYSByZXF1ZXN0IHRvIGEgd2luc3RvbmQgc2VydmVyIG9yIGFueSBodHRwIHNlcnZlciB3aGljaCBjYW5cbiAgICogaGFuZGxlIGpzb24tcnBjLlxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBvcHRpb25zIC0gT3B0aW9ucyB0byBzZW50IHRoZSByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge09iamVjdD99IGF1dGggLSBhdXRoZW50aWNhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gcmVxdWVzdCBwYXRoXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ29udGludWF0aW9uIHRvIHJlc3BvbmQgdG8gd2hlbiBjb21wbGV0ZS5cbiAgICovXG4gIF9yZXF1ZXN0KG9wdGlvbnMsIGF1dGgsIHBhdGgsIGNhbGxiYWNrKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cbiAgICBhdXRoID0gYXV0aCB8fCB0aGlzLmF1dGg7XG4gICAgcGF0aCA9IHBhdGggfHwgdGhpcy5wYXRoIHx8ICcnO1xuXG4gICAgaWYgKHRoaXMuYmF0Y2gpIHtcbiAgICAgIHRoaXMuX2RvQmF0Y2gob3B0aW9ucywgY2FsbGJhY2ssIGF1dGgsIHBhdGgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9kb1JlcXVlc3Qob3B0aW9ucywgY2FsbGJhY2ssIGF1dGgsIHBhdGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIG9yIG1lbW9yaXplIHRoZSBvcHRpb25zIGFjY29yZGluZyB0byBiYXRjaCBjb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IG9wdGlvbnMgLSBPcHRpb25zIHRvIHNlbnQgdGhlIHJlcXVlc3QuXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ29udGludWF0aW9uIHRvIHJlc3BvbmQgdG8gd2hlbiBjb21wbGV0ZS5cbiAgICogQHBhcmFtIHtPYmplY3Q/fSBhdXRoIC0gYXV0aGVudGljYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHJlcXVlc3QgcGF0aFxuICAgKi9cbiAgX2RvQmF0Y2gob3B0aW9ucywgY2FsbGJhY2ssIGF1dGgsIHBhdGgpIHtcbiAgICB0aGlzLmJhdGNoT3B0aW9ucy5wdXNoKG9wdGlvbnMpO1xuICAgIGlmICh0aGlzLmJhdGNoT3B0aW9ucy5sZW5ndGggPT09IDEpIHtcbiAgICAgIC8vIEZpcnN0IG1lc3NhZ2Ugc3RvcmVkLCBpdCdzIHRpbWUgdG8gc3RhcnQgdGhlIHRpbWVvdXQhXG4gICAgICBjb25zdCBtZSA9IHRoaXM7XG4gICAgICB0aGlzLmJhdGNoQ2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICAgIHRoaXMuYmF0Y2hUaW1lb3V0SUQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gdGltZW91dCBpcyByZWFjaGVkLCBzZW5kIGFsbCBtZXNzYWdlcyB0byBlbmRwb2ludFxuICAgICAgICBtZS5iYXRjaFRpbWVvdXRJRCA9IC0xO1xuICAgICAgICBtZS5fZG9CYXRjaFJlcXVlc3QobWUuYmF0Y2hDYWxsYmFjaywgYXV0aCwgcGF0aCk7XG4gICAgICB9LCB0aGlzLmJhdGNoSW50ZXJ2YWwpO1xuICAgIH1cbiAgICBpZiAodGhpcy5iYXRjaE9wdGlvbnMubGVuZ3RoID09PSB0aGlzLmJhdGNoQ291bnQpIHtcbiAgICAgIC8vIG1heCBiYXRjaCBjb3VudCBpcyByZWFjaGVkLCBzZW5kIGFsbCBtZXNzYWdlcyB0byBlbmRwb2ludFxuICAgICAgdGhpcy5fZG9CYXRjaFJlcXVlc3QodGhpcy5iYXRjaENhbGxiYWNrLCBhdXRoLCBwYXRoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogSW5pdGlhdGUgYSByZXF1ZXN0IHdpdGggdGhlIG1lbW9yaXplZCBiYXRjaCBvcHRpb25zLCBzdG9wIHRoZSBiYXRjaCB0aW1lb3V0XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNhbGxiYWNrIC0gQ29udGludWF0aW9uIHRvIHJlc3BvbmQgdG8gd2hlbiBjb21wbGV0ZS5cbiAgICogQHBhcmFtIHtPYmplY3Q/fSBhdXRoIC0gYXV0aGVudGljYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCAtIHJlcXVlc3QgcGF0aFxuICAgKi9cbiAgX2RvQmF0Y2hSZXF1ZXN0KGNhbGxiYWNrLCBhdXRoLCBwYXRoKSB7XG4gICAgaWYgKHRoaXMuYmF0Y2hUaW1lb3V0SUQgPiAwKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5iYXRjaFRpbWVvdXRJRCk7XG4gICAgICB0aGlzLmJhdGNoVGltZW91dElEID0gLTE7XG4gICAgfVxuICAgIGNvbnN0IGJhdGNoT3B0aW9uc0NvcHkgPSB0aGlzLmJhdGNoT3B0aW9ucy5zbGljZSgpO1xuICAgIHRoaXMuYmF0Y2hPcHRpb25zID0gW107XG4gICAgdGhpcy5fZG9SZXF1ZXN0KGJhdGNoT3B0aW9uc0NvcHksIGNhbGxiYWNrLCBhdXRoLCBwYXRoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNYWtlIGEgcmVxdWVzdCB0byBhIHdpbnN0b25kIHNlcnZlciBvciBhbnkgaHR0cCBzZXJ2ZXIgd2hpY2ggY2FuXG4gICAqIGhhbmRsZSBqc29uLXJwYy5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gc2VudCB0aGUgcmVxdWVzdC5cbiAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2FsbGJhY2sgLSBDb250aW51YXRpb24gdG8gcmVzcG9uZCB0byB3aGVuIGNvbXBsZXRlLlxuICAgKiBAcGFyYW0ge09iamVjdD99IGF1dGggLSBhdXRoZW50aWNhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoIC0gcmVxdWVzdCBwYXRoXG4gICAqL1xuICBfZG9SZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrLCBhdXRoLCBwYXRoKSB7XG4gICAgLy8gUHJlcGFyZSBvcHRpb25zIGZvciBvdXRnb2luZyBIVFRQIHJlcXVlc3RcbiAgICBjb25zdCBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oZWFkZXJzKTtcbiAgICBpZiAoYXV0aCAmJiBhdXRoLmJlYXJlcikge1xuICAgICAgaGVhZGVycy5BdXRob3JpemF0aW9uID0gYEJlYXJlciAke2F1dGguYmVhcmVyfWA7XG4gICAgfVxuICAgIGNvbnN0IHJlcSA9ICh0aGlzLnNzbCA/IGh0dHBzIDogaHR0cCkucmVxdWVzdCh7XG4gICAgICAuLi50aGlzLm9wdGlvbnMsXG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGhvc3Q6IHRoaXMuaG9zdCxcbiAgICAgIHBvcnQ6IHRoaXMucG9ydCxcbiAgICAgIHBhdGg6IGAvJHtwYXRoLnJlcGxhY2UoL15cXC8vLCAnJyl9YCxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICBhdXRoOiAoYXV0aCAmJiBhdXRoLnVzZXJuYW1lICYmIGF1dGgucGFzc3dvcmQpID8gKGAke2F1dGgudXNlcm5hbWV9OiR7YXV0aC5wYXNzd29yZH1gKSA6ICcnLFxuICAgICAgYWdlbnQ6IHRoaXMuYWdlbnRcbiAgICB9KTtcblxuICAgIHJlcS5vbignZXJyb3InLCBjYWxsYmFjayk7XG4gICAgcmVxLm9uKCdyZXNwb25zZScsIHJlcyA9PiAoXG4gICAgICByZXMub24oJ2VuZCcsICgpID0+IGNhbGxiYWNrKG51bGwsIHJlcykpLnJlc3VtZSgpXG4gICAgKSk7XG4gICAgY29uc3QganNvblN0cmluZ2lmeSA9IGNvbmZpZ3VyZSh7XG4gICAgICAuLi4odGhpcy5tYXhpbXVtRGVwdGggJiYgeyBtYXhpbXVtRGVwdGg6IHRoaXMubWF4aW11bURlcHRoIH0pXG4gICAgfSk7XG4gICAgcmVxLmVuZChCdWZmZXIuZnJvbShqc29uU3RyaW5naWZ5KG9wdGlvbnMsIHRoaXMub3B0aW9ucy5yZXBsYWNlciksICd1dGY4JykpO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/transports/http.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/transports/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/winston/lib/winston/transports/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/**\n * transports.js: Set of all transports Winston knows about.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\n/**\n * TODO: add property description.\n * @type {Console}\n */\nObject.defineProperty(exports, \"Console\", ({\n  configurable: true,\n  enumerable: true,\n  get() {\n    return __webpack_require__(/*! ./console */ \"(rsc)/./node_modules/winston/lib/winston/transports/console.js\");\n  }\n}));\n\n/**\n * TODO: add property description.\n * @type {File}\n */\nObject.defineProperty(exports, \"File\", ({\n  configurable: true,\n  enumerable: true,\n  get() {\n    return __webpack_require__(/*! ./file */ \"(rsc)/./node_modules/winston/lib/winston/transports/file.js\");\n  }\n}));\n\n/**\n * TODO: add property description.\n * @type {Http}\n */\nObject.defineProperty(exports, \"Http\", ({\n  configurable: true,\n  enumerable: true,\n  get() {\n    return __webpack_require__(/*! ./http */ \"(rsc)/./node_modules/winston/lib/winston/transports/http.js\");\n  }\n}));\n\n/**\n * TODO: add property description.\n * @type {Stream}\n */\nObject.defineProperty(exports, \"Stream\", ({\n  configurable: true,\n  enumerable: true,\n  get() {\n    return __webpack_require__(/*! ./stream */ \"(rsc)/./node_modules/winston/lib/winston/transports/stream.js\");\n  }\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90cmFuc3BvcnRzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMkNBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQyxpRkFBVztBQUM5QjtBQUNBLENBQUMsRUFBQzs7QUFFRjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQywyRUFBUTtBQUMzQjtBQUNBLENBQUMsRUFBQzs7QUFFRjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0Esd0NBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQywyRUFBUTtBQUMzQjtBQUNBLENBQUMsRUFBQzs7QUFFRjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMENBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQU8sQ0FBQywrRUFBVTtBQUM3QjtBQUNBLENBQUMsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy93aW5zdG9uL2xpYi93aW5zdG9uL3RyYW5zcG9ydHMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiB0cmFuc3BvcnRzLmpzOiBTZXQgb2YgYWxsIHRyYW5zcG9ydHMgV2luc3RvbiBrbm93cyBhYm91dC5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFRPRE86IGFkZCBwcm9wZXJ0eSBkZXNjcmlwdGlvbi5cbiAqIEB0eXBlIHtDb25zb2xlfVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ0NvbnNvbGUnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0KCkge1xuICAgIHJldHVybiByZXF1aXJlKCcuL2NvbnNvbGUnKTtcbiAgfVxufSk7XG5cbi8qKlxuICogVE9ETzogYWRkIHByb3BlcnR5IGRlc2NyaXB0aW9uLlxuICogQHR5cGUge0ZpbGV9XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnRmlsZScsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQoKSB7XG4gICAgcmV0dXJuIHJlcXVpcmUoJy4vZmlsZScpO1xuICB9XG59KTtcblxuLyoqXG4gKiBUT0RPOiBhZGQgcHJvcGVydHkgZGVzY3JpcHRpb24uXG4gKiBAdHlwZSB7SHR0cH1cbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdIdHRwJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldCgpIHtcbiAgICByZXR1cm4gcmVxdWlyZSgnLi9odHRwJyk7XG4gIH1cbn0pO1xuXG4vKipcbiAqIFRPRE86IGFkZCBwcm9wZXJ0eSBkZXNjcmlwdGlvbi5cbiAqIEB0eXBlIHtTdHJlYW19XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnU3RyZWFtJywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldCgpIHtcbiAgICByZXR1cm4gcmVxdWlyZSgnLi9zdHJlYW0nKTtcbiAgfVxufSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/transports/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/lib/winston/transports/stream.js":
/*!***************************************************************!*\
  !*** ./node_modules/winston/lib/winston/transports/stream.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * stream.js: Transport for outputting to any arbitrary stream.\n *\n * (C) 2010 Charlie Robbins\n * MIT LICENCE\n */\n\n\n\nconst isStream = __webpack_require__(/*! is-stream */ \"(rsc)/./node_modules/is-stream/index.js\");\nconst { MESSAGE } = __webpack_require__(/*! triple-beam */ \"(rsc)/./node_modules/triple-beam/index.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst TransportStream = __webpack_require__(/*! winston-transport */ \"(rsc)/./node_modules/winston-transport/index.js\");\n\n/**\n * Transport for outputting to any arbitrary stream.\n * @type {Stream}\n * @extends {TransportStream}\n */\nmodule.exports = class Stream extends TransportStream {\n  /**\n   * Constructor function for the Console transport object responsible for\n   * persisting log messages and metadata to a terminal or TTY.\n   * @param {!Object} [options={}] - Options for this instance.\n   */\n  constructor(options = {}) {\n    super(options);\n\n    if (!options.stream || !isStream(options.stream)) {\n      throw new Error('options.stream is required.');\n    }\n\n    // We need to listen for drain events when write() returns false. This can\n    // make node mad at times.\n    this._stream = options.stream;\n    this._stream.setMaxListeners(Infinity);\n    this.isObjectMode = options.stream._writableState.objectMode;\n    this.eol = (typeof options.eol === 'string') ? options.eol : os.EOL;\n  }\n\n  /**\n   * Core logging method exposed to Winston.\n   * @param {Object} info - TODO: add param description.\n   * @param {Function} callback - TODO: add param description.\n   * @returns {undefined}\n   */\n  log(info, callback) {\n    setImmediate(() => this.emit('logged', info));\n    if (this.isObjectMode) {\n      this._stream.write(info);\n      if (callback) {\n        callback(); // eslint-disable-line callback-return\n      }\n      return;\n    }\n\n    this._stream.write(`${info[MESSAGE]}${this.eol}`);\n    if (callback) {\n      callback(); // eslint-disable-line callback-return\n    }\n    return;\n  }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvd2luc3Rvbi9saWIvd2luc3Rvbi90cmFuc3BvcnRzL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsaUJBQWlCLG1CQUFPLENBQUMsMERBQVc7QUFDcEMsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyw4REFBYTtBQUN6QyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2Qix3QkFBd0IsbUJBQU8sQ0FBQywwRUFBbUI7O0FBRW5EO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVMsV0FBVztBQUNqQztBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCLGNBQWMsRUFBRSxTQUFTO0FBQ25EO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3dpbnN0b24vbGliL3dpbnN0b24vdHJhbnNwb3J0cy9zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBzdHJlYW0uanM6IFRyYW5zcG9ydCBmb3Igb3V0cHV0dGluZyB0byBhbnkgYXJiaXRyYXJ5IHN0cmVhbS5cbiAqXG4gKiAoQykgMjAxMCBDaGFybGllIFJvYmJpbnNcbiAqIE1JVCBMSUNFTkNFXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBpc1N0cmVhbSA9IHJlcXVpcmUoJ2lzLXN0cmVhbScpO1xuY29uc3QgeyBNRVNTQUdFIH0gPSByZXF1aXJlKCd0cmlwbGUtYmVhbScpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgVHJhbnNwb3J0U3RyZWFtID0gcmVxdWlyZSgnd2luc3Rvbi10cmFuc3BvcnQnKTtcblxuLyoqXG4gKiBUcmFuc3BvcnQgZm9yIG91dHB1dHRpbmcgdG8gYW55IGFyYml0cmFyeSBzdHJlYW0uXG4gKiBAdHlwZSB7U3RyZWFtfVxuICogQGV4dGVuZHMge1RyYW5zcG9ydFN0cmVhbX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBjbGFzcyBTdHJlYW0gZXh0ZW5kcyBUcmFuc3BvcnRTdHJlYW0ge1xuICAvKipcbiAgICogQ29uc3RydWN0b3IgZnVuY3Rpb24gZm9yIHRoZSBDb25zb2xlIHRyYW5zcG9ydCBvYmplY3QgcmVzcG9uc2libGUgZm9yXG4gICAqIHBlcnNpc3RpbmcgbG9nIG1lc3NhZ2VzIGFuZCBtZXRhZGF0YSB0byBhIHRlcm1pbmFsIG9yIFRUWS5cbiAgICogQHBhcmFtIHshT2JqZWN0fSBbb3B0aW9ucz17fV0gLSBPcHRpb25zIGZvciB0aGlzIGluc3RhbmNlLlxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG5cbiAgICBpZiAoIW9wdGlvbnMuc3RyZWFtIHx8ICFpc1N0cmVhbShvcHRpb25zLnN0cmVhbSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignb3B0aW9ucy5zdHJlYW0gaXMgcmVxdWlyZWQuJyk7XG4gICAgfVxuXG4gICAgLy8gV2UgbmVlZCB0byBsaXN0ZW4gZm9yIGRyYWluIGV2ZW50cyB3aGVuIHdyaXRlKCkgcmV0dXJucyBmYWxzZS4gVGhpcyBjYW5cbiAgICAvLyBtYWtlIG5vZGUgbWFkIGF0IHRpbWVzLlxuICAgIHRoaXMuX3N0cmVhbSA9IG9wdGlvbnMuc3RyZWFtO1xuICAgIHRoaXMuX3N0cmVhbS5zZXRNYXhMaXN0ZW5lcnMoSW5maW5pdHkpO1xuICAgIHRoaXMuaXNPYmplY3RNb2RlID0gb3B0aW9ucy5zdHJlYW0uX3dyaXRhYmxlU3RhdGUub2JqZWN0TW9kZTtcbiAgICB0aGlzLmVvbCA9ICh0eXBlb2Ygb3B0aW9ucy5lb2wgPT09ICdzdHJpbmcnKSA/IG9wdGlvbnMuZW9sIDogb3MuRU9MO1xuICB9XG5cbiAgLyoqXG4gICAqIENvcmUgbG9nZ2luZyBtZXRob2QgZXhwb3NlZCB0byBXaW5zdG9uLlxuICAgKiBAcGFyYW0ge09iamVjdH0gaW5mbyAtIFRPRE86IGFkZCBwYXJhbSBkZXNjcmlwdGlvbi5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUT0RPOiBhZGQgcGFyYW0gZGVzY3JpcHRpb24uXG4gICAqIEByZXR1cm5zIHt1bmRlZmluZWR9XG4gICAqL1xuICBsb2coaW5mbywgY2FsbGJhY2spIHtcbiAgICBzZXRJbW1lZGlhdGUoKCkgPT4gdGhpcy5lbWl0KCdsb2dnZWQnLCBpbmZvKSk7XG4gICAgaWYgKHRoaXMuaXNPYmplY3RNb2RlKSB7XG4gICAgICB0aGlzLl9zdHJlYW0ud3JpdGUoaW5mbyk7XG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9zdHJlYW0ud3JpdGUoYCR7aW5mb1tNRVNTQUdFXX0ke3RoaXMuZW9sfWApO1xuICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgY2FsbGJhY2soKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBjYWxsYmFjay1yZXR1cm5cbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/winston/lib/winston/transports/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/winston/package.json":
/*!*******************************************!*\
  !*** ./node_modules/winston/package.json ***!
  \*******************************************/
/***/ ((module) => {

module.exports = /*#__PURE__*/JSON.parse('{"name":"winston","description":"A logger for just about everything.","version":"3.17.0","author":"Charlie Robbins <charlie.robbins@gmail.com>","maintainers":["David Hyde <dabh@alumni.stanford.edu>"],"repository":{"type":"git","url":"https://github.com/winstonjs/winston.git"},"keywords":["winston","logger","logging","logs","sysadmin","bunyan","pino","loglevel","tools","json","stream"],"dependencies":{"@dabh/diagnostics":"^2.0.2","@colors/colors":"^1.6.0","async":"^3.2.3","is-stream":"^2.0.0","logform":"^2.7.0","one-time":"^1.0.0","readable-stream":"^3.4.0","safe-stable-stringify":"^2.3.1","stack-trace":"0.0.x","triple-beam":"^1.3.0","winston-transport":"^4.9.0"},"devDependencies":{"@babel/cli":"^7.23.9","@babel/core":"^7.24.0","@babel/preset-env":"^7.24.0","@dabh/eslint-config-populist":"^4.4.0","@types/node":"^20.11.24","abstract-winston-transport":"^0.5.1","assume":"^2.2.0","cross-spawn-async":"^2.2.5","eslint":"^8.57.0","hock":"^1.4.1","mocha":"^10.3.0","nyc":"^17.1.0","rimraf":"5.0.1","split2":"^4.1.0","std-mocks":"^2.0.0","through2":"^4.0.2","winston-compat":"^0.1.5"},"main":"./lib/winston.js","browser":"./dist/winston","types":"./index.d.ts","scripts":{"lint":"eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist","test":"rimraf test/fixtures/logs/* && mocha","test:coverage":"nyc npm run test:unit","test:unit":"mocha test/unit","test:integration":"mocha test/integration","build":"rimraf dist && babel lib -d dist","prepublishOnly":"npm run build"},"engines":{"node":">= 12.0.0"},"license":"MIT"}');

/***/ })

};
;