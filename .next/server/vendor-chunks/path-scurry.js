"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/path-scurry";
exports.ids = ["vendor-chunks/path-scurry"];
exports.modules = {

/***/ "(rsc)/./node_modules/path-scurry/dist/commonjs/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/path-scurry/dist/commonjs/index.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.PathScurry = exports.Path = exports.PathScurryDarwin = exports.PathScurryPosix = exports.PathScurryWin32 = exports.PathScurryBase = exports.PathPosix = exports.PathWin32 = exports.PathBase = exports.ChildrenCache = exports.ResolveCache = void 0;\nconst lru_cache_1 = __webpack_require__(/*! lru-cache */ \"(rsc)/./node_modules/lru-cache/dist/commonjs/index.js\");\nconst node_path_1 = __webpack_require__(/*! node:path */ \"node:path\");\nconst node_url_1 = __webpack_require__(/*! node:url */ \"node:url\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst actualFS = __importStar(__webpack_require__(/*! node:fs */ \"node:fs\"));\nconst realpathSync = fs_1.realpathSync.native;\n// TODO: test perf of fs/promises realpath vs realpathCB,\n// since the promises one uses realpath.native\nconst promises_1 = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\nconst minipass_1 = __webpack_require__(/*! minipass */ \"(rsc)/./node_modules/minipass/dist/commonjs/index.js\");\nconst defaultFS = {\n    lstatSync: fs_1.lstatSync,\n    readdir: fs_1.readdir,\n    readdirSync: fs_1.readdirSync,\n    readlinkSync: fs_1.readlinkSync,\n    realpathSync,\n    promises: {\n        lstat: promises_1.lstat,\n        readdir: promises_1.readdir,\n        readlink: promises_1.readlink,\n        realpath: promises_1.realpath,\n    },\n};\n// if they just gave us require('fs') then use our default\nconst fsFromOption = (fsOption) => !fsOption || fsOption === defaultFS || fsOption === actualFS ?\n    defaultFS\n    : {\n        ...defaultFS,\n        ...fsOption,\n        promises: {\n            ...defaultFS.promises,\n            ...(fsOption.promises || {}),\n        },\n    };\n// turn something like //?/c:/ into c:\\\nconst uncDriveRegexp = /^\\\\\\\\\\?\\\\([a-z]:)\\\\?$/i;\nconst uncToDrive = (rootPath) => rootPath.replace(/\\//g, '\\\\').replace(uncDriveRegexp, '$1\\\\');\n// windows paths are separated by either / or \\\nconst eitherSep = /[\\\\\\/]/;\nconst UNKNOWN = 0; // may not even exist, for all we know\nconst IFIFO = 0b0001;\nconst IFCHR = 0b0010;\nconst IFDIR = 0b0100;\nconst IFBLK = 0b0110;\nconst IFREG = 0b1000;\nconst IFLNK = 0b1010;\nconst IFSOCK = 0b1100;\nconst IFMT = 0b1111;\n// mask to unset low 4 bits\nconst IFMT_UNKNOWN = ~IFMT;\n// set after successfully calling readdir() and getting entries.\nconst READDIR_CALLED = 0b0000_0001_0000;\n// set after a successful lstat()\nconst LSTAT_CALLED = 0b0000_0010_0000;\n// set if an entry (or one of its parents) is definitely not a dir\nconst ENOTDIR = 0b0000_0100_0000;\n// set if an entry (or one of its parents) does not exist\n// (can also be set on lstat errors like EACCES or ENAMETOOLONG)\nconst ENOENT = 0b0000_1000_0000;\n// cannot have child entries -- also verify &IFMT is either IFDIR or IFLNK\n// set if we fail to readlink\nconst ENOREADLINK = 0b0001_0000_0000;\n// set if we know realpath() will fail\nconst ENOREALPATH = 0b0010_0000_0000;\nconst ENOCHILD = ENOTDIR | ENOENT | ENOREALPATH;\nconst TYPEMASK = 0b0011_1111_1111;\nconst entToType = (s) => s.isFile() ? IFREG\n    : s.isDirectory() ? IFDIR\n        : s.isSymbolicLink() ? IFLNK\n            : s.isCharacterDevice() ? IFCHR\n                : s.isBlockDevice() ? IFBLK\n                    : s.isSocket() ? IFSOCK\n                        : s.isFIFO() ? IFIFO\n                            : UNKNOWN;\n// normalize unicode path names\nconst normalizeCache = new Map();\nconst normalize = (s) => {\n    const c = normalizeCache.get(s);\n    if (c)\n        return c;\n    const n = s.normalize('NFKD');\n    normalizeCache.set(s, n);\n    return n;\n};\nconst normalizeNocaseCache = new Map();\nconst normalizeNocase = (s) => {\n    const c = normalizeNocaseCache.get(s);\n    if (c)\n        return c;\n    const n = normalize(s.toLowerCase());\n    normalizeNocaseCache.set(s, n);\n    return n;\n};\n/**\n * An LRUCache for storing resolved path strings or Path objects.\n * @internal\n */\nclass ResolveCache extends lru_cache_1.LRUCache {\n    constructor() {\n        super({ max: 256 });\n    }\n}\nexports.ResolveCache = ResolveCache;\n// In order to prevent blowing out the js heap by allocating hundreds of\n// thousands of Path entries when walking extremely large trees, the \"children\"\n// in this tree are represented by storing an array of Path entries in an\n// LRUCache, indexed by the parent.  At any time, Path.children() may return an\n// empty array, indicating that it doesn't know about any of its children, and\n// thus has to rebuild that cache.  This is fine, it just means that we don't\n// benefit as much from having the cached entries, but huge directory walks\n// don't blow out the stack, and smaller ones are still as fast as possible.\n//\n//It does impose some complexity when building up the readdir data, because we\n//need to pass a reference to the children array that we started with.\n/**\n * an LRUCache for storing child entries.\n * @internal\n */\nclass ChildrenCache extends lru_cache_1.LRUCache {\n    constructor(maxSize = 16 * 1024) {\n        super({\n            maxSize,\n            // parent + children\n            sizeCalculation: a => a.length + 1,\n        });\n    }\n}\nexports.ChildrenCache = ChildrenCache;\nconst setAsCwd = Symbol('PathScurry setAsCwd');\n/**\n * Path objects are sort of like a super-powered\n * {@link https://nodejs.org/docs/latest/api/fs.html#class-fsdirent fs.Dirent}\n *\n * Each one represents a single filesystem entry on disk, which may or may not\n * exist. It includes methods for reading various types of information via\n * lstat, readlink, and readdir, and caches all information to the greatest\n * degree possible.\n *\n * Note that fs operations that would normally throw will instead return an\n * \"empty\" value. This is in order to prevent excessive overhead from error\n * stack traces.\n */\nclass PathBase {\n    /**\n     * the basename of this path\n     *\n     * **Important**: *always* test the path name against any test string\n     * usingthe {@link isNamed} method, and not by directly comparing this\n     * string. Otherwise, unicode path strings that the system sees as identical\n     * will not be properly treated as the same path, leading to incorrect\n     * behavior and possible security issues.\n     */\n    name;\n    /**\n     * the Path entry corresponding to the path root.\n     *\n     * @internal\n     */\n    root;\n    /**\n     * All roots found within the current PathScurry family\n     *\n     * @internal\n     */\n    roots;\n    /**\n     * a reference to the parent path, or undefined in the case of root entries\n     *\n     * @internal\n     */\n    parent;\n    /**\n     * boolean indicating whether paths are compared case-insensitively\n     * @internal\n     */\n    nocase;\n    /**\n     * boolean indicating that this path is the current working directory\n     * of the PathScurry collection that contains it.\n     */\n    isCWD = false;\n    // potential default fs override\n    #fs;\n    // Stats fields\n    #dev;\n    get dev() {\n        return this.#dev;\n    }\n    #mode;\n    get mode() {\n        return this.#mode;\n    }\n    #nlink;\n    get nlink() {\n        return this.#nlink;\n    }\n    #uid;\n    get uid() {\n        return this.#uid;\n    }\n    #gid;\n    get gid() {\n        return this.#gid;\n    }\n    #rdev;\n    get rdev() {\n        return this.#rdev;\n    }\n    #blksize;\n    get blksize() {\n        return this.#blksize;\n    }\n    #ino;\n    get ino() {\n        return this.#ino;\n    }\n    #size;\n    get size() {\n        return this.#size;\n    }\n    #blocks;\n    get blocks() {\n        return this.#blocks;\n    }\n    #atimeMs;\n    get atimeMs() {\n        return this.#atimeMs;\n    }\n    #mtimeMs;\n    get mtimeMs() {\n        return this.#mtimeMs;\n    }\n    #ctimeMs;\n    get ctimeMs() {\n        return this.#ctimeMs;\n    }\n    #birthtimeMs;\n    get birthtimeMs() {\n        return this.#birthtimeMs;\n    }\n    #atime;\n    get atime() {\n        return this.#atime;\n    }\n    #mtime;\n    get mtime() {\n        return this.#mtime;\n    }\n    #ctime;\n    get ctime() {\n        return this.#ctime;\n    }\n    #birthtime;\n    get birthtime() {\n        return this.#birthtime;\n    }\n    #matchName;\n    #depth;\n    #fullpath;\n    #fullpathPosix;\n    #relative;\n    #relativePosix;\n    #type;\n    #children;\n    #linkTarget;\n    #realpath;\n    /**\n     * This property is for compatibility with the Dirent class as of\n     * Node v20, where Dirent['parentPath'] refers to the path of the\n     * directory that was passed to readdir. For root entries, it's the path\n     * to the entry itself.\n     */\n    get parentPath() {\n        return (this.parent || this).fullpath();\n    }\n    /**\n     * Deprecated alias for Dirent['parentPath'] Somewhat counterintuitively,\n     * this property refers to the *parent* path, not the path object itself.\n     */\n    get path() {\n        return this.parentPath;\n    }\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        this.name = name;\n        this.#matchName = nocase ? normalizeNocase(name) : normalize(name);\n        this.#type = type & TYPEMASK;\n        this.nocase = nocase;\n        this.roots = roots;\n        this.root = root || this;\n        this.#children = children;\n        this.#fullpath = opts.fullpath;\n        this.#relative = opts.relative;\n        this.#relativePosix = opts.relativePosix;\n        this.parent = opts.parent;\n        if (this.parent) {\n            this.#fs = this.parent.#fs;\n        }\n        else {\n            this.#fs = fsFromOption(opts.fs);\n        }\n    }\n    /**\n     * Returns the depth of the Path object from its root.\n     *\n     * For example, a path at `/foo/bar` would have a depth of 2.\n     */\n    depth() {\n        if (this.#depth !== undefined)\n            return this.#depth;\n        if (!this.parent)\n            return (this.#depth = 0);\n        return (this.#depth = this.parent.depth() + 1);\n    }\n    /**\n     * @internal\n     */\n    childrenCache() {\n        return this.#children;\n    }\n    /**\n     * Get the Path object referenced by the string path, resolved from this Path\n     */\n    resolve(path) {\n        if (!path) {\n            return this;\n        }\n        const rootPath = this.getRootString(path);\n        const dir = path.substring(rootPath.length);\n        const dirParts = dir.split(this.splitSep);\n        const result = rootPath ?\n            this.getRoot(rootPath).#resolveParts(dirParts)\n            : this.#resolveParts(dirParts);\n        return result;\n    }\n    #resolveParts(dirParts) {\n        let p = this;\n        for (const part of dirParts) {\n            p = p.child(part);\n        }\n        return p;\n    }\n    /**\n     * Returns the cached children Path objects, if still available.  If they\n     * have fallen out of the cache, then returns an empty array, and resets the\n     * READDIR_CALLED bit, so that future calls to readdir() will require an fs\n     * lookup.\n     *\n     * @internal\n     */\n    children() {\n        const cached = this.#children.get(this);\n        if (cached) {\n            return cached;\n        }\n        const children = Object.assign([], { provisional: 0 });\n        this.#children.set(this, children);\n        this.#type &= ~READDIR_CALLED;\n        return children;\n    }\n    /**\n     * Resolves a path portion and returns or creates the child Path.\n     *\n     * Returns `this` if pathPart is `''` or `'.'`, or `parent` if pathPart is\n     * `'..'`.\n     *\n     * This should not be called directly.  If `pathPart` contains any path\n     * separators, it will lead to unsafe undefined behavior.\n     *\n     * Use `Path.resolve()` instead.\n     *\n     * @internal\n     */\n    child(pathPart, opts) {\n        if (pathPart === '' || pathPart === '.') {\n            return this;\n        }\n        if (pathPart === '..') {\n            return this.parent || this;\n        }\n        // find the child\n        const children = this.children();\n        const name = this.nocase ? normalizeNocase(pathPart) : normalize(pathPart);\n        for (const p of children) {\n            if (p.#matchName === name) {\n                return p;\n            }\n        }\n        // didn't find it, create provisional child, since it might not\n        // actually exist.  If we know the parent isn't a dir, then\n        // in fact it CAN'T exist.\n        const s = this.parent ? this.sep : '';\n        const fullpath = this.#fullpath ? this.#fullpath + s + pathPart : undefined;\n        const pchild = this.newChild(pathPart, UNKNOWN, {\n            ...opts,\n            parent: this,\n            fullpath,\n        });\n        if (!this.canReaddir()) {\n            pchild.#type |= ENOENT;\n        }\n        // don't have to update provisional, because if we have real children,\n        // then provisional is set to children.length, otherwise a lower number\n        children.push(pchild);\n        return pchild;\n    }\n    /**\n     * The relative path from the cwd. If it does not share an ancestor with\n     * the cwd, then this ends up being equivalent to the fullpath()\n     */\n    relative() {\n        if (this.isCWD)\n            return '';\n        if (this.#relative !== undefined) {\n            return this.#relative;\n        }\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#relative = this.name);\n        }\n        const pv = p.relative();\n        return pv + (!pv || !p.parent ? '' : this.sep) + name;\n    }\n    /**\n     * The relative path from the cwd, using / as the path separator.\n     * If it does not share an ancestor with\n     * the cwd, then this ends up being equivalent to the fullpathPosix()\n     * On posix systems, this is identical to relative().\n     */\n    relativePosix() {\n        if (this.sep === '/')\n            return this.relative();\n        if (this.isCWD)\n            return '';\n        if (this.#relativePosix !== undefined)\n            return this.#relativePosix;\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#relativePosix = this.fullpathPosix());\n        }\n        const pv = p.relativePosix();\n        return pv + (!pv || !p.parent ? '' : '/') + name;\n    }\n    /**\n     * The fully resolved path string for this Path entry\n     */\n    fullpath() {\n        if (this.#fullpath !== undefined) {\n            return this.#fullpath;\n        }\n        const name = this.name;\n        const p = this.parent;\n        if (!p) {\n            return (this.#fullpath = this.name);\n        }\n        const pv = p.fullpath();\n        const fp = pv + (!p.parent ? '' : this.sep) + name;\n        return (this.#fullpath = fp);\n    }\n    /**\n     * On platforms other than windows, this is identical to fullpath.\n     *\n     * On windows, this is overridden to return the forward-slash form of the\n     * full UNC path.\n     */\n    fullpathPosix() {\n        if (this.#fullpathPosix !== undefined)\n            return this.#fullpathPosix;\n        if (this.sep === '/')\n            return (this.#fullpathPosix = this.fullpath());\n        if (!this.parent) {\n            const p = this.fullpath().replace(/\\\\/g, '/');\n            if (/^[a-z]:\\//i.test(p)) {\n                return (this.#fullpathPosix = `//?/${p}`);\n            }\n            else {\n                return (this.#fullpathPosix = p);\n            }\n        }\n        const p = this.parent;\n        const pfpp = p.fullpathPosix();\n        const fpp = pfpp + (!pfpp || !p.parent ? '' : '/') + this.name;\n        return (this.#fullpathPosix = fpp);\n    }\n    /**\n     * Is the Path of an unknown type?\n     *\n     * Note that we might know *something* about it if there has been a previous\n     * filesystem operation, for example that it does not exist, or is not a\n     * link, or whether it has child entries.\n     */\n    isUnknown() {\n        return (this.#type & IFMT) === UNKNOWN;\n    }\n    isType(type) {\n        return this[`is${type}`]();\n    }\n    getType() {\n        return (this.isUnknown() ? 'Unknown'\n            : this.isDirectory() ? 'Directory'\n                : this.isFile() ? 'File'\n                    : this.isSymbolicLink() ? 'SymbolicLink'\n                        : this.isFIFO() ? 'FIFO'\n                            : this.isCharacterDevice() ? 'CharacterDevice'\n                                : this.isBlockDevice() ? 'BlockDevice'\n                                    : /* c8 ignore start */ this.isSocket() ? 'Socket'\n                                        : 'Unknown');\n        /* c8 ignore stop */\n    }\n    /**\n     * Is the Path a regular file?\n     */\n    isFile() {\n        return (this.#type & IFMT) === IFREG;\n    }\n    /**\n     * Is the Path a directory?\n     */\n    isDirectory() {\n        return (this.#type & IFMT) === IFDIR;\n    }\n    /**\n     * Is the path a character device?\n     */\n    isCharacterDevice() {\n        return (this.#type & IFMT) === IFCHR;\n    }\n    /**\n     * Is the path a block device?\n     */\n    isBlockDevice() {\n        return (this.#type & IFMT) === IFBLK;\n    }\n    /**\n     * Is the path a FIFO pipe?\n     */\n    isFIFO() {\n        return (this.#type & IFMT) === IFIFO;\n    }\n    /**\n     * Is the path a socket?\n     */\n    isSocket() {\n        return (this.#type & IFMT) === IFSOCK;\n    }\n    /**\n     * Is the path a symbolic link?\n     */\n    isSymbolicLink() {\n        return (this.#type & IFLNK) === IFLNK;\n    }\n    /**\n     * Return the entry if it has been subject of a successful lstat, or\n     * undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* simply\n     * mean that we haven't called lstat on it.\n     */\n    lstatCached() {\n        return this.#type & LSTAT_CALLED ? this : undefined;\n    }\n    /**\n     * Return the cached link target if the entry has been the subject of a\n     * successful readlink, or undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * readlink() has been called at some point.\n     */\n    readlinkCached() {\n        return this.#linkTarget;\n    }\n    /**\n     * Returns the cached realpath target if the entry has been the subject\n     * of a successful realpath, or undefined otherwise.\n     *\n     * Does not read the filesystem, so an undefined result *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * realpath() has been called at some point.\n     */\n    realpathCached() {\n        return this.#realpath;\n    }\n    /**\n     * Returns the cached child Path entries array if the entry has been the\n     * subject of a successful readdir(), or [] otherwise.\n     *\n     * Does not read the filesystem, so an empty array *could* just mean we\n     * don't have any cached data. Only use it if you are very sure that a\n     * readdir() has been called recently enough to still be valid.\n     */\n    readdirCached() {\n        const children = this.children();\n        return children.slice(0, children.provisional);\n    }\n    /**\n     * Return true if it's worth trying to readlink.  Ie, we don't (yet) have\n     * any indication that readlink will definitely fail.\n     *\n     * Returns false if the path is known to not be a symlink, if a previous\n     * readlink failed, or if the entry does not exist.\n     */\n    canReadlink() {\n        if (this.#linkTarget)\n            return true;\n        if (!this.parent)\n            return false;\n        // cases where it cannot possibly succeed\n        const ifmt = this.#type & IFMT;\n        return !((ifmt !== UNKNOWN && ifmt !== IFLNK) ||\n            this.#type & ENOREADLINK ||\n            this.#type & ENOENT);\n    }\n    /**\n     * Return true if readdir has previously been successfully called on this\n     * path, indicating that cachedReaddir() is likely valid.\n     */\n    calledReaddir() {\n        return !!(this.#type & READDIR_CALLED);\n    }\n    /**\n     * Returns true if the path is known to not exist. That is, a previous lstat\n     * or readdir failed to verify its existence when that would have been\n     * expected, or a parent entry was marked either enoent or enotdir.\n     */\n    isENOENT() {\n        return !!(this.#type & ENOENT);\n    }\n    /**\n     * Return true if the path is a match for the given path name.  This handles\n     * case sensitivity and unicode normalization.\n     *\n     * Note: even on case-sensitive systems, it is **not** safe to test the\n     * equality of the `.name` property to determine whether a given pathname\n     * matches, due to unicode normalization mismatches.\n     *\n     * Always use this method instead of testing the `path.name` property\n     * directly.\n     */\n    isNamed(n) {\n        return !this.nocase ?\n            this.#matchName === normalize(n)\n            : this.#matchName === normalizeNocase(n);\n    }\n    /**\n     * Return the Path object corresponding to the target of a symbolic link.\n     *\n     * If the Path is not a symbolic link, or if the readlink call fails for any\n     * reason, `undefined` is returned.\n     *\n     * Result is cached, and thus may be outdated if the filesystem is mutated.\n     */\n    async readlink() {\n        const target = this.#linkTarget;\n        if (target) {\n            return target;\n        }\n        if (!this.canReadlink()) {\n            return undefined;\n        }\n        /* c8 ignore start */\n        // already covered by the canReadlink test, here for ts grumples\n        if (!this.parent) {\n            return undefined;\n        }\n        /* c8 ignore stop */\n        try {\n            const read = await this.#fs.promises.readlink(this.fullpath());\n            const linkTarget = (await this.parent.realpath())?.resolve(read);\n            if (linkTarget) {\n                return (this.#linkTarget = linkTarget);\n            }\n        }\n        catch (er) {\n            this.#readlinkFail(er.code);\n            return undefined;\n        }\n    }\n    /**\n     * Synchronous {@link PathBase.readlink}\n     */\n    readlinkSync() {\n        const target = this.#linkTarget;\n        if (target) {\n            return target;\n        }\n        if (!this.canReadlink()) {\n            return undefined;\n        }\n        /* c8 ignore start */\n        // already covered by the canReadlink test, here for ts grumples\n        if (!this.parent) {\n            return undefined;\n        }\n        /* c8 ignore stop */\n        try {\n            const read = this.#fs.readlinkSync(this.fullpath());\n            const linkTarget = this.parent.realpathSync()?.resolve(read);\n            if (linkTarget) {\n                return (this.#linkTarget = linkTarget);\n            }\n        }\n        catch (er) {\n            this.#readlinkFail(er.code);\n            return undefined;\n        }\n    }\n    #readdirSuccess(children) {\n        // succeeded, mark readdir called bit\n        this.#type |= READDIR_CALLED;\n        // mark all remaining provisional children as ENOENT\n        for (let p = children.provisional; p < children.length; p++) {\n            const c = children[p];\n            if (c)\n                c.#markENOENT();\n        }\n    }\n    #markENOENT() {\n        // mark as UNKNOWN and ENOENT\n        if (this.#type & ENOENT)\n            return;\n        this.#type = (this.#type | ENOENT) & IFMT_UNKNOWN;\n        this.#markChildrenENOENT();\n    }\n    #markChildrenENOENT() {\n        // all children are provisional and do not exist\n        const children = this.children();\n        children.provisional = 0;\n        for (const p of children) {\n            p.#markENOENT();\n        }\n    }\n    #markENOREALPATH() {\n        this.#type |= ENOREALPATH;\n        this.#markENOTDIR();\n    }\n    // save the information when we know the entry is not a dir\n    #markENOTDIR() {\n        // entry is not a directory, so any children can't exist.\n        // this *should* be impossible, since any children created\n        // after it's been marked ENOTDIR should be marked ENOENT,\n        // so it won't even get to this point.\n        /* c8 ignore start */\n        if (this.#type & ENOTDIR)\n            return;\n        /* c8 ignore stop */\n        let t = this.#type;\n        // this could happen if we stat a dir, then delete it,\n        // then try to read it or one of its children.\n        if ((t & IFMT) === IFDIR)\n            t &= IFMT_UNKNOWN;\n        this.#type = t | ENOTDIR;\n        this.#markChildrenENOENT();\n    }\n    #readdirFail(code = '') {\n        // markENOTDIR and markENOENT also set provisional=0\n        if (code === 'ENOTDIR' || code === 'EPERM') {\n            this.#markENOTDIR();\n        }\n        else if (code === 'ENOENT') {\n            this.#markENOENT();\n        }\n        else {\n            this.children().provisional = 0;\n        }\n    }\n    #lstatFail(code = '') {\n        // Windows just raises ENOENT in this case, disable for win CI\n        /* c8 ignore start */\n        if (code === 'ENOTDIR') {\n            // already know it has a parent by this point\n            const p = this.parent;\n            p.#markENOTDIR();\n        }\n        else if (code === 'ENOENT') {\n            /* c8 ignore stop */\n            this.#markENOENT();\n        }\n    }\n    #readlinkFail(code = '') {\n        let ter = this.#type;\n        ter |= ENOREADLINK;\n        if (code === 'ENOENT')\n            ter |= ENOENT;\n        // windows gets a weird error when you try to readlink a file\n        if (code === 'EINVAL' || code === 'UNKNOWN') {\n            // exists, but not a symlink, we don't know WHAT it is, so remove\n            // all IFMT bits.\n            ter &= IFMT_UNKNOWN;\n        }\n        this.#type = ter;\n        // windows just gets ENOENT in this case.  We do cover the case,\n        // just disabled because it's impossible on Windows CI\n        /* c8 ignore start */\n        if (code === 'ENOTDIR' && this.parent) {\n            this.parent.#markENOTDIR();\n        }\n        /* c8 ignore stop */\n    }\n    #readdirAddChild(e, c) {\n        return (this.#readdirMaybePromoteChild(e, c) ||\n            this.#readdirAddNewChild(e, c));\n    }\n    #readdirAddNewChild(e, c) {\n        // alloc new entry at head, so it's never provisional\n        const type = entToType(e);\n        const child = this.newChild(e.name, type, { parent: this });\n        const ifmt = child.#type & IFMT;\n        if (ifmt !== IFDIR && ifmt !== IFLNK && ifmt !== UNKNOWN) {\n            child.#type |= ENOTDIR;\n        }\n        c.unshift(child);\n        c.provisional++;\n        return child;\n    }\n    #readdirMaybePromoteChild(e, c) {\n        for (let p = c.provisional; p < c.length; p++) {\n            const pchild = c[p];\n            const name = this.nocase ? normalizeNocase(e.name) : normalize(e.name);\n            if (name !== pchild.#matchName) {\n                continue;\n            }\n            return this.#readdirPromoteChild(e, pchild, p, c);\n        }\n    }\n    #readdirPromoteChild(e, p, index, c) {\n        const v = p.name;\n        // retain any other flags, but set ifmt from dirent\n        p.#type = (p.#type & IFMT_UNKNOWN) | entToType(e);\n        // case sensitivity fixing when we learn the true name.\n        if (v !== e.name)\n            p.name = e.name;\n        // just advance provisional index (potentially off the list),\n        // otherwise we have to splice/pop it out and re-insert at head\n        if (index !== c.provisional) {\n            if (index === c.length - 1)\n                c.pop();\n            else\n                c.splice(index, 1);\n            c.unshift(p);\n        }\n        c.provisional++;\n        return p;\n    }\n    /**\n     * Call lstat() on this Path, and update all known information that can be\n     * determined.\n     *\n     * Note that unlike `fs.lstat()`, the returned value does not contain some\n     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n     * information is required, you will need to call `fs.lstat` yourself.\n     *\n     * If the Path refers to a nonexistent file, or if the lstat call fails for\n     * any reason, `undefined` is returned.  Otherwise the updated Path object is\n     * returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async lstat() {\n        if ((this.#type & ENOENT) === 0) {\n            try {\n                this.#applyStat(await this.#fs.promises.lstat(this.fullpath()));\n                return this;\n            }\n            catch (er) {\n                this.#lstatFail(er.code);\n            }\n        }\n    }\n    /**\n     * synchronous {@link PathBase.lstat}\n     */\n    lstatSync() {\n        if ((this.#type & ENOENT) === 0) {\n            try {\n                this.#applyStat(this.#fs.lstatSync(this.fullpath()));\n                return this;\n            }\n            catch (er) {\n                this.#lstatFail(er.code);\n            }\n        }\n    }\n    #applyStat(st) {\n        const { atime, atimeMs, birthtime, birthtimeMs, blksize, blocks, ctime, ctimeMs, dev, gid, ino, mode, mtime, mtimeMs, nlink, rdev, size, uid, } = st;\n        this.#atime = atime;\n        this.#atimeMs = atimeMs;\n        this.#birthtime = birthtime;\n        this.#birthtimeMs = birthtimeMs;\n        this.#blksize = blksize;\n        this.#blocks = blocks;\n        this.#ctime = ctime;\n        this.#ctimeMs = ctimeMs;\n        this.#dev = dev;\n        this.#gid = gid;\n        this.#ino = ino;\n        this.#mode = mode;\n        this.#mtime = mtime;\n        this.#mtimeMs = mtimeMs;\n        this.#nlink = nlink;\n        this.#rdev = rdev;\n        this.#size = size;\n        this.#uid = uid;\n        const ifmt = entToType(st);\n        // retain any other flags, but set the ifmt\n        this.#type = (this.#type & IFMT_UNKNOWN) | ifmt | LSTAT_CALLED;\n        if (ifmt !== UNKNOWN && ifmt !== IFDIR && ifmt !== IFLNK) {\n            this.#type |= ENOTDIR;\n        }\n    }\n    #onReaddirCB = [];\n    #readdirCBInFlight = false;\n    #callOnReaddirCB(children) {\n        this.#readdirCBInFlight = false;\n        const cbs = this.#onReaddirCB.slice();\n        this.#onReaddirCB.length = 0;\n        cbs.forEach(cb => cb(null, children));\n    }\n    /**\n     * Standard node-style callback interface to get list of directory entries.\n     *\n     * If the Path cannot or does not contain any children, then an empty array\n     * is returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     *\n     * @param cb The callback called with (er, entries).  Note that the `er`\n     * param is somewhat extraneous, as all readdir() errors are handled and\n     * simply result in an empty set of entries being returned.\n     * @param allowZalgo Boolean indicating that immediately known results should\n     * *not* be deferred with `queueMicrotask`. Defaults to `false`. Release\n     * zalgo at your peril, the dark pony lord is devious and unforgiving.\n     */\n    readdirCB(cb, allowZalgo = false) {\n        if (!this.canReaddir()) {\n            if (allowZalgo)\n                cb(null, []);\n            else\n                queueMicrotask(() => cb(null, []));\n            return;\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            const c = children.slice(0, children.provisional);\n            if (allowZalgo)\n                cb(null, c);\n            else\n                queueMicrotask(() => cb(null, c));\n            return;\n        }\n        // don't have to worry about zalgo at this point.\n        this.#onReaddirCB.push(cb);\n        if (this.#readdirCBInFlight) {\n            return;\n        }\n        this.#readdirCBInFlight = true;\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        this.#fs.readdir(fullpath, { withFileTypes: true }, (er, entries) => {\n            if (er) {\n                this.#readdirFail(er.code);\n                children.provisional = 0;\n            }\n            else {\n                // if we didn't get an error, we always get entries.\n                //@ts-ignore\n                for (const e of entries) {\n                    this.#readdirAddChild(e, children);\n                }\n                this.#readdirSuccess(children);\n            }\n            this.#callOnReaddirCB(children.slice(0, children.provisional));\n            return;\n        });\n    }\n    #asyncReaddirInFlight;\n    /**\n     * Return an array of known child entries.\n     *\n     * If the Path cannot or does not contain any children, then an empty array\n     * is returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async readdir() {\n        if (!this.canReaddir()) {\n            return [];\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            return children.slice(0, children.provisional);\n        }\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        if (this.#asyncReaddirInFlight) {\n            await this.#asyncReaddirInFlight;\n        }\n        else {\n            /* c8 ignore start */\n            let resolve = () => { };\n            /* c8 ignore stop */\n            this.#asyncReaddirInFlight = new Promise(res => (resolve = res));\n            try {\n                for (const e of await this.#fs.promises.readdir(fullpath, {\n                    withFileTypes: true,\n                })) {\n                    this.#readdirAddChild(e, children);\n                }\n                this.#readdirSuccess(children);\n            }\n            catch (er) {\n                this.#readdirFail(er.code);\n                children.provisional = 0;\n            }\n            this.#asyncReaddirInFlight = undefined;\n            resolve();\n        }\n        return children.slice(0, children.provisional);\n    }\n    /**\n     * synchronous {@link PathBase.readdir}\n     */\n    readdirSync() {\n        if (!this.canReaddir()) {\n            return [];\n        }\n        const children = this.children();\n        if (this.calledReaddir()) {\n            return children.slice(0, children.provisional);\n        }\n        // else read the directory, fill up children\n        // de-provisionalize any provisional children.\n        const fullpath = this.fullpath();\n        try {\n            for (const e of this.#fs.readdirSync(fullpath, {\n                withFileTypes: true,\n            })) {\n                this.#readdirAddChild(e, children);\n            }\n            this.#readdirSuccess(children);\n        }\n        catch (er) {\n            this.#readdirFail(er.code);\n            children.provisional = 0;\n        }\n        return children.slice(0, children.provisional);\n    }\n    canReaddir() {\n        if (this.#type & ENOCHILD)\n            return false;\n        const ifmt = IFMT & this.#type;\n        // we always set ENOTDIR when setting IFMT, so should be impossible\n        /* c8 ignore start */\n        if (!(ifmt === UNKNOWN || ifmt === IFDIR || ifmt === IFLNK)) {\n            return false;\n        }\n        /* c8 ignore stop */\n        return true;\n    }\n    shouldWalk(dirs, walkFilter) {\n        return ((this.#type & IFDIR) === IFDIR &&\n            !(this.#type & ENOCHILD) &&\n            !dirs.has(this) &&\n            (!walkFilter || walkFilter(this)));\n    }\n    /**\n     * Return the Path object corresponding to path as resolved\n     * by realpath(3).\n     *\n     * If the realpath call fails for any reason, `undefined` is returned.\n     *\n     * Result is cached, and thus may be outdated if the filesystem is mutated.\n     * On success, returns a Path object.\n     */\n    async realpath() {\n        if (this.#realpath)\n            return this.#realpath;\n        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)\n            return undefined;\n        try {\n            const rp = await this.#fs.promises.realpath(this.fullpath());\n            return (this.#realpath = this.resolve(rp));\n        }\n        catch (_) {\n            this.#markENOREALPATH();\n        }\n    }\n    /**\n     * Synchronous {@link realpath}\n     */\n    realpathSync() {\n        if (this.#realpath)\n            return this.#realpath;\n        if ((ENOREALPATH | ENOREADLINK | ENOENT) & this.#type)\n            return undefined;\n        try {\n            const rp = this.#fs.realpathSync(this.fullpath());\n            return (this.#realpath = this.resolve(rp));\n        }\n        catch (_) {\n            this.#markENOREALPATH();\n        }\n    }\n    /**\n     * Internal method to mark this Path object as the scurry cwd,\n     * called by {@link PathScurry#chdir}\n     *\n     * @internal\n     */\n    [setAsCwd](oldCwd) {\n        if (oldCwd === this)\n            return;\n        oldCwd.isCWD = false;\n        this.isCWD = true;\n        const changed = new Set([]);\n        let rp = [];\n        let p = this;\n        while (p && p.parent) {\n            changed.add(p);\n            p.#relative = rp.join(this.sep);\n            p.#relativePosix = rp.join('/');\n            p = p.parent;\n            rp.push('..');\n        }\n        // now un-memoize parents of old cwd\n        p = oldCwd;\n        while (p && p.parent && !changed.has(p)) {\n            p.#relative = undefined;\n            p.#relativePosix = undefined;\n            p = p.parent;\n        }\n    }\n}\nexports.PathBase = PathBase;\n/**\n * Path class used on win32 systems\n *\n * Uses `'\\\\'` as the path separator for returned paths, either `'\\\\'` or `'/'`\n * as the path separator for parsing paths.\n */\nclass PathWin32 extends PathBase {\n    /**\n     * Separator for generating path strings.\n     */\n    sep = '\\\\';\n    /**\n     * Separator for parsing path strings.\n     */\n    splitSep = eitherSep;\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        super(name, type, root, roots, nocase, children, opts);\n    }\n    /**\n     * @internal\n     */\n    newChild(name, type = UNKNOWN, opts = {}) {\n        return new PathWin32(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n    }\n    /**\n     * @internal\n     */\n    getRootString(path) {\n        return node_path_1.win32.parse(path).root;\n    }\n    /**\n     * @internal\n     */\n    getRoot(rootPath) {\n        rootPath = uncToDrive(rootPath.toUpperCase());\n        if (rootPath === this.root.name) {\n            return this.root;\n        }\n        // ok, not that one, check if it matches another we know about\n        for (const [compare, root] of Object.entries(this.roots)) {\n            if (this.sameRoot(rootPath, compare)) {\n                return (this.roots[rootPath] = root);\n            }\n        }\n        // otherwise, have to create a new one.\n        return (this.roots[rootPath] = new PathScurryWin32(rootPath, this).root);\n    }\n    /**\n     * @internal\n     */\n    sameRoot(rootPath, compare = this.root.name) {\n        // windows can (rarely) have case-sensitive filesystem, but\n        // UNC and drive letters are always case-insensitive, and canonically\n        // represented uppercase.\n        rootPath = rootPath\n            .toUpperCase()\n            .replace(/\\//g, '\\\\')\n            .replace(uncDriveRegexp, '$1\\\\');\n        return rootPath === compare;\n    }\n}\nexports.PathWin32 = PathWin32;\n/**\n * Path class used on all posix systems.\n *\n * Uses `'/'` as the path separator.\n */\nclass PathPosix extends PathBase {\n    /**\n     * separator for parsing path strings\n     */\n    splitSep = '/';\n    /**\n     * separator for generating path strings\n     */\n    sep = '/';\n    /**\n     * Do not create new Path objects directly.  They should always be accessed\n     * via the PathScurry class or other methods on the Path class.\n     *\n     * @internal\n     */\n    constructor(name, type = UNKNOWN, root, roots, nocase, children, opts) {\n        super(name, type, root, roots, nocase, children, opts);\n    }\n    /**\n     * @internal\n     */\n    getRootString(path) {\n        return path.startsWith('/') ? '/' : '';\n    }\n    /**\n     * @internal\n     */\n    getRoot(_rootPath) {\n        return this.root;\n    }\n    /**\n     * @internal\n     */\n    newChild(name, type = UNKNOWN, opts = {}) {\n        return new PathPosix(name, type, this.root, this.roots, this.nocase, this.childrenCache(), opts);\n    }\n}\nexports.PathPosix = PathPosix;\n/**\n * The base class for all PathScurry classes, providing the interface for path\n * resolution and filesystem operations.\n *\n * Typically, you should *not* instantiate this class directly, but rather one\n * of the platform-specific classes, or the exported {@link PathScurry} which\n * defaults to the current platform.\n */\nclass PathScurryBase {\n    /**\n     * The root Path entry for the current working directory of this Scurry\n     */\n    root;\n    /**\n     * The string path for the root of this Scurry's current working directory\n     */\n    rootPath;\n    /**\n     * A collection of all roots encountered, referenced by rootPath\n     */\n    roots;\n    /**\n     * The Path entry corresponding to this PathScurry's current working directory.\n     */\n    cwd;\n    #resolveCache;\n    #resolvePosixCache;\n    #children;\n    /**\n     * Perform path comparisons case-insensitively.\n     *\n     * Defaults true on Darwin and Windows systems, false elsewhere.\n     */\n    nocase;\n    #fs;\n    /**\n     * This class should not be instantiated directly.\n     *\n     * Use PathScurryWin32, PathScurryDarwin, PathScurryPosix, or PathScurry\n     *\n     * @internal\n     */\n    constructor(cwd = process.cwd(), pathImpl, sep, { nocase, childrenCacheSize = 16 * 1024, fs = defaultFS, } = {}) {\n        this.#fs = fsFromOption(fs);\n        if (cwd instanceof URL || cwd.startsWith('file://')) {\n            cwd = (0, node_url_1.fileURLToPath)(cwd);\n        }\n        // resolve and split root, and then add to the store.\n        // this is the only time we call path.resolve()\n        const cwdPath = pathImpl.resolve(cwd);\n        this.roots = Object.create(null);\n        this.rootPath = this.parseRootPath(cwdPath);\n        this.#resolveCache = new ResolveCache();\n        this.#resolvePosixCache = new ResolveCache();\n        this.#children = new ChildrenCache(childrenCacheSize);\n        const split = cwdPath.substring(this.rootPath.length).split(sep);\n        // resolve('/') leaves '', splits to [''], we don't want that.\n        if (split.length === 1 && !split[0]) {\n            split.pop();\n        }\n        /* c8 ignore start */\n        if (nocase === undefined) {\n            throw new TypeError('must provide nocase setting to PathScurryBase ctor');\n        }\n        /* c8 ignore stop */\n        this.nocase = nocase;\n        this.root = this.newRoot(this.#fs);\n        this.roots[this.rootPath] = this.root;\n        let prev = this.root;\n        let len = split.length - 1;\n        const joinSep = pathImpl.sep;\n        let abs = this.rootPath;\n        let sawFirst = false;\n        for (const part of split) {\n            const l = len--;\n            prev = prev.child(part, {\n                relative: new Array(l).fill('..').join(joinSep),\n                relativePosix: new Array(l).fill('..').join('/'),\n                fullpath: (abs += (sawFirst ? '' : joinSep) + part),\n            });\n            sawFirst = true;\n        }\n        this.cwd = prev;\n    }\n    /**\n     * Get the depth of a provided path, string, or the cwd\n     */\n    depth(path = this.cwd) {\n        if (typeof path === 'string') {\n            path = this.cwd.resolve(path);\n        }\n        return path.depth();\n    }\n    /**\n     * Return the cache of child entries.  Exposed so subclasses can create\n     * child Path objects in a platform-specific way.\n     *\n     * @internal\n     */\n    childrenCache() {\n        return this.#children;\n    }\n    /**\n     * Resolve one or more path strings to a resolved string\n     *\n     * Same interface as require('path').resolve.\n     *\n     * Much faster than path.resolve() when called multiple times for the same\n     * path, because the resolved Path objects are cached.  Much slower\n     * otherwise.\n     */\n    resolve(...paths) {\n        // first figure out the minimum number of paths we have to test\n        // we always start at cwd, but any absolutes will bump the start\n        let r = '';\n        for (let i = paths.length - 1; i >= 0; i--) {\n            const p = paths[i];\n            if (!p || p === '.')\n                continue;\n            r = r ? `${p}/${r}` : p;\n            if (this.isAbsolute(p)) {\n                break;\n            }\n        }\n        const cached = this.#resolveCache.get(r);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const result = this.cwd.resolve(r).fullpath();\n        this.#resolveCache.set(r, result);\n        return result;\n    }\n    /**\n     * Resolve one or more path strings to a resolved string, returning\n     * the posix path.  Identical to .resolve() on posix systems, but on\n     * windows will return a forward-slash separated UNC path.\n     *\n     * Same interface as require('path').resolve.\n     *\n     * Much faster than path.resolve() when called multiple times for the same\n     * path, because the resolved Path objects are cached.  Much slower\n     * otherwise.\n     */\n    resolvePosix(...paths) {\n        // first figure out the minimum number of paths we have to test\n        // we always start at cwd, but any absolutes will bump the start\n        let r = '';\n        for (let i = paths.length - 1; i >= 0; i--) {\n            const p = paths[i];\n            if (!p || p === '.')\n                continue;\n            r = r ? `${p}/${r}` : p;\n            if (this.isAbsolute(p)) {\n                break;\n            }\n        }\n        const cached = this.#resolvePosixCache.get(r);\n        if (cached !== undefined) {\n            return cached;\n        }\n        const result = this.cwd.resolve(r).fullpathPosix();\n        this.#resolvePosixCache.set(r, result);\n        return result;\n    }\n    /**\n     * find the relative path from the cwd to the supplied path string or entry\n     */\n    relative(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.relative();\n    }\n    /**\n     * find the relative path from the cwd to the supplied path string or\n     * entry, using / as the path delimiter, even on Windows.\n     */\n    relativePosix(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.relativePosix();\n    }\n    /**\n     * Return the basename for the provided string or Path object\n     */\n    basename(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.name;\n    }\n    /**\n     * Return the dirname for the provided string or Path object\n     */\n    dirname(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return (entry.parent || entry).fullpath();\n    }\n    async readdir(entry = this.cwd, opts = {\n        withFileTypes: true,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes } = opts;\n        if (!entry.canReaddir()) {\n            return [];\n        }\n        else {\n            const p = await entry.readdir();\n            return withFileTypes ? p : p.map(e => e.name);\n        }\n    }\n    readdirSync(entry = this.cwd, opts = {\n        withFileTypes: true,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true } = opts;\n        if (!entry.canReaddir()) {\n            return [];\n        }\n        else if (withFileTypes) {\n            return entry.readdirSync();\n        }\n        else {\n            return entry.readdirSync().map(e => e.name);\n        }\n    }\n    /**\n     * Call lstat() on the string or Path object, and update all known\n     * information that can be determined.\n     *\n     * Note that unlike `fs.lstat()`, the returned value does not contain some\n     * information, such as `mode`, `dev`, `nlink`, and `ino`.  If that\n     * information is required, you will need to call `fs.lstat` yourself.\n     *\n     * If the Path refers to a nonexistent file, or if the lstat call fails for\n     * any reason, `undefined` is returned.  Otherwise the updated Path object is\n     * returned.\n     *\n     * Results are cached, and thus may be out of date if the filesystem is\n     * mutated.\n     */\n    async lstat(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.lstat();\n    }\n    /**\n     * synchronous {@link PathScurryBase.lstat}\n     */\n    lstatSync(entry = this.cwd) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        return entry.lstatSync();\n    }\n    async readlink(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = await entry.readlink();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    readlinkSync(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = entry.readlinkSync();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    async realpath(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = await entry.realpath();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    realpathSync(entry = this.cwd, { withFileTypes } = {\n        withFileTypes: false,\n    }) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            withFileTypes = entry.withFileTypes;\n            entry = this.cwd;\n        }\n        const e = entry.realpathSync();\n        return withFileTypes ? e : e?.fullpath();\n    }\n    async walk(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = [];\n        if (!filter || filter(entry)) {\n            results.push(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set();\n        const walk = (dir, cb) => {\n            dirs.add(dir);\n            dir.readdirCB((er, entries) => {\n                /* c8 ignore start */\n                if (er) {\n                    return cb(er);\n                }\n                /* c8 ignore stop */\n                let len = entries.length;\n                if (!len)\n                    return cb();\n                const next = () => {\n                    if (--len === 0) {\n                        cb();\n                    }\n                };\n                for (const e of entries) {\n                    if (!filter || filter(e)) {\n                        results.push(withFileTypes ? e : e.fullpath());\n                    }\n                    if (follow && e.isSymbolicLink()) {\n                        e.realpath()\n                            .then(r => (r?.isUnknown() ? r.lstat() : r))\n                            .then(r => r?.shouldWalk(dirs, walkFilter) ? walk(r, next) : next());\n                    }\n                    else {\n                        if (e.shouldWalk(dirs, walkFilter)) {\n                            walk(e, next);\n                        }\n                        else {\n                            next();\n                        }\n                    }\n                }\n            }, true); // zalgooooooo\n        };\n        const start = entry;\n        return new Promise((res, rej) => {\n            walk(start, er => {\n                /* c8 ignore start */\n                if (er)\n                    return rej(er);\n                /* c8 ignore stop */\n                res(results);\n            });\n        });\n    }\n    walkSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = [];\n        if (!filter || filter(entry)) {\n            results.push(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set([entry]);\n        for (const dir of dirs) {\n            const entries = dir.readdirSync();\n            for (const e of entries) {\n                if (!filter || filter(e)) {\n                    results.push(withFileTypes ? e : e.fullpath());\n                }\n                let r = e;\n                if (e.isSymbolicLink()) {\n                    if (!(follow && (r = e.realpathSync())))\n                        continue;\n                    if (r.isUnknown())\n                        r.lstatSync();\n                }\n                if (r.shouldWalk(dirs, walkFilter)) {\n                    dirs.add(r);\n                }\n            }\n        }\n        return results;\n    }\n    /**\n     * Support for `for await`\n     *\n     * Alias for {@link PathScurryBase.iterate}\n     *\n     * Note: As of Node 19, this is very slow, compared to other methods of\n     * walking.  Consider using {@link PathScurryBase.stream} if memory overhead\n     * and backpressure are concerns, or {@link PathScurryBase.walk} if not.\n     */\n    [Symbol.asyncIterator]() {\n        return this.iterate();\n    }\n    iterate(entry = this.cwd, options = {}) {\n        // iterating async over the stream is significantly more performant,\n        // especially in the warm-cache scenario, because it buffers up directory\n        // entries in the background instead of waiting for a yield for each one.\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            options = entry;\n            entry = this.cwd;\n        }\n        return this.stream(entry, options)[Symbol.asyncIterator]();\n    }\n    /**\n     * Iterating over a PathScurry performs a synchronous walk.\n     *\n     * Alias for {@link PathScurryBase.iterateSync}\n     */\n    [Symbol.iterator]() {\n        return this.iterateSync();\n    }\n    *iterateSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        if (!filter || filter(entry)) {\n            yield withFileTypes ? entry : entry.fullpath();\n        }\n        const dirs = new Set([entry]);\n        for (const dir of dirs) {\n            const entries = dir.readdirSync();\n            for (const e of entries) {\n                if (!filter || filter(e)) {\n                    yield withFileTypes ? e : e.fullpath();\n                }\n                let r = e;\n                if (e.isSymbolicLink()) {\n                    if (!(follow && (r = e.realpathSync())))\n                        continue;\n                    if (r.isUnknown())\n                        r.lstatSync();\n                }\n                if (r.shouldWalk(dirs, walkFilter)) {\n                    dirs.add(r);\n                }\n            }\n        }\n    }\n    stream(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = new minipass_1.Minipass({ objectMode: true });\n        if (!filter || filter(entry)) {\n            results.write(withFileTypes ? entry : entry.fullpath());\n        }\n        const dirs = new Set();\n        const queue = [entry];\n        let processing = 0;\n        const process = () => {\n            let paused = false;\n            while (!paused) {\n                const dir = queue.shift();\n                if (!dir) {\n                    if (processing === 0)\n                        results.end();\n                    return;\n                }\n                processing++;\n                dirs.add(dir);\n                const onReaddir = (er, entries, didRealpaths = false) => {\n                    /* c8 ignore start */\n                    if (er)\n                        return results.emit('error', er);\n                    /* c8 ignore stop */\n                    if (follow && !didRealpaths) {\n                        const promises = [];\n                        for (const e of entries) {\n                            if (e.isSymbolicLink()) {\n                                promises.push(e\n                                    .realpath()\n                                    .then((r) => r?.isUnknown() ? r.lstat() : r));\n                            }\n                        }\n                        if (promises.length) {\n                            Promise.all(promises).then(() => onReaddir(null, entries, true));\n                            return;\n                        }\n                    }\n                    for (const e of entries) {\n                        if (e && (!filter || filter(e))) {\n                            if (!results.write(withFileTypes ? e : e.fullpath())) {\n                                paused = true;\n                            }\n                        }\n                    }\n                    processing--;\n                    for (const e of entries) {\n                        const r = e.realpathCached() || e;\n                        if (r.shouldWalk(dirs, walkFilter)) {\n                            queue.push(r);\n                        }\n                    }\n                    if (paused && !results.flowing) {\n                        results.once('drain', process);\n                    }\n                    else if (!sync) {\n                        process();\n                    }\n                };\n                // zalgo containment\n                let sync = true;\n                dir.readdirCB(onReaddir, true);\n                sync = false;\n            }\n        };\n        process();\n        return results;\n    }\n    streamSync(entry = this.cwd, opts = {}) {\n        if (typeof entry === 'string') {\n            entry = this.cwd.resolve(entry);\n        }\n        else if (!(entry instanceof PathBase)) {\n            opts = entry;\n            entry = this.cwd;\n        }\n        const { withFileTypes = true, follow = false, filter, walkFilter, } = opts;\n        const results = new minipass_1.Minipass({ objectMode: true });\n        const dirs = new Set();\n        if (!filter || filter(entry)) {\n            results.write(withFileTypes ? entry : entry.fullpath());\n        }\n        const queue = [entry];\n        let processing = 0;\n        const process = () => {\n            let paused = false;\n            while (!paused) {\n                const dir = queue.shift();\n                if (!dir) {\n                    if (processing === 0)\n                        results.end();\n                    return;\n                }\n                processing++;\n                dirs.add(dir);\n                const entries = dir.readdirSync();\n                for (const e of entries) {\n                    if (!filter || filter(e)) {\n                        if (!results.write(withFileTypes ? e : e.fullpath())) {\n                            paused = true;\n                        }\n                    }\n                }\n                processing--;\n                for (const e of entries) {\n                    let r = e;\n                    if (e.isSymbolicLink()) {\n                        if (!(follow && (r = e.realpathSync())))\n                            continue;\n                        if (r.isUnknown())\n                            r.lstatSync();\n                    }\n                    if (r.shouldWalk(dirs, walkFilter)) {\n                        queue.push(r);\n                    }\n                }\n            }\n            if (paused && !results.flowing)\n                results.once('drain', process);\n        };\n        process();\n        return results;\n    }\n    chdir(path = this.cwd) {\n        const oldCwd = this.cwd;\n        this.cwd = typeof path === 'string' ? this.cwd.resolve(path) : path;\n        this.cwd[setAsCwd](oldCwd);\n    }\n}\nexports.PathScurryBase = PathScurryBase;\n/**\n * Windows implementation of {@link PathScurryBase}\n *\n * Defaults to case insensitve, uses `'\\\\'` to generate path strings.  Uses\n * {@link PathWin32} for Path objects.\n */\nclass PathScurryWin32 extends PathScurryBase {\n    /**\n     * separator for generating path strings\n     */\n    sep = '\\\\';\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = true } = opts;\n        super(cwd, node_path_1.win32, '\\\\', { ...opts, nocase });\n        this.nocase = nocase;\n        for (let p = this.cwd; p; p = p.parent) {\n            p.nocase = this.nocase;\n        }\n    }\n    /**\n     * @internal\n     */\n    parseRootPath(dir) {\n        // if the path starts with a single separator, it's not a UNC, and we'll\n        // just get separator as the root, and driveFromUNC will return \\\n        // In that case, mount \\ on the root from the cwd.\n        return node_path_1.win32.parse(dir).root.toUpperCase();\n    }\n    /**\n     * @internal\n     */\n    newRoot(fs) {\n        return new PathWin32(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });\n    }\n    /**\n     * Return true if the provided path string is an absolute path\n     */\n    isAbsolute(p) {\n        return (p.startsWith('/') || p.startsWith('\\\\') || /^[a-z]:(\\/|\\\\)/i.test(p));\n    }\n}\nexports.PathScurryWin32 = PathScurryWin32;\n/**\n * {@link PathScurryBase} implementation for all posix systems other than Darwin.\n *\n * Defaults to case-sensitive matching, uses `'/'` to generate path strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryPosix extends PathScurryBase {\n    /**\n     * separator for generating path strings\n     */\n    sep = '/';\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = false } = opts;\n        super(cwd, node_path_1.posix, '/', { ...opts, nocase });\n        this.nocase = nocase;\n    }\n    /**\n     * @internal\n     */\n    parseRootPath(_dir) {\n        return '/';\n    }\n    /**\n     * @internal\n     */\n    newRoot(fs) {\n        return new PathPosix(this.rootPath, IFDIR, undefined, this.roots, this.nocase, this.childrenCache(), { fs });\n    }\n    /**\n     * Return true if the provided path string is an absolute path\n     */\n    isAbsolute(p) {\n        return p.startsWith('/');\n    }\n}\nexports.PathScurryPosix = PathScurryPosix;\n/**\n * {@link PathScurryBase} implementation for Darwin (macOS) systems.\n *\n * Defaults to case-insensitive matching, uses `'/'` for generating path\n * strings.\n *\n * Uses {@link PathPosix} for Path objects.\n */\nclass PathScurryDarwin extends PathScurryPosix {\n    constructor(cwd = process.cwd(), opts = {}) {\n        const { nocase = true } = opts;\n        super(cwd, { ...opts, nocase });\n    }\n}\nexports.PathScurryDarwin = PathScurryDarwin;\n/**\n * Default {@link PathBase} implementation for the current platform.\n *\n * {@link PathWin32} on Windows systems, {@link PathPosix} on all others.\n */\nexports.Path = process.platform === 'win32' ? PathWin32 : PathPosix;\n/**\n * Default {@link PathScurryBase} implementation for the current platform.\n *\n * {@link PathScurryWin32} on Windows systems, {@link PathScurryDarwin} on\n * Darwin (macOS) systems, {@link PathScurryPosix} on all others.\n */\nexports.PathScurry = process.platform === 'win32' ? PathScurryWin32\n    : process.platform === 'darwin' ? PathScurryDarwin\n        : PathScurryPosix;\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcGF0aC1zY3VycnkvZGlzdC9jb21tb25qcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxvQ0FBb0M7QUFDbkQ7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsMENBQTBDLDRCQUE0QjtBQUN0RSxDQUFDO0FBQ0Q7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsWUFBWSxHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLHVCQUF1QixHQUFHLHNCQUFzQixHQUFHLGlCQUFpQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLHFCQUFxQixHQUFHLG9CQUFvQjtBQUNuUCxvQkFBb0IsbUJBQU8sQ0FBQyx3RUFBVztBQUN2QyxvQkFBb0IsbUJBQU8sQ0FBQyw0QkFBVztBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQywwQkFBVTtBQUNyQyxhQUFhLG1CQUFPLENBQUMsY0FBSTtBQUN6Qiw4QkFBOEIsbUJBQU8sQ0FBQyx3QkFBUztBQUMvQztBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDN0MsbUJBQW1CLG1CQUFPLENBQUMsc0VBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFVBQVU7QUFDMUI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGVBQWU7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELEVBQUU7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLEtBQUs7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLHFCQUFxQjtBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxjQUFjO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxjQUFjO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3SUFBd0k7QUFDeEo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLHFCQUFxQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxrQkFBa0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELHlEQUF5RCxJQUFJO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLEVBQUUsR0FBRyxFQUFFO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxRQUFRO0FBQy9DO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixFQUFFLEdBQUcsRUFBRTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0JBQWdCO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHVCQUF1QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdCQUFnQjtBQUN2RDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGdCQUFnQjtBQUNyRDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBNEQ7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsNERBQTREO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQSxpQ0FBaUMsNkJBQTZCO0FBQzlELDBDQUEwQywyQkFBMkI7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUE0RDtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLDREQUE0RDtBQUM1RSxrREFBa0Qsa0JBQWtCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQiw0REFBNEQ7QUFDNUUsa0RBQWtELGtCQUFrQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBLElBQUksaUJBQWlCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QyxnQkFBZ0IsZ0JBQWdCO0FBQ2hDLDhDQUE4QyxpQkFBaUI7QUFDL0Q7QUFDQSwrQkFBK0IsR0FBRztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRyxJQUFJO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQSxTQUFTLGlCQUFpQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsZ0JBQWdCLGlCQUFpQjtBQUNqQyw2Q0FBNkMsaUJBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtHQUErRyxJQUFJO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSxJQUFJLHNCQUFzQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsaUJBQWlCO0FBQzFCO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUMsZ0JBQWdCLGdCQUFnQjtBQUNoQyxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxZQUFZLGdCQUFnQjtBQUM1QjtBQUNBLElBQUksaUJBQWlCLHFCQUFxQixpQkFBaUI7QUFDM0Q7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZLHNCQUFzQjtBQUNsQztBQUNBLElBQUksdUJBQXVCLHFCQUFxQix3QkFBd0I7QUFDeEUsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvcGF0aC1zY3VycnkvZGlzdC9jb21tb25qcy9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXRoU2N1cnJ5ID0gZXhwb3J0cy5QYXRoID0gZXhwb3J0cy5QYXRoU2N1cnJ5RGFyd2luID0gZXhwb3J0cy5QYXRoU2N1cnJ5UG9zaXggPSBleHBvcnRzLlBhdGhTY3VycnlXaW4zMiA9IGV4cG9ydHMuUGF0aFNjdXJyeUJhc2UgPSBleHBvcnRzLlBhdGhQb3NpeCA9IGV4cG9ydHMuUGF0aFdpbjMyID0gZXhwb3J0cy5QYXRoQmFzZSA9IGV4cG9ydHMuQ2hpbGRyZW5DYWNoZSA9IGV4cG9ydHMuUmVzb2x2ZUNhY2hlID0gdm9pZCAwO1xuY29uc3QgbHJ1X2NhY2hlXzEgPSByZXF1aXJlKFwibHJ1LWNhY2hlXCIpO1xuY29uc3Qgbm9kZV9wYXRoXzEgPSByZXF1aXJlKFwibm9kZTpwYXRoXCIpO1xuY29uc3Qgbm9kZV91cmxfMSA9IHJlcXVpcmUoXCJub2RlOnVybFwiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBhY3R1YWxGUyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwibm9kZTpmc1wiKSk7XG5jb25zdCByZWFscGF0aFN5bmMgPSBmc18xLnJlYWxwYXRoU3luYy5uYXRpdmU7XG4vLyBUT0RPOiB0ZXN0IHBlcmYgb2YgZnMvcHJvbWlzZXMgcmVhbHBhdGggdnMgcmVhbHBhdGhDQixcbi8vIHNpbmNlIHRoZSBwcm9taXNlcyBvbmUgdXNlcyByZWFscGF0aC5uYXRpdmVcbmNvbnN0IHByb21pc2VzXzEgPSByZXF1aXJlKFwibm9kZTpmcy9wcm9taXNlc1wiKTtcbmNvbnN0IG1pbmlwYXNzXzEgPSByZXF1aXJlKFwibWluaXBhc3NcIik7XG5jb25zdCBkZWZhdWx0RlMgPSB7XG4gICAgbHN0YXRTeW5jOiBmc18xLmxzdGF0U3luYyxcbiAgICByZWFkZGlyOiBmc18xLnJlYWRkaXIsXG4gICAgcmVhZGRpclN5bmM6IGZzXzEucmVhZGRpclN5bmMsXG4gICAgcmVhZGxpbmtTeW5jOiBmc18xLnJlYWRsaW5rU3luYyxcbiAgICByZWFscGF0aFN5bmMsXG4gICAgcHJvbWlzZXM6IHtcbiAgICAgICAgbHN0YXQ6IHByb21pc2VzXzEubHN0YXQsXG4gICAgICAgIHJlYWRkaXI6IHByb21pc2VzXzEucmVhZGRpcixcbiAgICAgICAgcmVhZGxpbms6IHByb21pc2VzXzEucmVhZGxpbmssXG4gICAgICAgIHJlYWxwYXRoOiBwcm9taXNlc18xLnJlYWxwYXRoLFxuICAgIH0sXG59O1xuLy8gaWYgdGhleSBqdXN0IGdhdmUgdXMgcmVxdWlyZSgnZnMnKSB0aGVuIHVzZSBvdXIgZGVmYXVsdFxuY29uc3QgZnNGcm9tT3B0aW9uID0gKGZzT3B0aW9uKSA9PiAhZnNPcHRpb24gfHwgZnNPcHRpb24gPT09IGRlZmF1bHRGUyB8fCBmc09wdGlvbiA9PT0gYWN0dWFsRlMgP1xuICAgIGRlZmF1bHRGU1xuICAgIDoge1xuICAgICAgICAuLi5kZWZhdWx0RlMsXG4gICAgICAgIC4uLmZzT3B0aW9uLFxuICAgICAgICBwcm9taXNlczoge1xuICAgICAgICAgICAgLi4uZGVmYXVsdEZTLnByb21pc2VzLFxuICAgICAgICAgICAgLi4uKGZzT3B0aW9uLnByb21pc2VzIHx8IHt9KSxcbiAgICAgICAgfSxcbiAgICB9O1xuLy8gdHVybiBzb21ldGhpbmcgbGlrZSAvLz8vYzovIGludG8gYzpcXFxuY29uc3QgdW5jRHJpdmVSZWdleHAgPSAvXlxcXFxcXFxcXFw/XFxcXChbYS16XTopXFxcXD8kL2k7XG5jb25zdCB1bmNUb0RyaXZlID0gKHJvb3RQYXRoKSA9PiByb290UGF0aC5yZXBsYWNlKC9cXC8vZywgJ1xcXFwnKS5yZXBsYWNlKHVuY0RyaXZlUmVnZXhwLCAnJDFcXFxcJyk7XG4vLyB3aW5kb3dzIHBhdGhzIGFyZSBzZXBhcmF0ZWQgYnkgZWl0aGVyIC8gb3IgXFxcbmNvbnN0IGVpdGhlclNlcCA9IC9bXFxcXFxcL10vO1xuY29uc3QgVU5LTk9XTiA9IDA7IC8vIG1heSBub3QgZXZlbiBleGlzdCwgZm9yIGFsbCB3ZSBrbm93XG5jb25zdCBJRklGTyA9IDBiMDAwMTtcbmNvbnN0IElGQ0hSID0gMGIwMDEwO1xuY29uc3QgSUZESVIgPSAwYjAxMDA7XG5jb25zdCBJRkJMSyA9IDBiMDExMDtcbmNvbnN0IElGUkVHID0gMGIxMDAwO1xuY29uc3QgSUZMTksgPSAwYjEwMTA7XG5jb25zdCBJRlNPQ0sgPSAwYjExMDA7XG5jb25zdCBJRk1UID0gMGIxMTExO1xuLy8gbWFzayB0byB1bnNldCBsb3cgNCBiaXRzXG5jb25zdCBJRk1UX1VOS05PV04gPSB+SUZNVDtcbi8vIHNldCBhZnRlciBzdWNjZXNzZnVsbHkgY2FsbGluZyByZWFkZGlyKCkgYW5kIGdldHRpbmcgZW50cmllcy5cbmNvbnN0IFJFQURESVJfQ0FMTEVEID0gMGIwMDAwXzAwMDFfMDAwMDtcbi8vIHNldCBhZnRlciBhIHN1Y2Nlc3NmdWwgbHN0YXQoKVxuY29uc3QgTFNUQVRfQ0FMTEVEID0gMGIwMDAwXzAwMTBfMDAwMDtcbi8vIHNldCBpZiBhbiBlbnRyeSAob3Igb25lIG9mIGl0cyBwYXJlbnRzKSBpcyBkZWZpbml0ZWx5IG5vdCBhIGRpclxuY29uc3QgRU5PVERJUiA9IDBiMDAwMF8wMTAwXzAwMDA7XG4vLyBzZXQgaWYgYW4gZW50cnkgKG9yIG9uZSBvZiBpdHMgcGFyZW50cykgZG9lcyBub3QgZXhpc3Rcbi8vIChjYW4gYWxzbyBiZSBzZXQgb24gbHN0YXQgZXJyb3JzIGxpa2UgRUFDQ0VTIG9yIEVOQU1FVE9PTE9ORylcbmNvbnN0IEVOT0VOVCA9IDBiMDAwMF8xMDAwXzAwMDA7XG4vLyBjYW5ub3QgaGF2ZSBjaGlsZCBlbnRyaWVzIC0tIGFsc28gdmVyaWZ5ICZJRk1UIGlzIGVpdGhlciBJRkRJUiBvciBJRkxOS1xuLy8gc2V0IGlmIHdlIGZhaWwgdG8gcmVhZGxpbmtcbmNvbnN0IEVOT1JFQURMSU5LID0gMGIwMDAxXzAwMDBfMDAwMDtcbi8vIHNldCBpZiB3ZSBrbm93IHJlYWxwYXRoKCkgd2lsbCBmYWlsXG5jb25zdCBFTk9SRUFMUEFUSCA9IDBiMDAxMF8wMDAwXzAwMDA7XG5jb25zdCBFTk9DSElMRCA9IEVOT1RESVIgfCBFTk9FTlQgfCBFTk9SRUFMUEFUSDtcbmNvbnN0IFRZUEVNQVNLID0gMGIwMDExXzExMTFfMTExMTtcbmNvbnN0IGVudFRvVHlwZSA9IChzKSA9PiBzLmlzRmlsZSgpID8gSUZSRUdcbiAgICA6IHMuaXNEaXJlY3RvcnkoKSA/IElGRElSXG4gICAgICAgIDogcy5pc1N5bWJvbGljTGluaygpID8gSUZMTktcbiAgICAgICAgICAgIDogcy5pc0NoYXJhY3RlckRldmljZSgpID8gSUZDSFJcbiAgICAgICAgICAgICAgICA6IHMuaXNCbG9ja0RldmljZSgpID8gSUZCTEtcbiAgICAgICAgICAgICAgICAgICAgOiBzLmlzU29ja2V0KCkgPyBJRlNPQ0tcbiAgICAgICAgICAgICAgICAgICAgICAgIDogcy5pc0ZJRk8oKSA/IElGSUZPXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBVTktOT1dOO1xuLy8gbm9ybWFsaXplIHVuaWNvZGUgcGF0aCBuYW1lc1xuY29uc3Qgbm9ybWFsaXplQ2FjaGUgPSBuZXcgTWFwKCk7XG5jb25zdCBub3JtYWxpemUgPSAocykgPT4ge1xuICAgIGNvbnN0IGMgPSBub3JtYWxpemVDYWNoZS5nZXQocyk7XG4gICAgaWYgKGMpXG4gICAgICAgIHJldHVybiBjO1xuICAgIGNvbnN0IG4gPSBzLm5vcm1hbGl6ZSgnTkZLRCcpO1xuICAgIG5vcm1hbGl6ZUNhY2hlLnNldChzLCBuKTtcbiAgICByZXR1cm4gbjtcbn07XG5jb25zdCBub3JtYWxpemVOb2Nhc2VDYWNoZSA9IG5ldyBNYXAoKTtcbmNvbnN0IG5vcm1hbGl6ZU5vY2FzZSA9IChzKSA9PiB7XG4gICAgY29uc3QgYyA9IG5vcm1hbGl6ZU5vY2FzZUNhY2hlLmdldChzKTtcbiAgICBpZiAoYylcbiAgICAgICAgcmV0dXJuIGM7XG4gICAgY29uc3QgbiA9IG5vcm1hbGl6ZShzLnRvTG93ZXJDYXNlKCkpO1xuICAgIG5vcm1hbGl6ZU5vY2FzZUNhY2hlLnNldChzLCBuKTtcbiAgICByZXR1cm4gbjtcbn07XG4vKipcbiAqIEFuIExSVUNhY2hlIGZvciBzdG9yaW5nIHJlc29sdmVkIHBhdGggc3RyaW5ncyBvciBQYXRoIG9iamVjdHMuXG4gKiBAaW50ZXJuYWxcbiAqL1xuY2xhc3MgUmVzb2x2ZUNhY2hlIGV4dGVuZHMgbHJ1X2NhY2hlXzEuTFJVQ2FjaGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcih7IG1heDogMjU2IH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVzb2x2ZUNhY2hlID0gUmVzb2x2ZUNhY2hlO1xuLy8gSW4gb3JkZXIgdG8gcHJldmVudCBibG93aW5nIG91dCB0aGUganMgaGVhcCBieSBhbGxvY2F0aW5nIGh1bmRyZWRzIG9mXG4vLyB0aG91c2FuZHMgb2YgUGF0aCBlbnRyaWVzIHdoZW4gd2Fsa2luZyBleHRyZW1lbHkgbGFyZ2UgdHJlZXMsIHRoZSBcImNoaWxkcmVuXCJcbi8vIGluIHRoaXMgdHJlZSBhcmUgcmVwcmVzZW50ZWQgYnkgc3RvcmluZyBhbiBhcnJheSBvZiBQYXRoIGVudHJpZXMgaW4gYW5cbi8vIExSVUNhY2hlLCBpbmRleGVkIGJ5IHRoZSBwYXJlbnQuICBBdCBhbnkgdGltZSwgUGF0aC5jaGlsZHJlbigpIG1heSByZXR1cm4gYW5cbi8vIGVtcHR5IGFycmF5LCBpbmRpY2F0aW5nIHRoYXQgaXQgZG9lc24ndCBrbm93IGFib3V0IGFueSBvZiBpdHMgY2hpbGRyZW4sIGFuZFxuLy8gdGh1cyBoYXMgdG8gcmVidWlsZCB0aGF0IGNhY2hlLiAgVGhpcyBpcyBmaW5lLCBpdCBqdXN0IG1lYW5zIHRoYXQgd2UgZG9uJ3Rcbi8vIGJlbmVmaXQgYXMgbXVjaCBmcm9tIGhhdmluZyB0aGUgY2FjaGVkIGVudHJpZXMsIGJ1dCBodWdlIGRpcmVjdG9yeSB3YWxrc1xuLy8gZG9uJ3QgYmxvdyBvdXQgdGhlIHN0YWNrLCBhbmQgc21hbGxlciBvbmVzIGFyZSBzdGlsbCBhcyBmYXN0IGFzIHBvc3NpYmxlLlxuLy9cbi8vSXQgZG9lcyBpbXBvc2Ugc29tZSBjb21wbGV4aXR5IHdoZW4gYnVpbGRpbmcgdXAgdGhlIHJlYWRkaXIgZGF0YSwgYmVjYXVzZSB3ZVxuLy9uZWVkIHRvIHBhc3MgYSByZWZlcmVuY2UgdG8gdGhlIGNoaWxkcmVuIGFycmF5IHRoYXQgd2Ugc3RhcnRlZCB3aXRoLlxuLyoqXG4gKiBhbiBMUlVDYWNoZSBmb3Igc3RvcmluZyBjaGlsZCBlbnRyaWVzLlxuICogQGludGVybmFsXG4gKi9cbmNsYXNzIENoaWxkcmVuQ2FjaGUgZXh0ZW5kcyBscnVfY2FjaGVfMS5MUlVDYWNoZSB7XG4gICAgY29uc3RydWN0b3IobWF4U2l6ZSA9IDE2ICogMTAyNCkge1xuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBtYXhTaXplLFxuICAgICAgICAgICAgLy8gcGFyZW50ICsgY2hpbGRyZW5cbiAgICAgICAgICAgIHNpemVDYWxjdWxhdGlvbjogYSA9PiBhLmxlbmd0aCArIDEsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2hpbGRyZW5DYWNoZSA9IENoaWxkcmVuQ2FjaGU7XG5jb25zdCBzZXRBc0N3ZCA9IFN5bWJvbCgnUGF0aFNjdXJyeSBzZXRBc0N3ZCcpO1xuLyoqXG4gKiBQYXRoIG9iamVjdHMgYXJlIHNvcnQgb2YgbGlrZSBhIHN1cGVyLXBvd2VyZWRcbiAqIHtAbGluayBodHRwczovL25vZGVqcy5vcmcvZG9jcy9sYXRlc3QvYXBpL2ZzLmh0bWwjY2xhc3MtZnNkaXJlbnQgZnMuRGlyZW50fVxuICpcbiAqIEVhY2ggb25lIHJlcHJlc2VudHMgYSBzaW5nbGUgZmlsZXN5c3RlbSBlbnRyeSBvbiBkaXNrLCB3aGljaCBtYXkgb3IgbWF5IG5vdFxuICogZXhpc3QuIEl0IGluY2x1ZGVzIG1ldGhvZHMgZm9yIHJlYWRpbmcgdmFyaW91cyB0eXBlcyBvZiBpbmZvcm1hdGlvbiB2aWFcbiAqIGxzdGF0LCByZWFkbGluaywgYW5kIHJlYWRkaXIsIGFuZCBjYWNoZXMgYWxsIGluZm9ybWF0aW9uIHRvIHRoZSBncmVhdGVzdFxuICogZGVncmVlIHBvc3NpYmxlLlxuICpcbiAqIE5vdGUgdGhhdCBmcyBvcGVyYXRpb25zIHRoYXQgd291bGQgbm9ybWFsbHkgdGhyb3cgd2lsbCBpbnN0ZWFkIHJldHVybiBhblxuICogXCJlbXB0eVwiIHZhbHVlLiBUaGlzIGlzIGluIG9yZGVyIHRvIHByZXZlbnQgZXhjZXNzaXZlIG92ZXJoZWFkIGZyb20gZXJyb3JcbiAqIHN0YWNrIHRyYWNlcy5cbiAqL1xuY2xhc3MgUGF0aEJhc2Uge1xuICAgIC8qKlxuICAgICAqIHRoZSBiYXNlbmFtZSBvZiB0aGlzIHBhdGhcbiAgICAgKlxuICAgICAqICoqSW1wb3J0YW50Kio6ICphbHdheXMqIHRlc3QgdGhlIHBhdGggbmFtZSBhZ2FpbnN0IGFueSB0ZXN0IHN0cmluZ1xuICAgICAqIHVzaW5ndGhlIHtAbGluayBpc05hbWVkfSBtZXRob2QsIGFuZCBub3QgYnkgZGlyZWN0bHkgY29tcGFyaW5nIHRoaXNcbiAgICAgKiBzdHJpbmcuIE90aGVyd2lzZSwgdW5pY29kZSBwYXRoIHN0cmluZ3MgdGhhdCB0aGUgc3lzdGVtIHNlZXMgYXMgaWRlbnRpY2FsXG4gICAgICogd2lsbCBub3QgYmUgcHJvcGVybHkgdHJlYXRlZCBhcyB0aGUgc2FtZSBwYXRoLCBsZWFkaW5nIHRvIGluY29ycmVjdFxuICAgICAqIGJlaGF2aW9yIGFuZCBwb3NzaWJsZSBzZWN1cml0eSBpc3N1ZXMuXG4gICAgICovXG4gICAgbmFtZTtcbiAgICAvKipcbiAgICAgKiB0aGUgUGF0aCBlbnRyeSBjb3JyZXNwb25kaW5nIHRvIHRoZSBwYXRoIHJvb3QuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICByb290O1xuICAgIC8qKlxuICAgICAqIEFsbCByb290cyBmb3VuZCB3aXRoaW4gdGhlIGN1cnJlbnQgUGF0aFNjdXJyeSBmYW1pbHlcbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIHJvb3RzO1xuICAgIC8qKlxuICAgICAqIGEgcmVmZXJlbmNlIHRvIHRoZSBwYXJlbnQgcGF0aCwgb3IgdW5kZWZpbmVkIGluIHRoZSBjYXNlIG9mIHJvb3QgZW50cmllc1xuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcGFyZW50O1xuICAgIC8qKlxuICAgICAqIGJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIHBhdGhzIGFyZSBjb21wYXJlZCBjYXNlLWluc2Vuc2l0aXZlbHlcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBub2Nhc2U7XG4gICAgLyoqXG4gICAgICogYm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgdGhpcyBwYXRoIGlzIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5XG4gICAgICogb2YgdGhlIFBhdGhTY3VycnkgY29sbGVjdGlvbiB0aGF0IGNvbnRhaW5zIGl0LlxuICAgICAqL1xuICAgIGlzQ1dEID0gZmFsc2U7XG4gICAgLy8gcG90ZW50aWFsIGRlZmF1bHQgZnMgb3ZlcnJpZGVcbiAgICAjZnM7XG4gICAgLy8gU3RhdHMgZmllbGRzXG4gICAgI2RldjtcbiAgICBnZXQgZGV2KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jZGV2O1xuICAgIH1cbiAgICAjbW9kZTtcbiAgICBnZXQgbW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI21vZGU7XG4gICAgfVxuICAgICNubGluaztcbiAgICBnZXQgbmxpbmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNubGluaztcbiAgICB9XG4gICAgI3VpZDtcbiAgICBnZXQgdWlkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdWlkO1xuICAgIH1cbiAgICAjZ2lkO1xuICAgIGdldCBnaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNnaWQ7XG4gICAgfVxuICAgICNyZGV2O1xuICAgIGdldCByZGV2KCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmRldjtcbiAgICB9XG4gICAgI2Jsa3NpemU7XG4gICAgZ2V0IGJsa3NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNibGtzaXplO1xuICAgIH1cbiAgICAjaW5vO1xuICAgIGdldCBpbm8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNpbm87XG4gICAgfVxuICAgICNzaXplO1xuICAgIGdldCBzaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jc2l6ZTtcbiAgICB9XG4gICAgI2Jsb2NrcztcbiAgICBnZXQgYmxvY2tzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYmxvY2tzO1xuICAgIH1cbiAgICAjYXRpbWVNcztcbiAgICBnZXQgYXRpbWVNcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2F0aW1lTXM7XG4gICAgfVxuICAgICNtdGltZU1zO1xuICAgIGdldCBtdGltZU1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jbXRpbWVNcztcbiAgICB9XG4gICAgI2N0aW1lTXM7XG4gICAgZ2V0IGN0aW1lTXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNjdGltZU1zO1xuICAgIH1cbiAgICAjYmlydGh0aW1lTXM7XG4gICAgZ2V0IGJpcnRodGltZU1zKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jYmlydGh0aW1lTXM7XG4gICAgfVxuICAgICNhdGltZTtcbiAgICBnZXQgYXRpbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiNhdGltZTtcbiAgICB9XG4gICAgI210aW1lO1xuICAgIGdldCBtdGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI210aW1lO1xuICAgIH1cbiAgICAjY3RpbWU7XG4gICAgZ2V0IGN0aW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jY3RpbWU7XG4gICAgfVxuICAgICNiaXJ0aHRpbWU7XG4gICAgZ2V0IGJpcnRodGltZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2JpcnRodGltZTtcbiAgICB9XG4gICAgI21hdGNoTmFtZTtcbiAgICAjZGVwdGg7XG4gICAgI2Z1bGxwYXRoO1xuICAgICNmdWxscGF0aFBvc2l4O1xuICAgICNyZWxhdGl2ZTtcbiAgICAjcmVsYXRpdmVQb3NpeDtcbiAgICAjdHlwZTtcbiAgICAjY2hpbGRyZW47XG4gICAgI2xpbmtUYXJnZXQ7XG4gICAgI3JlYWxwYXRoO1xuICAgIC8qKlxuICAgICAqIFRoaXMgcHJvcGVydHkgaXMgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgRGlyZW50IGNsYXNzIGFzIG9mXG4gICAgICogTm9kZSB2MjAsIHdoZXJlIERpcmVudFsncGFyZW50UGF0aCddIHJlZmVycyB0byB0aGUgcGF0aCBvZiB0aGVcbiAgICAgKiBkaXJlY3RvcnkgdGhhdCB3YXMgcGFzc2VkIHRvIHJlYWRkaXIuIEZvciByb290IGVudHJpZXMsIGl0J3MgdGhlIHBhdGhcbiAgICAgKiB0byB0aGUgZW50cnkgaXRzZWxmLlxuICAgICAqL1xuICAgIGdldCBwYXJlbnRQYXRoKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucGFyZW50IHx8IHRoaXMpLmZ1bGxwYXRoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcHJlY2F0ZWQgYWxpYXMgZm9yIERpcmVudFsncGFyZW50UGF0aCddIFNvbWV3aGF0IGNvdW50ZXJpbnR1aXRpdmVseSxcbiAgICAgKiB0aGlzIHByb3BlcnR5IHJlZmVycyB0byB0aGUgKnBhcmVudCogcGF0aCwgbm90IHRoZSBwYXRoIG9iamVjdCBpdHNlbGYuXG4gICAgICovXG4gICAgZ2V0IHBhdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmVudFBhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvIG5vdCBjcmVhdGUgbmV3IFBhdGggb2JqZWN0cyBkaXJlY3RseS4gIFRoZXkgc2hvdWxkIGFsd2F5cyBiZSBhY2Nlc3NlZFxuICAgICAqIHZpYSB0aGUgUGF0aFNjdXJyeSBjbGFzcyBvciBvdGhlciBtZXRob2RzIG9uIHRoZSBQYXRoIGNsYXNzLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSA9IFVOS05PV04sIHJvb3QsIHJvb3RzLCBub2Nhc2UsIGNoaWxkcmVuLCBvcHRzKSB7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuI21hdGNoTmFtZSA9IG5vY2FzZSA/IG5vcm1hbGl6ZU5vY2FzZShuYW1lKSA6IG5vcm1hbGl6ZShuYW1lKTtcbiAgICAgICAgdGhpcy4jdHlwZSA9IHR5cGUgJiBUWVBFTUFTSztcbiAgICAgICAgdGhpcy5ub2Nhc2UgPSBub2Nhc2U7XG4gICAgICAgIHRoaXMucm9vdHMgPSByb290cztcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdCB8fCB0aGlzO1xuICAgICAgICB0aGlzLiNjaGlsZHJlbiA9IGNoaWxkcmVuO1xuICAgICAgICB0aGlzLiNmdWxscGF0aCA9IG9wdHMuZnVsbHBhdGg7XG4gICAgICAgIHRoaXMuI3JlbGF0aXZlID0gb3B0cy5yZWxhdGl2ZTtcbiAgICAgICAgdGhpcy4jcmVsYXRpdmVQb3NpeCA9IG9wdHMucmVsYXRpdmVQb3NpeDtcbiAgICAgICAgdGhpcy5wYXJlbnQgPSBvcHRzLnBhcmVudDtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLiNmcyA9IHRoaXMucGFyZW50LiNmcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuI2ZzID0gZnNGcm9tT3B0aW9uKG9wdHMuZnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGRlcHRoIG9mIHRoZSBQYXRoIG9iamVjdCBmcm9tIGl0cyByb290LlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIGEgcGF0aCBhdCBgL2Zvby9iYXJgIHdvdWxkIGhhdmUgYSBkZXB0aCBvZiAyLlxuICAgICAqL1xuICAgIGRlcHRoKCkge1xuICAgICAgICBpZiAodGhpcy4jZGVwdGggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNkZXB0aDtcbiAgICAgICAgaWYgKCF0aGlzLnBhcmVudClcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jZGVwdGggPSAwKTtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNkZXB0aCA9IHRoaXMucGFyZW50LmRlcHRoKCkgKyAxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY2hpbGRyZW5DYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoaWxkcmVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIFBhdGggb2JqZWN0IHJlZmVyZW5jZWQgYnkgdGhlIHN0cmluZyBwYXRoLCByZXNvbHZlZCBmcm9tIHRoaXMgUGF0aFxuICAgICAqL1xuICAgIHJlc29sdmUocGF0aCkge1xuICAgICAgICBpZiAoIXBhdGgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJvb3RQYXRoID0gdGhpcy5nZXRSb290U3RyaW5nKHBhdGgpO1xuICAgICAgICBjb25zdCBkaXIgPSBwYXRoLnN1YnN0cmluZyhyb290UGF0aC5sZW5ndGgpO1xuICAgICAgICBjb25zdCBkaXJQYXJ0cyA9IGRpci5zcGxpdCh0aGlzLnNwbGl0U2VwKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcm9vdFBhdGggP1xuICAgICAgICAgICAgdGhpcy5nZXRSb290KHJvb3RQYXRoKS4jcmVzb2x2ZVBhcnRzKGRpclBhcnRzKVxuICAgICAgICAgICAgOiB0aGlzLiNyZXNvbHZlUGFydHMoZGlyUGFydHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAjcmVzb2x2ZVBhcnRzKGRpclBhcnRzKSB7XG4gICAgICAgIGxldCBwID0gdGhpcztcbiAgICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIGRpclBhcnRzKSB7XG4gICAgICAgICAgICBwID0gcC5jaGlsZChwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgY2FjaGVkIGNoaWxkcmVuIFBhdGggb2JqZWN0cywgaWYgc3RpbGwgYXZhaWxhYmxlLiAgSWYgdGhleVxuICAgICAqIGhhdmUgZmFsbGVuIG91dCBvZiB0aGUgY2FjaGUsIHRoZW4gcmV0dXJucyBhbiBlbXB0eSBhcnJheSwgYW5kIHJlc2V0cyB0aGVcbiAgICAgKiBSRUFERElSX0NBTExFRCBiaXQsIHNvIHRoYXQgZnV0dXJlIGNhbGxzIHRvIHJlYWRkaXIoKSB3aWxsIHJlcXVpcmUgYW4gZnNcbiAgICAgKiBsb29rdXAuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjaGlsZHJlbigpIHtcbiAgICAgICAgY29uc3QgY2FjaGVkID0gdGhpcy4jY2hpbGRyZW4uZ2V0KHRoaXMpO1xuICAgICAgICBpZiAoY2FjaGVkKSB7XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoaWxkcmVuID0gT2JqZWN0LmFzc2lnbihbXSwgeyBwcm92aXNpb25hbDogMCB9KTtcbiAgICAgICAgdGhpcy4jY2hpbGRyZW4uc2V0KHRoaXMsIGNoaWxkcmVuKTtcbiAgICAgICAgdGhpcy4jdHlwZSAmPSB+UkVBRERJUl9DQUxMRUQ7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzb2x2ZXMgYSBwYXRoIHBvcnRpb24gYW5kIHJldHVybnMgb3IgY3JlYXRlcyB0aGUgY2hpbGQgUGF0aC5cbiAgICAgKlxuICAgICAqIFJldHVybnMgYHRoaXNgIGlmIHBhdGhQYXJ0IGlzIGAnJ2Agb3IgYCcuJ2AsIG9yIGBwYXJlbnRgIGlmIHBhdGhQYXJ0IGlzXG4gICAgICogYCcuLidgLlxuICAgICAqXG4gICAgICogVGhpcyBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseS4gIElmIGBwYXRoUGFydGAgY29udGFpbnMgYW55IHBhdGhcbiAgICAgKiBzZXBhcmF0b3JzLCBpdCB3aWxsIGxlYWQgdG8gdW5zYWZlIHVuZGVmaW5lZCBiZWhhdmlvci5cbiAgICAgKlxuICAgICAqIFVzZSBgUGF0aC5yZXNvbHZlKClgIGluc3RlYWQuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjaGlsZChwYXRoUGFydCwgb3B0cykge1xuICAgICAgICBpZiAocGF0aFBhcnQgPT09ICcnIHx8IHBhdGhQYXJ0ID09PSAnLicpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXRoUGFydCA9PT0gJy4uJykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50IHx8IHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZmluZCB0aGUgY2hpbGRcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5vY2FzZSA/IG5vcm1hbGl6ZU5vY2FzZShwYXRoUGFydCkgOiBub3JtYWxpemUocGF0aFBhcnQpO1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGlmIChwLiNtYXRjaE5hbWUgPT09IG5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBkaWRuJ3QgZmluZCBpdCwgY3JlYXRlIHByb3Zpc2lvbmFsIGNoaWxkLCBzaW5jZSBpdCBtaWdodCBub3RcbiAgICAgICAgLy8gYWN0dWFsbHkgZXhpc3QuICBJZiB3ZSBrbm93IHRoZSBwYXJlbnQgaXNuJ3QgYSBkaXIsIHRoZW5cbiAgICAgICAgLy8gaW4gZmFjdCBpdCBDQU4nVCBleGlzdC5cbiAgICAgICAgY29uc3QgcyA9IHRoaXMucGFyZW50ID8gdGhpcy5zZXAgOiAnJztcbiAgICAgICAgY29uc3QgZnVsbHBhdGggPSB0aGlzLiNmdWxscGF0aCA/IHRoaXMuI2Z1bGxwYXRoICsgcyArIHBhdGhQYXJ0IDogdW5kZWZpbmVkO1xuICAgICAgICBjb25zdCBwY2hpbGQgPSB0aGlzLm5ld0NoaWxkKHBhdGhQYXJ0LCBVTktOT1dOLCB7XG4gICAgICAgICAgICAuLi5vcHRzLFxuICAgICAgICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgICAgICAgZnVsbHBhdGgsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXRoaXMuY2FuUmVhZGRpcigpKSB7XG4gICAgICAgICAgICBwY2hpbGQuI3R5cGUgfD0gRU5PRU5UO1xuICAgICAgICB9XG4gICAgICAgIC8vIGRvbid0IGhhdmUgdG8gdXBkYXRlIHByb3Zpc2lvbmFsLCBiZWNhdXNlIGlmIHdlIGhhdmUgcmVhbCBjaGlsZHJlbixcbiAgICAgICAgLy8gdGhlbiBwcm92aXNpb25hbCBpcyBzZXQgdG8gY2hpbGRyZW4ubGVuZ3RoLCBvdGhlcndpc2UgYSBsb3dlciBudW1iZXJcbiAgICAgICAgY2hpbGRyZW4ucHVzaChwY2hpbGQpO1xuICAgICAgICByZXR1cm4gcGNoaWxkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgcmVsYXRpdmUgcGF0aCBmcm9tIHRoZSBjd2QuIElmIGl0IGRvZXMgbm90IHNoYXJlIGFuIGFuY2VzdG9yIHdpdGhcbiAgICAgKiB0aGUgY3dkLCB0aGVuIHRoaXMgZW5kcyB1cCBiZWluZyBlcXVpdmFsZW50IHRvIHRoZSBmdWxscGF0aCgpXG4gICAgICovXG4gICAgcmVsYXRpdmUoKSB7XG4gICAgICAgIGlmICh0aGlzLmlzQ1dEKVxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICBpZiAodGhpcy4jcmVsYXRpdmUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3JlbGF0aXZlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLm5hbWU7XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI3JlbGF0aXZlID0gdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwdiA9IHAucmVsYXRpdmUoKTtcbiAgICAgICAgcmV0dXJuIHB2ICsgKCFwdiB8fCAhcC5wYXJlbnQgPyAnJyA6IHRoaXMuc2VwKSArIG5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSByZWxhdGl2ZSBwYXRoIGZyb20gdGhlIGN3ZCwgdXNpbmcgLyBhcyB0aGUgcGF0aCBzZXBhcmF0b3IuXG4gICAgICogSWYgaXQgZG9lcyBub3Qgc2hhcmUgYW4gYW5jZXN0b3Igd2l0aFxuICAgICAqIHRoZSBjd2QsIHRoZW4gdGhpcyBlbmRzIHVwIGJlaW5nIGVxdWl2YWxlbnQgdG8gdGhlIGZ1bGxwYXRoUG9zaXgoKVxuICAgICAqIE9uIHBvc2l4IHN5c3RlbXMsIHRoaXMgaXMgaWRlbnRpY2FsIHRvIHJlbGF0aXZlKCkuXG4gICAgICovXG4gICAgcmVsYXRpdmVQb3NpeCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VwID09PSAnLycpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZWxhdGl2ZSgpO1xuICAgICAgICBpZiAodGhpcy5pc0NXRClcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgaWYgKHRoaXMuI3JlbGF0aXZlUG9zaXggIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNyZWxhdGl2ZVBvc2l4O1xuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICBjb25zdCBwID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGlmICghcCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNyZWxhdGl2ZVBvc2l4ID0gdGhpcy5mdWxscGF0aFBvc2l4KCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHB2ID0gcC5yZWxhdGl2ZVBvc2l4KCk7XG4gICAgICAgIHJldHVybiBwdiArICghcHYgfHwgIXAucGFyZW50ID8gJycgOiAnLycpICsgbmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGZ1bGx5IHJlc29sdmVkIHBhdGggc3RyaW5nIGZvciB0aGlzIFBhdGggZW50cnlcbiAgICAgKi9cbiAgICBmdWxscGF0aCgpIHtcbiAgICAgICAgaWYgKHRoaXMuI2Z1bGxwYXRoICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiNmdWxscGF0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5uYW1lO1xuICAgICAgICBjb25zdCBwID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgIGlmICghcCkge1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNmdWxscGF0aCA9IHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHYgPSBwLmZ1bGxwYXRoKCk7XG4gICAgICAgIGNvbnN0IGZwID0gcHYgKyAoIXAucGFyZW50ID8gJycgOiB0aGlzLnNlcCkgKyBuYW1lO1xuICAgICAgICByZXR1cm4gKHRoaXMuI2Z1bGxwYXRoID0gZnApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPbiBwbGF0Zm9ybXMgb3RoZXIgdGhhbiB3aW5kb3dzLCB0aGlzIGlzIGlkZW50aWNhbCB0byBmdWxscGF0aC5cbiAgICAgKlxuICAgICAqIE9uIHdpbmRvd3MsIHRoaXMgaXMgb3ZlcnJpZGRlbiB0byByZXR1cm4gdGhlIGZvcndhcmQtc2xhc2ggZm9ybSBvZiB0aGVcbiAgICAgKiBmdWxsIFVOQyBwYXRoLlxuICAgICAqL1xuICAgIGZ1bGxwYXRoUG9zaXgoKSB7XG4gICAgICAgIGlmICh0aGlzLiNmdWxscGF0aFBvc2l4ICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jZnVsbHBhdGhQb3NpeDtcbiAgICAgICAgaWYgKHRoaXMuc2VwID09PSAnLycpXG4gICAgICAgICAgICByZXR1cm4gKHRoaXMuI2Z1bGxwYXRoUG9zaXggPSB0aGlzLmZ1bGxwYXRoKCkpO1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5mdWxscGF0aCgpLnJlcGxhY2UoL1xcXFwvZywgJy8nKTtcbiAgICAgICAgICAgIGlmICgvXlthLXpdOlxcLy9pLnRlc3QocCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKHRoaXMuI2Z1bGxwYXRoUG9zaXggPSBgLy8/LyR7cH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jZnVsbHBhdGhQb3NpeCA9IHApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHAgPSB0aGlzLnBhcmVudDtcbiAgICAgICAgY29uc3QgcGZwcCA9IHAuZnVsbHBhdGhQb3NpeCgpO1xuICAgICAgICBjb25zdCBmcHAgPSBwZnBwICsgKCFwZnBwIHx8ICFwLnBhcmVudCA/ICcnIDogJy8nKSArIHRoaXMubmFtZTtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNmdWxscGF0aFBvc2l4ID0gZnBwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIFBhdGggb2YgYW4gdW5rbm93biB0eXBlP1xuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHdlIG1pZ2h0IGtub3cgKnNvbWV0aGluZyogYWJvdXQgaXQgaWYgdGhlcmUgaGFzIGJlZW4gYSBwcmV2aW91c1xuICAgICAqIGZpbGVzeXN0ZW0gb3BlcmF0aW9uLCBmb3IgZXhhbXBsZSB0aGF0IGl0IGRvZXMgbm90IGV4aXN0LCBvciBpcyBub3QgYVxuICAgICAqIGxpbmssIG9yIHdoZXRoZXIgaXQgaGFzIGNoaWxkIGVudHJpZXMuXG4gICAgICovXG4gICAgaXNVbmtub3duKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgJiBJRk1UKSA9PT0gVU5LTk9XTjtcbiAgICB9XG4gICAgaXNUeXBlKHR5cGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbYGlzJHt0eXBlfWBdKCk7XG4gICAgfVxuICAgIGdldFR5cGUoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc1Vua25vd24oKSA/ICdVbmtub3duJ1xuICAgICAgICAgICAgOiB0aGlzLmlzRGlyZWN0b3J5KCkgPyAnRGlyZWN0b3J5J1xuICAgICAgICAgICAgICAgIDogdGhpcy5pc0ZpbGUoKSA/ICdGaWxlJ1xuICAgICAgICAgICAgICAgICAgICA6IHRoaXMuaXNTeW1ib2xpY0xpbmsoKSA/ICdTeW1ib2xpY0xpbmsnXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuaXNGSUZPKCkgPyAnRklGTydcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHRoaXMuaXNDaGFyYWN0ZXJEZXZpY2UoKSA/ICdDaGFyYWN0ZXJEZXZpY2UnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdGhpcy5pc0Jsb2NrRGV2aWNlKCkgPyAnQmxvY2tEZXZpY2UnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IC8qIGM4IGlnbm9yZSBzdGFydCAqLyB0aGlzLmlzU29ja2V0KCkgPyAnU29ja2V0J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogJ1Vua25vd24nKTtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIFBhdGggYSByZWd1bGFyIGZpbGU/XG4gICAgICovXG4gICAgaXNGaWxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgJiBJRk1UKSA9PT0gSUZSRUc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBQYXRoIGEgZGlyZWN0b3J5P1xuICAgICAqL1xuICAgIGlzRGlyZWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgJiBJRk1UKSA9PT0gSUZESVI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBwYXRoIGEgY2hhcmFjdGVyIGRldmljZT9cbiAgICAgKi9cbiAgICBpc0NoYXJhY3RlckRldmljZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiN0eXBlICYgSUZNVCkgPT09IElGQ0hSO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgcGF0aCBhIGJsb2NrIGRldmljZT9cbiAgICAgKi9cbiAgICBpc0Jsb2NrRGV2aWNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgJiBJRk1UKSA9PT0gSUZCTEs7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElzIHRoZSBwYXRoIGEgRklGTyBwaXBlP1xuICAgICAqL1xuICAgIGlzRklGTygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiN0eXBlICYgSUZNVCkgPT09IElGSUZPO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJcyB0aGUgcGF0aCBhIHNvY2tldD9cbiAgICAgKi9cbiAgICBpc1NvY2tldCgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiN0eXBlICYgSUZNVCkgPT09IElGU09DSztcbiAgICB9XG4gICAgLyoqXG4gICAgICogSXMgdGhlIHBhdGggYSBzeW1ib2xpYyBsaW5rP1xuICAgICAqL1xuICAgIGlzU3ltYm9saWNMaW5rKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuI3R5cGUgJiBJRkxOSykgPT09IElGTE5LO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGVudHJ5IGlmIGl0IGhhcyBiZWVuIHN1YmplY3Qgb2YgYSBzdWNjZXNzZnVsIGxzdGF0LCBvclxuICAgICAqIHVuZGVmaW5lZCBvdGhlcndpc2UuXG4gICAgICpcbiAgICAgKiBEb2VzIG5vdCByZWFkIHRoZSBmaWxlc3lzdGVtLCBzbyBhbiB1bmRlZmluZWQgcmVzdWx0ICpjb3VsZCogc2ltcGx5XG4gICAgICogbWVhbiB0aGF0IHdlIGhhdmVuJ3QgY2FsbGVkIGxzdGF0IG9uIGl0LlxuICAgICAqL1xuICAgIGxzdGF0Q2FjaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jdHlwZSAmIExTVEFUX0NBTExFRCA/IHRoaXMgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY2FjaGVkIGxpbmsgdGFyZ2V0IGlmIHRoZSBlbnRyeSBoYXMgYmVlbiB0aGUgc3ViamVjdCBvZiBhXG4gICAgICogc3VjY2Vzc2Z1bCByZWFkbGluaywgb3IgdW5kZWZpbmVkIG90aGVyd2lzZS5cbiAgICAgKlxuICAgICAqIERvZXMgbm90IHJlYWQgdGhlIGZpbGVzeXN0ZW0sIHNvIGFuIHVuZGVmaW5lZCByZXN1bHQgKmNvdWxkKiBqdXN0IG1lYW4gd2VcbiAgICAgKiBkb24ndCBoYXZlIGFueSBjYWNoZWQgZGF0YS4gT25seSB1c2UgaXQgaWYgeW91IGFyZSB2ZXJ5IHN1cmUgdGhhdCBhXG4gICAgICogcmVhZGxpbmsoKSBoYXMgYmVlbiBjYWxsZWQgYXQgc29tZSBwb2ludC5cbiAgICAgKi9cbiAgICByZWFkbGlua0NhY2hlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2xpbmtUYXJnZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhY2hlZCByZWFscGF0aCB0YXJnZXQgaWYgdGhlIGVudHJ5IGhhcyBiZWVuIHRoZSBzdWJqZWN0XG4gICAgICogb2YgYSBzdWNjZXNzZnVsIHJlYWxwYXRoLCBvciB1bmRlZmluZWQgb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogRG9lcyBub3QgcmVhZCB0aGUgZmlsZXN5c3RlbSwgc28gYW4gdW5kZWZpbmVkIHJlc3VsdCAqY291bGQqIGp1c3QgbWVhbiB3ZVxuICAgICAqIGRvbid0IGhhdmUgYW55IGNhY2hlZCBkYXRhLiBPbmx5IHVzZSBpdCBpZiB5b3UgYXJlIHZlcnkgc3VyZSB0aGF0IGFcbiAgICAgKiByZWFscGF0aCgpIGhhcyBiZWVuIGNhbGxlZCBhdCBzb21lIHBvaW50LlxuICAgICAqL1xuICAgIHJlYWxwYXRoQ2FjaGVkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy4jcmVhbHBhdGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGNhY2hlZCBjaGlsZCBQYXRoIGVudHJpZXMgYXJyYXkgaWYgdGhlIGVudHJ5IGhhcyBiZWVuIHRoZVxuICAgICAqIHN1YmplY3Qgb2YgYSBzdWNjZXNzZnVsIHJlYWRkaXIoKSwgb3IgW10gb3RoZXJ3aXNlLlxuICAgICAqXG4gICAgICogRG9lcyBub3QgcmVhZCB0aGUgZmlsZXN5c3RlbSwgc28gYW4gZW1wdHkgYXJyYXkgKmNvdWxkKiBqdXN0IG1lYW4gd2VcbiAgICAgKiBkb24ndCBoYXZlIGFueSBjYWNoZWQgZGF0YS4gT25seSB1c2UgaXQgaWYgeW91IGFyZSB2ZXJ5IHN1cmUgdGhhdCBhXG4gICAgICogcmVhZGRpcigpIGhhcyBiZWVuIGNhbGxlZCByZWNlbnRseSBlbm91Z2ggdG8gc3RpbGwgYmUgdmFsaWQuXG4gICAgICovXG4gICAgcmVhZGRpckNhY2hlZCgpIHtcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XG4gICAgICAgIHJldHVybiBjaGlsZHJlbi5zbGljZSgwLCBjaGlsZHJlbi5wcm92aXNpb25hbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIGl0J3Mgd29ydGggdHJ5aW5nIHRvIHJlYWRsaW5rLiAgSWUsIHdlIGRvbid0ICh5ZXQpIGhhdmVcbiAgICAgKiBhbnkgaW5kaWNhdGlvbiB0aGF0IHJlYWRsaW5rIHdpbGwgZGVmaW5pdGVseSBmYWlsLlxuICAgICAqXG4gICAgICogUmV0dXJucyBmYWxzZSBpZiB0aGUgcGF0aCBpcyBrbm93biB0byBub3QgYmUgYSBzeW1saW5rLCBpZiBhIHByZXZpb3VzXG4gICAgICogcmVhZGxpbmsgZmFpbGVkLCBvciBpZiB0aGUgZW50cnkgZG9lcyBub3QgZXhpc3QuXG4gICAgICovXG4gICAgY2FuUmVhZGxpbmsoKSB7XG4gICAgICAgIGlmICh0aGlzLiNsaW5rVGFyZ2V0KVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIC8vIGNhc2VzIHdoZXJlIGl0IGNhbm5vdCBwb3NzaWJseSBzdWNjZWVkXG4gICAgICAgIGNvbnN0IGlmbXQgPSB0aGlzLiN0eXBlICYgSUZNVDtcbiAgICAgICAgcmV0dXJuICEoKGlmbXQgIT09IFVOS05PV04gJiYgaWZtdCAhPT0gSUZMTkspIHx8XG4gICAgICAgICAgICB0aGlzLiN0eXBlICYgRU5PUkVBRExJTksgfHxcbiAgICAgICAgICAgIHRoaXMuI3R5cGUgJiBFTk9FTlQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdHJ1ZSBpZiByZWFkZGlyIGhhcyBwcmV2aW91c2x5IGJlZW4gc3VjY2Vzc2Z1bGx5IGNhbGxlZCBvbiB0aGlzXG4gICAgICogcGF0aCwgaW5kaWNhdGluZyB0aGF0IGNhY2hlZFJlYWRkaXIoKSBpcyBsaWtlbHkgdmFsaWQuXG4gICAgICovXG4gICAgY2FsbGVkUmVhZGRpcigpIHtcbiAgICAgICAgcmV0dXJuICEhKHRoaXMuI3R5cGUgJiBSRUFERElSX0NBTExFRCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgcGF0aCBpcyBrbm93biB0byBub3QgZXhpc3QuIFRoYXQgaXMsIGEgcHJldmlvdXMgbHN0YXRcbiAgICAgKiBvciByZWFkZGlyIGZhaWxlZCB0byB2ZXJpZnkgaXRzIGV4aXN0ZW5jZSB3aGVuIHRoYXQgd291bGQgaGF2ZSBiZWVuXG4gICAgICogZXhwZWN0ZWQsIG9yIGEgcGFyZW50IGVudHJ5IHdhcyBtYXJrZWQgZWl0aGVyIGVub2VudCBvciBlbm90ZGlyLlxuICAgICAqL1xuICAgIGlzRU5PRU5UKCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy4jdHlwZSAmIEVOT0VOVCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBwYXRoIGlzIGEgbWF0Y2ggZm9yIHRoZSBnaXZlbiBwYXRoIG5hbWUuICBUaGlzIGhhbmRsZXNcbiAgICAgKiBjYXNlIHNlbnNpdGl2aXR5IGFuZCB1bmljb2RlIG5vcm1hbGl6YXRpb24uXG4gICAgICpcbiAgICAgKiBOb3RlOiBldmVuIG9uIGNhc2Utc2Vuc2l0aXZlIHN5c3RlbXMsIGl0IGlzICoqbm90Kiogc2FmZSB0byB0ZXN0IHRoZVxuICAgICAqIGVxdWFsaXR5IG9mIHRoZSBgLm5hbWVgIHByb3BlcnR5IHRvIGRldGVybWluZSB3aGV0aGVyIGEgZ2l2ZW4gcGF0aG5hbWVcbiAgICAgKiBtYXRjaGVzLCBkdWUgdG8gdW5pY29kZSBub3JtYWxpemF0aW9uIG1pc21hdGNoZXMuXG4gICAgICpcbiAgICAgKiBBbHdheXMgdXNlIHRoaXMgbWV0aG9kIGluc3RlYWQgb2YgdGVzdGluZyB0aGUgYHBhdGgubmFtZWAgcHJvcGVydHlcbiAgICAgKiBkaXJlY3RseS5cbiAgICAgKi9cbiAgICBpc05hbWVkKG4pIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLm5vY2FzZSA/XG4gICAgICAgICAgICB0aGlzLiNtYXRjaE5hbWUgPT09IG5vcm1hbGl6ZShuKVxuICAgICAgICAgICAgOiB0aGlzLiNtYXRjaE5hbWUgPT09IG5vcm1hbGl6ZU5vY2FzZShuKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBQYXRoIG9iamVjdCBjb3JyZXNwb25kaW5nIHRvIHRoZSB0YXJnZXQgb2YgYSBzeW1ib2xpYyBsaW5rLlxuICAgICAqXG4gICAgICogSWYgdGhlIFBhdGggaXMgbm90IGEgc3ltYm9saWMgbGluaywgb3IgaWYgdGhlIHJlYWRsaW5rIGNhbGwgZmFpbHMgZm9yIGFueVxuICAgICAqIHJlYXNvbiwgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBSZXN1bHQgaXMgY2FjaGVkLCBhbmQgdGh1cyBtYXkgYmUgb3V0ZGF0ZWQgaWYgdGhlIGZpbGVzeXN0ZW0gaXMgbXV0YXRlZC5cbiAgICAgKi9cbiAgICBhc3luYyByZWFkbGluaygpIHtcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy4jbGlua1RhcmdldDtcbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuY2FuUmVhZGxpbmsoKSkge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgLy8gYWxyZWFkeSBjb3ZlcmVkIGJ5IHRoZSBjYW5SZWFkbGluayB0ZXN0LCBoZXJlIGZvciB0cyBncnVtcGxlc1xuICAgICAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCByZWFkID0gYXdhaXQgdGhpcy4jZnMucHJvbWlzZXMucmVhZGxpbmsodGhpcy5mdWxscGF0aCgpKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtUYXJnZXQgPSAoYXdhaXQgdGhpcy5wYXJlbnQucmVhbHBhdGgoKSk/LnJlc29sdmUocmVhZCk7XG4gICAgICAgICAgICBpZiAobGlua1RhcmdldCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy4jbGlua1RhcmdldCA9IGxpbmtUYXJnZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgdGhpcy4jcmVhZGxpbmtGYWlsKGVyLmNvZGUpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTeW5jaHJvbm91cyB7QGxpbmsgUGF0aEJhc2UucmVhZGxpbmt9XG4gICAgICovXG4gICAgcmVhZGxpbmtTeW5jKCkge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLiNsaW5rVGFyZ2V0O1xuICAgICAgICBpZiAodGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jYW5SZWFkbGluaygpKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAvLyBhbHJlYWR5IGNvdmVyZWQgYnkgdGhlIGNhblJlYWRsaW5rIHRlc3QsIGhlcmUgZm9yIHRzIGdydW1wbGVzXG4gICAgICAgIGlmICghdGhpcy5wYXJlbnQpIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlYWQgPSB0aGlzLiNmcy5yZWFkbGlua1N5bmModGhpcy5mdWxscGF0aCgpKTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmtUYXJnZXQgPSB0aGlzLnBhcmVudC5yZWFscGF0aFN5bmMoKT8ucmVzb2x2ZShyZWFkKTtcbiAgICAgICAgICAgIGlmIChsaW5rVGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNsaW5rVGFyZ2V0ID0gbGlua1RhcmdldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICB0aGlzLiNyZWFkbGlua0ZhaWwoZXIuY29kZSk7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxuICAgICNyZWFkZGlyU3VjY2VzcyhjaGlsZHJlbikge1xuICAgICAgICAvLyBzdWNjZWVkZWQsIG1hcmsgcmVhZGRpciBjYWxsZWQgYml0XG4gICAgICAgIHRoaXMuI3R5cGUgfD0gUkVBRERJUl9DQUxMRUQ7XG4gICAgICAgIC8vIG1hcmsgYWxsIHJlbWFpbmluZyBwcm92aXNpb25hbCBjaGlsZHJlbiBhcyBFTk9FTlRcbiAgICAgICAgZm9yIChsZXQgcCA9IGNoaWxkcmVuLnByb3Zpc2lvbmFsOyBwIDwgY2hpbGRyZW4ubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSBjaGlsZHJlbltwXTtcbiAgICAgICAgICAgIGlmIChjKVxuICAgICAgICAgICAgICAgIGMuI21hcmtFTk9FTlQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjbWFya0VOT0VOVCgpIHtcbiAgICAgICAgLy8gbWFyayBhcyBVTktOT1dOIGFuZCBFTk9FTlRcbiAgICAgICAgaWYgKHRoaXMuI3R5cGUgJiBFTk9FTlQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuI3R5cGUgPSAodGhpcy4jdHlwZSB8IEVOT0VOVCkgJiBJRk1UX1VOS05PV047XG4gICAgICAgIHRoaXMuI21hcmtDaGlsZHJlbkVOT0VOVCgpO1xuICAgIH1cbiAgICAjbWFya0NoaWxkcmVuRU5PRU5UKCkge1xuICAgICAgICAvLyBhbGwgY2hpbGRyZW4gYXJlIHByb3Zpc2lvbmFsIGFuZCBkbyBub3QgZXhpc3RcbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XG4gICAgICAgIGNoaWxkcmVuLnByb3Zpc2lvbmFsID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIGNoaWxkcmVuKSB7XG4gICAgICAgICAgICBwLiNtYXJrRU5PRU5UKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgI21hcmtFTk9SRUFMUEFUSCgpIHtcbiAgICAgICAgdGhpcy4jdHlwZSB8PSBFTk9SRUFMUEFUSDtcbiAgICAgICAgdGhpcy4jbWFya0VOT1RESVIoKTtcbiAgICB9XG4gICAgLy8gc2F2ZSB0aGUgaW5mb3JtYXRpb24gd2hlbiB3ZSBrbm93IHRoZSBlbnRyeSBpcyBub3QgYSBkaXJcbiAgICAjbWFya0VOT1RESVIoKSB7XG4gICAgICAgIC8vIGVudHJ5IGlzIG5vdCBhIGRpcmVjdG9yeSwgc28gYW55IGNoaWxkcmVuIGNhbid0IGV4aXN0LlxuICAgICAgICAvLyB0aGlzICpzaG91bGQqIGJlIGltcG9zc2libGUsIHNpbmNlIGFueSBjaGlsZHJlbiBjcmVhdGVkXG4gICAgICAgIC8vIGFmdGVyIGl0J3MgYmVlbiBtYXJrZWQgRU5PVERJUiBzaG91bGQgYmUgbWFya2VkIEVOT0VOVCxcbiAgICAgICAgLy8gc28gaXQgd29uJ3QgZXZlbiBnZXQgdG8gdGhpcyBwb2ludC5cbiAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgIGlmICh0aGlzLiN0eXBlICYgRU5PVERJUilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgbGV0IHQgPSB0aGlzLiN0eXBlO1xuICAgICAgICAvLyB0aGlzIGNvdWxkIGhhcHBlbiBpZiB3ZSBzdGF0IGEgZGlyLCB0aGVuIGRlbGV0ZSBpdCxcbiAgICAgICAgLy8gdGhlbiB0cnkgdG8gcmVhZCBpdCBvciBvbmUgb2YgaXRzIGNoaWxkcmVuLlxuICAgICAgICBpZiAoKHQgJiBJRk1UKSA9PT0gSUZESVIpXG4gICAgICAgICAgICB0ICY9IElGTVRfVU5LTk9XTjtcbiAgICAgICAgdGhpcy4jdHlwZSA9IHQgfCBFTk9URElSO1xuICAgICAgICB0aGlzLiNtYXJrQ2hpbGRyZW5FTk9FTlQoKTtcbiAgICB9XG4gICAgI3JlYWRkaXJGYWlsKGNvZGUgPSAnJykge1xuICAgICAgICAvLyBtYXJrRU5PVERJUiBhbmQgbWFya0VOT0VOVCBhbHNvIHNldCBwcm92aXNpb25hbD0wXG4gICAgICAgIGlmIChjb2RlID09PSAnRU5PVERJUicgfHwgY29kZSA9PT0gJ0VQRVJNJykge1xuICAgICAgICAgICAgdGhpcy4jbWFya0VOT1RESVIoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgICAgICAgdGhpcy4jbWFya0VOT0VOVCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbigpLnByb3Zpc2lvbmFsID0gMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAjbHN0YXRGYWlsKGNvZGUgPSAnJykge1xuICAgICAgICAvLyBXaW5kb3dzIGp1c3QgcmFpc2VzIEVOT0VOVCBpbiB0aGlzIGNhc2UsIGRpc2FibGUgZm9yIHdpbiBDSVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgaWYgKGNvZGUgPT09ICdFTk9URElSJykge1xuICAgICAgICAgICAgLy8gYWxyZWFkeSBrbm93IGl0IGhhcyBhIHBhcmVudCBieSB0aGlzIHBvaW50XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5wYXJlbnQ7XG4gICAgICAgICAgICBwLiNtYXJrRU5PVERJUigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvZGUgPT09ICdFTk9FTlQnKSB7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgdGhpcy4jbWFya0VOT0VOVCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgICNyZWFkbGlua0ZhaWwoY29kZSA9ICcnKSB7XG4gICAgICAgIGxldCB0ZXIgPSB0aGlzLiN0eXBlO1xuICAgICAgICB0ZXIgfD0gRU5PUkVBRExJTks7XG4gICAgICAgIGlmIChjb2RlID09PSAnRU5PRU5UJylcbiAgICAgICAgICAgIHRlciB8PSBFTk9FTlQ7XG4gICAgICAgIC8vIHdpbmRvd3MgZ2V0cyBhIHdlaXJkIGVycm9yIHdoZW4geW91IHRyeSB0byByZWFkbGluayBhIGZpbGVcbiAgICAgICAgaWYgKGNvZGUgPT09ICdFSU5WQUwnIHx8IGNvZGUgPT09ICdVTktOT1dOJykge1xuICAgICAgICAgICAgLy8gZXhpc3RzLCBidXQgbm90IGEgc3ltbGluaywgd2UgZG9uJ3Qga25vdyBXSEFUIGl0IGlzLCBzbyByZW1vdmVcbiAgICAgICAgICAgIC8vIGFsbCBJRk1UIGJpdHMuXG4gICAgICAgICAgICB0ZXIgJj0gSUZNVF9VTktOT1dOO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3R5cGUgPSB0ZXI7XG4gICAgICAgIC8vIHdpbmRvd3MganVzdCBnZXRzIEVOT0VOVCBpbiB0aGlzIGNhc2UuICBXZSBkbyBjb3ZlciB0aGUgY2FzZSxcbiAgICAgICAgLy8ganVzdCBkaXNhYmxlZCBiZWNhdXNlIGl0J3MgaW1wb3NzaWJsZSBvbiBXaW5kb3dzIENJXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoY29kZSA9PT0gJ0VOT1RESVInICYmIHRoaXMucGFyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnBhcmVudC4jbWFya0VOT1RESVIoKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgIH1cbiAgICAjcmVhZGRpckFkZENoaWxkKGUsIGMpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLiNyZWFkZGlyTWF5YmVQcm9tb3RlQ2hpbGQoZSwgYykgfHxcbiAgICAgICAgICAgIHRoaXMuI3JlYWRkaXJBZGROZXdDaGlsZChlLCBjKSk7XG4gICAgfVxuICAgICNyZWFkZGlyQWRkTmV3Q2hpbGQoZSwgYykge1xuICAgICAgICAvLyBhbGxvYyBuZXcgZW50cnkgYXQgaGVhZCwgc28gaXQncyBuZXZlciBwcm92aXNpb25hbFxuICAgICAgICBjb25zdCB0eXBlID0gZW50VG9UeXBlKGUpO1xuICAgICAgICBjb25zdCBjaGlsZCA9IHRoaXMubmV3Q2hpbGQoZS5uYW1lLCB0eXBlLCB7IHBhcmVudDogdGhpcyB9KTtcbiAgICAgICAgY29uc3QgaWZtdCA9IGNoaWxkLiN0eXBlICYgSUZNVDtcbiAgICAgICAgaWYgKGlmbXQgIT09IElGRElSICYmIGlmbXQgIT09IElGTE5LICYmIGlmbXQgIT09IFVOS05PV04pIHtcbiAgICAgICAgICAgIGNoaWxkLiN0eXBlIHw9IEVOT1RESVI7XG4gICAgICAgIH1cbiAgICAgICAgYy51bnNoaWZ0KGNoaWxkKTtcbiAgICAgICAgYy5wcm92aXNpb25hbCsrO1xuICAgICAgICByZXR1cm4gY2hpbGQ7XG4gICAgfVxuICAgICNyZWFkZGlyTWF5YmVQcm9tb3RlQ2hpbGQoZSwgYykge1xuICAgICAgICBmb3IgKGxldCBwID0gYy5wcm92aXNpb25hbDsgcCA8IGMubGVuZ3RoOyBwKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHBjaGlsZCA9IGNbcF07XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdGhpcy5ub2Nhc2UgPyBub3JtYWxpemVOb2Nhc2UoZS5uYW1lKSA6IG5vcm1hbGl6ZShlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT09IHBjaGlsZC4jbWF0Y2hOYW1lKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVhZGRpclByb21vdGVDaGlsZChlLCBwY2hpbGQsIHAsIGMpO1xuICAgICAgICB9XG4gICAgfVxuICAgICNyZWFkZGlyUHJvbW90ZUNoaWxkKGUsIHAsIGluZGV4LCBjKSB7XG4gICAgICAgIGNvbnN0IHYgPSBwLm5hbWU7XG4gICAgICAgIC8vIHJldGFpbiBhbnkgb3RoZXIgZmxhZ3MsIGJ1dCBzZXQgaWZtdCBmcm9tIGRpcmVudFxuICAgICAgICBwLiN0eXBlID0gKHAuI3R5cGUgJiBJRk1UX1VOS05PV04pIHwgZW50VG9UeXBlKGUpO1xuICAgICAgICAvLyBjYXNlIHNlbnNpdGl2aXR5IGZpeGluZyB3aGVuIHdlIGxlYXJuIHRoZSB0cnVlIG5hbWUuXG4gICAgICAgIGlmICh2ICE9PSBlLm5hbWUpXG4gICAgICAgICAgICBwLm5hbWUgPSBlLm5hbWU7XG4gICAgICAgIC8vIGp1c3QgYWR2YW5jZSBwcm92aXNpb25hbCBpbmRleCAocG90ZW50aWFsbHkgb2ZmIHRoZSBsaXN0KSxcbiAgICAgICAgLy8gb3RoZXJ3aXNlIHdlIGhhdmUgdG8gc3BsaWNlL3BvcCBpdCBvdXQgYW5kIHJlLWluc2VydCBhdCBoZWFkXG4gICAgICAgIGlmIChpbmRleCAhPT0gYy5wcm92aXNpb25hbCkge1xuICAgICAgICAgICAgaWYgKGluZGV4ID09PSBjLmxlbmd0aCAtIDEpXG4gICAgICAgICAgICAgICAgYy5wb3AoKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICBjLnVuc2hpZnQocCk7XG4gICAgICAgIH1cbiAgICAgICAgYy5wcm92aXNpb25hbCsrO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBsc3RhdCgpIG9uIHRoaXMgUGF0aCwgYW5kIHVwZGF0ZSBhbGwga25vd24gaW5mb3JtYXRpb24gdGhhdCBjYW4gYmVcbiAgICAgKiBkZXRlcm1pbmVkLlxuICAgICAqXG4gICAgICogTm90ZSB0aGF0IHVubGlrZSBgZnMubHN0YXQoKWAsIHRoZSByZXR1cm5lZCB2YWx1ZSBkb2VzIG5vdCBjb250YWluIHNvbWVcbiAgICAgKiBpbmZvcm1hdGlvbiwgc3VjaCBhcyBgbW9kZWAsIGBkZXZgLCBgbmxpbmtgLCBhbmQgYGlub2AuICBJZiB0aGF0XG4gICAgICogaW5mb3JtYXRpb24gaXMgcmVxdWlyZWQsIHlvdSB3aWxsIG5lZWQgdG8gY2FsbCBgZnMubHN0YXRgIHlvdXJzZWxmLlxuICAgICAqXG4gICAgICogSWYgdGhlIFBhdGggcmVmZXJzIHRvIGEgbm9uZXhpc3RlbnQgZmlsZSwgb3IgaWYgdGhlIGxzdGF0IGNhbGwgZmFpbHMgZm9yXG4gICAgICogYW55IHJlYXNvbiwgYHVuZGVmaW5lZGAgaXMgcmV0dXJuZWQuICBPdGhlcndpc2UgdGhlIHVwZGF0ZWQgUGF0aCBvYmplY3QgaXNcbiAgICAgKiByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIFJlc3VsdHMgYXJlIGNhY2hlZCwgYW5kIHRodXMgbWF5IGJlIG91dCBvZiBkYXRlIGlmIHRoZSBmaWxlc3lzdGVtIGlzXG4gICAgICogbXV0YXRlZC5cbiAgICAgKi9cbiAgICBhc3luYyBsc3RhdCgpIHtcbiAgICAgICAgaWYgKCh0aGlzLiN0eXBlICYgRU5PRU5UKSA9PT0gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNhcHBseVN0YXQoYXdhaXQgdGhpcy4jZnMucHJvbWlzZXMubHN0YXQodGhpcy5mdWxscGF0aCgpKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNsc3RhdEZhaWwoZXIuY29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogc3luY2hyb25vdXMge0BsaW5rIFBhdGhCYXNlLmxzdGF0fVxuICAgICAqL1xuICAgIGxzdGF0U3luYygpIHtcbiAgICAgICAgaWYgKCh0aGlzLiN0eXBlICYgRU5PRU5UKSA9PT0gMCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLiNhcHBseVN0YXQodGhpcy4jZnMubHN0YXRTeW5jKHRoaXMuZnVsbHBhdGgoKSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jbHN0YXRGYWlsKGVyLmNvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgICNhcHBseVN0YXQoc3QpIHtcbiAgICAgICAgY29uc3QgeyBhdGltZSwgYXRpbWVNcywgYmlydGh0aW1lLCBiaXJ0aHRpbWVNcywgYmxrc2l6ZSwgYmxvY2tzLCBjdGltZSwgY3RpbWVNcywgZGV2LCBnaWQsIGlubywgbW9kZSwgbXRpbWUsIG10aW1lTXMsIG5saW5rLCByZGV2LCBzaXplLCB1aWQsIH0gPSBzdDtcbiAgICAgICAgdGhpcy4jYXRpbWUgPSBhdGltZTtcbiAgICAgICAgdGhpcy4jYXRpbWVNcyA9IGF0aW1lTXM7XG4gICAgICAgIHRoaXMuI2JpcnRodGltZSA9IGJpcnRodGltZTtcbiAgICAgICAgdGhpcy4jYmlydGh0aW1lTXMgPSBiaXJ0aHRpbWVNcztcbiAgICAgICAgdGhpcy4jYmxrc2l6ZSA9IGJsa3NpemU7XG4gICAgICAgIHRoaXMuI2Jsb2NrcyA9IGJsb2NrcztcbiAgICAgICAgdGhpcy4jY3RpbWUgPSBjdGltZTtcbiAgICAgICAgdGhpcy4jY3RpbWVNcyA9IGN0aW1lTXM7XG4gICAgICAgIHRoaXMuI2RldiA9IGRldjtcbiAgICAgICAgdGhpcy4jZ2lkID0gZ2lkO1xuICAgICAgICB0aGlzLiNpbm8gPSBpbm87XG4gICAgICAgIHRoaXMuI21vZGUgPSBtb2RlO1xuICAgICAgICB0aGlzLiNtdGltZSA9IG10aW1lO1xuICAgICAgICB0aGlzLiNtdGltZU1zID0gbXRpbWVNcztcbiAgICAgICAgdGhpcy4jbmxpbmsgPSBubGluaztcbiAgICAgICAgdGhpcy4jcmRldiA9IHJkZXY7XG4gICAgICAgIHRoaXMuI3NpemUgPSBzaXplO1xuICAgICAgICB0aGlzLiN1aWQgPSB1aWQ7XG4gICAgICAgIGNvbnN0IGlmbXQgPSBlbnRUb1R5cGUoc3QpO1xuICAgICAgICAvLyByZXRhaW4gYW55IG90aGVyIGZsYWdzLCBidXQgc2V0IHRoZSBpZm10XG4gICAgICAgIHRoaXMuI3R5cGUgPSAodGhpcy4jdHlwZSAmIElGTVRfVU5LTk9XTikgfCBpZm10IHwgTFNUQVRfQ0FMTEVEO1xuICAgICAgICBpZiAoaWZtdCAhPT0gVU5LTk9XTiAmJiBpZm10ICE9PSBJRkRJUiAmJiBpZm10ICE9PSBJRkxOSykge1xuICAgICAgICAgICAgdGhpcy4jdHlwZSB8PSBFTk9URElSO1xuICAgICAgICB9XG4gICAgfVxuICAgICNvblJlYWRkaXJDQiA9IFtdO1xuICAgICNyZWFkZGlyQ0JJbkZsaWdodCA9IGZhbHNlO1xuICAgICNjYWxsT25SZWFkZGlyQ0IoY2hpbGRyZW4pIHtcbiAgICAgICAgdGhpcy4jcmVhZGRpckNCSW5GbGlnaHQgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgY2JzID0gdGhpcy4jb25SZWFkZGlyQ0Iuc2xpY2UoKTtcbiAgICAgICAgdGhpcy4jb25SZWFkZGlyQ0IubGVuZ3RoID0gMDtcbiAgICAgICAgY2JzLmZvckVhY2goY2IgPT4gY2IobnVsbCwgY2hpbGRyZW4pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgbm9kZS1zdHlsZSBjYWxsYmFjayBpbnRlcmZhY2UgdG8gZ2V0IGxpc3Qgb2YgZGlyZWN0b3J5IGVudHJpZXMuXG4gICAgICpcbiAgICAgKiBJZiB0aGUgUGF0aCBjYW5ub3Qgb3IgZG9lcyBub3QgY29udGFpbiBhbnkgY2hpbGRyZW4sIHRoZW4gYW4gZW1wdHkgYXJyYXlcbiAgICAgKiBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIFJlc3VsdHMgYXJlIGNhY2hlZCwgYW5kIHRodXMgbWF5IGJlIG91dCBvZiBkYXRlIGlmIHRoZSBmaWxlc3lzdGVtIGlzXG4gICAgICogbXV0YXRlZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYiBUaGUgY2FsbGJhY2sgY2FsbGVkIHdpdGggKGVyLCBlbnRyaWVzKS4gIE5vdGUgdGhhdCB0aGUgYGVyYFxuICAgICAqIHBhcmFtIGlzIHNvbWV3aGF0IGV4dHJhbmVvdXMsIGFzIGFsbCByZWFkZGlyKCkgZXJyb3JzIGFyZSBoYW5kbGVkIGFuZFxuICAgICAqIHNpbXBseSByZXN1bHQgaW4gYW4gZW1wdHkgc2V0IG9mIGVudHJpZXMgYmVpbmcgcmV0dXJuZWQuXG4gICAgICogQHBhcmFtIGFsbG93WmFsZ28gQm9vbGVhbiBpbmRpY2F0aW5nIHRoYXQgaW1tZWRpYXRlbHkga25vd24gcmVzdWx0cyBzaG91bGRcbiAgICAgKiAqbm90KiBiZSBkZWZlcnJlZCB3aXRoIGBxdWV1ZU1pY3JvdGFza2AuIERlZmF1bHRzIHRvIGBmYWxzZWAuIFJlbGVhc2VcbiAgICAgKiB6YWxnbyBhdCB5b3VyIHBlcmlsLCB0aGUgZGFyayBwb255IGxvcmQgaXMgZGV2aW91cyBhbmQgdW5mb3JnaXZpbmcuXG4gICAgICovXG4gICAgcmVhZGRpckNCKGNiLCBhbGxvd1phbGdvID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhblJlYWRkaXIoKSkge1xuICAgICAgICAgICAgaWYgKGFsbG93WmFsZ28pXG4gICAgICAgICAgICAgICAgY2IobnVsbCwgW10pO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNiKG51bGwsIFtdKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuKCk7XG4gICAgICAgIGlmICh0aGlzLmNhbGxlZFJlYWRkaXIoKSkge1xuICAgICAgICAgICAgY29uc3QgYyA9IGNoaWxkcmVuLnNsaWNlKDAsIGNoaWxkcmVuLnByb3Zpc2lvbmFsKTtcbiAgICAgICAgICAgIGlmIChhbGxvd1phbGdvKVxuICAgICAgICAgICAgICAgIGNiKG51bGwsIGMpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHF1ZXVlTWljcm90YXNrKCgpID0+IGNiKG51bGwsIGMpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBkb24ndCBoYXZlIHRvIHdvcnJ5IGFib3V0IHphbGdvIGF0IHRoaXMgcG9pbnQuXG4gICAgICAgIHRoaXMuI29uUmVhZGRpckNCLnB1c2goY2IpO1xuICAgICAgICBpZiAodGhpcy4jcmVhZGRpckNCSW5GbGlnaHQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNyZWFkZGlyQ0JJbkZsaWdodCA9IHRydWU7XG4gICAgICAgIC8vIGVsc2UgcmVhZCB0aGUgZGlyZWN0b3J5LCBmaWxsIHVwIGNoaWxkcmVuXG4gICAgICAgIC8vIGRlLXByb3Zpc2lvbmFsaXplIGFueSBwcm92aXNpb25hbCBjaGlsZHJlbi5cbiAgICAgICAgY29uc3QgZnVsbHBhdGggPSB0aGlzLmZ1bGxwYXRoKCk7XG4gICAgICAgIHRoaXMuI2ZzLnJlYWRkaXIoZnVsbHBhdGgsIHsgd2l0aEZpbGVUeXBlczogdHJ1ZSB9LCAoZXIsIGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuI3JlYWRkaXJGYWlsKGVyLmNvZGUpO1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuLnByb3Zpc2lvbmFsID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYW4gZXJyb3IsIHdlIGFsd2F5cyBnZXQgZW50cmllcy5cbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiNyZWFkZGlyQWRkQ2hpbGQoZSwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLiNyZWFkZGlyU3VjY2VzcyhjaGlsZHJlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLiNjYWxsT25SZWFkZGlyQ0IoY2hpbGRyZW4uc2xpY2UoMCwgY2hpbGRyZW4ucHJvdmlzaW9uYWwpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgICNhc3luY1JlYWRkaXJJbkZsaWdodDtcbiAgICAvKipcbiAgICAgKiBSZXR1cm4gYW4gYXJyYXkgb2Yga25vd24gY2hpbGQgZW50cmllcy5cbiAgICAgKlxuICAgICAqIElmIHRoZSBQYXRoIGNhbm5vdCBvciBkb2VzIG5vdCBjb250YWluIGFueSBjaGlsZHJlbiwgdGhlbiBhbiBlbXB0eSBhcnJheVxuICAgICAqIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogUmVzdWx0cyBhcmUgY2FjaGVkLCBhbmQgdGh1cyBtYXkgYmUgb3V0IG9mIGRhdGUgaWYgdGhlIGZpbGVzeXN0ZW0gaXNcbiAgICAgKiBtdXRhdGVkLlxuICAgICAqL1xuICAgIGFzeW5jIHJlYWRkaXIoKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW5SZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcbiAgICAgICAgaWYgKHRoaXMuY2FsbGVkUmVhZGRpcigpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW4uc2xpY2UoMCwgY2hpbGRyZW4ucHJvdmlzaW9uYWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UgcmVhZCB0aGUgZGlyZWN0b3J5LCBmaWxsIHVwIGNoaWxkcmVuXG4gICAgICAgIC8vIGRlLXByb3Zpc2lvbmFsaXplIGFueSBwcm92aXNpb25hbCBjaGlsZHJlbi5cbiAgICAgICAgY29uc3QgZnVsbHBhdGggPSB0aGlzLmZ1bGxwYXRoKCk7XG4gICAgICAgIGlmICh0aGlzLiNhc3luY1JlYWRkaXJJbkZsaWdodCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy4jYXN5bmNSZWFkZGlySW5GbGlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgIGxldCByZXNvbHZlID0gKCkgPT4geyB9O1xuICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgIHRoaXMuI2FzeW5jUmVhZGRpckluRmxpZ2h0ID0gbmV3IFByb21pc2UocmVzID0+IChyZXNvbHZlID0gcmVzKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBhd2FpdCB0aGlzLiNmcy5wcm9taXNlcy5yZWFkZGlyKGZ1bGxwYXRoLCB7XG4gICAgICAgICAgICAgICAgICAgIHdpdGhGaWxlVHlwZXM6IHRydWUsXG4gICAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4jcmVhZGRpckFkZENoaWxkKGUsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVhZGRpclN1Y2Nlc3MoY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4jcmVhZGRpckZhaWwoZXIuY29kZSk7XG4gICAgICAgICAgICAgICAgY2hpbGRyZW4ucHJvdmlzaW9uYWwgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jYXN5bmNSZWFkZGlySW5GbGlnaHQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuLnNsaWNlKDAsIGNoaWxkcmVuLnByb3Zpc2lvbmFsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc3luY2hyb25vdXMge0BsaW5rIFBhdGhCYXNlLnJlYWRkaXJ9XG4gICAgICovXG4gICAgcmVhZGRpclN5bmMoKSB7XG4gICAgICAgIGlmICghdGhpcy5jYW5SZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuY2hpbGRyZW4oKTtcbiAgICAgICAgaWYgKHRoaXMuY2FsbGVkUmVhZGRpcigpKSB7XG4gICAgICAgICAgICByZXR1cm4gY2hpbGRyZW4uc2xpY2UoMCwgY2hpbGRyZW4ucHJvdmlzaW9uYWwpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGVsc2UgcmVhZCB0aGUgZGlyZWN0b3J5LCBmaWxsIHVwIGNoaWxkcmVuXG4gICAgICAgIC8vIGRlLXByb3Zpc2lvbmFsaXplIGFueSBwcm92aXNpb25hbCBjaGlsZHJlbi5cbiAgICAgICAgY29uc3QgZnVsbHBhdGggPSB0aGlzLmZ1bGxwYXRoKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgdGhpcy4jZnMucmVhZGRpclN5bmMoZnVsbHBhdGgsIHtcbiAgICAgICAgICAgICAgICB3aXRoRmlsZVR5cGVzOiB0cnVlLFxuICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLiNyZWFkZGlyQWRkQ2hpbGQoZSwgY2hpbGRyZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy4jcmVhZGRpclN1Y2Nlc3MoY2hpbGRyZW4pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcikge1xuICAgICAgICAgICAgdGhpcy4jcmVhZGRpckZhaWwoZXIuY29kZSk7XG4gICAgICAgICAgICBjaGlsZHJlbi5wcm92aXNpb25hbCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuLnNsaWNlKDAsIGNoaWxkcmVuLnByb3Zpc2lvbmFsKTtcbiAgICB9XG4gICAgY2FuUmVhZGRpcigpIHtcbiAgICAgICAgaWYgKHRoaXMuI3R5cGUgJiBFTk9DSElMRClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3QgaWZtdCA9IElGTVQgJiB0aGlzLiN0eXBlO1xuICAgICAgICAvLyB3ZSBhbHdheXMgc2V0IEVOT1RESVIgd2hlbiBzZXR0aW5nIElGTVQsIHNvIHNob3VsZCBiZSBpbXBvc3NpYmxlXG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAoIShpZm10ID09PSBVTktOT1dOIHx8IGlmbXQgPT09IElGRElSIHx8IGlmbXQgPT09IElGTE5LKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdG9wICovXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzaG91bGRXYWxrKGRpcnMsIHdhbGtGaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuICgodGhpcy4jdHlwZSAmIElGRElSKSA9PT0gSUZESVIgJiZcbiAgICAgICAgICAgICEodGhpcy4jdHlwZSAmIEVOT0NISUxEKSAmJlxuICAgICAgICAgICAgIWRpcnMuaGFzKHRoaXMpICYmXG4gICAgICAgICAgICAoIXdhbGtGaWx0ZXIgfHwgd2Fsa0ZpbHRlcih0aGlzKSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIFBhdGggb2JqZWN0IGNvcnJlc3BvbmRpbmcgdG8gcGF0aCBhcyByZXNvbHZlZFxuICAgICAqIGJ5IHJlYWxwYXRoKDMpLlxuICAgICAqXG4gICAgICogSWYgdGhlIHJlYWxwYXRoIGNhbGwgZmFpbHMgZm9yIGFueSByZWFzb24sIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogUmVzdWx0IGlzIGNhY2hlZCwgYW5kIHRodXMgbWF5IGJlIG91dGRhdGVkIGlmIHRoZSBmaWxlc3lzdGVtIGlzIG11dGF0ZWQuXG4gICAgICogT24gc3VjY2VzcywgcmV0dXJucyBhIFBhdGggb2JqZWN0LlxuICAgICAqL1xuICAgIGFzeW5jIHJlYWxwYXRoKCkge1xuICAgICAgICBpZiAodGhpcy4jcmVhbHBhdGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy4jcmVhbHBhdGg7XG4gICAgICAgIGlmICgoRU5PUkVBTFBBVEggfCBFTk9SRUFETElOSyB8IEVOT0VOVCkgJiB0aGlzLiN0eXBlKVxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJwID0gYXdhaXQgdGhpcy4jZnMucHJvbWlzZXMucmVhbHBhdGgodGhpcy5mdWxscGF0aCgpKTtcbiAgICAgICAgICAgIHJldHVybiAodGhpcy4jcmVhbHBhdGggPSB0aGlzLnJlc29sdmUocnApKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoXykge1xuICAgICAgICAgICAgdGhpcy4jbWFya0VOT1JFQUxQQVRIKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3luY2hyb25vdXMge0BsaW5rIHJlYWxwYXRofVxuICAgICAqL1xuICAgIHJlYWxwYXRoU3luYygpIHtcbiAgICAgICAgaWYgKHRoaXMuI3JlYWxwYXRoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuI3JlYWxwYXRoO1xuICAgICAgICBpZiAoKEVOT1JFQUxQQVRIIHwgRU5PUkVBRExJTksgfCBFTk9FTlQpICYgdGhpcy4jdHlwZSlcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBycCA9IHRoaXMuI2ZzLnJlYWxwYXRoU3luYyh0aGlzLmZ1bGxwYXRoKCkpO1xuICAgICAgICAgICAgcmV0dXJuICh0aGlzLiNyZWFscGF0aCA9IHRoaXMucmVzb2x2ZShycCkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICB0aGlzLiNtYXJrRU5PUkVBTFBBVEgoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnRlcm5hbCBtZXRob2QgdG8gbWFyayB0aGlzIFBhdGggb2JqZWN0IGFzIHRoZSBzY3VycnkgY3dkLFxuICAgICAqIGNhbGxlZCBieSB7QGxpbmsgUGF0aFNjdXJyeSNjaGRpcn1cbiAgICAgKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIFtzZXRBc0N3ZF0ob2xkQ3dkKSB7XG4gICAgICAgIGlmIChvbGRDd2QgPT09IHRoaXMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIG9sZEN3ZC5pc0NXRCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmlzQ1dEID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgY2hhbmdlZCA9IG5ldyBTZXQoW10pO1xuICAgICAgICBsZXQgcnAgPSBbXTtcbiAgICAgICAgbGV0IHAgPSB0aGlzO1xuICAgICAgICB3aGlsZSAocCAmJiBwLnBhcmVudCkge1xuICAgICAgICAgICAgY2hhbmdlZC5hZGQocCk7XG4gICAgICAgICAgICBwLiNyZWxhdGl2ZSA9IHJwLmpvaW4odGhpcy5zZXApO1xuICAgICAgICAgICAgcC4jcmVsYXRpdmVQb3NpeCA9IHJwLmpvaW4oJy8nKTtcbiAgICAgICAgICAgIHAgPSBwLnBhcmVudDtcbiAgICAgICAgICAgIHJwLnB1c2goJy4uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbm93IHVuLW1lbW9pemUgcGFyZW50cyBvZiBvbGQgY3dkXG4gICAgICAgIHAgPSBvbGRDd2Q7XG4gICAgICAgIHdoaWxlIChwICYmIHAucGFyZW50ICYmICFjaGFuZ2VkLmhhcyhwKSkge1xuICAgICAgICAgICAgcC4jcmVsYXRpdmUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwLiNyZWxhdGl2ZVBvc2l4ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgcCA9IHAucGFyZW50O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5QYXRoQmFzZSA9IFBhdGhCYXNlO1xuLyoqXG4gKiBQYXRoIGNsYXNzIHVzZWQgb24gd2luMzIgc3lzdGVtc1xuICpcbiAqIFVzZXMgYCdcXFxcJ2AgYXMgdGhlIHBhdGggc2VwYXJhdG9yIGZvciByZXR1cm5lZCBwYXRocywgZWl0aGVyIGAnXFxcXCdgIG9yIGAnLydgXG4gKiBhcyB0aGUgcGF0aCBzZXBhcmF0b3IgZm9yIHBhcnNpbmcgcGF0aHMuXG4gKi9cbmNsYXNzIFBhdGhXaW4zMiBleHRlbmRzIFBhdGhCYXNlIHtcbiAgICAvKipcbiAgICAgKiBTZXBhcmF0b3IgZm9yIGdlbmVyYXRpbmcgcGF0aCBzdHJpbmdzLlxuICAgICAqL1xuICAgIHNlcCA9ICdcXFxcJztcbiAgICAvKipcbiAgICAgKiBTZXBhcmF0b3IgZm9yIHBhcnNpbmcgcGF0aCBzdHJpbmdzLlxuICAgICAqL1xuICAgIHNwbGl0U2VwID0gZWl0aGVyU2VwO1xuICAgIC8qKlxuICAgICAqIERvIG5vdCBjcmVhdGUgbmV3IFBhdGggb2JqZWN0cyBkaXJlY3RseS4gIFRoZXkgc2hvdWxkIGFsd2F5cyBiZSBhY2Nlc3NlZFxuICAgICAqIHZpYSB0aGUgUGF0aFNjdXJyeSBjbGFzcyBvciBvdGhlciBtZXRob2RzIG9uIHRoZSBQYXRoIGNsYXNzLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobmFtZSwgdHlwZSA9IFVOS05PV04sIHJvb3QsIHJvb3RzLCBub2Nhc2UsIGNoaWxkcmVuLCBvcHRzKSB7XG4gICAgICAgIHN1cGVyKG5hbWUsIHR5cGUsIHJvb3QsIHJvb3RzLCBub2Nhc2UsIGNoaWxkcmVuLCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbmV3Q2hpbGQobmFtZSwgdHlwZSA9IFVOS05PV04sIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGhXaW4zMihuYW1lLCB0eXBlLCB0aGlzLnJvb3QsIHRoaXMucm9vdHMsIHRoaXMubm9jYXNlLCB0aGlzLmNoaWxkcmVuQ2FjaGUoKSwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldFJvb3RTdHJpbmcocGF0aCkge1xuICAgICAgICByZXR1cm4gbm9kZV9wYXRoXzEud2luMzIucGFyc2UocGF0aCkucm9vdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2V0Um9vdChyb290UGF0aCkge1xuICAgICAgICByb290UGF0aCA9IHVuY1RvRHJpdmUocm9vdFBhdGgudG9VcHBlckNhc2UoKSk7XG4gICAgICAgIGlmIChyb290UGF0aCA9PT0gdGhpcy5yb290Lm5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgLy8gb2ssIG5vdCB0aGF0IG9uZSwgY2hlY2sgaWYgaXQgbWF0Y2hlcyBhbm90aGVyIHdlIGtub3cgYWJvdXRcbiAgICAgICAgZm9yIChjb25zdCBbY29tcGFyZSwgcm9vdF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5yb290cykpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNhbWVSb290KHJvb3RQYXRoLCBjb21wYXJlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiAodGhpcy5yb290c1tyb290UGF0aF0gPSByb290KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBvdGhlcndpc2UsIGhhdmUgdG8gY3JlYXRlIGEgbmV3IG9uZS5cbiAgICAgICAgcmV0dXJuICh0aGlzLnJvb3RzW3Jvb3RQYXRoXSA9IG5ldyBQYXRoU2N1cnJ5V2luMzIocm9vdFBhdGgsIHRoaXMpLnJvb3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBzYW1lUm9vdChyb290UGF0aCwgY29tcGFyZSA9IHRoaXMucm9vdC5uYW1lKSB7XG4gICAgICAgIC8vIHdpbmRvd3MgY2FuIChyYXJlbHkpIGhhdmUgY2FzZS1zZW5zaXRpdmUgZmlsZXN5c3RlbSwgYnV0XG4gICAgICAgIC8vIFVOQyBhbmQgZHJpdmUgbGV0dGVycyBhcmUgYWx3YXlzIGNhc2UtaW5zZW5zaXRpdmUsIGFuZCBjYW5vbmljYWxseVxuICAgICAgICAvLyByZXByZXNlbnRlZCB1cHBlcmNhc2UuXG4gICAgICAgIHJvb3RQYXRoID0gcm9vdFBhdGhcbiAgICAgICAgICAgIC50b1VwcGVyQ2FzZSgpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFwvL2csICdcXFxcJylcbiAgICAgICAgICAgIC5yZXBsYWNlKHVuY0RyaXZlUmVnZXhwLCAnJDFcXFxcJyk7XG4gICAgICAgIHJldHVybiByb290UGF0aCA9PT0gY29tcGFyZTtcbiAgICB9XG59XG5leHBvcnRzLlBhdGhXaW4zMiA9IFBhdGhXaW4zMjtcbi8qKlxuICogUGF0aCBjbGFzcyB1c2VkIG9uIGFsbCBwb3NpeCBzeXN0ZW1zLlxuICpcbiAqIFVzZXMgYCcvJ2AgYXMgdGhlIHBhdGggc2VwYXJhdG9yLlxuICovXG5jbGFzcyBQYXRoUG9zaXggZXh0ZW5kcyBQYXRoQmFzZSB7XG4gICAgLyoqXG4gICAgICogc2VwYXJhdG9yIGZvciBwYXJzaW5nIHBhdGggc3RyaW5nc1xuICAgICAqL1xuICAgIHNwbGl0U2VwID0gJy8nO1xuICAgIC8qKlxuICAgICAqIHNlcGFyYXRvciBmb3IgZ2VuZXJhdGluZyBwYXRoIHN0cmluZ3NcbiAgICAgKi9cbiAgICBzZXAgPSAnLyc7XG4gICAgLyoqXG4gICAgICogRG8gbm90IGNyZWF0ZSBuZXcgUGF0aCBvYmplY3RzIGRpcmVjdGx5LiAgVGhleSBzaG91bGQgYWx3YXlzIGJlIGFjY2Vzc2VkXG4gICAgICogdmlhIHRoZSBQYXRoU2N1cnJ5IGNsYXNzIG9yIG90aGVyIG1ldGhvZHMgb24gdGhlIFBhdGggY2xhc3MuXG4gICAgICpcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCB0eXBlID0gVU5LTk9XTiwgcm9vdCwgcm9vdHMsIG5vY2FzZSwgY2hpbGRyZW4sIG9wdHMpIHtcbiAgICAgICAgc3VwZXIobmFtZSwgdHlwZSwgcm9vdCwgcm9vdHMsIG5vY2FzZSwgY2hpbGRyZW4sIG9wdHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBnZXRSb290U3RyaW5nKHBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHBhdGguc3RhcnRzV2l0aCgnLycpID8gJy8nIDogJyc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIGdldFJvb3QoX3Jvb3RQYXRoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpbnRlcm5hbFxuICAgICAqL1xuICAgIG5ld0NoaWxkKG5hbWUsIHR5cGUgPSBVTktOT1dOLCBvcHRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQYXRoUG9zaXgobmFtZSwgdHlwZSwgdGhpcy5yb290LCB0aGlzLnJvb3RzLCB0aGlzLm5vY2FzZSwgdGhpcy5jaGlsZHJlbkNhY2hlKCksIG9wdHMpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGF0aFBvc2l4ID0gUGF0aFBvc2l4O1xuLyoqXG4gKiBUaGUgYmFzZSBjbGFzcyBmb3IgYWxsIFBhdGhTY3VycnkgY2xhc3NlcywgcHJvdmlkaW5nIHRoZSBpbnRlcmZhY2UgZm9yIHBhdGhcbiAqIHJlc29sdXRpb24gYW5kIGZpbGVzeXN0ZW0gb3BlcmF0aW9ucy5cbiAqXG4gKiBUeXBpY2FsbHksIHlvdSBzaG91bGQgKm5vdCogaW5zdGFudGlhdGUgdGhpcyBjbGFzcyBkaXJlY3RseSwgYnV0IHJhdGhlciBvbmVcbiAqIG9mIHRoZSBwbGF0Zm9ybS1zcGVjaWZpYyBjbGFzc2VzLCBvciB0aGUgZXhwb3J0ZWQge0BsaW5rIFBhdGhTY3Vycnl9IHdoaWNoXG4gKiBkZWZhdWx0cyB0byB0aGUgY3VycmVudCBwbGF0Zm9ybS5cbiAqL1xuY2xhc3MgUGF0aFNjdXJyeUJhc2Uge1xuICAgIC8qKlxuICAgICAqIFRoZSByb290IFBhdGggZW50cnkgZm9yIHRoZSBjdXJyZW50IHdvcmtpbmcgZGlyZWN0b3J5IG9mIHRoaXMgU2N1cnJ5XG4gICAgICovXG4gICAgcm9vdDtcbiAgICAvKipcbiAgICAgKiBUaGUgc3RyaW5nIHBhdGggZm9yIHRoZSByb290IG9mIHRoaXMgU2N1cnJ5J3MgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeVxuICAgICAqL1xuICAgIHJvb3RQYXRoO1xuICAgIC8qKlxuICAgICAqIEEgY29sbGVjdGlvbiBvZiBhbGwgcm9vdHMgZW5jb3VudGVyZWQsIHJlZmVyZW5jZWQgYnkgcm9vdFBhdGhcbiAgICAgKi9cbiAgICByb290cztcbiAgICAvKipcbiAgICAgKiBUaGUgUGF0aCBlbnRyeSBjb3JyZXNwb25kaW5nIHRvIHRoaXMgUGF0aFNjdXJyeSdzIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgY3dkO1xuICAgICNyZXNvbHZlQ2FjaGU7XG4gICAgI3Jlc29sdmVQb3NpeENhY2hlO1xuICAgICNjaGlsZHJlbjtcbiAgICAvKipcbiAgICAgKiBQZXJmb3JtIHBhdGggY29tcGFyaXNvbnMgY2FzZS1pbnNlbnNpdGl2ZWx5LlxuICAgICAqXG4gICAgICogRGVmYXVsdHMgdHJ1ZSBvbiBEYXJ3aW4gYW5kIFdpbmRvd3Mgc3lzdGVtcywgZmFsc2UgZWxzZXdoZXJlLlxuICAgICAqL1xuICAgIG5vY2FzZTtcbiAgICAjZnM7XG4gICAgLyoqXG4gICAgICogVGhpcyBjbGFzcyBzaG91bGQgbm90IGJlIGluc3RhbnRpYXRlZCBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqIFVzZSBQYXRoU2N1cnJ5V2luMzIsIFBhdGhTY3VycnlEYXJ3aW4sIFBhdGhTY3VycnlQb3NpeCwgb3IgUGF0aFNjdXJyeVxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoY3dkID0gcHJvY2Vzcy5jd2QoKSwgcGF0aEltcGwsIHNlcCwgeyBub2Nhc2UsIGNoaWxkcmVuQ2FjaGVTaXplID0gMTYgKiAxMDI0LCBmcyA9IGRlZmF1bHRGUywgfSA9IHt9KSB7XG4gICAgICAgIHRoaXMuI2ZzID0gZnNGcm9tT3B0aW9uKGZzKTtcbiAgICAgICAgaWYgKGN3ZCBpbnN0YW5jZW9mIFVSTCB8fCBjd2Quc3RhcnRzV2l0aCgnZmlsZTovLycpKSB7XG4gICAgICAgICAgICBjd2QgPSAoMCwgbm9kZV91cmxfMS5maWxlVVJMVG9QYXRoKShjd2QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc29sdmUgYW5kIHNwbGl0IHJvb3QsIGFuZCB0aGVuIGFkZCB0byB0aGUgc3RvcmUuXG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIG9ubHkgdGltZSB3ZSBjYWxsIHBhdGgucmVzb2x2ZSgpXG4gICAgICAgIGNvbnN0IGN3ZFBhdGggPSBwYXRoSW1wbC5yZXNvbHZlKGN3ZCk7XG4gICAgICAgIHRoaXMucm9vdHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLnJvb3RQYXRoID0gdGhpcy5wYXJzZVJvb3RQYXRoKGN3ZFBhdGgpO1xuICAgICAgICB0aGlzLiNyZXNvbHZlQ2FjaGUgPSBuZXcgUmVzb2x2ZUNhY2hlKCk7XG4gICAgICAgIHRoaXMuI3Jlc29sdmVQb3NpeENhY2hlID0gbmV3IFJlc29sdmVDYWNoZSgpO1xuICAgICAgICB0aGlzLiNjaGlsZHJlbiA9IG5ldyBDaGlsZHJlbkNhY2hlKGNoaWxkcmVuQ2FjaGVTaXplKTtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBjd2RQYXRoLnN1YnN0cmluZyh0aGlzLnJvb3RQYXRoLmxlbmd0aCkuc3BsaXQoc2VwKTtcbiAgICAgICAgLy8gcmVzb2x2ZSgnLycpIGxlYXZlcyAnJywgc3BsaXRzIHRvIFsnJ10sIHdlIGRvbid0IHdhbnQgdGhhdC5cbiAgICAgICAgaWYgKHNwbGl0Lmxlbmd0aCA9PT0gMSAmJiAhc3BsaXRbMF0pIHtcbiAgICAgICAgICAgIHNwbGl0LnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICBpZiAobm9jYXNlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ211c3QgcHJvdmlkZSBub2Nhc2Ugc2V0dGluZyB0byBQYXRoU2N1cnJ5QmFzZSBjdG9yJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgdGhpcy5ub2Nhc2UgPSBub2Nhc2U7XG4gICAgICAgIHRoaXMucm9vdCA9IHRoaXMubmV3Um9vdCh0aGlzLiNmcyk7XG4gICAgICAgIHRoaXMucm9vdHNbdGhpcy5yb290UGF0aF0gPSB0aGlzLnJvb3Q7XG4gICAgICAgIGxldCBwcmV2ID0gdGhpcy5yb290O1xuICAgICAgICBsZXQgbGVuID0gc3BsaXQubGVuZ3RoIC0gMTtcbiAgICAgICAgY29uc3Qgam9pblNlcCA9IHBhdGhJbXBsLnNlcDtcbiAgICAgICAgbGV0IGFicyA9IHRoaXMucm9vdFBhdGg7XG4gICAgICAgIGxldCBzYXdGaXJzdCA9IGZhbHNlO1xuICAgICAgICBmb3IgKGNvbnN0IHBhcnQgb2Ygc3BsaXQpIHtcbiAgICAgICAgICAgIGNvbnN0IGwgPSBsZW4tLTtcbiAgICAgICAgICAgIHByZXYgPSBwcmV2LmNoaWxkKHBhcnQsIHtcbiAgICAgICAgICAgICAgICByZWxhdGl2ZTogbmV3IEFycmF5KGwpLmZpbGwoJy4uJykuam9pbihqb2luU2VwKSxcbiAgICAgICAgICAgICAgICByZWxhdGl2ZVBvc2l4OiBuZXcgQXJyYXkobCkuZmlsbCgnLi4nKS5qb2luKCcvJyksXG4gICAgICAgICAgICAgICAgZnVsbHBhdGg6IChhYnMgKz0gKHNhd0ZpcnN0ID8gJycgOiBqb2luU2VwKSArIHBhcnQpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzYXdGaXJzdCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jd2QgPSBwcmV2O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGRlcHRoIG9mIGEgcHJvdmlkZWQgcGF0aCwgc3RyaW5nLCBvciB0aGUgY3dkXG4gICAgICovXG4gICAgZGVwdGgocGF0aCA9IHRoaXMuY3dkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGF0aCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHBhdGggPSB0aGlzLmN3ZC5yZXNvbHZlKHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYXRoLmRlcHRoKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0aGUgY2FjaGUgb2YgY2hpbGQgZW50cmllcy4gIEV4cG9zZWQgc28gc3ViY2xhc3NlcyBjYW4gY3JlYXRlXG4gICAgICogY2hpbGQgUGF0aCBvYmplY3RzIGluIGEgcGxhdGZvcm0tc3BlY2lmaWMgd2F5LlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgY2hpbGRyZW5DYWNoZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2NoaWxkcmVuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNvbHZlIG9uZSBvciBtb3JlIHBhdGggc3RyaW5ncyB0byBhIHJlc29sdmVkIHN0cmluZ1xuICAgICAqXG4gICAgICogU2FtZSBpbnRlcmZhY2UgYXMgcmVxdWlyZSgncGF0aCcpLnJlc29sdmUuXG4gICAgICpcbiAgICAgKiBNdWNoIGZhc3RlciB0aGFuIHBhdGgucmVzb2x2ZSgpIHdoZW4gY2FsbGVkIG11bHRpcGxlIHRpbWVzIGZvciB0aGUgc2FtZVxuICAgICAqIHBhdGgsIGJlY2F1c2UgdGhlIHJlc29sdmVkIFBhdGggb2JqZWN0cyBhcmUgY2FjaGVkLiAgTXVjaCBzbG93ZXJcbiAgICAgKiBvdGhlcndpc2UuXG4gICAgICovXG4gICAgcmVzb2x2ZSguLi5wYXRocykge1xuICAgICAgICAvLyBmaXJzdCBmaWd1cmUgb3V0IHRoZSBtaW5pbXVtIG51bWJlciBvZiBwYXRocyB3ZSBoYXZlIHRvIHRlc3RcbiAgICAgICAgLy8gd2UgYWx3YXlzIHN0YXJ0IGF0IGN3ZCwgYnV0IGFueSBhYnNvbHV0ZXMgd2lsbCBidW1wIHRoZSBzdGFydFxuICAgICAgICBsZXQgciA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gcGF0aHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwYXRoc1tpXTtcbiAgICAgICAgICAgIGlmICghcCB8fCBwID09PSAnLicpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByID0gciA/IGAke3B9LyR7cn1gIDogcDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWJzb2x1dGUocCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLiNyZXNvbHZlQ2FjaGUuZ2V0KHIpO1xuICAgICAgICBpZiAoY2FjaGVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5jd2QucmVzb2x2ZShyKS5mdWxscGF0aCgpO1xuICAgICAgICB0aGlzLiNyZXNvbHZlQ2FjaGUuc2V0KHIsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc29sdmUgb25lIG9yIG1vcmUgcGF0aCBzdHJpbmdzIHRvIGEgcmVzb2x2ZWQgc3RyaW5nLCByZXR1cm5pbmdcbiAgICAgKiB0aGUgcG9zaXggcGF0aC4gIElkZW50aWNhbCB0byAucmVzb2x2ZSgpIG9uIHBvc2l4IHN5c3RlbXMsIGJ1dCBvblxuICAgICAqIHdpbmRvd3Mgd2lsbCByZXR1cm4gYSBmb3J3YXJkLXNsYXNoIHNlcGFyYXRlZCBVTkMgcGF0aC5cbiAgICAgKlxuICAgICAqIFNhbWUgaW50ZXJmYWNlIGFzIHJlcXVpcmUoJ3BhdGgnKS5yZXNvbHZlLlxuICAgICAqXG4gICAgICogTXVjaCBmYXN0ZXIgdGhhbiBwYXRoLnJlc29sdmUoKSB3aGVuIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyBmb3IgdGhlIHNhbWVcbiAgICAgKiBwYXRoLCBiZWNhdXNlIHRoZSByZXNvbHZlZCBQYXRoIG9iamVjdHMgYXJlIGNhY2hlZC4gIE11Y2ggc2xvd2VyXG4gICAgICogb3RoZXJ3aXNlLlxuICAgICAqL1xuICAgIHJlc29sdmVQb3NpeCguLi5wYXRocykge1xuICAgICAgICAvLyBmaXJzdCBmaWd1cmUgb3V0IHRoZSBtaW5pbXVtIG51bWJlciBvZiBwYXRocyB3ZSBoYXZlIHRvIHRlc3RcbiAgICAgICAgLy8gd2UgYWx3YXlzIHN0YXJ0IGF0IGN3ZCwgYnV0IGFueSBhYnNvbHV0ZXMgd2lsbCBidW1wIHRoZSBzdGFydFxuICAgICAgICBsZXQgciA9ICcnO1xuICAgICAgICBmb3IgKGxldCBpID0gcGF0aHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBwYXRoc1tpXTtcbiAgICAgICAgICAgIGlmICghcCB8fCBwID09PSAnLicpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICByID0gciA/IGAke3B9LyR7cn1gIDogcDtcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQWJzb2x1dGUocCkpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjYWNoZWQgPSB0aGlzLiNyZXNvbHZlUG9zaXhDYWNoZS5nZXQocik7XG4gICAgICAgIGlmIChjYWNoZWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmN3ZC5yZXNvbHZlKHIpLmZ1bGxwYXRoUG9zaXgoKTtcbiAgICAgICAgdGhpcy4jcmVzb2x2ZVBvc2l4Q2FjaGUuc2V0KHIsIHJlc3VsdCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGZpbmQgdGhlIHJlbGF0aXZlIHBhdGggZnJvbSB0aGUgY3dkIHRvIHRoZSBzdXBwbGllZCBwYXRoIHN0cmluZyBvciBlbnRyeVxuICAgICAqL1xuICAgIHJlbGF0aXZlKGVudHJ5ID0gdGhpcy5jd2QpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5LnJlbGF0aXZlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGZpbmQgdGhlIHJlbGF0aXZlIHBhdGggZnJvbSB0aGUgY3dkIHRvIHRoZSBzdXBwbGllZCBwYXRoIHN0cmluZyBvclxuICAgICAqIGVudHJ5LCB1c2luZyAvIGFzIHRoZSBwYXRoIGRlbGltaXRlciwgZXZlbiBvbiBXaW5kb3dzLlxuICAgICAqL1xuICAgIHJlbGF0aXZlUG9zaXgoZW50cnkgPSB0aGlzLmN3ZCkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnkucmVsYXRpdmVQb3NpeCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm4gdGhlIGJhc2VuYW1lIGZvciB0aGUgcHJvdmlkZWQgc3RyaW5nIG9yIFBhdGggb2JqZWN0XG4gICAgICovXG4gICAgYmFzZW5hbWUoZW50cnkgPSB0aGlzLmN3ZCkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnkubmFtZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRoZSBkaXJuYW1lIGZvciB0aGUgcHJvdmlkZWQgc3RyaW5nIG9yIFBhdGggb2JqZWN0XG4gICAgICovXG4gICAgZGlybmFtZShlbnRyeSA9IHRoaXMuY3dkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoZW50cnkucGFyZW50IHx8IGVudHJ5KS5mdWxscGF0aCgpO1xuICAgIH1cbiAgICBhc3luYyByZWFkZGlyKGVudHJ5ID0gdGhpcy5jd2QsIG9wdHMgPSB7XG4gICAgICAgIHdpdGhGaWxlVHlwZXM6IHRydWUsXG4gICAgfSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICBvcHRzID0gZW50cnk7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgd2l0aEZpbGVUeXBlcyB9ID0gb3B0cztcbiAgICAgICAgaWYgKCFlbnRyeS5jYW5SZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBhd2FpdCBlbnRyeS5yZWFkZGlyKCk7XG4gICAgICAgICAgICByZXR1cm4gd2l0aEZpbGVUeXBlcyA/IHAgOiBwLm1hcChlID0+IGUubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVhZGRpclN5bmMoZW50cnkgPSB0aGlzLmN3ZCwgb3B0cyA9IHtcbiAgICAgICAgd2l0aEZpbGVUeXBlczogdHJ1ZSxcbiAgICB9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB3aXRoRmlsZVR5cGVzID0gdHJ1ZSB9ID0gb3B0cztcbiAgICAgICAgaWYgKCFlbnRyeS5jYW5SZWFkZGlyKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh3aXRoRmlsZVR5cGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gZW50cnkucmVhZGRpclN5bmMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbnRyeS5yZWFkZGlyU3luYygpLm1hcChlID0+IGUubmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCBsc3RhdCgpIG9uIHRoZSBzdHJpbmcgb3IgUGF0aCBvYmplY3QsIGFuZCB1cGRhdGUgYWxsIGtub3duXG4gICAgICogaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgZGV0ZXJtaW5lZC5cbiAgICAgKlxuICAgICAqIE5vdGUgdGhhdCB1bmxpa2UgYGZzLmxzdGF0KClgLCB0aGUgcmV0dXJuZWQgdmFsdWUgZG9lcyBub3QgY29udGFpbiBzb21lXG4gICAgICogaW5mb3JtYXRpb24sIHN1Y2ggYXMgYG1vZGVgLCBgZGV2YCwgYG5saW5rYCwgYW5kIGBpbm9gLiAgSWYgdGhhdFxuICAgICAqIGluZm9ybWF0aW9uIGlzIHJlcXVpcmVkLCB5b3Ugd2lsbCBuZWVkIHRvIGNhbGwgYGZzLmxzdGF0YCB5b3Vyc2VsZi5cbiAgICAgKlxuICAgICAqIElmIHRoZSBQYXRoIHJlZmVycyB0byBhIG5vbmV4aXN0ZW50IGZpbGUsIG9yIGlmIHRoZSBsc3RhdCBjYWxsIGZhaWxzIGZvclxuICAgICAqIGFueSByZWFzb24sIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLiAgT3RoZXJ3aXNlIHRoZSB1cGRhdGVkIFBhdGggb2JqZWN0IGlzXG4gICAgICogcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBSZXN1bHRzIGFyZSBjYWNoZWQsIGFuZCB0aHVzIG1heSBiZSBvdXQgb2YgZGF0ZSBpZiB0aGUgZmlsZXN5c3RlbSBpc1xuICAgICAqIG11dGF0ZWQuXG4gICAgICovXG4gICAgYXN5bmMgbHN0YXQoZW50cnkgPSB0aGlzLmN3ZCkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW50cnkubHN0YXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogc3luY2hyb25vdXMge0BsaW5rIFBhdGhTY3VycnlCYXNlLmxzdGF0fVxuICAgICAqL1xuICAgIGxzdGF0U3luYyhlbnRyeSA9IHRoaXMuY3dkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbnRyeS5sc3RhdFN5bmMoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhZGxpbmsoZW50cnkgPSB0aGlzLmN3ZCwgeyB3aXRoRmlsZVR5cGVzIH0gPSB7XG4gICAgICAgIHdpdGhGaWxlVHlwZXM6IGZhbHNlLFxuICAgIH0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgd2l0aEZpbGVUeXBlcyA9IGVudHJ5LndpdGhGaWxlVHlwZXM7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGUgPSBhd2FpdCBlbnRyeS5yZWFkbGluaygpO1xuICAgICAgICByZXR1cm4gd2l0aEZpbGVUeXBlcyA/IGUgOiBlPy5mdWxscGF0aCgpO1xuICAgIH1cbiAgICByZWFkbGlua1N5bmMoZW50cnkgPSB0aGlzLmN3ZCwgeyB3aXRoRmlsZVR5cGVzIH0gPSB7XG4gICAgICAgIHdpdGhGaWxlVHlwZXM6IGZhbHNlLFxuICAgIH0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgd2l0aEZpbGVUeXBlcyA9IGVudHJ5LndpdGhGaWxlVHlwZXM7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGUgPSBlbnRyeS5yZWFkbGlua1N5bmMoKTtcbiAgICAgICAgcmV0dXJuIHdpdGhGaWxlVHlwZXMgPyBlIDogZT8uZnVsbHBhdGgoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVhbHBhdGgoZW50cnkgPSB0aGlzLmN3ZCwgeyB3aXRoRmlsZVR5cGVzIH0gPSB7XG4gICAgICAgIHdpdGhGaWxlVHlwZXM6IGZhbHNlLFxuICAgIH0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgd2l0aEZpbGVUeXBlcyA9IGVudHJ5LndpdGhGaWxlVHlwZXM7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGUgPSBhd2FpdCBlbnRyeS5yZWFscGF0aCgpO1xuICAgICAgICByZXR1cm4gd2l0aEZpbGVUeXBlcyA/IGUgOiBlPy5mdWxscGF0aCgpO1xuICAgIH1cbiAgICByZWFscGF0aFN5bmMoZW50cnkgPSB0aGlzLmN3ZCwgeyB3aXRoRmlsZVR5cGVzIH0gPSB7XG4gICAgICAgIHdpdGhGaWxlVHlwZXM6IGZhbHNlLFxuICAgIH0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgd2l0aEZpbGVUeXBlcyA9IGVudHJ5LndpdGhGaWxlVHlwZXM7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGUgPSBlbnRyeS5yZWFscGF0aFN5bmMoKTtcbiAgICAgICAgcmV0dXJuIHdpdGhGaWxlVHlwZXMgPyBlIDogZT8uZnVsbHBhdGgoKTtcbiAgICB9XG4gICAgYXN5bmMgd2FsayhlbnRyeSA9IHRoaXMuY3dkLCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgb3B0cyA9IGVudHJ5O1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpdGhGaWxlVHlwZXMgPSB0cnVlLCBmb2xsb3cgPSBmYWxzZSwgZmlsdGVyLCB3YWxrRmlsdGVyLCB9ID0gb3B0cztcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZW50cnkpKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2god2l0aEZpbGVUeXBlcyA/IGVudHJ5IDogZW50cnkuZnVsbHBhdGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3Qgd2FsayA9IChkaXIsIGNiKSA9PiB7XG4gICAgICAgICAgICBkaXJzLmFkZChkaXIpO1xuICAgICAgICAgICAgZGlyLnJlYWRkaXJDQigoZXIsIGVudHJpZXMpID0+IHtcbiAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RhcnQgKi9cbiAgICAgICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICBsZXQgbGVuID0gZW50cmllcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKCFsZW4pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjYigpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICgtLWxlbiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLnB1c2god2l0aEZpbGVUeXBlcyA/IGUgOiBlLmZ1bGxwYXRoKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChmb2xsb3cgJiYgZS5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlLnJlYWxwYXRoKClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAudGhlbihyID0+IChyPy5pc1Vua25vd24oKSA/IHIubHN0YXQoKSA6IHIpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC50aGVuKHIgPT4gcj8uc2hvdWxkV2FsayhkaXJzLCB3YWxrRmlsdGVyKSA/IHdhbGsociwgbmV4dCkgOiBuZXh0KCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUuc2hvdWxkV2FsayhkaXJzLCB3YWxrRmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhbGsoZSwgbmV4dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCB0cnVlKTsgLy8gemFsZ29vb29vb29cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc3RhcnQgPSBlbnRyeTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgICAgICAgd2FsayhzdGFydCwgZXIgPT4ge1xuICAgICAgICAgICAgICAgIC8qIGM4IGlnbm9yZSBzdGFydCAqL1xuICAgICAgICAgICAgICAgIGlmIChlcilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlaihlcik7XG4gICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0b3AgKi9cbiAgICAgICAgICAgICAgICByZXMocmVzdWx0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHdhbGtTeW5jKGVudHJ5ID0gdGhpcy5jd2QsIG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICBvcHRzID0gZW50cnk7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgd2l0aEZpbGVUeXBlcyA9IHRydWUsIGZvbGxvdyA9IGZhbHNlLCBmaWx0ZXIsIHdhbGtGaWx0ZXIsIH0gPSBvcHRzO1xuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihlbnRyeSkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaCh3aXRoRmlsZVR5cGVzID8gZW50cnkgOiBlbnRyeS5mdWxscGF0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaXJzID0gbmV3IFNldChbZW50cnldKTtcbiAgICAgICAgZm9yIChjb25zdCBkaXIgb2YgZGlycykge1xuICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IGRpci5yZWFkZGlyU3luYygpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBlIG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbHRlciB8fCBmaWx0ZXIoZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHdpdGhGaWxlVHlwZXMgPyBlIDogZS5mdWxscGF0aCgpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IHIgPSBlO1xuICAgICAgICAgICAgICAgIGlmIChlLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoZm9sbG93ICYmIChyID0gZS5yZWFscGF0aFN5bmMoKSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyLmlzVW5rbm93bigpKVxuICAgICAgICAgICAgICAgICAgICAgICAgci5sc3RhdFN5bmMoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHIuc2hvdWxkV2FsayhkaXJzLCB3YWxrRmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJzLmFkZChyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN1cHBvcnQgZm9yIGBmb3IgYXdhaXRgXG4gICAgICpcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIFBhdGhTY3VycnlCYXNlLml0ZXJhdGV9XG4gICAgICpcbiAgICAgKiBOb3RlOiBBcyBvZiBOb2RlIDE5LCB0aGlzIGlzIHZlcnkgc2xvdywgY29tcGFyZWQgdG8gb3RoZXIgbWV0aG9kcyBvZlxuICAgICAqIHdhbGtpbmcuICBDb25zaWRlciB1c2luZyB7QGxpbmsgUGF0aFNjdXJyeUJhc2Uuc3RyZWFtfSBpZiBtZW1vcnkgb3ZlcmhlYWRcbiAgICAgKiBhbmQgYmFja3ByZXNzdXJlIGFyZSBjb25jZXJucywgb3Ige0BsaW5rIFBhdGhTY3VycnlCYXNlLndhbGt9IGlmIG5vdC5cbiAgICAgKi9cbiAgICBbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlKCk7XG4gICAgfVxuICAgIGl0ZXJhdGUoZW50cnkgPSB0aGlzLmN3ZCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIC8vIGl0ZXJhdGluZyBhc3luYyBvdmVyIHRoZSBzdHJlYW0gaXMgc2lnbmlmaWNhbnRseSBtb3JlIHBlcmZvcm1hbnQsXG4gICAgICAgIC8vIGVzcGVjaWFsbHkgaW4gdGhlIHdhcm0tY2FjaGUgc2NlbmFyaW8sIGJlY2F1c2UgaXQgYnVmZmVycyB1cCBkaXJlY3RvcnlcbiAgICAgICAgLy8gZW50cmllcyBpbiB0aGUgYmFja2dyb3VuZCBpbnN0ZWFkIG9mIHdhaXRpbmcgZm9yIGEgeWllbGQgZm9yIGVhY2ggb25lLlxuICAgICAgICBpZiAodHlwZW9mIGVudHJ5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZC5yZXNvbHZlKGVudHJ5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghKGVudHJ5IGluc3RhbmNlb2YgUGF0aEJhc2UpKSB7XG4gICAgICAgICAgICBvcHRpb25zID0gZW50cnk7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnN0cmVhbShlbnRyeSwgb3B0aW9ucylbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGluZyBvdmVyIGEgUGF0aFNjdXJyeSBwZXJmb3JtcyBhIHN5bmNocm9ub3VzIHdhbGsuXG4gICAgICpcbiAgICAgKiBBbGlhcyBmb3Ige0BsaW5rIFBhdGhTY3VycnlCYXNlLml0ZXJhdGVTeW5jfVxuICAgICAqL1xuICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pdGVyYXRlU3luYygpO1xuICAgIH1cbiAgICAqaXRlcmF0ZVN5bmMoZW50cnkgPSB0aGlzLmN3ZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB3aXRoRmlsZVR5cGVzID0gdHJ1ZSwgZm9sbG93ID0gZmFsc2UsIGZpbHRlciwgd2Fsa0ZpbHRlciwgfSA9IG9wdHM7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihlbnRyeSkpIHtcbiAgICAgICAgICAgIHlpZWxkIHdpdGhGaWxlVHlwZXMgPyBlbnRyeSA6IGVudHJ5LmZ1bGxwYXRoKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlycyA9IG5ldyBTZXQoW2VudHJ5XSk7XG4gICAgICAgIGZvciAoY29uc3QgZGlyIG9mIGRpcnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBkaXIucmVhZGRpclN5bmMoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHlpZWxkIHdpdGhGaWxlVHlwZXMgPyBlIDogZS5mdWxscGF0aCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgciA9IGU7XG4gICAgICAgICAgICAgICAgaWYgKGUuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIShmb2xsb3cgJiYgKHIgPSBlLnJlYWxwYXRoU3luYygpKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHIuaXNVbmtub3duKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICByLmxzdGF0U3luYygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoci5zaG91bGRXYWxrKGRpcnMsIHdhbGtGaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpcnMuYWRkKHIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzdHJlYW0oZW50cnkgPSB0aGlzLmN3ZCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmICh0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBlbnRyeSA9IHRoaXMuY3dkLnJlc29sdmUoZW50cnkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCEoZW50cnkgaW5zdGFuY2VvZiBQYXRoQmFzZSkpIHtcbiAgICAgICAgICAgIG9wdHMgPSBlbnRyeTtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2Q7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyB3aXRoRmlsZVR5cGVzID0gdHJ1ZSwgZm9sbG93ID0gZmFsc2UsIGZpbHRlciwgd2Fsa0ZpbHRlciwgfSA9IG9wdHM7XG4gICAgICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgbWluaXBhc3NfMS5NaW5pcGFzcyh7IG9iamVjdE1vZGU6IHRydWUgfSk7XG4gICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihlbnRyeSkpIHtcbiAgICAgICAgICAgIHJlc3VsdHMud3JpdGUod2l0aEZpbGVUeXBlcyA/IGVudHJ5IDogZW50cnkuZnVsbHBhdGgoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgY29uc3QgcXVldWUgPSBbZW50cnldO1xuICAgICAgICBsZXQgcHJvY2Vzc2luZyA9IDA7XG4gICAgICAgIGNvbnN0IHByb2Nlc3MgPSAoKSA9PiB7XG4gICAgICAgICAgICBsZXQgcGF1c2VkID0gZmFsc2U7XG4gICAgICAgICAgICB3aGlsZSAoIXBhdXNlZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRpciA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCFkaXIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2Nlc3NpbmcgPT09IDApXG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb2Nlc3NpbmcrKztcbiAgICAgICAgICAgICAgICBkaXJzLmFkZChkaXIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9uUmVhZGRpciA9IChlciwgZW50cmllcywgZGlkUmVhbHBhdGhzID0gZmFsc2UpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLyogYzggaWdub3JlIHN0YXJ0ICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcilcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRzLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgICAgICAgICAgICAgICAgICAvKiBjOCBpZ25vcmUgc3RvcCAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9sbG93ICYmICFkaWRSZWFscGF0aHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLmlzU3ltYm9saWNMaW5rKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMucHVzaChlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAucmVhbHBhdGgoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKHIpID0+IHI/LmlzVW5rbm93bigpID8gci5sc3RhdCgpIDogcikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwcm9taXNlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBQcm9taXNlLmFsbChwcm9taXNlcykudGhlbigoKSA9PiBvblJlYWRkaXIobnVsbCwgZW50cmllcywgdHJ1ZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGUgJiYgKCFmaWx0ZXIgfHwgZmlsdGVyKGUpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcmVzdWx0cy53cml0ZSh3aXRoRmlsZVR5cGVzID8gZSA6IGUuZnVsbHBhdGgoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcHJvY2Vzc2luZy0tO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGUgb2YgZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgciA9IGUucmVhbHBhdGhDYWNoZWQoKSB8fCBlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuc2hvdWxkV2FsayhkaXJzLCB3YWxrRmlsdGVyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLnB1c2gocik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhdXNlZCAmJiAhcmVzdWx0cy5mbG93aW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLm9uY2UoJ2RyYWluJywgcHJvY2Vzcyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIXN5bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2Nlc3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gemFsZ28gY29udGFpbm1lbnRcbiAgICAgICAgICAgICAgICBsZXQgc3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgZGlyLnJlYWRkaXJDQihvblJlYWRkaXIsIHRydWUpO1xuICAgICAgICAgICAgICAgIHN5bmMgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgc3RyZWFtU3luYyhlbnRyeSA9IHRoaXMuY3dkLCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIGVudHJ5ID0gdGhpcy5jd2QucmVzb2x2ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIShlbnRyeSBpbnN0YW5jZW9mIFBhdGhCYXNlKSkge1xuICAgICAgICAgICAgb3B0cyA9IGVudHJ5O1xuICAgICAgICAgICAgZW50cnkgPSB0aGlzLmN3ZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IHdpdGhGaWxlVHlwZXMgPSB0cnVlLCBmb2xsb3cgPSBmYWxzZSwgZmlsdGVyLCB3YWxrRmlsdGVyLCB9ID0gb3B0cztcbiAgICAgICAgY29uc3QgcmVzdWx0cyA9IG5ldyBtaW5pcGFzc18xLk1pbmlwYXNzKHsgb2JqZWN0TW9kZTogdHJ1ZSB9KTtcbiAgICAgICAgY29uc3QgZGlycyA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKCFmaWx0ZXIgfHwgZmlsdGVyKGVudHJ5KSkge1xuICAgICAgICAgICAgcmVzdWx0cy53cml0ZSh3aXRoRmlsZVR5cGVzID8gZW50cnkgOiBlbnRyeS5mdWxscGF0aCgpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWV1ZSA9IFtlbnRyeV07XG4gICAgICAgIGxldCBwcm9jZXNzaW5nID0gMDtcbiAgICAgICAgY29uc3QgcHJvY2VzcyA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBwYXVzZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHdoaWxlICghcGF1c2VkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGlyID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIWRpcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc2luZyA9PT0gMClcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdHMuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZysrO1xuICAgICAgICAgICAgICAgIGRpcnMuYWRkKGRpcik7XG4gICAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IGRpci5yZWFkZGlyU3luYygpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmlsdGVyIHx8IGZpbHRlcihlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bHRzLndyaXRlKHdpdGhGaWxlVHlwZXMgPyBlIDogZS5mdWxscGF0aCgpKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcHJvY2Vzc2luZy0tO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZSBvZiBlbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCByID0gZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGUuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoZm9sbG93ICYmIChyID0gZS5yZWFscGF0aFN5bmMoKSkpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHIuaXNVbmtub3duKCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgci5sc3RhdFN5bmMoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoci5zaG91bGRXYWxrKGRpcnMsIHdhbGtGaWx0ZXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhdXNlZCAmJiAhcmVzdWx0cy5mbG93aW5nKVxuICAgICAgICAgICAgICAgIHJlc3VsdHMub25jZSgnZHJhaW4nLCBwcm9jZXNzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcHJvY2VzcygpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9XG4gICAgY2hkaXIocGF0aCA9IHRoaXMuY3dkKSB7XG4gICAgICAgIGNvbnN0IG9sZEN3ZCA9IHRoaXMuY3dkO1xuICAgICAgICB0aGlzLmN3ZCA9IHR5cGVvZiBwYXRoID09PSAnc3RyaW5nJyA/IHRoaXMuY3dkLnJlc29sdmUocGF0aCkgOiBwYXRoO1xuICAgICAgICB0aGlzLmN3ZFtzZXRBc0N3ZF0ob2xkQ3dkKTtcbiAgICB9XG59XG5leHBvcnRzLlBhdGhTY3VycnlCYXNlID0gUGF0aFNjdXJyeUJhc2U7XG4vKipcbiAqIFdpbmRvd3MgaW1wbGVtZW50YXRpb24gb2Yge0BsaW5rIFBhdGhTY3VycnlCYXNlfVxuICpcbiAqIERlZmF1bHRzIHRvIGNhc2UgaW5zZW5zaXR2ZSwgdXNlcyBgJ1xcXFwnYCB0byBnZW5lcmF0ZSBwYXRoIHN0cmluZ3MuICBVc2VzXG4gKiB7QGxpbmsgUGF0aFdpbjMyfSBmb3IgUGF0aCBvYmplY3RzLlxuICovXG5jbGFzcyBQYXRoU2N1cnJ5V2luMzIgZXh0ZW5kcyBQYXRoU2N1cnJ5QmFzZSB7XG4gICAgLyoqXG4gICAgICogc2VwYXJhdG9yIGZvciBnZW5lcmF0aW5nIHBhdGggc3RyaW5nc1xuICAgICAqL1xuICAgIHNlcCA9ICdcXFxcJztcbiAgICBjb25zdHJ1Y3Rvcihjd2QgPSBwcm9jZXNzLmN3ZCgpLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBub2Nhc2UgPSB0cnVlIH0gPSBvcHRzO1xuICAgICAgICBzdXBlcihjd2QsIG5vZGVfcGF0aF8xLndpbjMyLCAnXFxcXCcsIHsgLi4ub3B0cywgbm9jYXNlIH0pO1xuICAgICAgICB0aGlzLm5vY2FzZSA9IG5vY2FzZTtcbiAgICAgICAgZm9yIChsZXQgcCA9IHRoaXMuY3dkOyBwOyBwID0gcC5wYXJlbnQpIHtcbiAgICAgICAgICAgIHAubm9jYXNlID0gdGhpcy5ub2Nhc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgcGFyc2VSb290UGF0aChkaXIpIHtcbiAgICAgICAgLy8gaWYgdGhlIHBhdGggc3RhcnRzIHdpdGggYSBzaW5nbGUgc2VwYXJhdG9yLCBpdCdzIG5vdCBhIFVOQywgYW5kIHdlJ2xsXG4gICAgICAgIC8vIGp1c3QgZ2V0IHNlcGFyYXRvciBhcyB0aGUgcm9vdCwgYW5kIGRyaXZlRnJvbVVOQyB3aWxsIHJldHVybiBcXFxuICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIG1vdW50IFxcIG9uIHRoZSByb290IGZyb20gdGhlIGN3ZC5cbiAgICAgICAgcmV0dXJuIG5vZGVfcGF0aF8xLndpbjMyLnBhcnNlKGRpcikucm9vdC50b1VwcGVyQ2FzZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBuZXdSb290KGZzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGF0aFdpbjMyKHRoaXMucm9vdFBhdGgsIElGRElSLCB1bmRlZmluZWQsIHRoaXMucm9vdHMsIHRoaXMubm9jYXNlLCB0aGlzLmNoaWxkcmVuQ2FjaGUoKSwgeyBmcyB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJuIHRydWUgaWYgdGhlIHByb3ZpZGVkIHBhdGggc3RyaW5nIGlzIGFuIGFic29sdXRlIHBhdGhcbiAgICAgKi9cbiAgICBpc0Fic29sdXRlKHApIHtcbiAgICAgICAgcmV0dXJuIChwLnN0YXJ0c1dpdGgoJy8nKSB8fCBwLnN0YXJ0c1dpdGgoJ1xcXFwnKSB8fCAvXlthLXpdOihcXC98XFxcXCkvaS50ZXN0KHApKTtcbiAgICB9XG59XG5leHBvcnRzLlBhdGhTY3VycnlXaW4zMiA9IFBhdGhTY3VycnlXaW4zMjtcbi8qKlxuICoge0BsaW5rIFBhdGhTY3VycnlCYXNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgYWxsIHBvc2l4IHN5c3RlbXMgb3RoZXIgdGhhbiBEYXJ3aW4uXG4gKlxuICogRGVmYXVsdHMgdG8gY2FzZS1zZW5zaXRpdmUgbWF0Y2hpbmcsIHVzZXMgYCcvJ2AgdG8gZ2VuZXJhdGUgcGF0aCBzdHJpbmdzLlxuICpcbiAqIFVzZXMge0BsaW5rIFBhdGhQb3NpeH0gZm9yIFBhdGggb2JqZWN0cy5cbiAqL1xuY2xhc3MgUGF0aFNjdXJyeVBvc2l4IGV4dGVuZHMgUGF0aFNjdXJyeUJhc2Uge1xuICAgIC8qKlxuICAgICAqIHNlcGFyYXRvciBmb3IgZ2VuZXJhdGluZyBwYXRoIHN0cmluZ3NcbiAgICAgKi9cbiAgICBzZXAgPSAnLyc7XG4gICAgY29uc3RydWN0b3IoY3dkID0gcHJvY2Vzcy5jd2QoKSwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHsgbm9jYXNlID0gZmFsc2UgfSA9IG9wdHM7XG4gICAgICAgIHN1cGVyKGN3ZCwgbm9kZV9wYXRoXzEucG9zaXgsICcvJywgeyAuLi5vcHRzLCBub2Nhc2UgfSk7XG4gICAgICAgIHRoaXMubm9jYXNlID0gbm9jYXNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaW50ZXJuYWxcbiAgICAgKi9cbiAgICBwYXJzZVJvb3RQYXRoKF9kaXIpIHtcbiAgICAgICAgcmV0dXJuICcvJztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgbmV3Um9vdChmcykge1xuICAgICAgICByZXR1cm4gbmV3IFBhdGhQb3NpeCh0aGlzLnJvb3RQYXRoLCBJRkRJUiwgdW5kZWZpbmVkLCB0aGlzLnJvb3RzLCB0aGlzLm5vY2FzZSwgdGhpcy5jaGlsZHJlbkNhY2hlKCksIHsgZnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBwcm92aWRlZCBwYXRoIHN0cmluZyBpcyBhbiBhYnNvbHV0ZSBwYXRoXG4gICAgICovXG4gICAgaXNBYnNvbHV0ZShwKSB7XG4gICAgICAgIHJldHVybiBwLnN0YXJ0c1dpdGgoJy8nKTtcbiAgICB9XG59XG5leHBvcnRzLlBhdGhTY3VycnlQb3NpeCA9IFBhdGhTY3VycnlQb3NpeDtcbi8qKlxuICoge0BsaW5rIFBhdGhTY3VycnlCYXNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgRGFyd2luIChtYWNPUykgc3lzdGVtcy5cbiAqXG4gKiBEZWZhdWx0cyB0byBjYXNlLWluc2Vuc2l0aXZlIG1hdGNoaW5nLCB1c2VzIGAnLydgIGZvciBnZW5lcmF0aW5nIHBhdGhcbiAqIHN0cmluZ3MuXG4gKlxuICogVXNlcyB7QGxpbmsgUGF0aFBvc2l4fSBmb3IgUGF0aCBvYmplY3RzLlxuICovXG5jbGFzcyBQYXRoU2N1cnJ5RGFyd2luIGV4dGVuZHMgUGF0aFNjdXJyeVBvc2l4IHtcbiAgICBjb25zdHJ1Y3Rvcihjd2QgPSBwcm9jZXNzLmN3ZCgpLCBvcHRzID0ge30pIHtcbiAgICAgICAgY29uc3QgeyBub2Nhc2UgPSB0cnVlIH0gPSBvcHRzO1xuICAgICAgICBzdXBlcihjd2QsIHsgLi4ub3B0cywgbm9jYXNlIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuUGF0aFNjdXJyeURhcndpbiA9IFBhdGhTY3VycnlEYXJ3aW47XG4vKipcbiAqIERlZmF1bHQge0BsaW5rIFBhdGhCYXNlfSBpbXBsZW1lbnRhdGlvbiBmb3IgdGhlIGN1cnJlbnQgcGxhdGZvcm0uXG4gKlxuICoge0BsaW5rIFBhdGhXaW4zMn0gb24gV2luZG93cyBzeXN0ZW1zLCB7QGxpbmsgUGF0aFBvc2l4fSBvbiBhbGwgb3RoZXJzLlxuICovXG5leHBvcnRzLlBhdGggPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gUGF0aFdpbjMyIDogUGF0aFBvc2l4O1xuLyoqXG4gKiBEZWZhdWx0IHtAbGluayBQYXRoU2N1cnJ5QmFzZX0gaW1wbGVtZW50YXRpb24gZm9yIHRoZSBjdXJyZW50IHBsYXRmb3JtLlxuICpcbiAqIHtAbGluayBQYXRoU2N1cnJ5V2luMzJ9IG9uIFdpbmRvd3Mgc3lzdGVtcywge0BsaW5rIFBhdGhTY3VycnlEYXJ3aW59IG9uXG4gKiBEYXJ3aW4gKG1hY09TKSBzeXN0ZW1zLCB7QGxpbmsgUGF0aFNjdXJyeVBvc2l4fSBvbiBhbGwgb3RoZXJzLlxuICovXG5leHBvcnRzLlBhdGhTY3VycnkgPSBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInID8gUGF0aFNjdXJyeVdpbjMyXG4gICAgOiBwcm9jZXNzLnBsYXRmb3JtID09PSAnZGFyd2luJyA/IFBhdGhTY3VycnlEYXJ3aW5cbiAgICAgICAgOiBQYXRoU2N1cnJ5UG9zaXg7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/path-scurry/dist/commonjs/index.js\n");

/***/ })

};
;