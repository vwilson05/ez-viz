/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/snowflake-sdk";
exports.ids = ["vendor-chunks/snowflake-sdk"];
exports.modules = {

/***/ "(rsc)/./node_modules/snowflake-sdk/index.js":
/*!*********************************************!*\
  !*** ./node_modules/snowflake-sdk/index.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("module.exports = __webpack_require__(/*! ./lib/snowflake */ \"(rsc)/./node_modules/snowflake-sdk/lib/snowflake.js\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrSEFBMkMiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9pbmRleC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL3Nub3dmbGFrZScpOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/agent/cert_util.js":
/*!***********************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/agent/cert_util.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("/*\n * This software is licensed under the MIT License.\n *\n * Copyright Fedor Indutny, 2015.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n\nconst process = __webpack_require__(/*! process */ \"process\");\nconst ocsp = __webpack_require__(/*! @techteamer/ocsp */ \"(rsc)/./node_modules/@techteamer/ocsp/lib/ocsp.js\");\nconst rfc2560 = __webpack_require__(/*! asn1.js-rfc2560 */ \"(rsc)/./node_modules/asn1.js-rfc2560/index.js\");\nconst rfc5280 = __webpack_require__(/*! asn1.js-rfc5280 */ \"(rsc)/./node_modules/asn1.js-rfc5280/index.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst bn = __webpack_require__(/*! bn.js */ \"(rsc)/./node_modules/bn.js/lib/bn.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\n\n\nconst TOLERABLE_VALIDITY_RANGE_RATIO = 0.01;\nconst MAX_CLOCK_SKEW_IN_MILLISECONDS = 900000;\nconst MIN_CACHE_WARMUP_TIME_IN_MILLISECONDS = 18000000;\n\n/**\n * Builds the certificate id for a given certificate.\n *\n * @param cert\n * @returns {*}\n */\nexports.buildCertId = function (cert) {\n  let issuer = cert.issuerCertificate;\n  cert = cert.raw;\n\n  try {\n    cert = rfc5280.Certificate.decode(cert, 'der');\n    if (issuer) {\n      issuer = issuer.raw;\n      issuer = rfc5280.Certificate.decode(issuer, 'der');\n    }\n  } catch (e) {\n    return null; // if we encountered an error during decoding, return null\n  }\n\n  const tbsCert = cert.tbsCertificate;\n  const tbsIssuer = issuer.tbsCertificate;\n\n  const certID = {\n    hashAlgorithm: {\n      // algorithm: [ 2, 16, 840, 1, 101, 3, 4, 2, 1 ]  // sha256\n      algorithm: [1, 3, 14, 3, 2, 26]  // sha1\n    },\n    issuerNameHash: sha1(rfc5280.Name.encode(tbsCert.issuer, 'der')),\n    issuerKeyHash: sha1(\n      tbsIssuer.subjectPublicKeyInfo.subjectPublicKey.data),\n    serialNumber: tbsCert.serialNumber\n  };\n  const certIDDer = rfc2560.CertID.encode(certID, 'der');\n  return encodeKey(certIDDer.toString('BASE64'));\n};\n\nfunction sha1(data) {\n  return crypto.createHash('sha1').update(data).digest();\n}\n\n/**\n * Parses a certificate and returns an object that contains decoded versions\n * of the certificate and its issuer.\n *\n * Note: this method might throw an error, so use a try-catch when calling it.\n *\n * @param cert\n * @returns {{cert: *, issuer: *}}\n */\nexports.decode = function (cert) {\n  let issuer = cert.issuerCertificate;\n  cert = cert.raw;\n\n  // note: this block might throw an error\n  cert = rfc5280.Certificate.decode(cert, 'der');\n  if (issuer) {\n    issuer = issuer.raw;\n    issuer = rfc5280.Certificate.decode(issuer, 'der');\n  }\n\n  return {\n    cert: cert,\n    issuer: issuer\n  };\n};\n\n/**\n * Encode certID to a cache key\n * @param base64Key {Object}\n * @return cache key {string}\n */\nconst encodeKey = function (base64Key) {\n  const buff = Buffer.from(base64Key, 'base64');\n  const certID = rfc2560.CertID.decode(buff, 'der');\n\n  return certID.issuerNameHash.toString('BASE64')\n    + '#' + certID.issuerKeyHash.toString('BASE64')\n    + '#' + certID.serialNumber.toString(10);\n};\nexports.encodeKey = encodeKey;\n\n/**\n * Encode certID to a cache key\n * @param cacheKey {Object}\n */\nconst decodeKey = function (cacheKey) {\n  // serialNumber.eq(certID.serialNumber)\n  const keys = cacheKey.split('#');\n  const issuerNameHash = Buffer.from(keys[0], 'base64');\n  const issuerKeyHash = Buffer.from(keys[1], 'base64');\n  const serialNumber = new bn(keys[2], 10);\n\n  const certID = {\n    hashAlgorithm: {\n      // algorithm: [ 2, 16, 840, 1, 101, 3, 4, 2, 1 ]  // sha256\n      algorithm: [1, 3, 14, 3, 2, 26]  // sha1\n    },\n    issuerNameHash: issuerNameHash,\n    issuerKeyHash: issuerKeyHash,\n    serialNumber: serialNumber\n  };\n\n  const certIDDer = rfc2560.CertID.encode(certID, 'der');\n  return certIDDer.toString('BASE64');\n};\nexports.decodeKey = decodeKey;\n\n/**\n * Calculates Tolerable validity\n * @param thisUpdate last update\n * @param nextUpdate next update\n * @returns {number}\n */\nconst calculateTolerableVadility = function (thisUpdate, nextUpdate) {\n  const currentRange = (nextUpdate - thisUpdate) *\n    TOLERABLE_VALIDITY_RANGE_RATIO;\n  return currentRange > MIN_CACHE_WARMUP_TIME_IN_MILLISECONDS ?\n    currentRange : MIN_CACHE_WARMUP_TIME_IN_MILLISECONDS;\n};\n\n/**\n * Checks the validity\n * @param currentTime current time\n * @param thisUpdate last update\n * @param nextUpdate next update\n * @return {boolean}\n */\nconst isValidityRange = function (currentTime, thisUpdate, nextUpdate) {\n  const tolerableValidity = calculateTolerableVadility(thisUpdate, nextUpdate);\n  return thisUpdate - MAX_CLOCK_SKEW_IN_MILLISECONDS <= currentTime &&\n    currentTime <= nextUpdate + tolerableValidity;\n};\nexports.isValidityRange = isValidityRange;\n\n/**\n * Converts a epoch time in milliseconds to a UTC datetime string\n * @param epochInMilliSeconds\n * @returns {Date}\n */\nconst toUTCString = function (epochInMilliSeconds) {\n  return new Date(epochInMilliSeconds);\n};\n\n/**\n * Return issuer certificate or signing certificate\n * @param issuer issuer certificate\n * @param certs\n * @param raws\n */\nconst findResponder = function (issuer, certs, raws) {\n  let issuerKey = issuer.tbsCertificate.subjectPublicKeyInfo;\n  issuerKey = ocsp.utils.toPEM(\n    rfc5280.SubjectPublicKeyInfo.encode(issuerKey, 'der'), 'PUBLIC KEY');\n  if (certs.length > 0) {\n    const currentTime = Date.now();\n    const cert = certs[0];\n    const certValidity = cert.tbsCertificate.validity;\n    if (certValidity.notAfter.value < currentTime || certValidity.notBefore.value > currentTime) {\n      return {\n        err: Errors.createOCSPError(\n          ErrorCodes.ERR_OCSP_INVALID_CERTIFICATE_VALIDITY,\n          'Valid from:', toUTCString(certValidity.notBefore.value),\n          ', Valid to:', toUTCString(certValidity.notAfter.value)),\n        responderKey: null\n      };\n    }\n    const signAlg = ocsp.utils.sign[cert.signatureAlgorithm.algorithm.join('.')];\n    if (!signAlg) {\n      return {\n        err: Errors.createOCSPError(ErrorCodes.ERR_OCSP_NO_SIGNATURE_ALGORITHM),\n        responderKey: null\n      };\n    }\n\n    const verify = crypto.createVerify(signAlg);\n\n    verify.update(raws[0]);\n    if (!verify.verify(issuerKey, cert.signature.data)) {\n      return {\n        err: Errors.createOCSPError(ErrorCodes.ERR_OCSP_INVALID_SIGNATURE),\n        responderKey: null\n      };\n    }\n\n    let certKey = cert.tbsCertificate.subjectPublicKeyInfo;\n    certKey = ocsp.utils.toPEM(\n      rfc5280.SubjectPublicKeyInfo.encode(certKey, 'der'), 'PUBLIC KEY');\n    return { err: null, responderKey: certKey };\n  }\n\n  return { err: null, responderKey: issuerKey };\n};\n\n/**\n * Verify OCSP response. If issuer is not specified, the signature will not be\n * verified.\n * @param issuer issuer certificate\n * @param rawRes OCSP Response\n * @returns {{success, error, revoked}|{res, success, error}}\n */\nconst verifyOCSPResponse = function (issuer, rawRes) {\n  function done(err) {\n    return {\n      err: err,\n      res: rawRes\n    };\n  }\n\n  let res;\n  try {\n    res = ocsp.utils.parseResponse(rawRes);\n  } catch (e) {\n    return done(e);\n  }\n  const value = res.value;\n  if (issuer) {\n    // verify signature only if issuer is given\n    const certs = res.certs;\n    const rawTBS = rawRes.slice(res.start, res.end);\n    const raws = res.certsTbs.map(function (tbs) {\n      return rawRes.slice(tbs.start, tbs.end);\n    });\n    const signAlg = ocsp.utils.sign[value.signatureAlgorithm.algorithm.join('.')];\n    if (!signAlg) {\n      return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_NO_SIGNATURE_ALGORITHM));\n    }\n    const responderStatus = findResponder(issuer, certs, raws);\n    if (responderStatus.err) {\n      return done(responderStatus.err);\n    }\n    const responderKey = responderStatus.responderKey;\n    const v = crypto.createVerify(signAlg);\n    const signature = value.signature.data;\n    v.update(rawTBS);\n    if (!v.verify(responderKey, signature)) {\n      return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_INVALID_SIGNATURE));\n    }\n  }\n  const tbs = value.tbsResponseData;\n  if (tbs.responses.length < 1) {\n    return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_NO_RESPONSE));\n  }\n  const sd = tbs.responses[0];\n  if (sd.certStatus.type === 'revoked') {\n    return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_REVOKED));\n  }\n  const currentTime = Date.now();\n  const isInjectValidity = process.env.SF_OCSP_TEST_INJECT_VALIDITY_ERROR || '';\n  if (isInjectValidity.toLowerCase() === 'true' || !isValidityRange(currentTime, sd.thisUpdate, sd.nextUpdate)) {\n    return done(Errors.createOCSPError(\n      ErrorCodes.ERR_OCSP_INVALID_VALIDITY,\n      'Valid from:', toUTCString(sd.thisUpdate), ', Valid to:', toUTCString(sd.nextUpdate)));\n  }\n  const isInjectUnknown = process.env.SF_OCSP_TEST_INJECT_UNKNOWN_STATUS || '';\n  if (isInjectUnknown.toLowerCase() === 'true' || sd.certStatus.type === 'unknown') {\n    return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_UNKNOWN));\n  }\n  if (sd.certStatus.type === 'good') {\n    return done(null);\n  }\n  return done(Errors.createOCSPError(ErrorCodes.ERR_OCSP_UNKNOWN_STATE));\n};\nexports.verifyOCSPResponse = verifyOCSPResponse;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYWdlbnQvY2VydF91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsZ0JBQWdCLG1CQUFPLENBQUMsd0JBQVM7QUFDakMsYUFBYSxtQkFBTyxDQUFDLDJFQUFrQjtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDekMsZ0JBQWdCLG1CQUFPLENBQUMsc0VBQWlCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixXQUFXLG1CQUFPLENBQUMsbURBQU87QUFDMUIsZUFBZSxtQkFBTyxDQUFDLG1FQUFXO0FBQ2xDOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osaUJBQWlCO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjs7QUFFakI7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCOztBQUV2QjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsd0JBQXdCLEVBQUU7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2FnZW50L2NlcnRfdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogVGhpcyBzb2Z0d2FyZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIExpY2Vuc2UuXG4gKlxuICogQ29weXJpZ2h0IEZlZG9yIEluZHV0bnksIDIwMTUuXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG4gKiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IHByb2Nlc3MgPSByZXF1aXJlKCdwcm9jZXNzJyk7XG5jb25zdCBvY3NwID0gcmVxdWlyZSgnQHRlY2h0ZWFtZXIvb2NzcCcpO1xuY29uc3QgcmZjMjU2MCA9IHJlcXVpcmUoJ2FzbjEuanMtcmZjMjU2MCcpO1xuY29uc3QgcmZjNTI4MCA9IHJlcXVpcmUoJ2FzbjEuanMtcmZjNTI4MCcpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBibiA9IHJlcXVpcmUoJ2JuLmpzJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSBFcnJvcnMuY29kZXM7XG5cblxuY29uc3QgVE9MRVJBQkxFX1ZBTElESVRZX1JBTkdFX1JBVElPID0gMC4wMTtcbmNvbnN0IE1BWF9DTE9DS19TS0VXX0lOX01JTExJU0VDT05EUyA9IDkwMDAwMDtcbmNvbnN0IE1JTl9DQUNIRV9XQVJNVVBfVElNRV9JTl9NSUxMSVNFQ09ORFMgPSAxODAwMDAwMDtcblxuLyoqXG4gKiBCdWlsZHMgdGhlIGNlcnRpZmljYXRlIGlkIGZvciBhIGdpdmVuIGNlcnRpZmljYXRlLlxuICpcbiAqIEBwYXJhbSBjZXJ0XG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZXhwb3J0cy5idWlsZENlcnRJZCA9IGZ1bmN0aW9uIChjZXJ0KSB7XG4gIGxldCBpc3N1ZXIgPSBjZXJ0Lmlzc3VlckNlcnRpZmljYXRlO1xuICBjZXJ0ID0gY2VydC5yYXc7XG5cbiAgdHJ5IHtcbiAgICBjZXJ0ID0gcmZjNTI4MC5DZXJ0aWZpY2F0ZS5kZWNvZGUoY2VydCwgJ2RlcicpO1xuICAgIGlmIChpc3N1ZXIpIHtcbiAgICAgIGlzc3VlciA9IGlzc3Vlci5yYXc7XG4gICAgICBpc3N1ZXIgPSByZmM1MjgwLkNlcnRpZmljYXRlLmRlY29kZShpc3N1ZXIsICdkZXInKTtcbiAgICB9XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gaWYgd2UgZW5jb3VudGVyZWQgYW4gZXJyb3IgZHVyaW5nIGRlY29kaW5nLCByZXR1cm4gbnVsbFxuICB9XG5cbiAgY29uc3QgdGJzQ2VydCA9IGNlcnQudGJzQ2VydGlmaWNhdGU7XG4gIGNvbnN0IHRic0lzc3VlciA9IGlzc3Vlci50YnNDZXJ0aWZpY2F0ZTtcblxuICBjb25zdCBjZXJ0SUQgPSB7XG4gICAgaGFzaEFsZ29yaXRobToge1xuICAgICAgLy8gYWxnb3JpdGhtOiBbIDIsIDE2LCA4NDAsIDEsIDEwMSwgMywgNCwgMiwgMSBdICAvLyBzaGEyNTZcbiAgICAgIGFsZ29yaXRobTogWzEsIDMsIDE0LCAzLCAyLCAyNl0gIC8vIHNoYTFcbiAgICB9LFxuICAgIGlzc3Vlck5hbWVIYXNoOiBzaGExKHJmYzUyODAuTmFtZS5lbmNvZGUodGJzQ2VydC5pc3N1ZXIsICdkZXInKSksXG4gICAgaXNzdWVyS2V5SGFzaDogc2hhMShcbiAgICAgIHRic0lzc3Vlci5zdWJqZWN0UHVibGljS2V5SW5mby5zdWJqZWN0UHVibGljS2V5LmRhdGEpLFxuICAgIHNlcmlhbE51bWJlcjogdGJzQ2VydC5zZXJpYWxOdW1iZXJcbiAgfTtcbiAgY29uc3QgY2VydElERGVyID0gcmZjMjU2MC5DZXJ0SUQuZW5jb2RlKGNlcnRJRCwgJ2RlcicpO1xuICByZXR1cm4gZW5jb2RlS2V5KGNlcnRJRERlci50b1N0cmluZygnQkFTRTY0JykpO1xufTtcblxuZnVuY3Rpb24gc2hhMShkYXRhKSB7XG4gIHJldHVybiBjcnlwdG8uY3JlYXRlSGFzaCgnc2hhMScpLnVwZGF0ZShkYXRhKS5kaWdlc3QoKTtcbn1cblxuLyoqXG4gKiBQYXJzZXMgYSBjZXJ0aWZpY2F0ZSBhbmQgcmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBkZWNvZGVkIHZlcnNpb25zXG4gKiBvZiB0aGUgY2VydGlmaWNhdGUgYW5kIGl0cyBpc3N1ZXIuXG4gKlxuICogTm90ZTogdGhpcyBtZXRob2QgbWlnaHQgdGhyb3cgYW4gZXJyb3IsIHNvIHVzZSBhIHRyeS1jYXRjaCB3aGVuIGNhbGxpbmcgaXQuXG4gKlxuICogQHBhcmFtIGNlcnRcbiAqIEByZXR1cm5zIHt7Y2VydDogKiwgaXNzdWVyOiAqfX1cbiAqL1xuZXhwb3J0cy5kZWNvZGUgPSBmdW5jdGlvbiAoY2VydCkge1xuICBsZXQgaXNzdWVyID0gY2VydC5pc3N1ZXJDZXJ0aWZpY2F0ZTtcbiAgY2VydCA9IGNlcnQucmF3O1xuXG4gIC8vIG5vdGU6IHRoaXMgYmxvY2sgbWlnaHQgdGhyb3cgYW4gZXJyb3JcbiAgY2VydCA9IHJmYzUyODAuQ2VydGlmaWNhdGUuZGVjb2RlKGNlcnQsICdkZXInKTtcbiAgaWYgKGlzc3Vlcikge1xuICAgIGlzc3VlciA9IGlzc3Vlci5yYXc7XG4gICAgaXNzdWVyID0gcmZjNTI4MC5DZXJ0aWZpY2F0ZS5kZWNvZGUoaXNzdWVyLCAnZGVyJyk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNlcnQ6IGNlcnQsXG4gICAgaXNzdWVyOiBpc3N1ZXJcbiAgfTtcbn07XG5cbi8qKlxuICogRW5jb2RlIGNlcnRJRCB0byBhIGNhY2hlIGtleVxuICogQHBhcmFtIGJhc2U2NEtleSB7T2JqZWN0fVxuICogQHJldHVybiBjYWNoZSBrZXkge3N0cmluZ31cbiAqL1xuY29uc3QgZW5jb2RlS2V5ID0gZnVuY3Rpb24gKGJhc2U2NEtleSkge1xuICBjb25zdCBidWZmID0gQnVmZmVyLmZyb20oYmFzZTY0S2V5LCAnYmFzZTY0Jyk7XG4gIGNvbnN0IGNlcnRJRCA9IHJmYzI1NjAuQ2VydElELmRlY29kZShidWZmLCAnZGVyJyk7XG5cbiAgcmV0dXJuIGNlcnRJRC5pc3N1ZXJOYW1lSGFzaC50b1N0cmluZygnQkFTRTY0JylcbiAgICArICcjJyArIGNlcnRJRC5pc3N1ZXJLZXlIYXNoLnRvU3RyaW5nKCdCQVNFNjQnKVxuICAgICsgJyMnICsgY2VydElELnNlcmlhbE51bWJlci50b1N0cmluZygxMCk7XG59O1xuZXhwb3J0cy5lbmNvZGVLZXkgPSBlbmNvZGVLZXk7XG5cbi8qKlxuICogRW5jb2RlIGNlcnRJRCB0byBhIGNhY2hlIGtleVxuICogQHBhcmFtIGNhY2hlS2V5IHtPYmplY3R9XG4gKi9cbmNvbnN0IGRlY29kZUtleSA9IGZ1bmN0aW9uIChjYWNoZUtleSkge1xuICAvLyBzZXJpYWxOdW1iZXIuZXEoY2VydElELnNlcmlhbE51bWJlcilcbiAgY29uc3Qga2V5cyA9IGNhY2hlS2V5LnNwbGl0KCcjJyk7XG4gIGNvbnN0IGlzc3Vlck5hbWVIYXNoID0gQnVmZmVyLmZyb20oa2V5c1swXSwgJ2Jhc2U2NCcpO1xuICBjb25zdCBpc3N1ZXJLZXlIYXNoID0gQnVmZmVyLmZyb20oa2V5c1sxXSwgJ2Jhc2U2NCcpO1xuICBjb25zdCBzZXJpYWxOdW1iZXIgPSBuZXcgYm4oa2V5c1syXSwgMTApO1xuXG4gIGNvbnN0IGNlcnRJRCA9IHtcbiAgICBoYXNoQWxnb3JpdGhtOiB7XG4gICAgICAvLyBhbGdvcml0aG06IFsgMiwgMTYsIDg0MCwgMSwgMTAxLCAzLCA0LCAyLCAxIF0gIC8vIHNoYTI1NlxuICAgICAgYWxnb3JpdGhtOiBbMSwgMywgMTQsIDMsIDIsIDI2XSAgLy8gc2hhMVxuICAgIH0sXG4gICAgaXNzdWVyTmFtZUhhc2g6IGlzc3Vlck5hbWVIYXNoLFxuICAgIGlzc3VlcktleUhhc2g6IGlzc3VlcktleUhhc2gsXG4gICAgc2VyaWFsTnVtYmVyOiBzZXJpYWxOdW1iZXJcbiAgfTtcblxuICBjb25zdCBjZXJ0SUREZXIgPSByZmMyNTYwLkNlcnRJRC5lbmNvZGUoY2VydElELCAnZGVyJyk7XG4gIHJldHVybiBjZXJ0SUREZXIudG9TdHJpbmcoJ0JBU0U2NCcpO1xufTtcbmV4cG9ydHMuZGVjb2RlS2V5ID0gZGVjb2RlS2V5O1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgVG9sZXJhYmxlIHZhbGlkaXR5XG4gKiBAcGFyYW0gdGhpc1VwZGF0ZSBsYXN0IHVwZGF0ZVxuICogQHBhcmFtIG5leHRVcGRhdGUgbmV4dCB1cGRhdGVcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbmNvbnN0IGNhbGN1bGF0ZVRvbGVyYWJsZVZhZGlsaXR5ID0gZnVuY3Rpb24gKHRoaXNVcGRhdGUsIG5leHRVcGRhdGUpIHtcbiAgY29uc3QgY3VycmVudFJhbmdlID0gKG5leHRVcGRhdGUgLSB0aGlzVXBkYXRlKSAqXG4gICAgVE9MRVJBQkxFX1ZBTElESVRZX1JBTkdFX1JBVElPO1xuICByZXR1cm4gY3VycmVudFJhbmdlID4gTUlOX0NBQ0hFX1dBUk1VUF9USU1FX0lOX01JTExJU0VDT05EUyA/XG4gICAgY3VycmVudFJhbmdlIDogTUlOX0NBQ0hFX1dBUk1VUF9USU1FX0lOX01JTExJU0VDT05EUztcbn07XG5cbi8qKlxuICogQ2hlY2tzIHRoZSB2YWxpZGl0eVxuICogQHBhcmFtIGN1cnJlbnRUaW1lIGN1cnJlbnQgdGltZVxuICogQHBhcmFtIHRoaXNVcGRhdGUgbGFzdCB1cGRhdGVcbiAqIEBwYXJhbSBuZXh0VXBkYXRlIG5leHQgdXBkYXRlXG4gKiBAcmV0dXJuIHtib29sZWFufVxuICovXG5jb25zdCBpc1ZhbGlkaXR5UmFuZ2UgPSBmdW5jdGlvbiAoY3VycmVudFRpbWUsIHRoaXNVcGRhdGUsIG5leHRVcGRhdGUpIHtcbiAgY29uc3QgdG9sZXJhYmxlVmFsaWRpdHkgPSBjYWxjdWxhdGVUb2xlcmFibGVWYWRpbGl0eSh0aGlzVXBkYXRlLCBuZXh0VXBkYXRlKTtcbiAgcmV0dXJuIHRoaXNVcGRhdGUgLSBNQVhfQ0xPQ0tfU0tFV19JTl9NSUxMSVNFQ09ORFMgPD0gY3VycmVudFRpbWUgJiZcbiAgICBjdXJyZW50VGltZSA8PSBuZXh0VXBkYXRlICsgdG9sZXJhYmxlVmFsaWRpdHk7XG59O1xuZXhwb3J0cy5pc1ZhbGlkaXR5UmFuZ2UgPSBpc1ZhbGlkaXR5UmFuZ2U7XG5cbi8qKlxuICogQ29udmVydHMgYSBlcG9jaCB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byBhIFVUQyBkYXRldGltZSBzdHJpbmdcbiAqIEBwYXJhbSBlcG9jaEluTWlsbGlTZWNvbmRzXG4gKiBAcmV0dXJucyB7RGF0ZX1cbiAqL1xuY29uc3QgdG9VVENTdHJpbmcgPSBmdW5jdGlvbiAoZXBvY2hJbk1pbGxpU2Vjb25kcykge1xuICByZXR1cm4gbmV3IERhdGUoZXBvY2hJbk1pbGxpU2Vjb25kcyk7XG59O1xuXG4vKipcbiAqIFJldHVybiBpc3N1ZXIgY2VydGlmaWNhdGUgb3Igc2lnbmluZyBjZXJ0aWZpY2F0ZVxuICogQHBhcmFtIGlzc3VlciBpc3N1ZXIgY2VydGlmaWNhdGVcbiAqIEBwYXJhbSBjZXJ0c1xuICogQHBhcmFtIHJhd3NcbiAqL1xuY29uc3QgZmluZFJlc3BvbmRlciA9IGZ1bmN0aW9uIChpc3N1ZXIsIGNlcnRzLCByYXdzKSB7XG4gIGxldCBpc3N1ZXJLZXkgPSBpc3N1ZXIudGJzQ2VydGlmaWNhdGUuc3ViamVjdFB1YmxpY0tleUluZm87XG4gIGlzc3VlcktleSA9IG9jc3AudXRpbHMudG9QRU0oXG4gICAgcmZjNTI4MC5TdWJqZWN0UHVibGljS2V5SW5mby5lbmNvZGUoaXNzdWVyS2V5LCAnZGVyJyksICdQVUJMSUMgS0VZJyk7XG4gIGlmIChjZXJ0cy5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgY3VycmVudFRpbWUgPSBEYXRlLm5vdygpO1xuICAgIGNvbnN0IGNlcnQgPSBjZXJ0c1swXTtcbiAgICBjb25zdCBjZXJ0VmFsaWRpdHkgPSBjZXJ0LnRic0NlcnRpZmljYXRlLnZhbGlkaXR5O1xuICAgIGlmIChjZXJ0VmFsaWRpdHkubm90QWZ0ZXIudmFsdWUgPCBjdXJyZW50VGltZSB8fCBjZXJ0VmFsaWRpdHkubm90QmVmb3JlLnZhbHVlID4gY3VycmVudFRpbWUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycjogRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihcbiAgICAgICAgICBFcnJvckNvZGVzLkVSUl9PQ1NQX0lOVkFMSURfQ0VSVElGSUNBVEVfVkFMSURJVFksXG4gICAgICAgICAgJ1ZhbGlkIGZyb206JywgdG9VVENTdHJpbmcoY2VydFZhbGlkaXR5Lm5vdEJlZm9yZS52YWx1ZSksXG4gICAgICAgICAgJywgVmFsaWQgdG86JywgdG9VVENTdHJpbmcoY2VydFZhbGlkaXR5Lm5vdEFmdGVyLnZhbHVlKSksXG4gICAgICAgIHJlc3BvbmRlcktleTogbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3Qgc2lnbkFsZyA9IG9jc3AudXRpbHMuc2lnbltjZXJ0LnNpZ25hdHVyZUFsZ29yaXRobS5hbGdvcml0aG0uam9pbignLicpXTtcbiAgICBpZiAoIXNpZ25BbGcpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycjogRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX05PX1NJR05BVFVSRV9BTEdPUklUSE0pLFxuICAgICAgICByZXNwb25kZXJLZXk6IG51bGxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgY29uc3QgdmVyaWZ5ID0gY3J5cHRvLmNyZWF0ZVZlcmlmeShzaWduQWxnKTtcblxuICAgIHZlcmlmeS51cGRhdGUocmF3c1swXSk7XG4gICAgaWYgKCF2ZXJpZnkudmVyaWZ5KGlzc3VlcktleSwgY2VydC5zaWduYXR1cmUuZGF0YSkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGVycjogRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX0lOVkFMSURfU0lHTkFUVVJFKSxcbiAgICAgICAgcmVzcG9uZGVyS2V5OiBudWxsXG4gICAgICB9O1xuICAgIH1cblxuICAgIGxldCBjZXJ0S2V5ID0gY2VydC50YnNDZXJ0aWZpY2F0ZS5zdWJqZWN0UHVibGljS2V5SW5mbztcbiAgICBjZXJ0S2V5ID0gb2NzcC51dGlscy50b1BFTShcbiAgICAgIHJmYzUyODAuU3ViamVjdFB1YmxpY0tleUluZm8uZW5jb2RlKGNlcnRLZXksICdkZXInKSwgJ1BVQkxJQyBLRVknKTtcbiAgICByZXR1cm4geyBlcnI6IG51bGwsIHJlc3BvbmRlcktleTogY2VydEtleSB9O1xuICB9XG5cbiAgcmV0dXJuIHsgZXJyOiBudWxsLCByZXNwb25kZXJLZXk6IGlzc3VlcktleSB9O1xufTtcblxuLyoqXG4gKiBWZXJpZnkgT0NTUCByZXNwb25zZS4gSWYgaXNzdWVyIGlzIG5vdCBzcGVjaWZpZWQsIHRoZSBzaWduYXR1cmUgd2lsbCBub3QgYmVcbiAqIHZlcmlmaWVkLlxuICogQHBhcmFtIGlzc3VlciBpc3N1ZXIgY2VydGlmaWNhdGVcbiAqIEBwYXJhbSByYXdSZXMgT0NTUCBSZXNwb25zZVxuICogQHJldHVybnMge3tzdWNjZXNzLCBlcnJvciwgcmV2b2tlZH18e3Jlcywgc3VjY2VzcywgZXJyb3J9fVxuICovXG5jb25zdCB2ZXJpZnlPQ1NQUmVzcG9uc2UgPSBmdW5jdGlvbiAoaXNzdWVyLCByYXdSZXMpIHtcbiAgZnVuY3Rpb24gZG9uZShlcnIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgZXJyOiBlcnIsXG4gICAgICByZXM6IHJhd1Jlc1xuICAgIH07XG4gIH1cblxuICBsZXQgcmVzO1xuICB0cnkge1xuICAgIHJlcyA9IG9jc3AudXRpbHMucGFyc2VSZXNwb25zZShyYXdSZXMpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGRvbmUoZSk7XG4gIH1cbiAgY29uc3QgdmFsdWUgPSByZXMudmFsdWU7XG4gIGlmIChpc3N1ZXIpIHtcbiAgICAvLyB2ZXJpZnkgc2lnbmF0dXJlIG9ubHkgaWYgaXNzdWVyIGlzIGdpdmVuXG4gICAgY29uc3QgY2VydHMgPSByZXMuY2VydHM7XG4gICAgY29uc3QgcmF3VEJTID0gcmF3UmVzLnNsaWNlKHJlcy5zdGFydCwgcmVzLmVuZCk7XG4gICAgY29uc3QgcmF3cyA9IHJlcy5jZXJ0c1Ricy5tYXAoZnVuY3Rpb24gKHRicykge1xuICAgICAgcmV0dXJuIHJhd1Jlcy5zbGljZSh0YnMuc3RhcnQsIHRicy5lbmQpO1xuICAgIH0pO1xuICAgIGNvbnN0IHNpZ25BbGcgPSBvY3NwLnV0aWxzLnNpZ25bdmFsdWUuc2lnbmF0dXJlQWxnb3JpdGhtLmFsZ29yaXRobS5qb2luKCcuJyldO1xuICAgIGlmICghc2lnbkFsZykge1xuICAgICAgcmV0dXJuIGRvbmUoRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX05PX1NJR05BVFVSRV9BTEdPUklUSE0pKTtcbiAgICB9XG4gICAgY29uc3QgcmVzcG9uZGVyU3RhdHVzID0gZmluZFJlc3BvbmRlcihpc3N1ZXIsIGNlcnRzLCByYXdzKTtcbiAgICBpZiAocmVzcG9uZGVyU3RhdHVzLmVycikge1xuICAgICAgcmV0dXJuIGRvbmUocmVzcG9uZGVyU3RhdHVzLmVycik7XG4gICAgfVxuICAgIGNvbnN0IHJlc3BvbmRlcktleSA9IHJlc3BvbmRlclN0YXR1cy5yZXNwb25kZXJLZXk7XG4gICAgY29uc3QgdiA9IGNyeXB0by5jcmVhdGVWZXJpZnkoc2lnbkFsZyk7XG4gICAgY29uc3Qgc2lnbmF0dXJlID0gdmFsdWUuc2lnbmF0dXJlLmRhdGE7XG4gICAgdi51cGRhdGUocmF3VEJTKTtcbiAgICBpZiAoIXYudmVyaWZ5KHJlc3BvbmRlcktleSwgc2lnbmF0dXJlKSkge1xuICAgICAgcmV0dXJuIGRvbmUoRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX0lOVkFMSURfU0lHTkFUVVJFKSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHRicyA9IHZhbHVlLnRic1Jlc3BvbnNlRGF0YTtcbiAgaWYgKHRicy5yZXNwb25zZXMubGVuZ3RoIDwgMSkge1xuICAgIHJldHVybiBkb25lKEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9OT19SRVNQT05TRSkpO1xuICB9XG4gIGNvbnN0IHNkID0gdGJzLnJlc3BvbnNlc1swXTtcbiAgaWYgKHNkLmNlcnRTdGF0dXMudHlwZSA9PT0gJ3Jldm9rZWQnKSB7XG4gICAgcmV0dXJuIGRvbmUoRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX1JFVk9LRUQpKTtcbiAgfVxuICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gIGNvbnN0IGlzSW5qZWN0VmFsaWRpdHkgPSBwcm9jZXNzLmVudi5TRl9PQ1NQX1RFU1RfSU5KRUNUX1ZBTElESVRZX0VSUk9SIHx8ICcnO1xuICBpZiAoaXNJbmplY3RWYWxpZGl0eS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScgfHwgIWlzVmFsaWRpdHlSYW5nZShjdXJyZW50VGltZSwgc2QudGhpc1VwZGF0ZSwgc2QubmV4dFVwZGF0ZSkpIHtcbiAgICByZXR1cm4gZG9uZShFcnJvcnMuY3JlYXRlT0NTUEVycm9yKFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfT0NTUF9JTlZBTElEX1ZBTElESVRZLFxuICAgICAgJ1ZhbGlkIGZyb206JywgdG9VVENTdHJpbmcoc2QudGhpc1VwZGF0ZSksICcsIFZhbGlkIHRvOicsIHRvVVRDU3RyaW5nKHNkLm5leHRVcGRhdGUpKSk7XG4gIH1cbiAgY29uc3QgaXNJbmplY3RVbmtub3duID0gcHJvY2Vzcy5lbnYuU0ZfT0NTUF9URVNUX0lOSkVDVF9VTktOT1dOX1NUQVRVUyB8fCAnJztcbiAgaWYgKGlzSW5qZWN0VW5rbm93bi50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScgfHwgc2QuY2VydFN0YXR1cy50eXBlID09PSAndW5rbm93bicpIHtcbiAgICByZXR1cm4gZG9uZShFcnJvcnMuY3JlYXRlT0NTUEVycm9yKEVycm9yQ29kZXMuRVJSX09DU1BfVU5LTk9XTikpO1xuICB9XG4gIGlmIChzZC5jZXJ0U3RhdHVzLnR5cGUgPT09ICdnb29kJykge1xuICAgIHJldHVybiBkb25lKG51bGwpO1xuICB9XG4gIHJldHVybiBkb25lKEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9VTktOT1dOX1NUQVRFKSk7XG59O1xuZXhwb3J0cy52ZXJpZnlPQ1NQUmVzcG9uc2UgPSB2ZXJpZnlPQ1NQUmVzcG9uc2U7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/agent/cert_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/agent/check.js":
/*!*******************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/agent/check.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/*\n * This software is licensed under the MIT License.\n *\n * Copyright Fedor Indutny, 2015.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n\n\nconst http = __webpack_require__(/*! http */ \"http\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst ocsp = __webpack_require__(/*! @techteamer/ocsp */ \"(rsc)/./node_modules/@techteamer/ocsp/lib/ocsp.js\");\nconst rfc2560 = __webpack_require__(/*! asn1.js-rfc2560 */ \"(rsc)/./node_modules/asn1.js-rfc2560/index.js\");\n\nconst SnowflakeUtil = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst CertUtil = __webpack_require__(/*! ./cert_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/agent/cert_util.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/lib/global_config.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\n\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\n\n/**\n * OCSP specific HTTP retryable errors\n * @param statusCode\n * @returns {boolean}\n */\nconst isRetryableHttpError = function (statusCode) {\n  return (statusCode >= 500 && statusCode < 600) ||\n    statusCode === 404 || statusCode === 403 || statusCode === 408;\n};\n\nfunction getResponse(uri, req, cb) {\n  uri = url.parse(uri);\n\n  const timeout = process.env.SF_OCSP_TEST_OCSP_RESPONDER_TIMEOUT || 10000;\n  const options = util._extend({\n    timeout: Number(timeout),\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/ocsp-request',\n      'Content-Length': req.length,\n    }\n  }, uri);\n\n  function done(err, response) {\n    if (cb) {\n      cb(err, response);\n    }\n    cb = null;\n  }\n\n  function onResponse(response) {\n    if (response.statusCode < 200 || response.statusCode >= 400) {\n      return done(\n        Errors.createOCSPError(ErrorCodes.ERR_OCSP_FAILED_OBTAIN_OCSP_RESPONSE,\n          response.statusCode), response);\n    }\n\n    const chunks = [];\n    response.on('readable', function () {\n      const chunk = response.read();\n      if (!chunk) {\n        return;\n      }\n      chunks.push(chunk);\n    });\n    response.on('end', function () {\n      Logger.getInstance().debug('Finish OCSP responder: %s', uri.host);\n      const ocsp = Buffer.concat(chunks);\n      done(null, ocsp);\n    });\n  }\n\n  const httpRequest = http.request(options, onResponse);\n  httpRequest.on('error', function (e) {\n    if (cb) {\n      cb(e);\n    }\n    cb = null;\n  });\n  httpRequest.on('timeout', function () {\n    httpRequest.abort();\n    Logger.getInstance().debug('Timeout OCSP responder: %s', uri.host);\n    if (cb) {\n      cb(Errors.createOCSPError(ErrorCodes.ERR_OCSP_RESPONDER_TIMEOUT));\n    }\n    cb = null;\n  });\n  httpRequest.end(req);\n}\n\nmodule.exports = function check(options, cb, mock) {\n  let sync = true;\n  const isFailClosed = GlobalConfig.getOcspMode() === GlobalConfig.ocspModes.FAIL_CLOSED;\n  const maxNumRetries = isFailClosed ? 2 : 1;\n\n  function done(err, data) {\n    if (sync) {\n      sync = false;\n      process.nextTick(function () {\n        cb(err, data);\n      });\n      return;\n    }\n\n    cb(err, data);\n  }\n\n  let req;\n  try {\n    req = mock ? mock.req : ocsp.request.generate(options.cert, options.issuer);\n  } catch (e) {\n    return done(e);\n  }\n\n  const ocspMethod = rfc2560['id-pkix-ocsp'].join('.');\n\n  let numRetries = 1;\n  let sleep = 1;\n\n  function ocspResponseVerify(err, raw) {\n    let retry = false;\n    if (err) {\n      if (Object.prototype.hasOwnProperty.call(err, 'code') && err.code === ErrorCodes.ERR_OCSP_RESPONDER_TIMEOUT) {\n        retry = true;\n      } else if (Object.prototype.hasOwnProperty.call(err, 'message')) {\n        const errorMessage = err.message.split(' ');\n        if (errorMessage.length === 0) {\n          return done(err);\n        }\n        try {\n          const statusCode = parseInt(errorMessage[errorMessage.length - 1], 10);\n          retry = isRetryableHttpError(statusCode);\n        } catch (e) {\n          // ignore\n        }\n      }\n      if (numRetries < maxNumRetries && retry) {\n        numRetries++;\n        sleep = SnowflakeUtil.nextSleepTime(1, 10, sleep);\n        setTimeout(ocspRequestSend, sleep * 1000);\n      } else {\n        Logger.getInstance().debug('Failed to all retries to OCSP responder.');\n        return done(err);\n      }\n    } else {\n      const status = CertUtil.verifyOCSPResponse(req.issuer, raw);\n      done(status.err, status);\n    }\n  }\n\n  function setOcspResponderUrl(uri) {\n    let parsedUrl = (__webpack_require__(/*! url */ \"url\").parse)(process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL);\n\n    let targetUrl;\n    if (parsedUrl.port) {\n      targetUrl = `${parsedUrl.protocol}//${parsedUrl.hostname}:${parsedUrl.port}/retry`;\n    } else {\n      targetUrl = `${parsedUrl.protocol}//${parsedUrl.hostname}/retry`;\n    }\n\n    const b64data = req.data.toString('base64');\n    parsedUrl = (__webpack_require__(/*! url */ \"url\").parse)(uri);\n\n    process.env.SF_OCSP_RESPONDER_URL = targetUrl + '/' + parsedUrl.hostname + '/' + b64data;\n  }\n\n  function ocspRequestCallback(err, uri) {\n    if (err) {\n      //This error message is from @techteamer/ocsp (ocsp.utils.getAuthorityInfo)\n      if (err.message === 'AuthorityInfoAccess not found in extensions') {\n        if (!isFailClosed) {\n          Logger.getInstance().debug('OCSP Responder URL is missing from the certificate.');\n          return done(null);\n        } else {\n          Logger.getInstance().error('OCSP Responder URL is missing from the certificate, so cannot verify with OCSP. Aborting connection attempt due to OCSP being set to FAIL_CLOSE https://docs.snowflake.com/en/user-guide/ocsp#fail-close');\n        }\n      }\n      return done(err);\n    }\n\n    if (process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL &&\n      process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL.includes('ocsp_response_cache.json')) {\n      setOcspResponderUrl(uri);\n    }\n\n    const responderUrl = process.env.SF_OCSP_RESPONDER_URL;\n    if (responderUrl) {\n      uri = responderUrl;\n    }\n    Logger.getInstance().trace(\n      'Contact OCSP responder: %s, (%s/%s)', uri, numRetries, maxNumRetries);\n\n    if (!mock) {\n      getResponse(uri, req.data, ocspResponseVerify);\n    }\n  }\n\n  function ocspRequestSend() {\n    if (!mock) {\n      ocsp.utils.getAuthorityInfo(req.cert, ocspMethod, ocspRequestCallback);\n    } else {\n      ocspRequestCallback(null, mock.uri);\n    }\n  }\n\n  ocspRequestSend();\n\n  sync = false;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYWdlbnQvY2hlY2suanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0IsYUFBYSxtQkFBTyxDQUFDLDJFQUFrQjtBQUN2QyxnQkFBZ0IsbUJBQU8sQ0FBQyxzRUFBaUI7O0FBRXpDLHNCQUFzQixtQkFBTyxDQUFDLCtEQUFTO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLDhFQUFhO0FBQ3RDLHFCQUFxQixtQkFBTyxDQUFDLGlGQUFrQjtBQUMvQyxlQUFlLG1CQUFPLENBQUMsbUVBQVc7QUFDbEM7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLG1FQUFXOztBQUVsQztBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQiw2Q0FBb0I7O0FBRXhDO0FBQ0E7QUFDQSxxQkFBcUIsbUJBQW1CLElBQUksbUJBQW1CLEdBQUcsZUFBZTtBQUNqRixNQUFNO0FBQ04scUJBQXFCLG1CQUFtQixJQUFJLG1CQUFtQjtBQUMvRDs7QUFFQTtBQUNBLGdCQUFnQiw2Q0FBb0I7O0FBRXBDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2FnZW50L2NoZWNrLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBUaGlzIHNvZnR3YXJlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZS5cbiAqXG4gKiBDb3B5cmlnaHQgRmVkb3IgSW5kdXRueSwgMjAxNS5cbiAqXG4gKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gKiBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG4gKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gKiBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbiAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gKlxuICogVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWQgaW5cbiAqIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAqIFNPRlRXQVJFLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3Qgb2NzcCA9IHJlcXVpcmUoJ0B0ZWNodGVhbWVyL29jc3AnKTtcbmNvbnN0IHJmYzI1NjAgPSByZXF1aXJlKCdhc24xLmpzLXJmYzI1NjAnKTtcblxuY29uc3QgU25vd2ZsYWtlVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IENlcnRVdGlsID0gcmVxdWlyZSgnLi9jZXJ0X3V0aWwnKTtcbmNvbnN0IEdsb2JhbENvbmZpZyA9IHJlcXVpcmUoJy4uL2dsb2JhbF9jb25maWcnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2RlcztcblxuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5cbi8qKlxuICogT0NTUCBzcGVjaWZpYyBIVFRQIHJldHJ5YWJsZSBlcnJvcnNcbiAqIEBwYXJhbSBzdGF0dXNDb2RlXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuY29uc3QgaXNSZXRyeWFibGVIdHRwRXJyb3IgPSBmdW5jdGlvbiAoc3RhdHVzQ29kZSkge1xuICByZXR1cm4gKHN0YXR1c0NvZGUgPj0gNTAwICYmIHN0YXR1c0NvZGUgPCA2MDApIHx8XG4gICAgc3RhdHVzQ29kZSA9PT0gNDA0IHx8IHN0YXR1c0NvZGUgPT09IDQwMyB8fCBzdGF0dXNDb2RlID09PSA0MDg7XG59O1xuXG5mdW5jdGlvbiBnZXRSZXNwb25zZSh1cmksIHJlcSwgY2IpIHtcbiAgdXJpID0gdXJsLnBhcnNlKHVyaSk7XG5cbiAgY29uc3QgdGltZW91dCA9IHByb2Nlc3MuZW52LlNGX09DU1BfVEVTVF9PQ1NQX1JFU1BPTkRFUl9USU1FT1VUIHx8IDEwMDAwO1xuICBjb25zdCBvcHRpb25zID0gdXRpbC5fZXh0ZW5kKHtcbiAgICB0aW1lb3V0OiBOdW1iZXIodGltZW91dCksXG4gICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgaGVhZGVyczoge1xuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9vY3NwLXJlcXVlc3QnLFxuICAgICAgJ0NvbnRlbnQtTGVuZ3RoJzogcmVxLmxlbmd0aCxcbiAgICB9XG4gIH0sIHVyaSk7XG5cbiAgZnVuY3Rpb24gZG9uZShlcnIsIHJlc3BvbnNlKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIsIHJlc3BvbnNlKTtcbiAgICB9XG4gICAgY2IgPSBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXNDb2RlIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1c0NvZGUgPj0gNDAwKSB7XG4gICAgICByZXR1cm4gZG9uZShcbiAgICAgICAgRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX0ZBSUxFRF9PQlRBSU5fT0NTUF9SRVNQT05TRSxcbiAgICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlKSwgcmVzcG9uc2UpO1xuICAgIH1cblxuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xuICAgIHJlc3BvbnNlLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbnN0IGNodW5rID0gcmVzcG9uc2UucmVhZCgpO1xuICAgICAgaWYgKCFjaHVuaykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjaHVua3MucHVzaChjaHVuayk7XG4gICAgfSk7XG4gICAgcmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdGaW5pc2ggT0NTUCByZXNwb25kZXI6ICVzJywgdXJpLmhvc3QpO1xuICAgICAgY29uc3Qgb2NzcCA9IEJ1ZmZlci5jb25jYXQoY2h1bmtzKTtcbiAgICAgIGRvbmUobnVsbCwgb2NzcCk7XG4gICAgfSk7XG4gIH1cblxuICBjb25zdCBodHRwUmVxdWVzdCA9IGh0dHAucmVxdWVzdChvcHRpb25zLCBvblJlc3BvbnNlKTtcbiAgaHR0cFJlcXVlc3Qub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGUpO1xuICAgIH1cbiAgICBjYiA9IG51bGw7XG4gIH0pO1xuICBodHRwUmVxdWVzdC5vbigndGltZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICBodHRwUmVxdWVzdC5hYm9ydCgpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdUaW1lb3V0IE9DU1AgcmVzcG9uZGVyOiAlcycsIHVyaS5ob3N0KTtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9SRVNQT05ERVJfVElNRU9VVCkpO1xuICAgIH1cbiAgICBjYiA9IG51bGw7XG4gIH0pO1xuICBodHRwUmVxdWVzdC5lbmQocmVxKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjaGVjayhvcHRpb25zLCBjYiwgbW9jaykge1xuICBsZXQgc3luYyA9IHRydWU7XG4gIGNvbnN0IGlzRmFpbENsb3NlZCA9IEdsb2JhbENvbmZpZy5nZXRPY3NwTW9kZSgpID09PSBHbG9iYWxDb25maWcub2NzcE1vZGVzLkZBSUxfQ0xPU0VEO1xuICBjb25zdCBtYXhOdW1SZXRyaWVzID0gaXNGYWlsQ2xvc2VkID8gMiA6IDE7XG5cbiAgZnVuY3Rpb24gZG9uZShlcnIsIGRhdGEpIHtcbiAgICBpZiAoc3luYykge1xuICAgICAgc3luYyA9IGZhbHNlO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNiKGVyciwgZGF0YSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjYihlcnIsIGRhdGEpO1xuICB9XG5cbiAgbGV0IHJlcTtcbiAgdHJ5IHtcbiAgICByZXEgPSBtb2NrID8gbW9jay5yZXEgOiBvY3NwLnJlcXVlc3QuZ2VuZXJhdGUob3B0aW9ucy5jZXJ0LCBvcHRpb25zLmlzc3Vlcik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZG9uZShlKTtcbiAgfVxuXG4gIGNvbnN0IG9jc3BNZXRob2QgPSByZmMyNTYwWydpZC1wa2l4LW9jc3AnXS5qb2luKCcuJyk7XG5cbiAgbGV0IG51bVJldHJpZXMgPSAxO1xuICBsZXQgc2xlZXAgPSAxO1xuXG4gIGZ1bmN0aW9uIG9jc3BSZXNwb25zZVZlcmlmeShlcnIsIHJhdykge1xuICAgIGxldCByZXRyeSA9IGZhbHNlO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXJyLCAnY29kZScpICYmIGVyci5jb2RlID09PSBFcnJvckNvZGVzLkVSUl9PQ1NQX1JFU1BPTkRFUl9USU1FT1VUKSB7XG4gICAgICAgIHJldHJ5ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVyciwgJ21lc3NhZ2UnKSkge1xuICAgICAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBlcnIubWVzc2FnZS5zcGxpdCgnICcpO1xuICAgICAgICBpZiAoZXJyb3JNZXNzYWdlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHJldHVybiBkb25lKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gcGFyc2VJbnQoZXJyb3JNZXNzYWdlW2Vycm9yTWVzc2FnZS5sZW5ndGggLSAxXSwgMTApO1xuICAgICAgICAgIHJldHJ5ID0gaXNSZXRyeWFibGVIdHRwRXJyb3Ioc3RhdHVzQ29kZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBpZ25vcmVcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG51bVJldHJpZXMgPCBtYXhOdW1SZXRyaWVzICYmIHJldHJ5KSB7XG4gICAgICAgIG51bVJldHJpZXMrKztcbiAgICAgICAgc2xlZXAgPSBTbm93Zmxha2VVdGlsLm5leHRTbGVlcFRpbWUoMSwgMTAsIHNsZWVwKTtcbiAgICAgICAgc2V0VGltZW91dChvY3NwUmVxdWVzdFNlbmQsIHNsZWVwICogMTAwMCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnRmFpbGVkIHRvIGFsbCByZXRyaWVzIHRvIE9DU1AgcmVzcG9uZGVyLicpO1xuICAgICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBzdGF0dXMgPSBDZXJ0VXRpbC52ZXJpZnlPQ1NQUmVzcG9uc2UocmVxLmlzc3VlciwgcmF3KTtcbiAgICAgIGRvbmUoc3RhdHVzLmVyciwgc3RhdHVzKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBzZXRPY3NwUmVzcG9uZGVyVXJsKHVyaSkge1xuICAgIGxldCBwYXJzZWRVcmwgPSByZXF1aXJlKCd1cmwnKS5wYXJzZShwcm9jZXNzLmVudi5TRl9PQ1NQX1JFU1BPTlNFX0NBQ0hFX1NFUlZFUl9VUkwpO1xuXG4gICAgbGV0IHRhcmdldFVybDtcbiAgICBpZiAocGFyc2VkVXJsLnBvcnQpIHtcbiAgICAgIHRhcmdldFVybCA9IGAke3BhcnNlZFVybC5wcm90b2NvbH0vLyR7cGFyc2VkVXJsLmhvc3RuYW1lfToke3BhcnNlZFVybC5wb3J0fS9yZXRyeWA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRhcmdldFVybCA9IGAke3BhcnNlZFVybC5wcm90b2NvbH0vLyR7cGFyc2VkVXJsLmhvc3RuYW1lfS9yZXRyeWA7XG4gICAgfVxuXG4gICAgY29uc3QgYjY0ZGF0YSA9IHJlcS5kYXRhLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICBwYXJzZWRVcmwgPSByZXF1aXJlKCd1cmwnKS5wYXJzZSh1cmkpO1xuXG4gICAgcHJvY2Vzcy5lbnYuU0ZfT0NTUF9SRVNQT05ERVJfVVJMID0gdGFyZ2V0VXJsICsgJy8nICsgcGFyc2VkVXJsLmhvc3RuYW1lICsgJy8nICsgYjY0ZGF0YTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9jc3BSZXF1ZXN0Q2FsbGJhY2soZXJyLCB1cmkpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICAvL1RoaXMgZXJyb3IgbWVzc2FnZSBpcyBmcm9tIEB0ZWNodGVhbWVyL29jc3AgKG9jc3AudXRpbHMuZ2V0QXV0aG9yaXR5SW5mbylcbiAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gJ0F1dGhvcml0eUluZm9BY2Nlc3Mgbm90IGZvdW5kIGluIGV4dGVuc2lvbnMnKSB7XG4gICAgICAgIGlmICghaXNGYWlsQ2xvc2VkKSB7XG4gICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ09DU1AgUmVzcG9uZGVyIFVSTCBpcyBtaXNzaW5nIGZyb20gdGhlIGNlcnRpZmljYXRlLicpO1xuICAgICAgICAgIHJldHVybiBkb25lKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdPQ1NQIFJlc3BvbmRlciBVUkwgaXMgbWlzc2luZyBmcm9tIHRoZSBjZXJ0aWZpY2F0ZSwgc28gY2Fubm90IHZlcmlmeSB3aXRoIE9DU1AuIEFib3J0aW5nIGNvbm5lY3Rpb24gYXR0ZW1wdCBkdWUgdG8gT0NTUCBiZWluZyBzZXQgdG8gRkFJTF9DTE9TRSBodHRwczovL2RvY3Muc25vd2ZsYWtlLmNvbS9lbi91c2VyLWd1aWRlL29jc3AjZmFpbC1jbG9zZScpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZG9uZShlcnIpO1xuICAgIH1cblxuICAgIGlmIChwcm9jZXNzLmVudi5TRl9PQ1NQX1JFU1BPTlNFX0NBQ0hFX1NFUlZFUl9VUkwgJiZcbiAgICAgIHByb2Nlc3MuZW52LlNGX09DU1BfUkVTUE9OU0VfQ0FDSEVfU0VSVkVSX1VSTC5pbmNsdWRlcygnb2NzcF9yZXNwb25zZV9jYWNoZS5qc29uJykpIHtcbiAgICAgIHNldE9jc3BSZXNwb25kZXJVcmwodXJpKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXNwb25kZXJVcmwgPSBwcm9jZXNzLmVudi5TRl9PQ1NQX1JFU1BPTkRFUl9VUkw7XG4gICAgaWYgKHJlc3BvbmRlclVybCkge1xuICAgICAgdXJpID0gcmVzcG9uZGVyVXJsO1xuICAgIH1cbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShcbiAgICAgICdDb250YWN0IE9DU1AgcmVzcG9uZGVyOiAlcywgKCVzLyVzKScsIHVyaSwgbnVtUmV0cmllcywgbWF4TnVtUmV0cmllcyk7XG5cbiAgICBpZiAoIW1vY2spIHtcbiAgICAgIGdldFJlc3BvbnNlKHVyaSwgcmVxLmRhdGEsIG9jc3BSZXNwb25zZVZlcmlmeSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb2NzcFJlcXVlc3RTZW5kKCkge1xuICAgIGlmICghbW9jaykge1xuICAgICAgb2NzcC51dGlscy5nZXRBdXRob3JpdHlJbmZvKHJlcS5jZXJ0LCBvY3NwTWV0aG9kLCBvY3NwUmVxdWVzdENhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgb2NzcFJlcXVlc3RDYWxsYmFjayhudWxsLCBtb2NrLnVyaSk7XG4gICAgfVxuICB9XG5cbiAgb2NzcFJlcXVlc3RTZW5kKCk7XG5cbiAgc3luYyA9IGZhbHNlO1xufTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/agent/check.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/agent/https_ocsp_agent.js":
/*!******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/agent/https_ocsp_agent.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const HttpsAgent = (__webpack_require__(/*! https */ \"https\").Agent);\nconst SocketUtil = __webpack_require__(/*! ./socket_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/agent/socket_util.js\");\n\n/**\n * Creates a new HttpsOcspAgent.\n *\n * @param {Object} options\n *\n * @returns {HttpsOcspAgent}\n * @constructor\n */\nfunction HttpsOcspAgent(options) {\n  const agent = HttpsAgent.apply(this, [options]);\n  agent.createConnection = function (port, host, options) {\n    // make sure the 'options' variables references the argument that actually\n    // contains the options\n    // Note: look at the Node.js https agent to understand why this code is\n    // written this way\n    if (port !== null && typeof port === 'object') {\n      options = port;\n    } else if (host !== null && typeof host === 'object') {\n      options = host;\n    } else if (options === null || typeof options !== 'object') {\n      options = {};\n    }\n\n    if (typeof host !== 'string') {\n      host = options.host;\n    }\n\n    // call super\n    const socket = HttpsAgent.prototype.createConnection.apply(this, arguments);\n\n    // secure the socket and return it\n    return SocketUtil.secureSocket(socket, host, null);\n  };\n\n  return agent;\n}\n\nmodule.exports = HttpsOcspAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYWdlbnQvaHR0cHNfb2NzcF9hZ2VudC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUIsaURBQXNCO0FBQ3pDLG1CQUFtQixtQkFBTyxDQUFDLGtGQUFlOztBQUUxQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2FnZW50L2h0dHBzX29jc3BfYWdlbnQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgSHR0cHNBZ2VudCA9IHJlcXVpcmUoJ2h0dHBzJykuQWdlbnQ7XG5jb25zdCBTb2NrZXRVdGlsID0gcmVxdWlyZSgnLi9zb2NrZXRfdXRpbCcpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgSHR0cHNPY3NwQWdlbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7SHR0cHNPY3NwQWdlbnR9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSHR0cHNPY3NwQWdlbnQob3B0aW9ucykge1xuICBjb25zdCBhZ2VudCA9IEh0dHBzQWdlbnQuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgYWdlbnQuY3JlYXRlQ29ubmVjdGlvbiA9IGZ1bmN0aW9uIChwb3J0LCBob3N0LCBvcHRpb25zKSB7XG4gICAgLy8gbWFrZSBzdXJlIHRoZSAnb3B0aW9ucycgdmFyaWFibGVzIHJlZmVyZW5jZXMgdGhlIGFyZ3VtZW50IHRoYXQgYWN0dWFsbHlcbiAgICAvLyBjb250YWlucyB0aGUgb3B0aW9uc1xuICAgIC8vIE5vdGU6IGxvb2sgYXQgdGhlIE5vZGUuanMgaHR0cHMgYWdlbnQgdG8gdW5kZXJzdGFuZCB3aHkgdGhpcyBjb2RlIGlzXG4gICAgLy8gd3JpdHRlbiB0aGlzIHdheVxuICAgIGlmIChwb3J0ICE9PSBudWxsICYmIHR5cGVvZiBwb3J0ID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IHBvcnQ7XG4gICAgfSBlbHNlIGlmIChob3N0ICE9PSBudWxsICYmIHR5cGVvZiBob3N0ID09PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IGhvc3Q7XG4gICAgfSBlbHNlIGlmIChvcHRpb25zID09PSBudWxsIHx8IHR5cGVvZiBvcHRpb25zICE9PSAnb2JqZWN0Jykge1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgaG9zdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGhvc3QgPSBvcHRpb25zLmhvc3Q7XG4gICAgfVxuXG4gICAgLy8gY2FsbCBzdXBlclxuICAgIGNvbnN0IHNvY2tldCA9IEh0dHBzQWdlbnQucHJvdG90eXBlLmNyZWF0ZUNvbm5lY3Rpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIHNlY3VyZSB0aGUgc29ja2V0IGFuZCByZXR1cm4gaXRcbiAgICByZXR1cm4gU29ja2V0VXRpbC5zZWN1cmVTb2NrZXQoc29ja2V0LCBob3N0LCBudWxsKTtcbiAgfTtcblxuICByZXR1cm4gYWdlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSHR0cHNPY3NwQWdlbnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/agent/https_ocsp_agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/agent/https_proxy_agent.js":
/*!*******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/agent/https_proxy_agent.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const tls = __webpack_require__(/*! tls */ \"tls\");\nconst { HttpsProxyAgent } = __webpack_require__(/*! https-proxy-agent */ \"(rsc)/./node_modules/https-proxy-agent/dist/index.js\");\nconst SocketUtil = __webpack_require__(/*! ./socket_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/agent/socket_util.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\n\nmodule.exports = createHttpsProxyAgent;\n\nfunction createHttpsProxyAgent(opts) {\n  // HttpsProxyAgent >= 6.x takes two arguments for its constructor\n  // See: https://github.com/TooTallNate/proxy-agents/blob/main/packages/https-proxy-agent/CHANGELOG.md#600\n  const { host: hostname, port, user: username, password, protocol: rawProtocol, ...agentOptions } = opts;\n  const protocol = rawProtocol.endsWith(':') ? rawProtocol : `${rawProtocol}:`;\n  return new SnowflakeHttpsProxyAgent({ hostname, port, username, password, protocol }, agentOptions);\n}\n\nclass SnowflakeHttpsProxyAgent extends HttpsProxyAgent {\n  constructor(proxy, opts) {\n    super(proxy, opts);\n  }\n\n  async connect(req, opts) {\n    Logger.getInstance().debug('Using proxy=%s for host %s', this.proxy.hostname, opts.host);\n    const socket = await super.connect(req, opts);\n    if (socket instanceof tls.TLSSocket) {\n      SocketUtil.secureSocket(socket, opts.host, this);\n    }\n    return socket;\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYWdlbnQvaHR0cHNfcHJveHlfYWdlbnQuanMiLCJtYXBwaW5ncyI6IkFBQUEsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQywrRUFBbUI7QUFDdkQsbUJBQW1CLG1CQUFPLENBQUMsa0ZBQWU7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLG1FQUFXOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLHlGQUF5RjtBQUNuRyxnRUFBZ0UsWUFBWTtBQUM1RSx3Q0FBd0MsOENBQThDO0FBQ3RGOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9hZ2VudC9odHRwc19wcm94eV9hZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgSHR0cHNQcm94eUFnZW50IH0gPSByZXF1aXJlKCdodHRwcy1wcm94eS1hZ2VudCcpO1xuY29uc3QgU29ja2V0VXRpbCA9IHJlcXVpcmUoJy4vc29ja2V0X3V0aWwnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZUh0dHBzUHJveHlBZ2VudDtcblxuZnVuY3Rpb24gY3JlYXRlSHR0cHNQcm94eUFnZW50KG9wdHMpIHtcbiAgLy8gSHR0cHNQcm94eUFnZW50ID49IDYueCB0YWtlcyB0d28gYXJndW1lbnRzIGZvciBpdHMgY29uc3RydWN0b3JcbiAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vVG9vVGFsbE5hdGUvcHJveHktYWdlbnRzL2Jsb2IvbWFpbi9wYWNrYWdlcy9odHRwcy1wcm94eS1hZ2VudC9DSEFOR0VMT0cubWQjNjAwXG4gIGNvbnN0IHsgaG9zdDogaG9zdG5hbWUsIHBvcnQsIHVzZXI6IHVzZXJuYW1lLCBwYXNzd29yZCwgcHJvdG9jb2w6IHJhd1Byb3RvY29sLCAuLi5hZ2VudE9wdGlvbnMgfSA9IG9wdHM7XG4gIGNvbnN0IHByb3RvY29sID0gcmF3UHJvdG9jb2wuZW5kc1dpdGgoJzonKSA/IHJhd1Byb3RvY29sIDogYCR7cmF3UHJvdG9jb2x9OmA7XG4gIHJldHVybiBuZXcgU25vd2ZsYWtlSHR0cHNQcm94eUFnZW50KHsgaG9zdG5hbWUsIHBvcnQsIHVzZXJuYW1lLCBwYXNzd29yZCwgcHJvdG9jb2wgfSwgYWdlbnRPcHRpb25zKTtcbn1cblxuY2xhc3MgU25vd2ZsYWtlSHR0cHNQcm94eUFnZW50IGV4dGVuZHMgSHR0cHNQcm94eUFnZW50IHtcbiAgY29uc3RydWN0b3IocHJveHksIG9wdHMpIHtcbiAgICBzdXBlcihwcm94eSwgb3B0cyk7XG4gIH1cblxuICBhc3luYyBjb25uZWN0KHJlcSwgb3B0cykge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdVc2luZyBwcm94eT0lcyBmb3IgaG9zdCAlcycsIHRoaXMucHJveHkuaG9zdG5hbWUsIG9wdHMuaG9zdCk7XG4gICAgY29uc3Qgc29ja2V0ID0gYXdhaXQgc3VwZXIuY29ubmVjdChyZXEsIG9wdHMpO1xuICAgIGlmIChzb2NrZXQgaW5zdGFuY2VvZiB0bHMuVExTU29ja2V0KSB7XG4gICAgICBTb2NrZXRVdGlsLnNlY3VyZVNvY2tldChzb2NrZXQsIG9wdHMuaG9zdCwgdGhpcyk7XG4gICAgfVxuICAgIHJldHVybiBzb2NrZXQ7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/agent/https_proxy_agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/agent/ocsp_response_cache.js":
/*!*********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/agent/ocsp_response_cache.js ***!
  \*********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const http = __webpack_require__(/*! http */ \"http\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst util = __webpack_require__(/*! util */ \"util\");\n\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst SimpleCache = __webpack_require__(/*! simple-lru-cache */ \"(rsc)/./node_modules/simple-lru-cache/index.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst CertUtil = __webpack_require__(/*! ./cert_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/agent/cert_util.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/lib/global_config.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\n\nconst status = {\n  NOT_START: 'not_start',\n  STARTED: 'started',\n  FINISHED: 'finish',\n};\n\n// validate input\nconst sizeLimit = GlobalConfig.getOcspResponseCacheSizeLimit();\n// ocsp cache max age in second\nlet maxAgeSec = GlobalConfig.getOcspResponseCacheMaxAge();\n\nErrors.assertInternal(Util.number.isPositiveInteger(sizeLimit));\nErrors.assertInternal(Util.number.isPositiveInteger(maxAgeSec));\n\nconst cacheDir = GlobalConfig.mkdirCacheDir();\nconst cacheFileName = path.join(cacheDir, 'ocsp_response_cache.json');\n// create a cache to store the responses, dynamically changes in size\nlet cache;\n// JSON object with previous cache's responses\nlet prevCacheObj;\n// Cache updated time, in seconds, initialized as current time.\n// Will be updated when load from local cache file or refresh by downloading\nlet cacheUpdateTimeSec = Date.now() / 1000;\n\nfunction deleteCache() {\n  try {\n    cache.reset();\n    fs.unlinkSync(cacheFileName);\n  } catch (e) {\n    Logger.getInstance()\n      .debug('Failed to delete OCSP cache file: %s, err: %s', cacheFileName, e);\n  }\n}\n\nexports.deleteCache = deleteCache;\n\n/**\n * Cache for storing OCSP responses. This covers both client and server caches.\n *\n * @constructor\n */\nfunction OcspResponseCache() {\n  let downloadStatus = status.NOT_START;\n  let cacheUpdated = false;\n  let cacheInitialized = false;\n  let proxyAgent = null;\n\n  /**\n   * Reads OCSP cache file.\n   */\n  // Current time in second\n  const currentTimeSec = Date.now() / 1000;\n  cacheUpdateTimeSec = currentTimeSec;\n\n  let OCSP_URL = process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL;\n  if (!OCSP_URL) {\n    OCSP_URL = 'http://ocsp.snowflakecomputing.com/ocsp_response_cache.json';\n  }\n  try {\n    Logger.getInstance().debug('Reading OCSP cache file. %s', cacheFileName);\n    const contents = fs.readFileSync(cacheFileName, 'utf-8');\n    prevCacheObj = JSON.parse(contents);\n    cache = new SimpleCache({ maxSize: Object.keys(prevCacheObj).length });\n    setCacheEntries(prevCacheObj);\n    cacheInitialized = true;\n  } catch (e) {\n    Logger.getInstance().debug('Failed to read OCSP cache file: %s, err: %s', cacheFileName, e);\n  }\n\n  /**\n   * set proxy agent for ocsp validation\n   *\n   * @param agent\n   */\n  this.setAgent = function setAgent(agent) {\n    proxyAgent = agent;\n  };\n\n  /**\n   * Initializes the cache\n   * \n   * @param cert \n   * @param response \n   */\n  this.initCache = function initCache(cert, response) {\n    cache = new SimpleCache({ maxSize: 1 });\n    this.set(cert, response);\n  };\n\n  /**\n   * Is OCSP Cache initialized?\n   * @returns {boolean}\n   */\n  this.isInitialized = function () {\n    return cacheInitialized;\n  };\n\n  /**\n   * Is OCSP Cache download finished?\n   * @returns {boolean}\n   */\n  this.isDownloadFinished = function () {\n    return downloadStatus === status.FINISHED;\n  };\n\n  /**\n   * Forces download status to finish\n   */\n  this.forceDownloadToFinish = function () {\n    downloadStatus = status.FINISHED;\n  };\n\n  /**\n   * Is local OCSP Cache expired?\n   * @returns {boolean}\n   */\n  this.IsCacheExpired = function () {\n    if (!cacheInitialized) {\n      return false;\n    }\n\n    // Update maxAge in case it could be changed through environment variable\n    maxAgeSec = GlobalConfig.getOcspResponseCacheMaxAge();\n\n    // Current time in seconds\n    const currentTimeSec = Date.now() / 1000;\n\n    if ((currentTimeSec - cacheUpdateTimeSec) > maxAgeSec) {\n      Logger.getInstance().debug(\n        'OCSP local cache validity is out of range. currentTime: %s, timestamp: %s, maxAge: %s',\n        currentTimeSec, cacheUpdateTimeSec, maxAgeSec);\n      return true;\n    }\n\n    return false;\n  };\n\n  /**\n   * Resets OCSP Cache status\n   */\n  this.resetCacheStatus = function () {\n    downloadStatus = status.NOT_START;\n    if (cacheUpdated) {\n      Logger.getInstance().debug(cacheFileName);\n\n      // current time in second\n      const currentTimeSec = Date.now() / 1000;\n      const cacheOutput = {};\n      cache.forEach(function (v, k) {\n        const certIdInBase64 = CertUtil.decodeKey(k);\n        const ocspResponseInBase64 = v.toString('BASE64');\n        cacheOutput[certIdInBase64] = [currentTimeSec, ocspResponseInBase64];\n      });\n      const writeContent = JSON.stringify(cacheOutput);\n      Logger.getInstance().debug('Writing OCSP cache file. %s', cacheFileName);\n      try {\n        fs.writeFileSync(cacheFileName, writeContent, 'utf-8');\n      } catch (e) {\n        Logger.getInstance().debug('Failed to update OCSP cache file: %s, err: %s', cacheFileName, e);\n      }\n      cacheUpdated = false;\n    }\n  };\n\n  /**\n   * Adds an entry to the cache.\n   *\n   * @param cert\n   * @param response\n   */\n  this.set = function set(cert, response) {\n    try {\n      const certId = CertUtil.buildCertId(cert);\n      cache.set(certId, response);\n      cacheUpdated = true;\n    } catch (e) {\n      Logger.getInstance().debug('Failed to add certificate to OCSP cache file. err: %s', e);\n    }\n  };\n\n  /**\n   * Returns an entry from the cache.\n   *\n   * @param cert\n   * @returns {*}\n   */\n  this.get = function get(cert) {\n    try {\n      const certId = CertUtil.buildCertId(cert);\n      return cache.get(certId);\n    } catch (e) {\n      Logger.getInstance().debug('Failed to get certificate from OCSP cache. err: %s', e);\n      return null;\n    }\n  };\n\n  /**\n   * Downloads OCSP cache from the Snowflake OCSP cache server.\n   * @param cb callback\n   */\n  this.downloadCache = function (cb) {\n    if (downloadStatus === status.STARTED) {\n      // reschedule calling cb\n      return false;\n    } else if (downloadStatus === status.FINISHED) {\n      // call cb immediately\n      cb(null, false);\n      return true;\n    }\n    downloadStatus = status.STARTED;\n\n    function checkOCSPResponse(err, cacheContent) {\n      if (downloadStatus === status.FINISHED) {\n        return;\n      }\n      downloadStatus = status.FINISHED;\n      Logger.getInstance().debug('Finish OCSP Cache Server: %s', OCSP_URL);\n      if (err) {\n        Logger.getInstance()\n          .debug('Failed to download OCSP cache file. %s. Ignored', err);\n        return cb(err, false);\n      }\n      try {\n        const jsonParsed = JSON.parse(cacheContent);\n        updateCache(jsonParsed);\n        cacheUpdated = true;\n        return cb(null, false);\n      } catch (e) {\n        cb(e, false);\n      }\n    }\n\n    function onResponse(response) {\n      if (response.statusCode < 200 || response.statusCode >= 400) {\n        return checkOCSPResponse(\n          new Error('Failed to obtain OCSP response: ' +\n            response.statusCode), null);\n      }\n\n      let rawData = '';\n\n      // A chunk of data has been received.\n      response.on('data', function (chunk) {\n        rawData += chunk;\n      });\n\n      // The whole response has been received. Print out the result.\n      response.on('end', function () {\n        checkOCSPResponse(null, rawData);\n      });\n    }\n\n    const uri = url.parse(OCSP_URL);\n    const timeout = process.env.SF_OCSP_TEST_OCSP_RESPONSE_CACHE_SERVER_TIMEOUT || 5000;\n    const options = util._extend({\n      timeout: Number(timeout),\n      method: 'GET',\n      agent: proxyAgent,\n    }, uri);\n    const httpRequest = http.request(options, onResponse);\n    httpRequest.on('error', function (e) {\n      downloadStatus = status.FINISHED;\n      if (cb) {\n        cb(e, false);\n      }\n      cb = null;\n    });\n    httpRequest.on('timeout', function () {\n      downloadStatus = status.FINISHED;\n      httpRequest.abort();\n      Logger.getInstance().debug('Timeout OCSP responder: %s, %ss', OCSP_URL, options.timeout);\n      if (cb) {\n        cb(Errors.createOCSPError(ErrorCodes.ERR_OCSP_CACHE_SERVER_TIMEOUT), false);\n      }\n      cb = null;\n    });\n    httpRequest.end();\n    Logger.getInstance().trace('Contact OCSP Cache Server: %s', OCSP_URL);\n\n    return true;\n  };\n\n  /**\n   * Validate cache entry\n   * @param certIdBase64 cache key\n   * @param ocspResponseBase64 cache value\n   * @returns {Object}\n   */\n  function validateCacheEntry(certIdBase64, ocspResponseBase64) {\n    let err;\n    if (ocspResponseBase64.length !== 2) {\n      Logger.getInstance()\n        .debug('OCSP cache value doesn\\'t consist of two elements. Ignored.');\n      err = Errors.createOCSPError(ErrorCodes.ERR_OCSP_NOT_TWO_ELEMENTS);\n    }\n    if ((currentTimeSec - ocspResponseBase64[0]) > maxAgeSec) {\n      Logger.getInstance().debug(\n        'OCSP cache validity is out of range. currentTime: %s, timestamp: %s, maxAge: %s',\n        currentTimeSec, ocspResponseBase64[0], maxAgeSec);\n      err = Errors.createOCSPError(ErrorCodes.ERR_OCSP_CACHE_EXPIRED);\n    }\n    try {\n      const k = CertUtil.encodeKey(certIdBase64);\n      if (err) {\n        return { err: err, key: k };\n      }\n      const rawOCSPResponse = Buffer.from(ocspResponseBase64[1], 'base64');\n      const status = CertUtil.verifyOCSPResponse(null, rawOCSPResponse);\n      if (!status.err) {\n        return { err: null, key: k, value: rawOCSPResponse };\n      }\n      return { err: status.err };\n    } catch (e) {\n      Logger.getInstance()\n        .debug('Failed to parse OCSP response. %s. Ignored.', e);\n      return { err: Errors.createOCSPError(ErrorCodes.ERR_OCSP_FAILED_PARSE_RESPONSE) };\n    }\n  }\n\n  function updateCache(jsonObject) {\n    // Get the size of cache retrieved from the cache server\n    const responseCacheSize = Object.keys(jsonObject).length;\n\n    // Check if there are previous entries to append\n    if (prevCacheObj) {\n      // Count overlap between previous cache and response cache\n      // And delete entry if expired\n      let cacheOverlapCount = 0;\n      for (const entry in jsonObject) {\n        if (entryExists(prevCacheObj, entry)) {\n          cacheOverlapCount++;\n          updateOrDeleteEntry(prevCacheObj, entry);\n        }\n      }\n\n      // Count entries from previous cache\n      const prevCacheSize = Object.keys(prevCacheObj).length;\n\n      // New cache size = previous cache size + response cache size - overlap between the two caches\n      const newCacheSize = prevCacheSize + responseCacheSize - cacheOverlapCount;\n\n      // Create cache using new cache size if it doesn't exceed the upper limit\n      cache = new SimpleCache({ maxSize: newCacheSize < sizeLimit ? newCacheSize : sizeLimit });\n\n      // Add new entries\n      setCacheEntries(jsonObject);\n\n      // Append older unique entries to cache\n      setCacheEntries(prevCacheObj);\n    } else {\n      // Create cache using response cache size if it doesn't exceed the upper limit\n      cache = new SimpleCache({ maxSize: responseCacheSize < sizeLimit ? responseCacheSize : sizeLimit });\n\n      // Add new entries\n      setCacheEntries(jsonObject);\n    }\n    // set cache update time\n    cacheUpdateTimeSec = Date.now() / 1000;\n    cacheInitialized = true;\n  }\n\n  function setCacheEntries(jsonObject) {\n    for (const entry in jsonObject) {\n      if (Object.prototype.hasOwnProperty.call(jsonObject, entry)) {\n        updateOrDeleteEntry(jsonObject, entry);\n      }\n    }\n  }\n\n  function updateOrDeleteEntry(jsonObject, entry) {\n    const status = validateCacheEntry(entry, jsonObject[entry]);\n    if (!status.err) {\n      // Add new entry or update existing one\n      cache.set(status.key, status.value);\n      // change cache update time if needed\n      if (jsonObject[entry][0] < cacheUpdateTimeSec) {\n        cacheUpdateTimeSec = jsonObject[entry][0];\n      }\n    } else if (status.err.code === ErrorCodes.ERR_OCSP_CACHE_EXPIRED) {\n      // If timestamp expired, delete entry\n      cache.del(status.key);\n    }\n  }\n\n  function entryExists(jsonObject, entry) {\n    for (const otherEntry in jsonObject) {\n      if (entry === otherEntry) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nexports.OcspResponseCache = OcspResponseCache;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYWdlbnQvb2NzcF9yZXNwb25zZV9jYWNoZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0IsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLG9CQUFvQixtQkFBTyxDQUFDLHdFQUFrQjtBQUM5QyxlQUFlLG1CQUFPLENBQUMsbUVBQVc7QUFDbEM7QUFDQSxhQUFhLG1CQUFPLENBQUMsK0RBQVM7QUFDOUIsaUJBQWlCLG1CQUFPLENBQUMsOEVBQWE7QUFDdEMscUJBQXFCLG1CQUFPLENBQUMsaUZBQWtCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLDJDQUEyQztBQUN6RTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLGVBQWU7QUFDZixNQUFNO0FBQ047QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyw4REFBOEQ7O0FBRTlGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLGdDQUFnQyx3RUFBd0U7O0FBRXhHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2FnZW50L29jc3BfcmVzcG9uc2VfY2FjaGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IFNpbXBsZUNhY2hlID0gcmVxdWlyZSgnc2ltcGxlLWxydS1jYWNoZScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBFcnJvckNvZGVzID0gRXJyb3JzLmNvZGVzO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IENlcnRVdGlsID0gcmVxdWlyZSgnLi9jZXJ0X3V0aWwnKTtcbmNvbnN0IEdsb2JhbENvbmZpZyA9IHJlcXVpcmUoJy4uL2dsb2JhbF9jb25maWcnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuXG5jb25zdCBzdGF0dXMgPSB7XG4gIE5PVF9TVEFSVDogJ25vdF9zdGFydCcsXG4gIFNUQVJURUQ6ICdzdGFydGVkJyxcbiAgRklOSVNIRUQ6ICdmaW5pc2gnLFxufTtcblxuLy8gdmFsaWRhdGUgaW5wdXRcbmNvbnN0IHNpemVMaW1pdCA9IEdsb2JhbENvbmZpZy5nZXRPY3NwUmVzcG9uc2VDYWNoZVNpemVMaW1pdCgpO1xuLy8gb2NzcCBjYWNoZSBtYXggYWdlIGluIHNlY29uZFxubGV0IG1heEFnZVNlYyA9IEdsb2JhbENvbmZpZy5nZXRPY3NwUmVzcG9uc2VDYWNoZU1heEFnZSgpO1xuXG5FcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5udW1iZXIuaXNQb3NpdGl2ZUludGVnZXIoc2l6ZUxpbWl0KSk7XG5FcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5udW1iZXIuaXNQb3NpdGl2ZUludGVnZXIobWF4QWdlU2VjKSk7XG5cbmNvbnN0IGNhY2hlRGlyID0gR2xvYmFsQ29uZmlnLm1rZGlyQ2FjaGVEaXIoKTtcbmNvbnN0IGNhY2hlRmlsZU5hbWUgPSBwYXRoLmpvaW4oY2FjaGVEaXIsICdvY3NwX3Jlc3BvbnNlX2NhY2hlLmpzb24nKTtcbi8vIGNyZWF0ZSBhIGNhY2hlIHRvIHN0b3JlIHRoZSByZXNwb25zZXMsIGR5bmFtaWNhbGx5IGNoYW5nZXMgaW4gc2l6ZVxubGV0IGNhY2hlO1xuLy8gSlNPTiBvYmplY3Qgd2l0aCBwcmV2aW91cyBjYWNoZSdzIHJlc3BvbnNlc1xubGV0IHByZXZDYWNoZU9iajtcbi8vIENhY2hlIHVwZGF0ZWQgdGltZSwgaW4gc2Vjb25kcywgaW5pdGlhbGl6ZWQgYXMgY3VycmVudCB0aW1lLlxuLy8gV2lsbCBiZSB1cGRhdGVkIHdoZW4gbG9hZCBmcm9tIGxvY2FsIGNhY2hlIGZpbGUgb3IgcmVmcmVzaCBieSBkb3dubG9hZGluZ1xubGV0IGNhY2hlVXBkYXRlVGltZVNlYyA9IERhdGUubm93KCkgLyAxMDAwO1xuXG5mdW5jdGlvbiBkZWxldGVDYWNoZSgpIHtcbiAgdHJ5IHtcbiAgICBjYWNoZS5yZXNldCgpO1xuICAgIGZzLnVubGlua1N5bmMoY2FjaGVGaWxlTmFtZSk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKVxuICAgICAgLmRlYnVnKCdGYWlsZWQgdG8gZGVsZXRlIE9DU1AgY2FjaGUgZmlsZTogJXMsIGVycjogJXMnLCBjYWNoZUZpbGVOYW1lLCBlKTtcbiAgfVxufVxuXG5leHBvcnRzLmRlbGV0ZUNhY2hlID0gZGVsZXRlQ2FjaGU7XG5cbi8qKlxuICogQ2FjaGUgZm9yIHN0b3JpbmcgT0NTUCByZXNwb25zZXMuIFRoaXMgY292ZXJzIGJvdGggY2xpZW50IGFuZCBzZXJ2ZXIgY2FjaGVzLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBPY3NwUmVzcG9uc2VDYWNoZSgpIHtcbiAgbGV0IGRvd25sb2FkU3RhdHVzID0gc3RhdHVzLk5PVF9TVEFSVDtcbiAgbGV0IGNhY2hlVXBkYXRlZCA9IGZhbHNlO1xuICBsZXQgY2FjaGVJbml0aWFsaXplZCA9IGZhbHNlO1xuICBsZXQgcHJveHlBZ2VudCA9IG51bGw7XG5cbiAgLyoqXG4gICAqIFJlYWRzIE9DU1AgY2FjaGUgZmlsZS5cbiAgICovXG4gIC8vIEN1cnJlbnQgdGltZSBpbiBzZWNvbmRcbiAgY29uc3QgY3VycmVudFRpbWVTZWMgPSBEYXRlLm5vdygpIC8gMTAwMDtcbiAgY2FjaGVVcGRhdGVUaW1lU2VjID0gY3VycmVudFRpbWVTZWM7XG5cbiAgbGV0IE9DU1BfVVJMID0gcHJvY2Vzcy5lbnYuU0ZfT0NTUF9SRVNQT05TRV9DQUNIRV9TRVJWRVJfVVJMO1xuICBpZiAoIU9DU1BfVVJMKSB7XG4gICAgT0NTUF9VUkwgPSAnaHR0cDovL29jc3Auc25vd2ZsYWtlY29tcHV0aW5nLmNvbS9vY3NwX3Jlc3BvbnNlX2NhY2hlLmpzb24nO1xuICB9XG4gIHRyeSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1JlYWRpbmcgT0NTUCBjYWNoZSBmaWxlLiAlcycsIGNhY2hlRmlsZU5hbWUpO1xuICAgIGNvbnN0IGNvbnRlbnRzID0gZnMucmVhZEZpbGVTeW5jKGNhY2hlRmlsZU5hbWUsICd1dGYtOCcpO1xuICAgIHByZXZDYWNoZU9iaiA9IEpTT04ucGFyc2UoY29udGVudHMpO1xuICAgIGNhY2hlID0gbmV3IFNpbXBsZUNhY2hlKHsgbWF4U2l6ZTogT2JqZWN0LmtleXMocHJldkNhY2hlT2JqKS5sZW5ndGggfSk7XG4gICAgc2V0Q2FjaGVFbnRyaWVzKHByZXZDYWNoZU9iaik7XG4gICAgY2FjaGVJbml0aWFsaXplZCA9IHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnRmFpbGVkIHRvIHJlYWQgT0NTUCBjYWNoZSBmaWxlOiAlcywgZXJyOiAlcycsIGNhY2hlRmlsZU5hbWUsIGUpO1xuICB9XG5cbiAgLyoqXG4gICAqIHNldCBwcm94eSBhZ2VudCBmb3Igb2NzcCB2YWxpZGF0aW9uXG4gICAqXG4gICAqIEBwYXJhbSBhZ2VudFxuICAgKi9cbiAgdGhpcy5zZXRBZ2VudCA9IGZ1bmN0aW9uIHNldEFnZW50KGFnZW50KSB7XG4gICAgcHJveHlBZ2VudCA9IGFnZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyB0aGUgY2FjaGVcbiAgICogXG4gICAqIEBwYXJhbSBjZXJ0IFxuICAgKiBAcGFyYW0gcmVzcG9uc2UgXG4gICAqL1xuICB0aGlzLmluaXRDYWNoZSA9IGZ1bmN0aW9uIGluaXRDYWNoZShjZXJ0LCByZXNwb25zZSkge1xuICAgIGNhY2hlID0gbmV3IFNpbXBsZUNhY2hlKHsgbWF4U2l6ZTogMSB9KTtcbiAgICB0aGlzLnNldChjZXJ0LCByZXNwb25zZSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIE9DU1AgQ2FjaGUgaW5pdGlhbGl6ZWQ/XG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgdGhpcy5pc0luaXRpYWxpemVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjYWNoZUluaXRpYWxpemVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJcyBPQ1NQIENhY2hlIGRvd25sb2FkIGZpbmlzaGVkP1xuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuaXNEb3dubG9hZEZpbmlzaGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkb3dubG9hZFN0YXR1cyA9PT0gc3RhdHVzLkZJTklTSEVEO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGb3JjZXMgZG93bmxvYWQgc3RhdHVzIHRvIGZpbmlzaFxuICAgKi9cbiAgdGhpcy5mb3JjZURvd25sb2FkVG9GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgZG93bmxvYWRTdGF0dXMgPSBzdGF0dXMuRklOSVNIRUQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIElzIGxvY2FsIE9DU1AgQ2FjaGUgZXhwaXJlZD9cbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLklzQ2FjaGVFeHBpcmVkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FjaGVJbml0aWFsaXplZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8vIFVwZGF0ZSBtYXhBZ2UgaW4gY2FzZSBpdCBjb3VsZCBiZSBjaGFuZ2VkIHRocm91Z2ggZW52aXJvbm1lbnQgdmFyaWFibGVcbiAgICBtYXhBZ2VTZWMgPSBHbG9iYWxDb25maWcuZ2V0T2NzcFJlc3BvbnNlQ2FjaGVNYXhBZ2UoKTtcblxuICAgIC8vIEN1cnJlbnQgdGltZSBpbiBzZWNvbmRzXG4gICAgY29uc3QgY3VycmVudFRpbWVTZWMgPSBEYXRlLm5vdygpIC8gMTAwMDtcblxuICAgIGlmICgoY3VycmVudFRpbWVTZWMgLSBjYWNoZVVwZGF0ZVRpbWVTZWMpID4gbWF4QWdlU2VjKSB7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhcbiAgICAgICAgJ09DU1AgbG9jYWwgY2FjaGUgdmFsaWRpdHkgaXMgb3V0IG9mIHJhbmdlLiBjdXJyZW50VGltZTogJXMsIHRpbWVzdGFtcDogJXMsIG1heEFnZTogJXMnLFxuICAgICAgICBjdXJyZW50VGltZVNlYywgY2FjaGVVcGRhdGVUaW1lU2VjLCBtYXhBZ2VTZWMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXNldHMgT0NTUCBDYWNoZSBzdGF0dXNcbiAgICovXG4gIHRoaXMucmVzZXRDYWNoZVN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICBkb3dubG9hZFN0YXR1cyA9IHN0YXR1cy5OT1RfU1RBUlQ7XG4gICAgaWYgKGNhY2hlVXBkYXRlZCkge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoY2FjaGVGaWxlTmFtZSk7XG5cbiAgICAgIC8vIGN1cnJlbnQgdGltZSBpbiBzZWNvbmRcbiAgICAgIGNvbnN0IGN1cnJlbnRUaW1lU2VjID0gRGF0ZS5ub3coKSAvIDEwMDA7XG4gICAgICBjb25zdCBjYWNoZU91dHB1dCA9IHt9O1xuICAgICAgY2FjaGUuZm9yRWFjaChmdW5jdGlvbiAodiwgaykge1xuICAgICAgICBjb25zdCBjZXJ0SWRJbkJhc2U2NCA9IENlcnRVdGlsLmRlY29kZUtleShrKTtcbiAgICAgICAgY29uc3Qgb2NzcFJlc3BvbnNlSW5CYXNlNjQgPSB2LnRvU3RyaW5nKCdCQVNFNjQnKTtcbiAgICAgICAgY2FjaGVPdXRwdXRbY2VydElkSW5CYXNlNjRdID0gW2N1cnJlbnRUaW1lU2VjLCBvY3NwUmVzcG9uc2VJbkJhc2U2NF07XG4gICAgICB9KTtcbiAgICAgIGNvbnN0IHdyaXRlQ29udGVudCA9IEpTT04uc3RyaW5naWZ5KGNhY2hlT3V0cHV0KTtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdXcml0aW5nIE9DU1AgY2FjaGUgZmlsZS4gJXMnLCBjYWNoZUZpbGVOYW1lKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZzLndyaXRlRmlsZVN5bmMoY2FjaGVGaWxlTmFtZSwgd3JpdGVDb250ZW50LCAndXRmLTgnKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0ZhaWxlZCB0byB1cGRhdGUgT0NTUCBjYWNoZSBmaWxlOiAlcywgZXJyOiAlcycsIGNhY2hlRmlsZU5hbWUsIGUpO1xuICAgICAgfVxuICAgICAgY2FjaGVVcGRhdGVkID0gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBBZGRzIGFuIGVudHJ5IHRvIHRoZSBjYWNoZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnRcbiAgICogQHBhcmFtIHJlc3BvbnNlXG4gICAqL1xuICB0aGlzLnNldCA9IGZ1bmN0aW9uIHNldChjZXJ0LCByZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjZXJ0SWQgPSBDZXJ0VXRpbC5idWlsZENlcnRJZChjZXJ0KTtcbiAgICAgIGNhY2hlLnNldChjZXJ0SWQsIHJlc3BvbnNlKTtcbiAgICAgIGNhY2hlVXBkYXRlZCA9IHRydWU7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0ZhaWxlZCB0byBhZGQgY2VydGlmaWNhdGUgdG8gT0NTUCBjYWNoZSBmaWxlLiBlcnI6ICVzJywgZSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIGVudHJ5IGZyb20gdGhlIGNhY2hlLlxuICAgKlxuICAgKiBAcGFyYW0gY2VydFxuICAgKiBAcmV0dXJucyB7Kn1cbiAgICovXG4gIHRoaXMuZ2V0ID0gZnVuY3Rpb24gZ2V0KGNlcnQpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY2VydElkID0gQ2VydFV0aWwuYnVpbGRDZXJ0SWQoY2VydCk7XG4gICAgICByZXR1cm4gY2FjaGUuZ2V0KGNlcnRJZCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0ZhaWxlZCB0byBnZXQgY2VydGlmaWNhdGUgZnJvbSBPQ1NQIGNhY2hlLiBlcnI6ICVzJywgZSk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIERvd25sb2FkcyBPQ1NQIGNhY2hlIGZyb20gdGhlIFNub3dmbGFrZSBPQ1NQIGNhY2hlIHNlcnZlci5cbiAgICogQHBhcmFtIGNiIGNhbGxiYWNrXG4gICAqL1xuICB0aGlzLmRvd25sb2FkQ2FjaGUgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICBpZiAoZG93bmxvYWRTdGF0dXMgPT09IHN0YXR1cy5TVEFSVEVEKSB7XG4gICAgICAvLyByZXNjaGVkdWxlIGNhbGxpbmcgY2JcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGRvd25sb2FkU3RhdHVzID09PSBzdGF0dXMuRklOSVNIRUQpIHtcbiAgICAgIC8vIGNhbGwgY2IgaW1tZWRpYXRlbHlcbiAgICAgIGNiKG51bGwsIGZhbHNlKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBkb3dubG9hZFN0YXR1cyA9IHN0YXR1cy5TVEFSVEVEO1xuXG4gICAgZnVuY3Rpb24gY2hlY2tPQ1NQUmVzcG9uc2UoZXJyLCBjYWNoZUNvbnRlbnQpIHtcbiAgICAgIGlmIChkb3dubG9hZFN0YXR1cyA9PT0gc3RhdHVzLkZJTklTSEVEKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGRvd25sb2FkU3RhdHVzID0gc3RhdHVzLkZJTklTSEVEO1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0ZpbmlzaCBPQ1NQIENhY2hlIFNlcnZlcjogJXMnLCBPQ1NQX1VSTCk7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpXG4gICAgICAgICAgLmRlYnVnKCdGYWlsZWQgdG8gZG93bmxvYWQgT0NTUCBjYWNoZSBmaWxlLiAlcy4gSWdub3JlZCcsIGVycik7XG4gICAgICAgIHJldHVybiBjYihlcnIsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGpzb25QYXJzZWQgPSBKU09OLnBhcnNlKGNhY2hlQ29udGVudCk7XG4gICAgICAgIHVwZGF0ZUNhY2hlKGpzb25QYXJzZWQpO1xuICAgICAgICBjYWNoZVVwZGF0ZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm4gY2IobnVsbCwgZmFsc2UpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYihlLCBmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gb25SZXNwb25zZShyZXNwb25zZSkge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPCAyMDAgfHwgcmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA0MDApIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrT0NTUFJlc3BvbnNlKFxuICAgICAgICAgIG5ldyBFcnJvcignRmFpbGVkIHRvIG9idGFpbiBPQ1NQIHJlc3BvbnNlOiAnICtcbiAgICAgICAgICAgIHJlc3BvbnNlLnN0YXR1c0NvZGUpLCBudWxsKTtcbiAgICAgIH1cblxuICAgICAgbGV0IHJhd0RhdGEgPSAnJztcblxuICAgICAgLy8gQSBjaHVuayBvZiBkYXRhIGhhcyBiZWVuIHJlY2VpdmVkLlxuICAgICAgcmVzcG9uc2Uub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgcmF3RGF0YSArPSBjaHVuaztcbiAgICAgIH0pO1xuXG4gICAgICAvLyBUaGUgd2hvbGUgcmVzcG9uc2UgaGFzIGJlZW4gcmVjZWl2ZWQuIFByaW50IG91dCB0aGUgcmVzdWx0LlxuICAgICAgcmVzcG9uc2Uub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2hlY2tPQ1NQUmVzcG9uc2UobnVsbCwgcmF3RGF0YSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCB1cmkgPSB1cmwucGFyc2UoT0NTUF9VUkwpO1xuICAgIGNvbnN0IHRpbWVvdXQgPSBwcm9jZXNzLmVudi5TRl9PQ1NQX1RFU1RfT0NTUF9SRVNQT05TRV9DQUNIRV9TRVJWRVJfVElNRU9VVCB8fCA1MDAwO1xuICAgIGNvbnN0IG9wdGlvbnMgPSB1dGlsLl9leHRlbmQoe1xuICAgICAgdGltZW91dDogTnVtYmVyKHRpbWVvdXQpLFxuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGFnZW50OiBwcm94eUFnZW50LFxuICAgIH0sIHVyaSk7XG4gICAgY29uc3QgaHR0cFJlcXVlc3QgPSBodHRwLnJlcXVlc3Qob3B0aW9ucywgb25SZXNwb25zZSk7XG4gICAgaHR0cFJlcXVlc3Qub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgIGRvd25sb2FkU3RhdHVzID0gc3RhdHVzLkZJTklTSEVEO1xuICAgICAgaWYgKGNiKSB7XG4gICAgICAgIGNiKGUsIGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGNiID0gbnVsbDtcbiAgICB9KTtcbiAgICBodHRwUmVxdWVzdC5vbigndGltZW91dCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGRvd25sb2FkU3RhdHVzID0gc3RhdHVzLkZJTklTSEVEO1xuICAgICAgaHR0cFJlcXVlc3QuYWJvcnQoKTtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdUaW1lb3V0IE9DU1AgcmVzcG9uZGVyOiAlcywgJXNzJywgT0NTUF9VUkwsIG9wdGlvbnMudGltZW91dCk7XG4gICAgICBpZiAoY2IpIHtcbiAgICAgICAgY2IoRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX0NBQ0hFX1NFUlZFUl9USU1FT1VUKSwgZmFsc2UpO1xuICAgICAgfVxuICAgICAgY2IgPSBudWxsO1xuICAgIH0pO1xuICAgIGh0dHBSZXF1ZXN0LmVuZCgpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb250YWN0IE9DU1AgQ2FjaGUgU2VydmVyOiAlcycsIE9DU1BfVVJMKTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZSBjYWNoZSBlbnRyeVxuICAgKiBAcGFyYW0gY2VydElkQmFzZTY0IGNhY2hlIGtleVxuICAgKiBAcGFyYW0gb2NzcFJlc3BvbnNlQmFzZTY0IGNhY2hlIHZhbHVlXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBmdW5jdGlvbiB2YWxpZGF0ZUNhY2hlRW50cnkoY2VydElkQmFzZTY0LCBvY3NwUmVzcG9uc2VCYXNlNjQpIHtcbiAgICBsZXQgZXJyO1xuICAgIGlmIChvY3NwUmVzcG9uc2VCYXNlNjQubGVuZ3RoICE9PSAyKSB7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKVxuICAgICAgICAuZGVidWcoJ09DU1AgY2FjaGUgdmFsdWUgZG9lc25cXCd0IGNvbnNpc3Qgb2YgdHdvIGVsZW1lbnRzLiBJZ25vcmVkLicpO1xuICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZU9DU1BFcnJvcihFcnJvckNvZGVzLkVSUl9PQ1NQX05PVF9UV09fRUxFTUVOVFMpO1xuICAgIH1cbiAgICBpZiAoKGN1cnJlbnRUaW1lU2VjIC0gb2NzcFJlc3BvbnNlQmFzZTY0WzBdKSA+IG1heEFnZVNlYykge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoXG4gICAgICAgICdPQ1NQIGNhY2hlIHZhbGlkaXR5IGlzIG91dCBvZiByYW5nZS4gY3VycmVudFRpbWU6ICVzLCB0aW1lc3RhbXA6ICVzLCBtYXhBZ2U6ICVzJyxcbiAgICAgICAgY3VycmVudFRpbWVTZWMsIG9jc3BSZXNwb25zZUJhc2U2NFswXSwgbWF4QWdlU2VjKTtcbiAgICAgIGVyciA9IEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9DQUNIRV9FWFBJUkVEKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IGsgPSBDZXJ0VXRpbC5lbmNvZGVLZXkoY2VydElkQmFzZTY0KTtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIHsgZXJyOiBlcnIsIGtleTogayB9O1xuICAgICAgfVxuICAgICAgY29uc3QgcmF3T0NTUFJlc3BvbnNlID0gQnVmZmVyLmZyb20ob2NzcFJlc3BvbnNlQmFzZTY0WzFdLCAnYmFzZTY0Jyk7XG4gICAgICBjb25zdCBzdGF0dXMgPSBDZXJ0VXRpbC52ZXJpZnlPQ1NQUmVzcG9uc2UobnVsbCwgcmF3T0NTUFJlc3BvbnNlKTtcbiAgICAgIGlmICghc3RhdHVzLmVycikge1xuICAgICAgICByZXR1cm4geyBlcnI6IG51bGwsIGtleTogaywgdmFsdWU6IHJhd09DU1BSZXNwb25zZSB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZXJyOiBzdGF0dXMuZXJyIH07XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKClcbiAgICAgICAgLmRlYnVnKCdGYWlsZWQgdG8gcGFyc2UgT0NTUCByZXNwb25zZS4gJXMuIElnbm9yZWQuJywgZSk7XG4gICAgICByZXR1cm4geyBlcnI6IEVycm9ycy5jcmVhdGVPQ1NQRXJyb3IoRXJyb3JDb2Rlcy5FUlJfT0NTUF9GQUlMRURfUEFSU0VfUkVTUE9OU0UpIH07XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2FjaGUoanNvbk9iamVjdCkge1xuICAgIC8vIEdldCB0aGUgc2l6ZSBvZiBjYWNoZSByZXRyaWV2ZWQgZnJvbSB0aGUgY2FjaGUgc2VydmVyXG4gICAgY29uc3QgcmVzcG9uc2VDYWNoZVNpemUgPSBPYmplY3Qua2V5cyhqc29uT2JqZWN0KS5sZW5ndGg7XG5cbiAgICAvLyBDaGVjayBpZiB0aGVyZSBhcmUgcHJldmlvdXMgZW50cmllcyB0byBhcHBlbmRcbiAgICBpZiAocHJldkNhY2hlT2JqKSB7XG4gICAgICAvLyBDb3VudCBvdmVybGFwIGJldHdlZW4gcHJldmlvdXMgY2FjaGUgYW5kIHJlc3BvbnNlIGNhY2hlXG4gICAgICAvLyBBbmQgZGVsZXRlIGVudHJ5IGlmIGV4cGlyZWRcbiAgICAgIGxldCBjYWNoZU92ZXJsYXBDb3VudCA9IDA7XG4gICAgICBmb3IgKGNvbnN0IGVudHJ5IGluIGpzb25PYmplY3QpIHtcbiAgICAgICAgaWYgKGVudHJ5RXhpc3RzKHByZXZDYWNoZU9iaiwgZW50cnkpKSB7XG4gICAgICAgICAgY2FjaGVPdmVybGFwQ291bnQrKztcbiAgICAgICAgICB1cGRhdGVPckRlbGV0ZUVudHJ5KHByZXZDYWNoZU9iaiwgZW50cnkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENvdW50IGVudHJpZXMgZnJvbSBwcmV2aW91cyBjYWNoZVxuICAgICAgY29uc3QgcHJldkNhY2hlU2l6ZSA9IE9iamVjdC5rZXlzKHByZXZDYWNoZU9iaikubGVuZ3RoO1xuXG4gICAgICAvLyBOZXcgY2FjaGUgc2l6ZSA9IHByZXZpb3VzIGNhY2hlIHNpemUgKyByZXNwb25zZSBjYWNoZSBzaXplIC0gb3ZlcmxhcCBiZXR3ZWVuIHRoZSB0d28gY2FjaGVzXG4gICAgICBjb25zdCBuZXdDYWNoZVNpemUgPSBwcmV2Q2FjaGVTaXplICsgcmVzcG9uc2VDYWNoZVNpemUgLSBjYWNoZU92ZXJsYXBDb3VudDtcblxuICAgICAgLy8gQ3JlYXRlIGNhY2hlIHVzaW5nIG5ldyBjYWNoZSBzaXplIGlmIGl0IGRvZXNuJ3QgZXhjZWVkIHRoZSB1cHBlciBsaW1pdFxuICAgICAgY2FjaGUgPSBuZXcgU2ltcGxlQ2FjaGUoeyBtYXhTaXplOiBuZXdDYWNoZVNpemUgPCBzaXplTGltaXQgPyBuZXdDYWNoZVNpemUgOiBzaXplTGltaXQgfSk7XG5cbiAgICAgIC8vIEFkZCBuZXcgZW50cmllc1xuICAgICAgc2V0Q2FjaGVFbnRyaWVzKGpzb25PYmplY3QpO1xuXG4gICAgICAvLyBBcHBlbmQgb2xkZXIgdW5pcXVlIGVudHJpZXMgdG8gY2FjaGVcbiAgICAgIHNldENhY2hlRW50cmllcyhwcmV2Q2FjaGVPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBDcmVhdGUgY2FjaGUgdXNpbmcgcmVzcG9uc2UgY2FjaGUgc2l6ZSBpZiBpdCBkb2Vzbid0IGV4Y2VlZCB0aGUgdXBwZXIgbGltaXRcbiAgICAgIGNhY2hlID0gbmV3IFNpbXBsZUNhY2hlKHsgbWF4U2l6ZTogcmVzcG9uc2VDYWNoZVNpemUgPCBzaXplTGltaXQgPyByZXNwb25zZUNhY2hlU2l6ZSA6IHNpemVMaW1pdCB9KTtcblxuICAgICAgLy8gQWRkIG5ldyBlbnRyaWVzXG4gICAgICBzZXRDYWNoZUVudHJpZXMoanNvbk9iamVjdCk7XG4gICAgfVxuICAgIC8vIHNldCBjYWNoZSB1cGRhdGUgdGltZVxuICAgIGNhY2hlVXBkYXRlVGltZVNlYyA9IERhdGUubm93KCkgLyAxMDAwO1xuICAgIGNhY2hlSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0Q2FjaGVFbnRyaWVzKGpzb25PYmplY3QpIHtcbiAgICBmb3IgKGNvbnN0IGVudHJ5IGluIGpzb25PYmplY3QpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoanNvbk9iamVjdCwgZW50cnkpKSB7XG4gICAgICAgIHVwZGF0ZU9yRGVsZXRlRW50cnkoanNvbk9iamVjdCwgZW50cnkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHVwZGF0ZU9yRGVsZXRlRW50cnkoanNvbk9iamVjdCwgZW50cnkpIHtcbiAgICBjb25zdCBzdGF0dXMgPSB2YWxpZGF0ZUNhY2hlRW50cnkoZW50cnksIGpzb25PYmplY3RbZW50cnldKTtcbiAgICBpZiAoIXN0YXR1cy5lcnIpIHtcbiAgICAgIC8vIEFkZCBuZXcgZW50cnkgb3IgdXBkYXRlIGV4aXN0aW5nIG9uZVxuICAgICAgY2FjaGUuc2V0KHN0YXR1cy5rZXksIHN0YXR1cy52YWx1ZSk7XG4gICAgICAvLyBjaGFuZ2UgY2FjaGUgdXBkYXRlIHRpbWUgaWYgbmVlZGVkXG4gICAgICBpZiAoanNvbk9iamVjdFtlbnRyeV1bMF0gPCBjYWNoZVVwZGF0ZVRpbWVTZWMpIHtcbiAgICAgICAgY2FjaGVVcGRhdGVUaW1lU2VjID0ganNvbk9iamVjdFtlbnRyeV1bMF07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChzdGF0dXMuZXJyLmNvZGUgPT09IEVycm9yQ29kZXMuRVJSX09DU1BfQ0FDSEVfRVhQSVJFRCkge1xuICAgICAgLy8gSWYgdGltZXN0YW1wIGV4cGlyZWQsIGRlbGV0ZSBlbnRyeVxuICAgICAgY2FjaGUuZGVsKHN0YXR1cy5rZXkpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVudHJ5RXhpc3RzKGpzb25PYmplY3QsIGVudHJ5KSB7XG4gICAgZm9yIChjb25zdCBvdGhlckVudHJ5IGluIGpzb25PYmplY3QpIHtcbiAgICAgIGlmIChlbnRyeSA9PT0gb3RoZXJFbnRyeSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmV4cG9ydHMuT2NzcFJlc3BvbnNlQ2FjaGUgPSBPY3NwUmVzcG9uc2VDYWNoZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/agent/ocsp_response_cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/agent/socket_util.js":
/*!*************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/agent/socket_util.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const Check = __webpack_require__(/*! ./check */ \"(rsc)/./node_modules/snowflake-sdk/lib/agent/check.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/lib/global_config.js\");\nconst Parameters = __webpack_require__(/*! ../parameters */ \"(rsc)/./node_modules/snowflake-sdk/lib/parameters.js\");\nconst CertUtil = __webpack_require__(/*! ./cert_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/agent/cert_util.js\");\nconst OcspResponseCache = __webpack_require__(/*! ./ocsp_response_cache */ \"(rsc)/./node_modules/snowflake-sdk/lib/agent/ocsp_response_cache.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\n\nconst REGEX_SNOWFLAKE_ENDPOINT = /.snowflakecomputing./;\n\nconst socketSecuredEvent = 'secureConnect';\n\nconst rawOcspFlag =\n  process.env.SF_OCSP_RESPONSE_CACHE_SERVER_ENABLED;\n\nconst variables = {\n  SF_OCSP_RESPONSE_CACHE_SERVER_ENABLED:\n    !rawOcspFlag || rawOcspFlag && rawOcspFlag.toLowerCase() !== 'false',\n  OCSP_RESPONSE_CACHE: undefined\n};\n\n/**\n * Returns the ocsp response cache.\n *\n * @returns {*}\n */\nfunction getOcspResponseCache() {\n  // initialize the ocsp response cache if needed\n  if (!variables.OCSP_RESPONSE_CACHE) {\n    variables.OCSP_RESPONSE_CACHE = new OcspResponseCache.OcspResponseCache();\n  }\n\n  return variables.OCSP_RESPONSE_CACHE;\n}\n\n\nexports.variables = variables;\n/**\n * Secures a given TLSSocket by blocking all writes until the certificate\n * associated with the socket has been validated.\n *\n * @param {Object} socket\n * @param {String} host\n * @param {Object} agent\n * @param {Object} mock\n *\n * @returns {Object}\n */\nexports.secureSocket = function (socket, host, agent, mock) {\n  // if ocsp validation is disabled for the given host, return the socket as is\n  if (isOcspValidationDisabled(host)) {\n    Logger.getInstance().debug('OCSP validation disabled for %s', host);\n    return socket;\n  }\n\n  if (agent != null) {\n    getOcspResponseCache().setAgent(agent);\n  }\n\n  const validate = function () {\n    // stop listening for the secure event\n    socket.removeListener(socketSecuredEvent, validate);\n\n    Logger.getInstance().trace('socket reused = %s', socket.isSessionReused());\n\n    // if the server has resumed our existing session, unblock all\n    // writes without performing any additional validation\n    if (socket.isSessionReused()) {\n      socket.uncork();\n    } else {\n      if (!socket.authorized) {\n        Logger.getInstance().warn('Socket is not authorized: %s', socket.authorizationError);\n        return socket.destroy(socket.authorizationError);\n      }\n      // use ocsp to make sure the entire certificate chain can be trusted\n      const certChain = socket.getPeerCertificate(true);\n      const vcc = mock ? mock.validateCertChain : validateCertChain;\n\n      vcc(certChain, function (err) {\n        getOcspResponseCache().resetCacheStatus();\n        if (err) {\n          // if there's an error, destroy the socket\n          Logger.getInstance().error('OCSP validation failed: %s', err);\n          return socket.destroy(err);\n        }\n\n        Logger.getInstance().trace('OCSP validation succeeded for %s', host);\n\n        // unblock all writes\n        socket.uncork();\n      });\n    }\n  };\n\n  // when the socket is secure, perform additional validation\n  socket.on(socketSecuredEvent, validate);\n\n  // block all writes until validation is complete\n  socket.cork();\n\n  return socket;\n};\n\n/**\n * Determines if ocsp validation is disabled for a given host.\n *\n * @param {String} host\n * @returns {boolean}\n */\nfunction isOcspValidationDisabled(host) {\n  // ocsp is disabled if insecure-connect is enabled, or if we've disabled ocsp\n  // for non-snowflake endpoints and the host is a non-snowflake endpoint\n  return GlobalConfig.isOCSPChecksDisabled() ||\n    (Parameters.getValue(Parameters.names.JS_DRIVER_DISABLE_OCSP_FOR_NON_SF_ENDPOINTS) &&\n      !REGEX_SNOWFLAKE_ENDPOINT.test(host));\n}\n\n/**\n * Is valid OCSP error for cache\n * @param err\n * @returns {boolean}\n */\nfunction isValidOCSPError(err) {\n  return err && (err.code === ErrorCodes.ERR_OCSP_REVOKED ||\n    err.code === ErrorCodes.ERR_OCSP_UNKNOWN);\n}\n\n/**\n * Return err if any valid error is found.\n * @param errors\n * @returns {null|*}\n */\nfunction canEarlyExitForOCSP(errors) {\n  if (GlobalConfig.getOcspMode() === GlobalConfig.ocspModes.FAIL_CLOSED) {\n    for (let errorIndex = 0, length = errors.length;\n      errorIndex < length; errorIndex++) {\n      // first error\n      const err = errors[errorIndex];\n      if (err) {\n        return Object.prototype.hasOwnProperty.call(err, 'err') ? err.err : err;\n      }\n    }\n  } else {\n    let anyRevoked = null;\n    for (let errorIndex = 0, length = errors.length;\n      errorIndex < length; errorIndex++) {\n      // first error\n      const err = errors[errorIndex];\n      if (err && !isValidOCSPError(err)) {\n        // any of the errors is NOT good/revoked/unknown\n        Logger.getInstance().debug(`OCSP responder didn't respond correctly. Assuming certificate is not revoked. Details: ${err}`);\n        return null;\n      } else if (err && err.code === ErrorCodes.ERR_OCSP_REVOKED) {\n        anyRevoked = err;\n      }\n    }\n    return anyRevoked;\n  }\n}\n\nexports.canEarlyExitForOCSP = canEarlyExitForOCSP;\n\n/**\n * Validates a certificate chain using OCSP.\n *\n * @param {Object} cert a top-level cert that represents the leaf of a\n *   certificate chain.\n * @param {Function} cb the callback to invoke once the validation is complete.\n */\nfunction validateCertChain(cert, cb) {\n  // walk up the certificate chain and collect all the certificates in an array\n  const certs = [];\n  while (cert && cert.issuerCertificate &&\n  (cert.fingerprint !== cert.issuerCertificate.fingerprint)) {\n    certs.push(cert);\n    cert = cert.issuerCertificate;\n  }\n\n  // create an array to store any errors encountered\n  // while validating the certificate chain\n  const errors = new Array(certs.length);\n\n  /**\n   * Called for every certificate as we traverse the certificate chain and\n   * validate each one.\n   *\n   * @param certs\n   * @param index\n   */\n  const eachCallback = function (certs, index) {\n    const cert = certs[index];\n    validateCert(cert, function (err, data) {\n      completed++;\n      errors[index] = err;\n      if (err) {\n        Logger.getInstance().debug(err);\n      }\n\n      // if we have an ocsp response, cache it\n      if (data && (!data.err || isValidOCSPError(data.err))) {\n        // check if cache is initialized before setting entry\n        if (getOcspResponseCache().isInitialized()) {\n          getOcspResponseCache().set(cert, data.res);\n        } else {\n          getOcspResponseCache().initCache(cert, data.res);\n        }\n        if (data.err) {\n          err = data.err;\n          errors[index] = err;\n        }\n      }\n\n      // if this is the last request to complete\n      if (completed === certs.length) {\n        const validError = canEarlyExitForOCSP(errors);\n        cb(validError);\n      }\n    });\n  };\n\n  // fire off requests to validate all the certificates in the chain\n  let completed = 0;\n  for (let index = 0, length = certs.length; index < length; index++) {\n    eachCallback(certs, index);\n  }\n}\n\n/**\n * Validates a certificate using OCSP.\n *\n * @param cert the certificate to validate.\n * @param cb the callback to invoke once the validation is complete.\n */\nfunction validateCert(cert, cb) {\n  function getOcspCache() {\n    try {\n      if (!getOcspResponseCache().downloadCache(getOcspResonseAndVerify)) {\n        setTimeout(getOcspCache, 10);\n      }\n    } catch (e) {\n      process.nextTick(function () {\n        cb(e);\n      });\n    }\n  }\n\n  /**\n   * Gets and Verifies OCSP Response\n   * @param err {object}\n   * @param useCacheServer {boolean}\n   */\n  function getOcspResonseAndVerify(err, useCacheServer) {\n    if (!useCacheServer && !getOcspResponseCache().isDownloadFinished()) {\n      setTimeout(getOcspResonseAndVerify, 10); // ms\n      return;\n    }\n\n    let decoded;\n    try {\n      decoded = CertUtil.decode(cert);\n    } catch (e) {\n      process.nextTick(function () {\n        cb(e);\n      });\n    }\n\n    let ocspResponse;\n    // check if cache is initialized before getting entry\n    if (getOcspResponseCache().isInitialized()) {\n      if (getOcspResponseCache().IsCacheExpired()) {\n        // reset cache status so it can be refreshed\n        getOcspResponseCache().resetCacheStatus();\n      } else {\n        // if we already have a valid entry in the cache, use it\n        ocspResponse = getOcspResponseCache().get(cert);\n      }\n    }\n    if (ocspResponse) {\n      Logger.getInstance().trace(\n        'Returning OCSP status for certificate %s from cache', cert.serialNumber);\n      const status = CertUtil.verifyOCSPResponse(decoded.issuer, ocspResponse);\n      if (!status.err) {\n        // verification was success with the cache\n        process.nextTick(function () {\n          cb(null, null);\n        });\n      } else {\n        // verification was failure with the cache\n        process.nextTick(function () {\n          cb(status.err, null);\n        });\n      }\n    } else {\n      if (useCacheServer) {\n        process.nextTick(function () {\n          getOcspCache();\n        });\n      } else {\n        Check(decoded, cb);\n      }\n    }\n  }\n\n  if (!variables.SF_OCSP_RESPONSE_CACHE_SERVER_ENABLED) {\n    getOcspResponseCache().forceDownloadToFinish();\n  }\n  getOcspResonseAndVerify(null, variables.SF_OCSP_RESPONSE_CACHE_SERVER_ENABLED);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYWdlbnQvc29ja2V0X3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUEsY0FBYyxtQkFBTyxDQUFDLHNFQUFTO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVztBQUNsQyxxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBa0I7QUFDL0MsbUJBQW1CLG1CQUFPLENBQUMsMkVBQWU7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsOEVBQWE7QUFDdEMsMEJBQTBCLG1CQUFPLENBQUMsa0dBQXVCO0FBQ3pELGVBQWUsbUJBQU8sQ0FBQyxtRUFBVztBQUNsQzs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZILElBQUk7QUFDakk7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2FnZW50L3NvY2tldF91dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IENoZWNrID0gcmVxdWlyZSgnLi9jaGVjaycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBHbG9iYWxDb25maWcgPSByZXF1aXJlKCcuLi9nbG9iYWxfY29uZmlnJyk7XG5jb25zdCBQYXJhbWV0ZXJzID0gcmVxdWlyZSgnLi4vcGFyYW1ldGVycycpO1xuY29uc3QgQ2VydFV0aWwgPSByZXF1aXJlKCcuL2NlcnRfdXRpbCcpO1xuY29uc3QgT2NzcFJlc3BvbnNlQ2FjaGUgPSByZXF1aXJlKCcuL29jc3BfcmVzcG9uc2VfY2FjaGUnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2RlcztcblxuY29uc3QgUkVHRVhfU05PV0ZMQUtFX0VORFBPSU5UID0gLy5zbm93Zmxha2Vjb21wdXRpbmcuLztcblxuY29uc3Qgc29ja2V0U2VjdXJlZEV2ZW50ID0gJ3NlY3VyZUNvbm5lY3QnO1xuXG5jb25zdCByYXdPY3NwRmxhZyA9XG4gIHByb2Nlc3MuZW52LlNGX09DU1BfUkVTUE9OU0VfQ0FDSEVfU0VSVkVSX0VOQUJMRUQ7XG5cbmNvbnN0IHZhcmlhYmxlcyA9IHtcbiAgU0ZfT0NTUF9SRVNQT05TRV9DQUNIRV9TRVJWRVJfRU5BQkxFRDpcbiAgICAhcmF3T2NzcEZsYWcgfHwgcmF3T2NzcEZsYWcgJiYgcmF3T2NzcEZsYWcudG9Mb3dlckNhc2UoKSAhPT0gJ2ZhbHNlJyxcbiAgT0NTUF9SRVNQT05TRV9DQUNIRTogdW5kZWZpbmVkXG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG9jc3AgcmVzcG9uc2UgY2FjaGUuXG4gKlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGdldE9jc3BSZXNwb25zZUNhY2hlKCkge1xuICAvLyBpbml0aWFsaXplIHRoZSBvY3NwIHJlc3BvbnNlIGNhY2hlIGlmIG5lZWRlZFxuICBpZiAoIXZhcmlhYmxlcy5PQ1NQX1JFU1BPTlNFX0NBQ0hFKSB7XG4gICAgdmFyaWFibGVzLk9DU1BfUkVTUE9OU0VfQ0FDSEUgPSBuZXcgT2NzcFJlc3BvbnNlQ2FjaGUuT2NzcFJlc3BvbnNlQ2FjaGUoKTtcbiAgfVxuXG4gIHJldHVybiB2YXJpYWJsZXMuT0NTUF9SRVNQT05TRV9DQUNIRTtcbn1cblxuXG5leHBvcnRzLnZhcmlhYmxlcyA9IHZhcmlhYmxlcztcbi8qKlxuICogU2VjdXJlcyBhIGdpdmVuIFRMU1NvY2tldCBieSBibG9ja2luZyBhbGwgd3JpdGVzIHVudGlsIHRoZSBjZXJ0aWZpY2F0ZVxuICogYXNzb2NpYXRlZCB3aXRoIHRoZSBzb2NrZXQgaGFzIGJlZW4gdmFsaWRhdGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb2NrZXRcbiAqIEBwYXJhbSB7U3RyaW5nfSBob3N0XG4gKiBAcGFyYW0ge09iamVjdH0gYWdlbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBtb2NrXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0cy5zZWN1cmVTb2NrZXQgPSBmdW5jdGlvbiAoc29ja2V0LCBob3N0LCBhZ2VudCwgbW9jaykge1xuICAvLyBpZiBvY3NwIHZhbGlkYXRpb24gaXMgZGlzYWJsZWQgZm9yIHRoZSBnaXZlbiBob3N0LCByZXR1cm4gdGhlIHNvY2tldCBhcyBpc1xuICBpZiAoaXNPY3NwVmFsaWRhdGlvbkRpc2FibGVkKGhvc3QpKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ09DU1AgdmFsaWRhdGlvbiBkaXNhYmxlZCBmb3IgJXMnLCBob3N0KTtcbiAgICByZXR1cm4gc29ja2V0O1xuICB9XG5cbiAgaWYgKGFnZW50ICE9IG51bGwpIHtcbiAgICBnZXRPY3NwUmVzcG9uc2VDYWNoZSgpLnNldEFnZW50KGFnZW50KTtcbiAgfVxuXG4gIGNvbnN0IHZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHN0b3AgbGlzdGVuaW5nIGZvciB0aGUgc2VjdXJlIGV2ZW50XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKHNvY2tldFNlY3VyZWRFdmVudCwgdmFsaWRhdGUpO1xuXG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ3NvY2tldCByZXVzZWQgPSAlcycsIHNvY2tldC5pc1Nlc3Npb25SZXVzZWQoKSk7XG5cbiAgICAvLyBpZiB0aGUgc2VydmVyIGhhcyByZXN1bWVkIG91ciBleGlzdGluZyBzZXNzaW9uLCB1bmJsb2NrIGFsbFxuICAgIC8vIHdyaXRlcyB3aXRob3V0IHBlcmZvcm1pbmcgYW55IGFkZGl0aW9uYWwgdmFsaWRhdGlvblxuICAgIGlmIChzb2NrZXQuaXNTZXNzaW9uUmV1c2VkKCkpIHtcbiAgICAgIHNvY2tldC51bmNvcmsoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKCFzb2NrZXQuYXV0aG9yaXplZCkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdTb2NrZXQgaXMgbm90IGF1dGhvcml6ZWQ6ICVzJywgc29ja2V0LmF1dGhvcml6YXRpb25FcnJvcik7XG4gICAgICAgIHJldHVybiBzb2NrZXQuZGVzdHJveShzb2NrZXQuYXV0aG9yaXphdGlvbkVycm9yKTtcbiAgICAgIH1cbiAgICAgIC8vIHVzZSBvY3NwIHRvIG1ha2Ugc3VyZSB0aGUgZW50aXJlIGNlcnRpZmljYXRlIGNoYWluIGNhbiBiZSB0cnVzdGVkXG4gICAgICBjb25zdCBjZXJ0Q2hhaW4gPSBzb2NrZXQuZ2V0UGVlckNlcnRpZmljYXRlKHRydWUpO1xuICAgICAgY29uc3QgdmNjID0gbW9jayA/IG1vY2sudmFsaWRhdGVDZXJ0Q2hhaW4gOiB2YWxpZGF0ZUNlcnRDaGFpbjtcblxuICAgICAgdmNjKGNlcnRDaGFpbiwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBnZXRPY3NwUmVzcG9uc2VDYWNoZSgpLnJlc2V0Q2FjaGVTdGF0dXMoKTtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIC8vIGlmIHRoZXJlJ3MgYW4gZXJyb3IsIGRlc3Ryb3kgdGhlIHNvY2tldFxuICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdPQ1NQIHZhbGlkYXRpb24gZmFpbGVkOiAlcycsIGVycik7XG4gICAgICAgICAgcmV0dXJuIHNvY2tldC5kZXN0cm95KGVycik7XG4gICAgICAgIH1cblxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnT0NTUCB2YWxpZGF0aW9uIHN1Y2NlZWRlZCBmb3IgJXMnLCBob3N0KTtcblxuICAgICAgICAvLyB1bmJsb2NrIGFsbCB3cml0ZXNcbiAgICAgICAgc29ja2V0LnVuY29yaygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9O1xuXG4gIC8vIHdoZW4gdGhlIHNvY2tldCBpcyBzZWN1cmUsIHBlcmZvcm0gYWRkaXRpb25hbCB2YWxpZGF0aW9uXG4gIHNvY2tldC5vbihzb2NrZXRTZWN1cmVkRXZlbnQsIHZhbGlkYXRlKTtcblxuICAvLyBibG9jayBhbGwgd3JpdGVzIHVudGlsIHZhbGlkYXRpb24gaXMgY29tcGxldGVcbiAgc29ja2V0LmNvcmsoKTtcblxuICByZXR1cm4gc29ja2V0O1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIG9jc3AgdmFsaWRhdGlvbiBpcyBkaXNhYmxlZCBmb3IgYSBnaXZlbiBob3N0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBob3N0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNPY3NwVmFsaWRhdGlvbkRpc2FibGVkKGhvc3QpIHtcbiAgLy8gb2NzcCBpcyBkaXNhYmxlZCBpZiBpbnNlY3VyZS1jb25uZWN0IGlzIGVuYWJsZWQsIG9yIGlmIHdlJ3ZlIGRpc2FibGVkIG9jc3BcbiAgLy8gZm9yIG5vbi1zbm93Zmxha2UgZW5kcG9pbnRzIGFuZCB0aGUgaG9zdCBpcyBhIG5vbi1zbm93Zmxha2UgZW5kcG9pbnRcbiAgcmV0dXJuIEdsb2JhbENvbmZpZy5pc09DU1BDaGVja3NEaXNhYmxlZCgpIHx8XG4gICAgKFBhcmFtZXRlcnMuZ2V0VmFsdWUoUGFyYW1ldGVycy5uYW1lcy5KU19EUklWRVJfRElTQUJMRV9PQ1NQX0ZPUl9OT05fU0ZfRU5EUE9JTlRTKSAmJlxuICAgICAgIVJFR0VYX1NOT1dGTEFLRV9FTkRQT0lOVC50ZXN0KGhvc3QpKTtcbn1cblxuLyoqXG4gKiBJcyB2YWxpZCBPQ1NQIGVycm9yIGZvciBjYWNoZVxuICogQHBhcmFtIGVyclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzVmFsaWRPQ1NQRXJyb3IoZXJyKSB7XG4gIHJldHVybiBlcnIgJiYgKGVyci5jb2RlID09PSBFcnJvckNvZGVzLkVSUl9PQ1NQX1JFVk9LRUQgfHxcbiAgICBlcnIuY29kZSA9PT0gRXJyb3JDb2Rlcy5FUlJfT0NTUF9VTktOT1dOKTtcbn1cblxuLyoqXG4gKiBSZXR1cm4gZXJyIGlmIGFueSB2YWxpZCBlcnJvciBpcyBmb3VuZC5cbiAqIEBwYXJhbSBlcnJvcnNcbiAqIEByZXR1cm5zIHtudWxsfCp9XG4gKi9cbmZ1bmN0aW9uIGNhbkVhcmx5RXhpdEZvck9DU1AoZXJyb3JzKSB7XG4gIGlmIChHbG9iYWxDb25maWcuZ2V0T2NzcE1vZGUoKSA9PT0gR2xvYmFsQ29uZmlnLm9jc3BNb2Rlcy5GQUlMX0NMT1NFRCkge1xuICAgIGZvciAobGV0IGVycm9ySW5kZXggPSAwLCBsZW5ndGggPSBlcnJvcnMubGVuZ3RoO1xuICAgICAgZXJyb3JJbmRleCA8IGxlbmd0aDsgZXJyb3JJbmRleCsrKSB7XG4gICAgICAvLyBmaXJzdCBlcnJvclxuICAgICAgY29uc3QgZXJyID0gZXJyb3JzW2Vycm9ySW5kZXhdO1xuICAgICAgaWYgKGVycikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGVyciwgJ2VycicpID8gZXJyLmVyciA6IGVycjtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbGV0IGFueVJldm9rZWQgPSBudWxsO1xuICAgIGZvciAobGV0IGVycm9ySW5kZXggPSAwLCBsZW5ndGggPSBlcnJvcnMubGVuZ3RoO1xuICAgICAgZXJyb3JJbmRleCA8IGxlbmd0aDsgZXJyb3JJbmRleCsrKSB7XG4gICAgICAvLyBmaXJzdCBlcnJvclxuICAgICAgY29uc3QgZXJyID0gZXJyb3JzW2Vycm9ySW5kZXhdO1xuICAgICAgaWYgKGVyciAmJiAhaXNWYWxpZE9DU1BFcnJvcihlcnIpKSB7XG4gICAgICAgIC8vIGFueSBvZiB0aGUgZXJyb3JzIGlzIE5PVCBnb29kL3Jldm9rZWQvdW5rbm93blxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgT0NTUCByZXNwb25kZXIgZGlkbid0IHJlc3BvbmQgY29ycmVjdGx5LiBBc3N1bWluZyBjZXJ0aWZpY2F0ZSBpcyBub3QgcmV2b2tlZC4gRGV0YWlsczogJHtlcnJ9YCk7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChlcnIgJiYgZXJyLmNvZGUgPT09IEVycm9yQ29kZXMuRVJSX09DU1BfUkVWT0tFRCkge1xuICAgICAgICBhbnlSZXZva2VkID0gZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYW55UmV2b2tlZDtcbiAgfVxufVxuXG5leHBvcnRzLmNhbkVhcmx5RXhpdEZvck9DU1AgPSBjYW5FYXJseUV4aXRGb3JPQ1NQO1xuXG4vKipcbiAqIFZhbGlkYXRlcyBhIGNlcnRpZmljYXRlIGNoYWluIHVzaW5nIE9DU1AuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNlcnQgYSB0b3AtbGV2ZWwgY2VydCB0aGF0IHJlcHJlc2VudHMgdGhlIGxlYWYgb2YgYVxuICogICBjZXJ0aWZpY2F0ZSBjaGFpbi5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIHRoZSBjYWxsYmFjayB0byBpbnZva2Ugb25jZSB0aGUgdmFsaWRhdGlvbiBpcyBjb21wbGV0ZS5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDZXJ0Q2hhaW4oY2VydCwgY2IpIHtcbiAgLy8gd2FsayB1cCB0aGUgY2VydGlmaWNhdGUgY2hhaW4gYW5kIGNvbGxlY3QgYWxsIHRoZSBjZXJ0aWZpY2F0ZXMgaW4gYW4gYXJyYXlcbiAgY29uc3QgY2VydHMgPSBbXTtcbiAgd2hpbGUgKGNlcnQgJiYgY2VydC5pc3N1ZXJDZXJ0aWZpY2F0ZSAmJlxuICAoY2VydC5maW5nZXJwcmludCAhPT0gY2VydC5pc3N1ZXJDZXJ0aWZpY2F0ZS5maW5nZXJwcmludCkpIHtcbiAgICBjZXJ0cy5wdXNoKGNlcnQpO1xuICAgIGNlcnQgPSBjZXJ0Lmlzc3VlckNlcnRpZmljYXRlO1xuICB9XG5cbiAgLy8gY3JlYXRlIGFuIGFycmF5IHRvIHN0b3JlIGFueSBlcnJvcnMgZW5jb3VudGVyZWRcbiAgLy8gd2hpbGUgdmFsaWRhdGluZyB0aGUgY2VydGlmaWNhdGUgY2hhaW5cbiAgY29uc3QgZXJyb3JzID0gbmV3IEFycmF5KGNlcnRzLmxlbmd0aCk7XG5cbiAgLyoqXG4gICAqIENhbGxlZCBmb3IgZXZlcnkgY2VydGlmaWNhdGUgYXMgd2UgdHJhdmVyc2UgdGhlIGNlcnRpZmljYXRlIGNoYWluIGFuZFxuICAgKiB2YWxpZGF0ZSBlYWNoIG9uZS5cbiAgICpcbiAgICogQHBhcmFtIGNlcnRzXG4gICAqIEBwYXJhbSBpbmRleFxuICAgKi9cbiAgY29uc3QgZWFjaENhbGxiYWNrID0gZnVuY3Rpb24gKGNlcnRzLCBpbmRleCkge1xuICAgIGNvbnN0IGNlcnQgPSBjZXJ0c1tpbmRleF07XG4gICAgdmFsaWRhdGVDZXJ0KGNlcnQsIGZ1bmN0aW9uIChlcnIsIGRhdGEpIHtcbiAgICAgIGNvbXBsZXRlZCsrO1xuICAgICAgZXJyb3JzW2luZGV4XSA9IGVycjtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoZXJyKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgd2UgaGF2ZSBhbiBvY3NwIHJlc3BvbnNlLCBjYWNoZSBpdFxuICAgICAgaWYgKGRhdGEgJiYgKCFkYXRhLmVyciB8fCBpc1ZhbGlkT0NTUEVycm9yKGRhdGEuZXJyKSkpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgY2FjaGUgaXMgaW5pdGlhbGl6ZWQgYmVmb3JlIHNldHRpbmcgZW50cnlcbiAgICAgICAgaWYgKGdldE9jc3BSZXNwb25zZUNhY2hlKCkuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgICAgZ2V0T2NzcFJlc3BvbnNlQ2FjaGUoKS5zZXQoY2VydCwgZGF0YS5yZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdldE9jc3BSZXNwb25zZUNhY2hlKCkuaW5pdENhY2hlKGNlcnQsIGRhdGEucmVzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5lcnIpIHtcbiAgICAgICAgICBlcnIgPSBkYXRhLmVycjtcbiAgICAgICAgICBlcnJvcnNbaW5kZXhdID0gZXJyO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRoaXMgaXMgdGhlIGxhc3QgcmVxdWVzdCB0byBjb21wbGV0ZVxuICAgICAgaWYgKGNvbXBsZXRlZCA9PT0gY2VydHMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkRXJyb3IgPSBjYW5FYXJseUV4aXRGb3JPQ1NQKGVycm9ycyk7XG4gICAgICAgIGNiKHZhbGlkRXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8vIGZpcmUgb2ZmIHJlcXVlc3RzIHRvIHZhbGlkYXRlIGFsbCB0aGUgY2VydGlmaWNhdGVzIGluIHRoZSBjaGFpblxuICBsZXQgY29tcGxldGVkID0gMDtcbiAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBjZXJ0cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgZWFjaENhbGxiYWNrKGNlcnRzLCBpbmRleCk7XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0ZXMgYSBjZXJ0aWZpY2F0ZSB1c2luZyBPQ1NQLlxuICpcbiAqIEBwYXJhbSBjZXJ0IHRoZSBjZXJ0aWZpY2F0ZSB0byB2YWxpZGF0ZS5cbiAqIEBwYXJhbSBjYiB0aGUgY2FsbGJhY2sgdG8gaW52b2tlIG9uY2UgdGhlIHZhbGlkYXRpb24gaXMgY29tcGxldGUuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlQ2VydChjZXJ0LCBjYikge1xuICBmdW5jdGlvbiBnZXRPY3NwQ2FjaGUoKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmICghZ2V0T2NzcFJlc3BvbnNlQ2FjaGUoKS5kb3dubG9hZENhY2hlKGdldE9jc3BSZXNvbnNlQW5kVmVyaWZ5KSkge1xuICAgICAgICBzZXRUaW1lb3V0KGdldE9jc3BDYWNoZSwgMTApO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBjYihlKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFuZCBWZXJpZmllcyBPQ1NQIFJlc3BvbnNlXG4gICAqIEBwYXJhbSBlcnIge29iamVjdH1cbiAgICogQHBhcmFtIHVzZUNhY2hlU2VydmVyIHtib29sZWFufVxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0T2NzcFJlc29uc2VBbmRWZXJpZnkoZXJyLCB1c2VDYWNoZVNlcnZlcikge1xuICAgIGlmICghdXNlQ2FjaGVTZXJ2ZXIgJiYgIWdldE9jc3BSZXNwb25zZUNhY2hlKCkuaXNEb3dubG9hZEZpbmlzaGVkKCkpIHtcbiAgICAgIHNldFRpbWVvdXQoZ2V0T2NzcFJlc29uc2VBbmRWZXJpZnksIDEwKTsgLy8gbXNcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgZGVjb2RlZDtcbiAgICB0cnkge1xuICAgICAgZGVjb2RlZCA9IENlcnRVdGlsLmRlY29kZShjZXJ0KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2IoZSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBsZXQgb2NzcFJlc3BvbnNlO1xuICAgIC8vIGNoZWNrIGlmIGNhY2hlIGlzIGluaXRpYWxpemVkIGJlZm9yZSBnZXR0aW5nIGVudHJ5XG4gICAgaWYgKGdldE9jc3BSZXNwb25zZUNhY2hlKCkuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICBpZiAoZ2V0T2NzcFJlc3BvbnNlQ2FjaGUoKS5Jc0NhY2hlRXhwaXJlZCgpKSB7XG4gICAgICAgIC8vIHJlc2V0IGNhY2hlIHN0YXR1cyBzbyBpdCBjYW4gYmUgcmVmcmVzaGVkXG4gICAgICAgIGdldE9jc3BSZXNwb25zZUNhY2hlKCkucmVzZXRDYWNoZVN0YXR1cygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgdmFsaWQgZW50cnkgaW4gdGhlIGNhY2hlLCB1c2UgaXRcbiAgICAgICAgb2NzcFJlc3BvbnNlID0gZ2V0T2NzcFJlc3BvbnNlQ2FjaGUoKS5nZXQoY2VydCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvY3NwUmVzcG9uc2UpIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKFxuICAgICAgICAnUmV0dXJuaW5nIE9DU1Agc3RhdHVzIGZvciBjZXJ0aWZpY2F0ZSAlcyBmcm9tIGNhY2hlJywgY2VydC5zZXJpYWxOdW1iZXIpO1xuICAgICAgY29uc3Qgc3RhdHVzID0gQ2VydFV0aWwudmVyaWZ5T0NTUFJlc3BvbnNlKGRlY29kZWQuaXNzdWVyLCBvY3NwUmVzcG9uc2UpO1xuICAgICAgaWYgKCFzdGF0dXMuZXJyKSB7XG4gICAgICAgIC8vIHZlcmlmaWNhdGlvbiB3YXMgc3VjY2VzcyB3aXRoIHRoZSBjYWNoZVxuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjYihudWxsLCBudWxsKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyB2ZXJpZmljYXRpb24gd2FzIGZhaWx1cmUgd2l0aCB0aGUgY2FjaGVcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgY2Ioc3RhdHVzLmVyciwgbnVsbCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodXNlQ2FjaGVTZXJ2ZXIpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgZ2V0T2NzcENhY2hlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgQ2hlY2soZGVjb2RlZCwgY2IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICghdmFyaWFibGVzLlNGX09DU1BfUkVTUE9OU0VfQ0FDSEVfU0VSVkVSX0VOQUJMRUQpIHtcbiAgICBnZXRPY3NwUmVzcG9uc2VDYWNoZSgpLmZvcmNlRG93bmxvYWRUb0ZpbmlzaCgpO1xuICB9XG4gIGdldE9jc3BSZXNvbnNlQW5kVmVyaWZ5KG51bGwsIHZhcmlhYmxlcy5TRl9PQ1NQX1JFU1BPTlNFX0NBQ0hFX1NFUlZFUl9FTkFCTEVEKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/agent/socket_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_default.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/authentication/auth_default.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const mfaAuthenticator = (__webpack_require__(/*! ./authentication_types.js */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/authentication_types.js\").USER_PWD_MFA_AUTHENTICATOR);\n\n/**\n * Creates a default authenticator.\n *\n * @param {String} password\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthDefault(connectionConfig) {\n  const password = connectionConfig.password;\n  const mfaToken = connectionConfig.mfaToken;\n  const passcode = connectionConfig.getPasscode();\n  const isPasscodeInPassword = connectionConfig.getPasscodeInPassword();\n\n  /**\n     * Update JSON body with password or token.\n     *\n     * @param {JSON} body\n     *\n     * @returns {null}\n     */\n  this.updateBody = function (body) {\n    body['data']['PASSWORD'] = password;\n\n    if (isMFAAuth()) {\n      setMFASessionParams(body);\n    }\n  };\n\n  function isMFAAuth() {\n    return ( connectionConfig.getAuthenticator() === mfaAuthenticator || mfaToken || passcode || isPasscodeInPassword);\n  }\n\n  function setMFASessionParams(body) {\n    body['data']['TOKEN'] = mfaToken;\n    body['data']['AUTHENTICATOR'] = mfaAuthenticator;\n    \n    if (isPasscodeInPassword) {\n      body['data']['EXT_AUTHN_DUO_METHOD'] = 'passcode';\n      body['data']['passcodeInPassword'] = true;\n    } else if (passcode) {\n      body['data']['EXT_AUTHN_DUO_METHOD'] = 'passcode';\n      body['data']['PASSCODE'] = passcode;\n    } else {\n      body['data']['EXT_AUTHN_DUO_METHOD'] = 'push';\n    }\n  }\n    \n  this.authenticate = async function () {\n    return;\n  };\n\n  this.reauthenticate = async function () {\n    return;\n  };\n}\n\nmodule.exports = AuthDefault;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYXV0aGVudGljYXRpb24vYXV0aF9kZWZhdWx0LmpzIiwibWFwcGluZ3MiOiJBQUFBLHlCQUF5QixrS0FBZ0U7O0FBRXpGO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2F1dGhlbnRpY2F0aW9uL2F1dGhfZGVmYXVsdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBtZmFBdXRoZW50aWNhdG9yID0gcmVxdWlyZSAoJy4vYXV0aGVudGljYXRpb25fdHlwZXMuanMnKS5VU0VSX1BXRF9NRkFfQVVUSEVOVElDQVRPUjtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZGVmYXVsdCBhdXRoZW50aWNhdG9yLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQXV0aERlZmF1bHQoY29ubmVjdGlvbkNvbmZpZykge1xuICBjb25zdCBwYXNzd29yZCA9IGNvbm5lY3Rpb25Db25maWcucGFzc3dvcmQ7XG4gIGNvbnN0IG1mYVRva2VuID0gY29ubmVjdGlvbkNvbmZpZy5tZmFUb2tlbjtcbiAgY29uc3QgcGFzc2NvZGUgPSBjb25uZWN0aW9uQ29uZmlnLmdldFBhc3Njb2RlKCk7XG4gIGNvbnN0IGlzUGFzc2NvZGVJblBhc3N3b3JkID0gY29ubmVjdGlvbkNvbmZpZy5nZXRQYXNzY29kZUluUGFzc3dvcmQoKTtcblxuICAvKipcbiAgICAgKiBVcGRhdGUgSlNPTiBib2R5IHdpdGggcGFzc3dvcmQgb3IgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0pTT059IGJvZHlcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtudWxsfVxuICAgICAqL1xuICB0aGlzLnVwZGF0ZUJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgIGJvZHlbJ2RhdGEnXVsnUEFTU1dPUkQnXSA9IHBhc3N3b3JkO1xuXG4gICAgaWYgKGlzTUZBQXV0aCgpKSB7XG4gICAgICBzZXRNRkFTZXNzaW9uUGFyYW1zKGJvZHkpO1xuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBpc01GQUF1dGgoKSB7XG4gICAgcmV0dXJuICggY29ubmVjdGlvbkNvbmZpZy5nZXRBdXRoZW50aWNhdG9yKCkgPT09IG1mYUF1dGhlbnRpY2F0b3IgfHwgbWZhVG9rZW4gfHwgcGFzc2NvZGUgfHwgaXNQYXNzY29kZUluUGFzc3dvcmQpO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0TUZBU2Vzc2lvblBhcmFtcyhib2R5KSB7XG4gICAgYm9keVsnZGF0YSddWydUT0tFTiddID0gbWZhVG9rZW47XG4gICAgYm9keVsnZGF0YSddWydBVVRIRU5USUNBVE9SJ10gPSBtZmFBdXRoZW50aWNhdG9yO1xuICAgIFxuICAgIGlmIChpc1Bhc3Njb2RlSW5QYXNzd29yZCkge1xuICAgICAgYm9keVsnZGF0YSddWydFWFRfQVVUSE5fRFVPX01FVEhPRCddID0gJ3Bhc3Njb2RlJztcbiAgICAgIGJvZHlbJ2RhdGEnXVsncGFzc2NvZGVJblBhc3N3b3JkJ10gPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAocGFzc2NvZGUpIHtcbiAgICAgIGJvZHlbJ2RhdGEnXVsnRVhUX0FVVEhOX0RVT19NRVRIT0QnXSA9ICdwYXNzY29kZSc7XG4gICAgICBib2R5WydkYXRhJ11bJ1BBU1NDT0RFJ10gPSBwYXNzY29kZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYm9keVsnZGF0YSddWydFWFRfQVVUSE5fRFVPX01FVEhPRCddID0gJ3B1c2gnO1xuICAgIH1cbiAgfVxuICAgIFxuICB0aGlzLmF1dGhlbnRpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm47XG4gIH07XG5cbiAgdGhpcy5yZWF1dGhlbnRpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm47XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0aERlZmF1bHQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_default.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_idtoken.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/authentication/auth_idtoken.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const AuthWeb = __webpack_require__(/*! ./auth_web */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_web.js\");\n\n/**\n * Creates an ID token authenticator.\n *\n * @param {Object} connectionConfig\n * @param {Object} httpClient\n * @param {module} webbrowser\n * \n * @returns {Object} the authenticator\n * @constructor\n */\nfunction AuthIDToken(connectionConfig, httpClient, webbrowser) {\n\n  this.idToken = connectionConfig.idToken;\n\n  /**\n   * Update JSON body with token.\n   *\n   * @param {JSON} body\n   *\n   * @returns {null}\n   */\n  this.updateBody = function (body) {\n    body['data']['TOKEN'] = this.idToken;\n    body['data']['AUTHENTICATOR'] = 'ID_TOKEN';\n  };\n  \n  this.authenticate = async function () {};\n\n  this.reauthenticate = async function (body) {\n    const auth = new AuthWeb(connectionConfig, httpClient, webbrowser);\n    await auth.authenticate(connectionConfig.getAuthenticator(),\n      connectionConfig.getServiceName(),\n      connectionConfig.account,\n      connectionConfig.username);\n    auth.updateBody(body);\n  };\n}\n\nmodule.exports = AuthIDToken;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYXV0aGVudGljYXRpb24vYXV0aF9pZHRva2VuLmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLHFGQUFZOztBQUVwQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX2lkdG9rZW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgQXV0aFdlYiA9IHJlcXVpcmUoJy4vYXV0aF93ZWInKTtcblxuLyoqXG4gKiBDcmVhdGVzIGFuIElEIHRva2VuIGF1dGhlbnRpY2F0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBodHRwQ2xpZW50XG4gKiBAcGFyYW0ge21vZHVsZX0gd2ViYnJvd3NlclxuICogXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgYXV0aGVudGljYXRvclxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEF1dGhJRFRva2VuKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQsIHdlYmJyb3dzZXIpIHtcblxuICB0aGlzLmlkVG9rZW4gPSBjb25uZWN0aW9uQ29uZmlnLmlkVG9rZW47XG5cbiAgLyoqXG4gICAqIFVwZGF0ZSBKU09OIGJvZHkgd2l0aCB0b2tlbi5cbiAgICpcbiAgICogQHBhcmFtIHtKU09OfSBib2R5XG4gICAqXG4gICAqIEByZXR1cm5zIHtudWxsfVxuICAgKi9cbiAgdGhpcy51cGRhdGVCb2R5ID0gZnVuY3Rpb24gKGJvZHkpIHtcbiAgICBib2R5WydkYXRhJ11bJ1RPS0VOJ10gPSB0aGlzLmlkVG9rZW47XG4gICAgYm9keVsnZGF0YSddWydBVVRIRU5USUNBVE9SJ10gPSAnSURfVE9LRU4nO1xuICB9O1xuICBcbiAgdGhpcy5hdXRoZW50aWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoKSB7fTtcblxuICB0aGlzLnJlYXV0aGVudGljYXRlID0gYXN5bmMgZnVuY3Rpb24gKGJvZHkpIHtcbiAgICBjb25zdCBhdXRoID0gbmV3IEF1dGhXZWIoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCwgd2ViYnJvd3Nlcik7XG4gICAgYXdhaXQgYXV0aC5hdXRoZW50aWNhdGUoY29ubmVjdGlvbkNvbmZpZy5nZXRBdXRoZW50aWNhdG9yKCksXG4gICAgICBjb25uZWN0aW9uQ29uZmlnLmdldFNlcnZpY2VOYW1lKCksXG4gICAgICBjb25uZWN0aW9uQ29uZmlnLmFjY291bnQsXG4gICAgICBjb25uZWN0aW9uQ29uZmlnLnVzZXJuYW1lKTtcbiAgICBhdXRoLnVwZGF0ZUJvZHkoYm9keSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0aElEVG9rZW47XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_idtoken.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_keypair.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/authentication/auth_keypair.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\n\n/**\n * Creates a key-pair authenticator.\n *\n * @param {String} privateKey\n * @param {String} privateKeyPath\n * @param {String} privateKeyPass\n * @param {module} cryptomod\n * @param {module} jwtmod\n * @param {module} filesystem\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthKeypair(connectionConfig, cryptomod, jwtmod, filesystem) {\n  const crypto = typeof cryptomod !== 'undefined' ? cryptomod : __webpack_require__(/*! crypto */ \"crypto\");\n  const jwt = typeof jwtmod !== 'undefined' ? jwtmod : __webpack_require__(/*! jsonwebtoken */ \"(rsc)/./node_modules/jsonwebtoken/index.js\");\n  const fs = typeof filesystem !== 'undefined' ? filesystem : __webpack_require__(/*! fs */ \"fs\");\n  let privateKey = connectionConfig.getPrivateKey();\n  const privateKeyPath = connectionConfig.getPrivateKeyPath();\n  const privateKeyPass =  connectionConfig.getPrivateKeyPass();\n\n  let jwtToken;\n\n  const LIFETIME = 120; // seconds\n  const ALGORITHM = 'RS256';\n  const ISSUER = 'iss';\n  const SUBJECT = 'sub';\n  const EXPIRE_TIME = 'exp';\n  const ISSUE_TIME = 'iat';\n\n  /**\n   * Update JSON body with token.\n   *\n   * @param {JSON} body\n   *\n   * @returns {null}\n   */\n  this.updateBody = function (body) {\n    body['data']['TOKEN'] = jwtToken;\n  };\n\n  /**\n   * Load private key from specified file location.\n   *\n   * @param {String} privateKeyPath\n   * @param {String} privateKeyPass\n   *\n   * @returns {String} the private key.\n   */\n  function loadPrivateKey(privateKeyPath, privateKeyPass) {\n    // Load private key file\n    const privateKeyFile = fs.readFileSync(privateKeyPath);\n\n    let privateKeyObject;\n\n    // For encrypted private key\n    if (privateKeyPass) {\n      // Get private key with passphrase\n      privateKeyObject = crypto.createPrivateKey({\n        key: privateKeyFile,\n        format: 'pem',\n        passphrase: privateKeyPass\n      });\n\n    } else { // For unencrypted private key\n      privateKeyObject = crypto.createPrivateKey({\n        key: privateKeyFile,\n        format: 'pem'\n      });\n    }\n\n    const privateKey = privateKeyObject.export({\n      format: 'pem',\n      type: 'pkcs8'\n    });\n\n    return privateKey;\n  }\n\n  /**\n   * Get public key fingerprint from private key.\n   *\n   * @param {String} privateKey\n   *\n   * @returns {String} the public key fingerprint.\n   */\n  function calculatePublicKeyFingerprint(privateKey) {\n    // Extract public key object from private key\n    const pubKeyObject = crypto.createPublicKey({\n      key: privateKey,\n      format: 'pem'\n    });\n\n    // Obtain public key string\n    const publicKey = pubKeyObject.export({\n      format: 'der',\n      type: 'spki'\n    });\n\n    // Generate SHA256 hash of public key and encode in base64\n    const publicKeyFingerprint = 'SHA256:' +\n      crypto.createHash('sha256')\n        .update(publicKey, 'utf8')\n        .digest('base64');\n\n    return publicKeyFingerprint;\n  }\n\n  /**\n   * Generate JWT token using RS256 algorithm.\n   *\n   * @param {String} authenticator\n   * @param {String} serviceName\n   * @param {String} account\n   * @param {String} username\n   *\n   * @returns {null}\n   */\n  this.authenticate = async function (authenticator, serviceName, account, username) {\n    let publicKeyFingerprint;\n\n    // Use private key if already set in connection string, otherwise use private key file location\n    if (privateKey) {\n      // Get public key fingerprint\n      publicKeyFingerprint = calculatePublicKeyFingerprint(privateKey);\n    } else if (privateKeyPath) {\n      // Extract private key and get fingerprint\n      privateKey = loadPrivateKey(privateKeyPath, privateKeyPass);\n      publicKeyFingerprint = calculatePublicKeyFingerprint(privateKey);\n    }\n\n    // Current time + 120 seconds\n    const currentTime = Date.now();\n    const jwtTokenExp = currentTime + (LIFETIME * 1000);\n\n    // Create payload containing jwt token and lifetime span\n    const payload = {\n      [ISSUER]: util.format('%s.%s.%s', account.toUpperCase(), username.toUpperCase(), publicKeyFingerprint),\n      [SUBJECT]: util.format('%s.%s', account.toUpperCase(), username.toUpperCase()),\n      [ISSUE_TIME]: currentTime,\n      [EXPIRE_TIME]: jwtTokenExp\n    };\n\n    // Sign payload with RS256 algorithm\n    jwtToken = jwt.sign(payload, privateKey, { algorithm: ALGORITHM });\n  };\n\n  this.reauthenticate = async function (body) {\n    this.authenticate(connectionConfig.getAuthenticator(),\n      connectionConfig.getServiceName(),\n      connectionConfig.account,\n      connectionConfig.username);\n\n    this.updateBody(body);\n  };\n}\n\nmodule.exports = AuthKeypair;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYXV0aGVudGljYXRpb24vYXV0aF9rZXlwYWlyLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQywrREFBUzs7QUFFOUI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsZ0VBQWdFLG1CQUFPLENBQUMsc0JBQVE7QUFDaEYsdURBQXVELG1CQUFPLENBQUMsZ0VBQWM7QUFDN0UsOERBQThELG1CQUFPLENBQUMsY0FBSTtBQUMxRTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQLE1BQU0sT0FBTztBQUNiO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxzQkFBc0I7QUFDckU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYXV0aGVudGljYXRpb24vYXV0aF9rZXlwYWlyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGtleS1wYWlyIGF1dGhlbnRpY2F0b3IuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHByaXZhdGVLZXlcbiAqIEBwYXJhbSB7U3RyaW5nfSBwcml2YXRlS2V5UGF0aFxuICogQHBhcmFtIHtTdHJpbmd9IHByaXZhdGVLZXlQYXNzXG4gKiBAcGFyYW0ge21vZHVsZX0gY3J5cHRvbW9kXG4gKiBAcGFyYW0ge21vZHVsZX0gand0bW9kXG4gKiBAcGFyYW0ge21vZHVsZX0gZmlsZXN5c3RlbVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQXV0aEtleXBhaXIoY29ubmVjdGlvbkNvbmZpZywgY3J5cHRvbW9kLCBqd3Rtb2QsIGZpbGVzeXN0ZW0pIHtcbiAgY29uc3QgY3J5cHRvID0gdHlwZW9mIGNyeXB0b21vZCAhPT0gJ3VuZGVmaW5lZCcgPyBjcnlwdG9tb2QgOiByZXF1aXJlKCdjcnlwdG8nKTtcbiAgY29uc3Qgand0ID0gdHlwZW9mIGp3dG1vZCAhPT0gJ3VuZGVmaW5lZCcgPyBqd3Rtb2QgOiByZXF1aXJlKCdqc29ud2VidG9rZW4nKTtcbiAgY29uc3QgZnMgPSB0eXBlb2YgZmlsZXN5c3RlbSAhPT0gJ3VuZGVmaW5lZCcgPyBmaWxlc3lzdGVtIDogcmVxdWlyZSgnZnMnKTtcbiAgbGV0IHByaXZhdGVLZXkgPSBjb25uZWN0aW9uQ29uZmlnLmdldFByaXZhdGVLZXkoKTtcbiAgY29uc3QgcHJpdmF0ZUtleVBhdGggPSBjb25uZWN0aW9uQ29uZmlnLmdldFByaXZhdGVLZXlQYXRoKCk7XG4gIGNvbnN0IHByaXZhdGVLZXlQYXNzID0gIGNvbm5lY3Rpb25Db25maWcuZ2V0UHJpdmF0ZUtleVBhc3MoKTtcblxuICBsZXQgand0VG9rZW47XG5cbiAgY29uc3QgTElGRVRJTUUgPSAxMjA7IC8vIHNlY29uZHNcbiAgY29uc3QgQUxHT1JJVEhNID0gJ1JTMjU2JztcbiAgY29uc3QgSVNTVUVSID0gJ2lzcyc7XG4gIGNvbnN0IFNVQkpFQ1QgPSAnc3ViJztcbiAgY29uc3QgRVhQSVJFX1RJTUUgPSAnZXhwJztcbiAgY29uc3QgSVNTVUVfVElNRSA9ICdpYXQnO1xuXG4gIC8qKlxuICAgKiBVcGRhdGUgSlNPTiBib2R5IHdpdGggdG9rZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7SlNPTn0gYm9keVxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICovXG4gIHRoaXMudXBkYXRlQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgYm9keVsnZGF0YSddWydUT0tFTiddID0gand0VG9rZW47XG4gIH07XG5cbiAgLyoqXG4gICAqIExvYWQgcHJpdmF0ZSBrZXkgZnJvbSBzcGVjaWZpZWQgZmlsZSBsb2NhdGlvbi5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHByaXZhdGVLZXlQYXRoXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBwcml2YXRlS2V5UGFzc1xuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgcHJpdmF0ZSBrZXkuXG4gICAqL1xuICBmdW5jdGlvbiBsb2FkUHJpdmF0ZUtleShwcml2YXRlS2V5UGF0aCwgcHJpdmF0ZUtleVBhc3MpIHtcbiAgICAvLyBMb2FkIHByaXZhdGUga2V5IGZpbGVcbiAgICBjb25zdCBwcml2YXRlS2V5RmlsZSA9IGZzLnJlYWRGaWxlU3luYyhwcml2YXRlS2V5UGF0aCk7XG5cbiAgICBsZXQgcHJpdmF0ZUtleU9iamVjdDtcblxuICAgIC8vIEZvciBlbmNyeXB0ZWQgcHJpdmF0ZSBrZXlcbiAgICBpZiAocHJpdmF0ZUtleVBhc3MpIHtcbiAgICAgIC8vIEdldCBwcml2YXRlIGtleSB3aXRoIHBhc3NwaHJhc2VcbiAgICAgIHByaXZhdGVLZXlPYmplY3QgPSBjcnlwdG8uY3JlYXRlUHJpdmF0ZUtleSh7XG4gICAgICAgIGtleTogcHJpdmF0ZUtleUZpbGUsXG4gICAgICAgIGZvcm1hdDogJ3BlbScsXG4gICAgICAgIHBhc3NwaHJhc2U6IHByaXZhdGVLZXlQYXNzXG4gICAgICB9KTtcblxuICAgIH0gZWxzZSB7IC8vIEZvciB1bmVuY3J5cHRlZCBwcml2YXRlIGtleVxuICAgICAgcHJpdmF0ZUtleU9iamVjdCA9IGNyeXB0by5jcmVhdGVQcml2YXRlS2V5KHtcbiAgICAgICAga2V5OiBwcml2YXRlS2V5RmlsZSxcbiAgICAgICAgZm9ybWF0OiAncGVtJ1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IHByaXZhdGVLZXlPYmplY3QuZXhwb3J0KHtcbiAgICAgIGZvcm1hdDogJ3BlbScsXG4gICAgICB0eXBlOiAncGtjczgnXG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJpdmF0ZUtleTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgcHVibGljIGtleSBmaW5nZXJwcmludCBmcm9tIHByaXZhdGUga2V5LlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJpdmF0ZUtleVxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgcHVibGljIGtleSBmaW5nZXJwcmludC5cbiAgICovXG4gIGZ1bmN0aW9uIGNhbGN1bGF0ZVB1YmxpY0tleUZpbmdlcnByaW50KHByaXZhdGVLZXkpIHtcbiAgICAvLyBFeHRyYWN0IHB1YmxpYyBrZXkgb2JqZWN0IGZyb20gcHJpdmF0ZSBrZXlcbiAgICBjb25zdCBwdWJLZXlPYmplY3QgPSBjcnlwdG8uY3JlYXRlUHVibGljS2V5KHtcbiAgICAgIGtleTogcHJpdmF0ZUtleSxcbiAgICAgIGZvcm1hdDogJ3BlbSdcbiAgICB9KTtcblxuICAgIC8vIE9idGFpbiBwdWJsaWMga2V5IHN0cmluZ1xuICAgIGNvbnN0IHB1YmxpY0tleSA9IHB1YktleU9iamVjdC5leHBvcnQoe1xuICAgICAgZm9ybWF0OiAnZGVyJyxcbiAgICAgIHR5cGU6ICdzcGtpJ1xuICAgIH0pO1xuXG4gICAgLy8gR2VuZXJhdGUgU0hBMjU2IGhhc2ggb2YgcHVibGljIGtleSBhbmQgZW5jb2RlIGluIGJhc2U2NFxuICAgIGNvbnN0IHB1YmxpY0tleUZpbmdlcnByaW50ID0gJ1NIQTI1NjonICtcbiAgICAgIGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgICAgICAudXBkYXRlKHB1YmxpY0tleSwgJ3V0ZjgnKVxuICAgICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIHJldHVybiBwdWJsaWNLZXlGaW5nZXJwcmludDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBKV1QgdG9rZW4gdXNpbmcgUlMyNTYgYWxnb3JpdGhtLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gYXV0aGVudGljYXRvclxuICAgKiBAcGFyYW0ge1N0cmluZ30gc2VydmljZU5hbWVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lXG4gICAqXG4gICAqIEByZXR1cm5zIHtudWxsfVxuICAgKi9cbiAgdGhpcy5hdXRoZW50aWNhdGUgPSBhc3luYyBmdW5jdGlvbiAoYXV0aGVudGljYXRvciwgc2VydmljZU5hbWUsIGFjY291bnQsIHVzZXJuYW1lKSB7XG4gICAgbGV0IHB1YmxpY0tleUZpbmdlcnByaW50O1xuXG4gICAgLy8gVXNlIHByaXZhdGUga2V5IGlmIGFscmVhZHkgc2V0IGluIGNvbm5lY3Rpb24gc3RyaW5nLCBvdGhlcndpc2UgdXNlIHByaXZhdGUga2V5IGZpbGUgbG9jYXRpb25cbiAgICBpZiAocHJpdmF0ZUtleSkge1xuICAgICAgLy8gR2V0IHB1YmxpYyBrZXkgZmluZ2VycHJpbnRcbiAgICAgIHB1YmxpY0tleUZpbmdlcnByaW50ID0gY2FsY3VsYXRlUHVibGljS2V5RmluZ2VycHJpbnQocHJpdmF0ZUtleSk7XG4gICAgfSBlbHNlIGlmIChwcml2YXRlS2V5UGF0aCkge1xuICAgICAgLy8gRXh0cmFjdCBwcml2YXRlIGtleSBhbmQgZ2V0IGZpbmdlcnByaW50XG4gICAgICBwcml2YXRlS2V5ID0gbG9hZFByaXZhdGVLZXkocHJpdmF0ZUtleVBhdGgsIHByaXZhdGVLZXlQYXNzKTtcbiAgICAgIHB1YmxpY0tleUZpbmdlcnByaW50ID0gY2FsY3VsYXRlUHVibGljS2V5RmluZ2VycHJpbnQocHJpdmF0ZUtleSk7XG4gICAgfVxuXG4gICAgLy8gQ3VycmVudCB0aW1lICsgMTIwIHNlY29uZHNcbiAgICBjb25zdCBjdXJyZW50VGltZSA9IERhdGUubm93KCk7XG4gICAgY29uc3Qgand0VG9rZW5FeHAgPSBjdXJyZW50VGltZSArIChMSUZFVElNRSAqIDEwMDApO1xuXG4gICAgLy8gQ3JlYXRlIHBheWxvYWQgY29udGFpbmluZyBqd3QgdG9rZW4gYW5kIGxpZmV0aW1lIHNwYW5cbiAgICBjb25zdCBwYXlsb2FkID0ge1xuICAgICAgW0lTU1VFUl06IHV0aWwuZm9ybWF0KCclcy4lcy4lcycsIGFjY291bnQudG9VcHBlckNhc2UoKSwgdXNlcm5hbWUudG9VcHBlckNhc2UoKSwgcHVibGljS2V5RmluZ2VycHJpbnQpLFxuICAgICAgW1NVQkpFQ1RdOiB1dGlsLmZvcm1hdCgnJXMuJXMnLCBhY2NvdW50LnRvVXBwZXJDYXNlKCksIHVzZXJuYW1lLnRvVXBwZXJDYXNlKCkpLFxuICAgICAgW0lTU1VFX1RJTUVdOiBjdXJyZW50VGltZSxcbiAgICAgIFtFWFBJUkVfVElNRV06IGp3dFRva2VuRXhwXG4gICAgfTtcblxuICAgIC8vIFNpZ24gcGF5bG9hZCB3aXRoIFJTMjU2IGFsZ29yaXRobVxuICAgIGp3dFRva2VuID0gand0LnNpZ24ocGF5bG9hZCwgcHJpdmF0ZUtleSwgeyBhbGdvcml0aG06IEFMR09SSVRITSB9KTtcbiAgfTtcblxuICB0aGlzLnJlYXV0aGVudGljYXRlID0gYXN5bmMgZnVuY3Rpb24gKGJvZHkpIHtcbiAgICB0aGlzLmF1dGhlbnRpY2F0ZShjb25uZWN0aW9uQ29uZmlnLmdldEF1dGhlbnRpY2F0b3IoKSxcbiAgICAgIGNvbm5lY3Rpb25Db25maWcuZ2V0U2VydmljZU5hbWUoKSxcbiAgICAgIGNvbm5lY3Rpb25Db25maWcuYWNjb3VudCxcbiAgICAgIGNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUpO1xuXG4gICAgdGhpcy51cGRhdGVCb2R5KGJvZHkpO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEF1dGhLZXlwYWlyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_keypair.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_oauth.js":
/*!*********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/authentication/auth_oauth.js ***!
  \*********************************************************************/
/***/ ((module) => {

eval("/**\n * Creates an oauth authenticator.\n *\n * @param {String} token\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthOauth(token) {\n  /**\n   * Update JSON body with token.\n   *\n   * @param {JSON} body\n   *\n   * @returns {null}\n   */\n  this.updateBody = function (body) {\n    body['data']['TOKEN'] = token;\n  };\n\n  this.authenticate = async function () {};\n}\n\nmodule.exports = AuthOauth;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYXV0aGVudGljYXRpb24vYXV0aF9vYXV0aC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYXV0aGVudGljYXRpb24vYXV0aF9vYXV0aC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENyZWF0ZXMgYW4gb2F1dGggYXV0aGVudGljYXRvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdG9rZW5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEF1dGhPYXV0aCh0b2tlbikge1xuICAvKipcbiAgICogVXBkYXRlIEpTT04gYm9keSB3aXRoIHRva2VuLlxuICAgKlxuICAgKiBAcGFyYW0ge0pTT059IGJvZHlcbiAgICpcbiAgICogQHJldHVybnMge251bGx9XG4gICAqL1xuICB0aGlzLnVwZGF0ZUJvZHkgPSBmdW5jdGlvbiAoYm9keSkge1xuICAgIGJvZHlbJ2RhdGEnXVsnVE9LRU4nXSA9IHRva2VuO1xuICB9O1xuXG4gIHRoaXMuYXV0aGVudGljYXRlID0gYXN5bmMgZnVuY3Rpb24gKCkge307XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0aE9hdXRoO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_oauth.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_okta.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/authentication/auth_okta.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst rest = (__webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/lib/global_config.js\").rest);\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\n\n/**\n * Creates an okta authenticator.\n *\n * @param {Object} connectionConfig\n * @param {HttpClient} httpClient\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthOkta(connectionConfig, httpClient) {\n  const password = connectionConfig.password;\n  const region = connectionConfig.region;\n  const account = connectionConfig.account;\n  const clientAppId = connectionConfig.getClientType();\n  const clientAppVersion = connectionConfig.getClientVersion();\n  const host = util.constructHostname(region, account);\n  const port = rest.HTTPS_PORT;\n  const protocol = rest.HTTPS_PROTOCOL;\n  let user;\n  let ssoUrl;\n  let tokenUrl;\n  let samlResponse;\n\n  /**\n   * Update JSON body with saml response.\n   *\n   * @param {JSON} body\n   *\n   * @returns {null}\n   */\n  this.updateBody = function (body) {\n    body['data']['RAW_SAML_RESPONSE'] = samlResponse;\n  };\n\n  /**\n  * Obtain saml response from Okta.\n  *\n  * @param {String} authenticator\n  * @param {String} serviceName\n  * @param {String} account\n  * @param {String} username\n  *\n  * @returns {null}\n  */\n  this.authenticate = async function (authenticator, serviceName, account, username) {\n    const response = await getAuthURLs(authenticator, serviceName, account, username);\n    const responseData = response['data'];\n    const success = responseData['success'];\n    const errorCode = responseData['code'];\n    const errorMessage = responseData['message'];\n    user = username;\n\n    if (typeof success === 'undefined' || errorCode === 'undefined' || errorMessage === 'undefined') {\n      throw new Error('Unable to use provided Okta address as an authenticator. Is the authenticator URL correct?');\n    }\n\n    if (success !== true) {\n      throw new Error(`Unable to use provided Okta address as an authenticator. Error code: ${errorCode}, error message: ${errorMessage}`);\n    }\n\n    ssoUrl = responseData['data']['ssoUrl'];\n    tokenUrl = responseData['data']['tokenUrl'];\n\n    this.validateURLs(authenticator, ssoUrl, tokenUrl);\n    \n    const responseHtml = await getSAMLResponse( await createAccessToken(tokenUrl, username, password), ssoUrl);\n\n    validateSAML(responseHtml);\n  };\n\n  this.reauthenticate = async function (body, retryOption) {\n    const maxRetryTimeout = connectionConfig.getRetryTimeout();\n    const maxRetryCount = connectionConfig.getRetrySfMaxLoginRetries();\n    const remainingTimeout =  (maxRetryTimeout - retryOption.totalElapsedTime) * 1000;\n\n    const startTime = Date.now();\n    const authRetryOption = {\n      maxRetryCount,\n      numRetries: retryOption.numRetries, \n      startTime,\n      remainingTimeout,\n      maxRetryTimeout,\n    };\n\n    let responseHtml;\n\n    while (util.shouldRetryOktaAuth(authRetryOption)) {\n      try { \n        responseHtml = await getSAMLResponse( await createAccessToken(tokenUrl, user, password), ssoUrl);\n        break;\n      } catch (err) {   \n        Logger.getInstance().debug('getSAMLResponse: refresh token for re-authentication');\n        authRetryOption.numRetries++;\n      }\n    }\n    if (remainingTimeout !== 0 && startTime + remainingTimeout  < Date.now()) {\n      Logger.getInstance().warn(`getSAMLResponse: Fail to get SAML response, timeout reached: ${remainingTimeout} miliseconds`);\n      throw new Error('Reached out to the Login Timeout');\n    }\n\n    if (maxRetryCount < authRetryOption.numRetries){\n      Logger.getInstance().warn(`getSAMLResponse: Fail to get SAML response, max retry reached: ${maxRetryCount} time`);\n      throw new Error('Reached out to the max retry count');\n    }\n    retryOption.totalElapsedTime += ((Date.now() - startTime) / 1000);\n    retryOption.numRetries = authRetryOption.numRetries;\n    validateSAML(responseHtml);\n\n    this.updateBody(body);\n  }; \n\n  /**\n  *\n  * @param {String} authenticator\n  * @param {String} serviceName\n  * @param {String} account\n  * @param {String} username\n  *\n  * @returns {Object}\n  */\n  async function getAuthURLs(authenticator, serviceName, account, username) {\n    // Create URL to send POST request to\n    const url = protocol + '://' + host + '/session/authenticator-request';\n\n    let header;\n    if (serviceName) {\n      header = {\n        'HTTP_HEADER_SERVICE_NAME': serviceName\n      };\n    }\n\n    // JSON body to send with POST request\n    const body = {\n      'data': {\n        'ACCOUNT_NAME': account,\n        'LOGIN_NAME': username,\n        'PORT': port,\n        'PROTOCOL': protocol,\n        'AUTHENTICATOR': authenticator,\n        'CLIENT_APP_ID': clientAppId,\n        'CLIENT_APP_VERSION': clientAppVersion\n      }\n    };\n\n    // POST request to get SSO URL and token URL\n    return await httpClient.post(url, body, {\n      headers: header\n    });\n  }\n\n  /**\n  *\n  * @param {String} authenticator\n  * @param {String} ssoUrl\n  * @param {String} tokenUrl\n  *\n  * @returns {null}\n  */\n  this.validateURLs = function (authenticator, ssoUrl, tokenUrl) {\n    const compareUrlsByProtocolAndHost =  (firstUrl, secondUrl) => firstUrl.protocol === secondUrl.protocol && firstUrl.host === secondUrl.host;\n\n    try {\n      const aUrl = new URL(authenticator);\n      const sUrl = new URL(ssoUrl);\n      const tUrl = new URL(tokenUrl);\n      if (!(compareUrlsByProtocolAndHost(aUrl, sUrl) && compareUrlsByProtocolAndHost(aUrl, tUrl))) {\n        throw new Error('The prefix of the SSO/token URL and the specified authenticator do not match.');\n      }\n    } catch (err) {\n      // we did not get a valid URL to test\n      if (err instanceof TypeError) {\n        throw new Error('Authenticator, SSO, or token URL is invalid.');\n      } else {\n        throw err;\n      }\n    }\n  };\n\n  /**\n  *\n  * @param {String} tokenUrl\n  * @param {String} username\n  * @param {String} password\n  *\n  * @returns {Object}\n  */\n  async function createAccessToken(tokenUrl, username, password) {\n    // JSON body to send with POST request\n    const body = {\n      'username': username,\n      'password': password\n    };\n\n    // Query IDP token url to authenticate and retrieve access token\n    const response = await httpClient.post(tokenUrl, body);\n    const data = response['data'];\n    let oneTimeToken;\n  \n    if (data['sessionToken']) {\n      oneTimeToken = data['sessionToken'];\n    } else {\n      oneTimeToken = data['cookieToken'];\n    }\n    return oneTimeToken;\n  }\n\n  /**\n  *\n  * @param {String} oneTimeToken\n  * @param {String} ssoUrl\n  *\n  * @returns {Object}\n  */\n  async function getSAMLResponse(oneTimeToken, ssoUrl) {\n    // Query IDP URL to get SAML response\n    const response = await httpClient.get(ssoUrl, {\n      params: {\n        'RelayState': '/some/deep/link',\n        'onetimetoken': oneTimeToken,\n      } }\n    );\n\n    return response['data'];\n  }\n\n  /**\n  *\n  * @param {String} responseHtml\n  *\n  * @returns {null}\n  */\n  function validateSAML(responseHtml) {\n    const postBackUrl = getPostBackUrlFromHtml(responseHtml);\n    const fullUrl = util.format('%s://%s:%s', protocol, host, port);    \n\n    // Validate the post back url come back with the SAML response\n    // contains the same prefix as the Snowflake's server url, which is the\n    // intended destination url to Snowflake.\n    if (!connectionConfig.getDisableSamlURLCheck()) {\n      if (postBackUrl.substring(0, 20) !== fullUrl.substring(0, 20)) {\n        throw new Error(util.format('The specified authenticator and destination URL ' +\n          'in the SAML assertion do not match: expected: %s postback: %s', fullUrl, postBackUrl));      \n      }\n    }\n    samlResponse = responseHtml;\n  }\n\n  /**\n  * Extract the postback URL from the HTML response.\n  *\n  * @param {String} html\n  *\n  * @returns {String}\n  */\n  function getPostBackUrlFromHtml(html) {\n    const index = html.search('<form');\n    const startIndex = html.indexOf('action=\"', index);\n    const endIndex = html.indexOf('\"', startIndex + 8);\n\n    return unescapeHtml(html.substring(startIndex + 8, endIndex));\n  }\n\n  /**\n  * Unescape the HTML hex characters in the string.\n  *\n  * @param {String} html\n  *\n  * @returns {String}\n  */\n  function unescapeHtml(html) {\n    return html\n      .replace(/&#x3a;/g, ':')\n      .replace(/&#x2f;/g, '/');\n  }\n}\n\nmodule.exports = AuthOkta;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYXV0aGVudGljYXRpb24vYXV0aF9va3RhLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQywrREFBUztBQUM5QixhQUFhLDZHQUFnQztBQUM3QyxlQUFlLG1CQUFPLENBQUMsbUVBQVc7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4RkFBOEYsVUFBVSxtQkFBbUIsYUFBYTtBQUN4STs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdHQUFnRyxrQkFBa0I7QUFDbEg7QUFDQTs7QUFFQTtBQUNBLGtHQUFrRyxlQUFlO0FBQ2pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2F1dGhlbnRpY2F0aW9uL2F1dGhfb2t0YS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgcmVzdCA9IHJlcXVpcmUoJy4uL2dsb2JhbF9jb25maWcnKS5yZXN0O1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBva3RhIGF1dGhlbnRpY2F0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBwYXJhbSB7SHR0cENsaWVudH0gaHR0cENsaWVudFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQXV0aE9rdGEoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCkge1xuICBjb25zdCBwYXNzd29yZCA9IGNvbm5lY3Rpb25Db25maWcucGFzc3dvcmQ7XG4gIGNvbnN0IHJlZ2lvbiA9IGNvbm5lY3Rpb25Db25maWcucmVnaW9uO1xuICBjb25zdCBhY2NvdW50ID0gY29ubmVjdGlvbkNvbmZpZy5hY2NvdW50O1xuICBjb25zdCBjbGllbnRBcHBJZCA9IGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VHlwZSgpO1xuICBjb25zdCBjbGllbnRBcHBWZXJzaW9uID0gY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRWZXJzaW9uKCk7XG4gIGNvbnN0IGhvc3QgPSB1dGlsLmNvbnN0cnVjdEhvc3RuYW1lKHJlZ2lvbiwgYWNjb3VudCk7XG4gIGNvbnN0IHBvcnQgPSByZXN0LkhUVFBTX1BPUlQ7XG4gIGNvbnN0IHByb3RvY29sID0gcmVzdC5IVFRQU19QUk9UT0NPTDtcbiAgbGV0IHVzZXI7XG4gIGxldCBzc29Vcmw7XG4gIGxldCB0b2tlblVybDtcbiAgbGV0IHNhbWxSZXNwb25zZTtcblxuICAvKipcbiAgICogVXBkYXRlIEpTT04gYm9keSB3aXRoIHNhbWwgcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7SlNPTn0gYm9keVxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICovXG4gIHRoaXMudXBkYXRlQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgYm9keVsnZGF0YSddWydSQVdfU0FNTF9SRVNQT05TRSddID0gc2FtbFJlc3BvbnNlO1xuICB9O1xuXG4gIC8qKlxuICAqIE9idGFpbiBzYW1sIHJlc3BvbnNlIGZyb20gT2t0YS5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBhdXRoZW50aWNhdG9yXG4gICogQHBhcmFtIHtTdHJpbmd9IHNlcnZpY2VOYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IGFjY291bnRcbiAgKiBAcGFyYW0ge1N0cmluZ30gdXNlcm5hbWVcbiAgKlxuICAqIEByZXR1cm5zIHtudWxsfVxuICAqL1xuICB0aGlzLmF1dGhlbnRpY2F0ZSA9IGFzeW5jIGZ1bmN0aW9uIChhdXRoZW50aWNhdG9yLCBzZXJ2aWNlTmFtZSwgYWNjb3VudCwgdXNlcm5hbWUpIHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldEF1dGhVUkxzKGF1dGhlbnRpY2F0b3IsIHNlcnZpY2VOYW1lLCBhY2NvdW50LCB1c2VybmFtZSk7XG4gICAgY29uc3QgcmVzcG9uc2VEYXRhID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICBjb25zdCBzdWNjZXNzID0gcmVzcG9uc2VEYXRhWydzdWNjZXNzJ107XG4gICAgY29uc3QgZXJyb3JDb2RlID0gcmVzcG9uc2VEYXRhWydjb2RlJ107XG4gICAgY29uc3QgZXJyb3JNZXNzYWdlID0gcmVzcG9uc2VEYXRhWydtZXNzYWdlJ107XG4gICAgdXNlciA9IHVzZXJuYW1lO1xuXG4gICAgaWYgKHR5cGVvZiBzdWNjZXNzID09PSAndW5kZWZpbmVkJyB8fCBlcnJvckNvZGUgPT09ICd1bmRlZmluZWQnIHx8IGVycm9yTWVzc2FnZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIHVzZSBwcm92aWRlZCBPa3RhIGFkZHJlc3MgYXMgYW4gYXV0aGVudGljYXRvci4gSXMgdGhlIGF1dGhlbnRpY2F0b3IgVVJMIGNvcnJlY3Q/Jyk7XG4gICAgfVxuXG4gICAgaWYgKHN1Y2Nlc3MgIT09IHRydWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIHVzZSBwcm92aWRlZCBPa3RhIGFkZHJlc3MgYXMgYW4gYXV0aGVudGljYXRvci4gRXJyb3IgY29kZTogJHtlcnJvckNvZGV9LCBlcnJvciBtZXNzYWdlOiAke2Vycm9yTWVzc2FnZX1gKTtcbiAgICB9XG5cbiAgICBzc29VcmwgPSByZXNwb25zZURhdGFbJ2RhdGEnXVsnc3NvVXJsJ107XG4gICAgdG9rZW5VcmwgPSByZXNwb25zZURhdGFbJ2RhdGEnXVsndG9rZW5VcmwnXTtcblxuICAgIHRoaXMudmFsaWRhdGVVUkxzKGF1dGhlbnRpY2F0b3IsIHNzb1VybCwgdG9rZW5VcmwpO1xuICAgIFxuICAgIGNvbnN0IHJlc3BvbnNlSHRtbCA9IGF3YWl0IGdldFNBTUxSZXNwb25zZSggYXdhaXQgY3JlYXRlQWNjZXNzVG9rZW4odG9rZW5VcmwsIHVzZXJuYW1lLCBwYXNzd29yZCksIHNzb1VybCk7XG5cbiAgICB2YWxpZGF0ZVNBTUwocmVzcG9uc2VIdG1sKTtcbiAgfTtcblxuICB0aGlzLnJlYXV0aGVudGljYXRlID0gYXN5bmMgZnVuY3Rpb24gKGJvZHksIHJldHJ5T3B0aW9uKSB7XG4gICAgY29uc3QgbWF4UmV0cnlUaW1lb3V0ID0gY29ubmVjdGlvbkNvbmZpZy5nZXRSZXRyeVRpbWVvdXQoKTtcbiAgICBjb25zdCBtYXhSZXRyeUNvdW50ID0gY29ubmVjdGlvbkNvbmZpZy5nZXRSZXRyeVNmTWF4TG9naW5SZXRyaWVzKCk7XG4gICAgY29uc3QgcmVtYWluaW5nVGltZW91dCA9ICAobWF4UmV0cnlUaW1lb3V0IC0gcmV0cnlPcHRpb24udG90YWxFbGFwc2VkVGltZSkgKiAxMDAwO1xuXG4gICAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgICBjb25zdCBhdXRoUmV0cnlPcHRpb24gPSB7XG4gICAgICBtYXhSZXRyeUNvdW50LFxuICAgICAgbnVtUmV0cmllczogcmV0cnlPcHRpb24ubnVtUmV0cmllcywgXG4gICAgICBzdGFydFRpbWUsXG4gICAgICByZW1haW5pbmdUaW1lb3V0LFxuICAgICAgbWF4UmV0cnlUaW1lb3V0LFxuICAgIH07XG5cbiAgICBsZXQgcmVzcG9uc2VIdG1sO1xuXG4gICAgd2hpbGUgKHV0aWwuc2hvdWxkUmV0cnlPa3RhQXV0aChhdXRoUmV0cnlPcHRpb24pKSB7XG4gICAgICB0cnkgeyBcbiAgICAgICAgcmVzcG9uc2VIdG1sID0gYXdhaXQgZ2V0U0FNTFJlc3BvbnNlKCBhd2FpdCBjcmVhdGVBY2Nlc3NUb2tlbih0b2tlblVybCwgdXNlciwgcGFzc3dvcmQpLCBzc29VcmwpO1xuICAgICAgICBicmVhaztcbiAgICAgIH0gY2F0Y2ggKGVycikgeyAgIFxuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnZ2V0U0FNTFJlc3BvbnNlOiByZWZyZXNoIHRva2VuIGZvciByZS1hdXRoZW50aWNhdGlvbicpO1xuICAgICAgICBhdXRoUmV0cnlPcHRpb24ubnVtUmV0cmllcysrO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAocmVtYWluaW5nVGltZW91dCAhPT0gMCAmJiBzdGFydFRpbWUgKyByZW1haW5pbmdUaW1lb3V0ICA8IERhdGUubm93KCkpIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oYGdldFNBTUxSZXNwb25zZTogRmFpbCB0byBnZXQgU0FNTCByZXNwb25zZSwgdGltZW91dCByZWFjaGVkOiAke3JlbWFpbmluZ1RpbWVvdXR9IG1pbGlzZWNvbmRzYCk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWNoZWQgb3V0IHRvIHRoZSBMb2dpbiBUaW1lb3V0Jyk7XG4gICAgfVxuXG4gICAgaWYgKG1heFJldHJ5Q291bnQgPCBhdXRoUmV0cnlPcHRpb24ubnVtUmV0cmllcyl7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBnZXRTQU1MUmVzcG9uc2U6IEZhaWwgdG8gZ2V0IFNBTUwgcmVzcG9uc2UsIG1heCByZXRyeSByZWFjaGVkOiAke21heFJldHJ5Q291bnR9IHRpbWVgKTtcbiAgICAgIHRocm93IG5ldyBFcnJvcignUmVhY2hlZCBvdXQgdG8gdGhlIG1heCByZXRyeSBjb3VudCcpO1xuICAgIH1cbiAgICByZXRyeU9wdGlvbi50b3RhbEVsYXBzZWRUaW1lICs9ICgoRGF0ZS5ub3coKSAtIHN0YXJ0VGltZSkgLyAxMDAwKTtcbiAgICByZXRyeU9wdGlvbi5udW1SZXRyaWVzID0gYXV0aFJldHJ5T3B0aW9uLm51bVJldHJpZXM7XG4gICAgdmFsaWRhdGVTQU1MKHJlc3BvbnNlSHRtbCk7XG5cbiAgICB0aGlzLnVwZGF0ZUJvZHkoYm9keSk7XG4gIH07IFxuXG4gIC8qKlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IGF1dGhlbnRpY2F0b3JcbiAgKiBAcGFyYW0ge1N0cmluZ30gc2VydmljZU5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudFxuICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZVxuICAqXG4gICogQHJldHVybnMge09iamVjdH1cbiAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0QXV0aFVSTHMoYXV0aGVudGljYXRvciwgc2VydmljZU5hbWUsIGFjY291bnQsIHVzZXJuYW1lKSB7XG4gICAgLy8gQ3JlYXRlIFVSTCB0byBzZW5kIFBPU1QgcmVxdWVzdCB0b1xuICAgIGNvbnN0IHVybCA9IHByb3RvY29sICsgJzovLycgKyBob3N0ICsgJy9zZXNzaW9uL2F1dGhlbnRpY2F0b3ItcmVxdWVzdCc7XG5cbiAgICBsZXQgaGVhZGVyO1xuICAgIGlmIChzZXJ2aWNlTmFtZSkge1xuICAgICAgaGVhZGVyID0ge1xuICAgICAgICAnSFRUUF9IRUFERVJfU0VSVklDRV9OQU1FJzogc2VydmljZU5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSlNPTiBib2R5IHRvIHNlbmQgd2l0aCBQT1NUIHJlcXVlc3RcbiAgICBjb25zdCBib2R5ID0ge1xuICAgICAgJ2RhdGEnOiB7XG4gICAgICAgICdBQ0NPVU5UX05BTUUnOiBhY2NvdW50LFxuICAgICAgICAnTE9HSU5fTkFNRSc6IHVzZXJuYW1lLFxuICAgICAgICAnUE9SVCc6IHBvcnQsXG4gICAgICAgICdQUk9UT0NPTCc6IHByb3RvY29sLFxuICAgICAgICAnQVVUSEVOVElDQVRPUic6IGF1dGhlbnRpY2F0b3IsXG4gICAgICAgICdDTElFTlRfQVBQX0lEJzogY2xpZW50QXBwSWQsXG4gICAgICAgICdDTElFTlRfQVBQX1ZFUlNJT04nOiBjbGllbnRBcHBWZXJzaW9uXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIFBPU1QgcmVxdWVzdCB0byBnZXQgU1NPIFVSTCBhbmQgdG9rZW4gVVJMXG4gICAgcmV0dXJuIGF3YWl0IGh0dHBDbGllbnQucG9zdCh1cmwsIGJvZHksIHtcbiAgICAgIGhlYWRlcnM6IGhlYWRlclxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gYXV0aGVudGljYXRvclxuICAqIEBwYXJhbSB7U3RyaW5nfSBzc29VcmxcbiAgKiBAcGFyYW0ge1N0cmluZ30gdG9rZW5VcmxcbiAgKlxuICAqIEByZXR1cm5zIHtudWxsfVxuICAqL1xuICB0aGlzLnZhbGlkYXRlVVJMcyA9IGZ1bmN0aW9uIChhdXRoZW50aWNhdG9yLCBzc29VcmwsIHRva2VuVXJsKSB7XG4gICAgY29uc3QgY29tcGFyZVVybHNCeVByb3RvY29sQW5kSG9zdCA9ICAoZmlyc3RVcmwsIHNlY29uZFVybCkgPT4gZmlyc3RVcmwucHJvdG9jb2wgPT09IHNlY29uZFVybC5wcm90b2NvbCAmJiBmaXJzdFVybC5ob3N0ID09PSBzZWNvbmRVcmwuaG9zdDtcblxuICAgIHRyeSB7XG4gICAgICBjb25zdCBhVXJsID0gbmV3IFVSTChhdXRoZW50aWNhdG9yKTtcbiAgICAgIGNvbnN0IHNVcmwgPSBuZXcgVVJMKHNzb1VybCk7XG4gICAgICBjb25zdCB0VXJsID0gbmV3IFVSTCh0b2tlblVybCk7XG4gICAgICBpZiAoIShjb21wYXJlVXJsc0J5UHJvdG9jb2xBbmRIb3N0KGFVcmwsIHNVcmwpICYmIGNvbXBhcmVVcmxzQnlQcm90b2NvbEFuZEhvc3QoYVVybCwgdFVybCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHByZWZpeCBvZiB0aGUgU1NPL3Rva2VuIFVSTCBhbmQgdGhlIHNwZWNpZmllZCBhdXRoZW50aWNhdG9yIGRvIG5vdCBtYXRjaC4nKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2V0IGEgdmFsaWQgVVJMIHRvIHRlc3RcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBUeXBlRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoZW50aWNhdG9yLCBTU08sIG9yIHRva2VuIFVSTCBpcyBpbnZhbGlkLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlblVybFxuICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBwYXNzd29yZFxuICAqXG4gICogQHJldHVybnMge09iamVjdH1cbiAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQWNjZXNzVG9rZW4odG9rZW5VcmwsIHVzZXJuYW1lLCBwYXNzd29yZCkge1xuICAgIC8vIEpTT04gYm9keSB0byBzZW5kIHdpdGggUE9TVCByZXF1ZXN0XG4gICAgY29uc3QgYm9keSA9IHtcbiAgICAgICd1c2VybmFtZSc6IHVzZXJuYW1lLFxuICAgICAgJ3Bhc3N3b3JkJzogcGFzc3dvcmRcbiAgICB9O1xuXG4gICAgLy8gUXVlcnkgSURQIHRva2VuIHVybCB0byBhdXRoZW50aWNhdGUgYW5kIHJldHJpZXZlIGFjY2VzcyB0b2tlblxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cENsaWVudC5wb3N0KHRva2VuVXJsLCBib2R5KTtcbiAgICBjb25zdCBkYXRhID0gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgICBsZXQgb25lVGltZVRva2VuO1xuICBcbiAgICBpZiAoZGF0YVsnc2Vzc2lvblRva2VuJ10pIHtcbiAgICAgIG9uZVRpbWVUb2tlbiA9IGRhdGFbJ3Nlc3Npb25Ub2tlbiddO1xuICAgIH0gZWxzZSB7XG4gICAgICBvbmVUaW1lVG9rZW4gPSBkYXRhWydjb29raWVUb2tlbiddO1xuICAgIH1cbiAgICByZXR1cm4gb25lVGltZVRva2VuO1xuICB9XG5cbiAgLyoqXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gb25lVGltZVRva2VuXG4gICogQHBhcmFtIHtTdHJpbmd9IHNzb1VybFxuICAqXG4gICogQHJldHVybnMge09iamVjdH1cbiAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gZ2V0U0FNTFJlc3BvbnNlKG9uZVRpbWVUb2tlbiwgc3NvVXJsKSB7XG4gICAgLy8gUXVlcnkgSURQIFVSTCB0byBnZXQgU0FNTCByZXNwb25zZVxuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgaHR0cENsaWVudC5nZXQoc3NvVXJsLCB7XG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgJ1JlbGF5U3RhdGUnOiAnL3NvbWUvZGVlcC9saW5rJyxcbiAgICAgICAgJ29uZXRpbWV0b2tlbic6IG9uZVRpbWVUb2tlbixcbiAgICAgIH0gfVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2VbJ2RhdGEnXTtcbiAgfVxuXG4gIC8qKlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHJlc3BvbnNlSHRtbFxuICAqXG4gICogQHJldHVybnMge251bGx9XG4gICovXG4gIGZ1bmN0aW9uIHZhbGlkYXRlU0FNTChyZXNwb25zZUh0bWwpIHtcbiAgICBjb25zdCBwb3N0QmFja1VybCA9IGdldFBvc3RCYWNrVXJsRnJvbUh0bWwocmVzcG9uc2VIdG1sKTtcbiAgICBjb25zdCBmdWxsVXJsID0gdXRpbC5mb3JtYXQoJyVzOi8vJXM6JXMnLCBwcm90b2NvbCwgaG9zdCwgcG9ydCk7ICAgIFxuXG4gICAgLy8gVmFsaWRhdGUgdGhlIHBvc3QgYmFjayB1cmwgY29tZSBiYWNrIHdpdGggdGhlIFNBTUwgcmVzcG9uc2VcbiAgICAvLyBjb250YWlucyB0aGUgc2FtZSBwcmVmaXggYXMgdGhlIFNub3dmbGFrZSdzIHNlcnZlciB1cmwsIHdoaWNoIGlzIHRoZVxuICAgIC8vIGludGVuZGVkIGRlc3RpbmF0aW9uIHVybCB0byBTbm93Zmxha2UuXG4gICAgaWYgKCFjb25uZWN0aW9uQ29uZmlnLmdldERpc2FibGVTYW1sVVJMQ2hlY2soKSkge1xuICAgICAgaWYgKHBvc3RCYWNrVXJsLnN1YnN0cmluZygwLCAyMCkgIT09IGZ1bGxVcmwuc3Vic3RyaW5nKDAsIDIwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbC5mb3JtYXQoJ1RoZSBzcGVjaWZpZWQgYXV0aGVudGljYXRvciBhbmQgZGVzdGluYXRpb24gVVJMICcgK1xuICAgICAgICAgICdpbiB0aGUgU0FNTCBhc3NlcnRpb24gZG8gbm90IG1hdGNoOiBleHBlY3RlZDogJXMgcG9zdGJhY2s6ICVzJywgZnVsbFVybCwgcG9zdEJhY2tVcmwpKTsgICAgICBcbiAgICAgIH1cbiAgICB9XG4gICAgc2FtbFJlc3BvbnNlID0gcmVzcG9uc2VIdG1sO1xuICB9XG5cbiAgLyoqXG4gICogRXh0cmFjdCB0aGUgcG9zdGJhY2sgVVJMIGZyb20gdGhlIEhUTUwgcmVzcG9uc2UuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICAqXG4gICogQHJldHVybnMge1N0cmluZ31cbiAgKi9cbiAgZnVuY3Rpb24gZ2V0UG9zdEJhY2tVcmxGcm9tSHRtbChodG1sKSB7XG4gICAgY29uc3QgaW5kZXggPSBodG1sLnNlYXJjaCgnPGZvcm0nKTtcbiAgICBjb25zdCBzdGFydEluZGV4ID0gaHRtbC5pbmRleE9mKCdhY3Rpb249XCInLCBpbmRleCk7XG4gICAgY29uc3QgZW5kSW5kZXggPSBodG1sLmluZGV4T2YoJ1wiJywgc3RhcnRJbmRleCArIDgpO1xuXG4gICAgcmV0dXJuIHVuZXNjYXBlSHRtbChodG1sLnN1YnN0cmluZyhzdGFydEluZGV4ICsgOCwgZW5kSW5kZXgpKTtcbiAgfVxuXG4gIC8qKlxuICAqIFVuZXNjYXBlIHRoZSBIVE1MIGhleCBjaGFyYWN0ZXJzIGluIHRoZSBzdHJpbmcuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gaHRtbFxuICAqXG4gICogQHJldHVybnMge1N0cmluZ31cbiAgKi9cbiAgZnVuY3Rpb24gdW5lc2NhcGVIdG1sKGh0bWwpIHtcbiAgICByZXR1cm4gaHRtbFxuICAgICAgLnJlcGxhY2UoLyYjeDNhOy9nLCAnOicpXG4gICAgICAucmVwbGFjZSgvJiN4MmY7L2csICcvJyk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBBdXRoT2t0YTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_okta.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_web.js":
/*!*******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/authentication/auth_web.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst querystring = __webpack_require__(/*! querystring */ \"querystring\");\nconst URLUtil = __webpack_require__(/*! ./../../lib/url_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/url_util.js\");\nconst Util = __webpack_require__(/*! ./../../lib/util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst SsoUrlProvider = __webpack_require__(/*! ../authentication/sso_url_provider */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/sso_url_provider.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst { rest } = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/lib/global_config.js\");\n\n/**\n * Creates an external browser authenticator.\n *\n * @param {Object} connectionConfig\n * @param {Object} httpClient\n * @param {module} webbrowser\n *\n * @returns {Object}\n * @constructor\n */\nfunction AuthWeb(connectionConfig, httpClient, webbrowser) {\n\n  const host = connectionConfig.host;\n  const browserActionTimeout = connectionConfig.getBrowserActionTimeout();\n  const ssoUrlProvider = new SsoUrlProvider(httpClient);\n\n  if (!Util.exists(host)) {\n    throw new Error(`Invalid value for host: ${host}`);\n  }\n  if (!Util.number.isPositiveInteger(browserActionTimeout)) {\n    throw new Error(`Invalid value for browser action timeout: ${browserActionTimeout}`);\n  }\n\n  const open = typeof webbrowser !== 'undefined' ? webbrowser : __webpack_require__(/*! open */ \"(rsc)/./node_modules/open/index.js\");\n\n  let proofKey;\n  let token;\n\n  const successResponse = 'HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nConnection: close\\r\\n\\r\\nYour identity was confirmed and propagated to Snowflake Node.js driver. You can close this window now and go back where you started from.';\n\n  /**\n   * Update JSON body with token and proof_key.\n   *\n   * @param {JSON} body\n   *\n   * @returns {null}\n   */\n  this.updateBody = function (body) {\n    body['data']['TOKEN'] = token;\n    body['data']['PROOF_KEY'] = proofKey;\n    body['data']['AUTHENTICATOR'] = 'EXTERNALBROWSER';\n  };\n\n  /**\n   * Obtain SAML token through SSO URL.\n   *\n   * @param {String} authenticator\n   * @param {String} serviceName\n   * @param {String} account\n   * @param {String} username\n   *\n   * @returns {null}\n   */\n  this.authenticate = async function (authenticator, serviceName, account, username) {\n    let server;\n    let loginUrl;\n\n    const receiveData = new Promise( (resolve) => {\n      // Server to receive SAML token\n      server = createServer(resolve);\n    }).then((result) => {\n      return result;\n    });\n\n    // Use a free random port and set to no backlog\n    server.listen(0, 0);\n\n    if (connectionConfig.getDisableConsoleLogin()) {\n      // Step 1: query Snowflake to obtain SSO url\n      const ssoData = await ssoUrlProvider.getSSOURL(authenticator,\n        serviceName,\n        account,\n        server.address().port,\n        username,\n        host);\n\n      proofKey = ssoData['proofKey'];\n      loginUrl = ssoData['ssoUrl'];\n    } else {\n      proofKey = this.generateProofKey();\n      loginUrl = this.getLoginUrl(username, proofKey, server.address().port);\n    }\n   \n    // Step 2: validate URL\n    if (!URLUtil.isValidURL(loginUrl)) {\n      throw new Error(util.format('Invalid SSO URL found - %s ', loginUrl));\n    }\n\n    // Step 3: open browser\n    open(loginUrl);\n\n    // Step 4: get SAML token\n    const tokenGetHttpLine = await withBrowserActionTimeout(browserActionTimeout, receiveData).catch((rejected) => {\n      server.close();\n      throw new Error(util.format('Error while getting SAML token: %s', rejected));\n    });\n    processGet(tokenGetHttpLine);\n  };\n  \n  this.generateProofKey = function () {\n    const randomness = crypto.randomBytes(32);\n    return Buffer.from(randomness, 'utf8').toString('base64');\n  };\n\n  this.getLoginUrl = function (username, proofKey, port) {\n    const url = new URL(rest.HTTPS_PROTOCOL + '://' + host + '/console/login');\n    url.searchParams.append('login_name', username);\n    url.searchParams.append('proof_key', proofKey);\n    url.searchParams.append('browser_mode_redirect_port', port);\n    return url.toString();\n  };\n\n  /**\n   * Create server to retrieve SAML token.\n   *\n   * @param {Function} resolve\n   *\n   * @returns {Server}\n   */\n  function createServer(resolve) {\n    const server = net.createServer(function (socket) {\n      socket.on('data', function (chunk) {\n        // User successfully entered credentials\n        socket.write(successResponse);\n\n        // Receive the data and split by line\n        const data = chunk.toString().split('\\r\\n');\n\n        socket.destroy();\n\n        // Do not close the server until GET request is received\n        if (!data[0].startsWith('GET /?token=')) {\n          return;\n        }\n\n        server.close();\n        resolve(data[0]);\n      });\n      socket.on('error', (socketErr) => {\n        if (socketErr['code'] === 'ECONNRESET') {\n          socket.end();\n        } else {\n          throw socketErr;\n        }\n      });\n    });\n\n    return server;\n  }\n\n  /**\n   * Parse the GET request and get token parameter value.\n   *\n   * @param {String} tokenHttpGetLine\n   *    \n   * @returns {null}\n   */\n  function processGet(tokenHttpGetLine) {\n    // Split the GET request line\n    const data = tokenHttpGetLine.split(' ');\n\n    // Get value of the \"token\" query parameter\n    token = querystring.parse(data[1])['/?token'];\n  }\n\n  const withBrowserActionTimeout = (millis, promise) => {\n    const timeout = new Promise((resolve, reject) =>\n      setTimeout(\n        () => reject(`Browser action timed out after ${browserActionTimeout} ms.`),\n        millis));\n    return Promise.race([\n      promise,\n      timeout\n    ]);\n  };\n}\n\nmodule.exports = AuthWeb;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYXV0aGVudGljYXRpb24vYXV0aF93ZWIuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLCtEQUFTO0FBQzlCLFlBQVksbUJBQU8sQ0FBQyxnQkFBSztBQUN6QixvQkFBb0IsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN6QyxnQkFBZ0IsbUJBQU8sQ0FBQyxnRkFBc0I7QUFDOUMsYUFBYSxtQkFBTyxDQUFDLHdFQUFrQjtBQUN2Qyx1QkFBdUIsbUJBQU8sQ0FBQyxxSEFBb0M7QUFDbkUsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsaUZBQWtCOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0NBQStDLEtBQUs7QUFDcEQ7QUFDQTtBQUNBLGlFQUFpRSxxQkFBcUI7QUFDdEY7O0FBRUEsZ0VBQWdFLG1CQUFPLENBQUMsZ0RBQU07O0FBRTlFO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxNQUFNO0FBQ25CO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHNCQUFzQjtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoX3dlYi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCBxdWVyeXN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5jb25zdCBVUkxVdGlsID0gcmVxdWlyZSgnLi8uLi8uLi9saWIvdXJsX3V0aWwnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLy4uLy4uL2xpYi91dGlsJyk7XG5jb25zdCBTc29VcmxQcm92aWRlciA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL3Nzb191cmxfcHJvdmlkZXInKTtcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuY29uc3QgeyByZXN0IH0gPSByZXF1aXJlKCcuLi9nbG9iYWxfY29uZmlnJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBleHRlcm5hbCBicm93c2VyIGF1dGhlbnRpY2F0b3IuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBodHRwQ2xpZW50XG4gKiBAcGFyYW0ge21vZHVsZX0gd2ViYnJvd3NlclxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQXV0aFdlYihjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50LCB3ZWJicm93c2VyKSB7XG5cbiAgY29uc3QgaG9zdCA9IGNvbm5lY3Rpb25Db25maWcuaG9zdDtcbiAgY29uc3QgYnJvd3NlckFjdGlvblRpbWVvdXQgPSBjb25uZWN0aW9uQ29uZmlnLmdldEJyb3dzZXJBY3Rpb25UaW1lb3V0KCk7XG4gIGNvbnN0IHNzb1VybFByb3ZpZGVyID0gbmV3IFNzb1VybFByb3ZpZGVyKGh0dHBDbGllbnQpO1xuXG4gIGlmICghVXRpbC5leGlzdHMoaG9zdCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgdmFsdWUgZm9yIGhvc3Q6ICR7aG9zdH1gKTtcbiAgfVxuICBpZiAoIVV0aWwubnVtYmVyLmlzUG9zaXRpdmVJbnRlZ2VyKGJyb3dzZXJBY3Rpb25UaW1lb3V0KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCB2YWx1ZSBmb3IgYnJvd3NlciBhY3Rpb24gdGltZW91dDogJHticm93c2VyQWN0aW9uVGltZW91dH1gKTtcbiAgfVxuXG4gIGNvbnN0IG9wZW4gPSB0eXBlb2Ygd2ViYnJvd3NlciAhPT0gJ3VuZGVmaW5lZCcgPyB3ZWJicm93c2VyIDogcmVxdWlyZSgnb3BlbicpO1xuXG4gIGxldCBwcm9vZktleTtcbiAgbGV0IHRva2VuO1xuXG4gIGNvbnN0IHN1Y2Nlc3NSZXNwb25zZSA9ICdIVFRQLzEuMSAyMDAgT0tcXHJcXG5Db250ZW50LVR5cGU6IHRleHQvcGxhaW5cXHJcXG5Db25uZWN0aW9uOiBjbG9zZVxcclxcblxcclxcbllvdXIgaWRlbnRpdHkgd2FzIGNvbmZpcm1lZCBhbmQgcHJvcGFnYXRlZCB0byBTbm93Zmxha2UgTm9kZS5qcyBkcml2ZXIuIFlvdSBjYW4gY2xvc2UgdGhpcyB3aW5kb3cgbm93IGFuZCBnbyBiYWNrIHdoZXJlIHlvdSBzdGFydGVkIGZyb20uJztcblxuICAvKipcbiAgICogVXBkYXRlIEpTT04gYm9keSB3aXRoIHRva2VuIGFuZCBwcm9vZl9rZXkuXG4gICAqXG4gICAqIEBwYXJhbSB7SlNPTn0gYm9keVxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICovXG4gIHRoaXMudXBkYXRlQm9keSA9IGZ1bmN0aW9uIChib2R5KSB7XG4gICAgYm9keVsnZGF0YSddWydUT0tFTiddID0gdG9rZW47XG4gICAgYm9keVsnZGF0YSddWydQUk9PRl9LRVknXSA9IHByb29mS2V5O1xuICAgIGJvZHlbJ2RhdGEnXVsnQVVUSEVOVElDQVRPUiddID0gJ0VYVEVSTkFMQlJPV1NFUic7XG4gIH07XG5cbiAgLyoqXG4gICAqIE9idGFpbiBTQU1MIHRva2VuIHRocm91Z2ggU1NPIFVSTC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGF1dGhlbnRpY2F0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IHNlcnZpY2VOYW1lXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhY2NvdW50XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VybmFtZVxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICovXG4gIHRoaXMuYXV0aGVudGljYXRlID0gYXN5bmMgZnVuY3Rpb24gKGF1dGhlbnRpY2F0b3IsIHNlcnZpY2VOYW1lLCBhY2NvdW50LCB1c2VybmFtZSkge1xuICAgIGxldCBzZXJ2ZXI7XG4gICAgbGV0IGxvZ2luVXJsO1xuXG4gICAgY29uc3QgcmVjZWl2ZURhdGEgPSBuZXcgUHJvbWlzZSggKHJlc29sdmUpID0+IHtcbiAgICAgIC8vIFNlcnZlciB0byByZWNlaXZlIFNBTUwgdG9rZW5cbiAgICAgIHNlcnZlciA9IGNyZWF0ZVNlcnZlcihyZXNvbHZlKTtcbiAgICB9KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvLyBVc2UgYSBmcmVlIHJhbmRvbSBwb3J0IGFuZCBzZXQgdG8gbm8gYmFja2xvZ1xuICAgIHNlcnZlci5saXN0ZW4oMCwgMCk7XG5cbiAgICBpZiAoY29ubmVjdGlvbkNvbmZpZy5nZXREaXNhYmxlQ29uc29sZUxvZ2luKCkpIHtcbiAgICAgIC8vIFN0ZXAgMTogcXVlcnkgU25vd2ZsYWtlIHRvIG9idGFpbiBTU08gdXJsXG4gICAgICBjb25zdCBzc29EYXRhID0gYXdhaXQgc3NvVXJsUHJvdmlkZXIuZ2V0U1NPVVJMKGF1dGhlbnRpY2F0b3IsXG4gICAgICAgIHNlcnZpY2VOYW1lLFxuICAgICAgICBhY2NvdW50LFxuICAgICAgICBzZXJ2ZXIuYWRkcmVzcygpLnBvcnQsXG4gICAgICAgIHVzZXJuYW1lLFxuICAgICAgICBob3N0KTtcblxuICAgICAgcHJvb2ZLZXkgPSBzc29EYXRhWydwcm9vZktleSddO1xuICAgICAgbG9naW5VcmwgPSBzc29EYXRhWydzc29VcmwnXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvb2ZLZXkgPSB0aGlzLmdlbmVyYXRlUHJvb2ZLZXkoKTtcbiAgICAgIGxvZ2luVXJsID0gdGhpcy5nZXRMb2dpblVybCh1c2VybmFtZSwgcHJvb2ZLZXksIHNlcnZlci5hZGRyZXNzKCkucG9ydCk7XG4gICAgfVxuICAgXG4gICAgLy8gU3RlcCAyOiB2YWxpZGF0ZSBVUkxcbiAgICBpZiAoIVVSTFV0aWwuaXNWYWxpZFVSTChsb2dpblVybCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih1dGlsLmZvcm1hdCgnSW52YWxpZCBTU08gVVJMIGZvdW5kIC0gJXMgJywgbG9naW5VcmwpKTtcbiAgICB9XG5cbiAgICAvLyBTdGVwIDM6IG9wZW4gYnJvd3NlclxuICAgIG9wZW4obG9naW5VcmwpO1xuXG4gICAgLy8gU3RlcCA0OiBnZXQgU0FNTCB0b2tlblxuICAgIGNvbnN0IHRva2VuR2V0SHR0cExpbmUgPSBhd2FpdCB3aXRoQnJvd3NlckFjdGlvblRpbWVvdXQoYnJvd3NlckFjdGlvblRpbWVvdXQsIHJlY2VpdmVEYXRhKS5jYXRjaCgocmVqZWN0ZWQpID0+IHtcbiAgICAgIHNlcnZlci5jbG9zZSgpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWwuZm9ybWF0KCdFcnJvciB3aGlsZSBnZXR0aW5nIFNBTUwgdG9rZW46ICVzJywgcmVqZWN0ZWQpKTtcbiAgICB9KTtcbiAgICBwcm9jZXNzR2V0KHRva2VuR2V0SHR0cExpbmUpO1xuICB9O1xuICBcbiAgdGhpcy5nZW5lcmF0ZVByb29mS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgIGNvbnN0IHJhbmRvbW5lc3MgPSBjcnlwdG8ucmFuZG9tQnl0ZXMoMzIpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShyYW5kb21uZXNzLCAndXRmOCcpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgfTtcblxuICB0aGlzLmdldExvZ2luVXJsID0gZnVuY3Rpb24gKHVzZXJuYW1lLCBwcm9vZktleSwgcG9ydCkge1xuICAgIGNvbnN0IHVybCA9IG5ldyBVUkwocmVzdC5IVFRQU19QUk9UT0NPTCArICc6Ly8nICsgaG9zdCArICcvY29uc29sZS9sb2dpbicpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdsb2dpbl9uYW1lJywgdXNlcm5hbWUpO1xuICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKCdwcm9vZl9rZXknLCBwcm9vZktleSk7XG4gICAgdXJsLnNlYXJjaFBhcmFtcy5hcHBlbmQoJ2Jyb3dzZXJfbW9kZV9yZWRpcmVjdF9wb3J0JywgcG9ydCk7XG4gICAgcmV0dXJuIHVybC50b1N0cmluZygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgc2VydmVyIHRvIHJldHJpZXZlIFNBTUwgdG9rZW4uXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmVcbiAgICpcbiAgICogQHJldHVybnMge1NlcnZlcn1cbiAgICovXG4gIGZ1bmN0aW9uIGNyZWF0ZVNlcnZlcihyZXNvbHZlKSB7XG4gICAgY29uc3Qgc2VydmVyID0gbmV0LmNyZWF0ZVNlcnZlcihmdW5jdGlvbiAoc29ja2V0KSB7XG4gICAgICBzb2NrZXQub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgLy8gVXNlciBzdWNjZXNzZnVsbHkgZW50ZXJlZCBjcmVkZW50aWFsc1xuICAgICAgICBzb2NrZXQud3JpdGUoc3VjY2Vzc1Jlc3BvbnNlKTtcblxuICAgICAgICAvLyBSZWNlaXZlIHRoZSBkYXRhIGFuZCBzcGxpdCBieSBsaW5lXG4gICAgICAgIGNvbnN0IGRhdGEgPSBjaHVuay50b1N0cmluZygpLnNwbGl0KCdcXHJcXG4nKTtcblxuICAgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuXG4gICAgICAgIC8vIERvIG5vdCBjbG9zZSB0aGUgc2VydmVyIHVudGlsIEdFVCByZXF1ZXN0IGlzIHJlY2VpdmVkXG4gICAgICAgIGlmICghZGF0YVswXS5zdGFydHNXaXRoKCdHRVQgLz90b2tlbj0nKSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlcnZlci5jbG9zZSgpO1xuICAgICAgICByZXNvbHZlKGRhdGFbMF0pO1xuICAgICAgfSk7XG4gICAgICBzb2NrZXQub24oJ2Vycm9yJywgKHNvY2tldEVycikgPT4ge1xuICAgICAgICBpZiAoc29ja2V0RXJyWydjb2RlJ10gPT09ICdFQ09OTlJFU0VUJykge1xuICAgICAgICAgIHNvY2tldC5lbmQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBzb2NrZXRFcnI7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHNlcnZlcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXJzZSB0aGUgR0VUIHJlcXVlc3QgYW5kIGdldCB0b2tlbiBwYXJhbWV0ZXIgdmFsdWUuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0b2tlbkh0dHBHZXRMaW5lXG4gICAqICAgIFxuICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICovXG4gIGZ1bmN0aW9uIHByb2Nlc3NHZXQodG9rZW5IdHRwR2V0TGluZSkge1xuICAgIC8vIFNwbGl0IHRoZSBHRVQgcmVxdWVzdCBsaW5lXG4gICAgY29uc3QgZGF0YSA9IHRva2VuSHR0cEdldExpbmUuc3BsaXQoJyAnKTtcblxuICAgIC8vIEdldCB2YWx1ZSBvZiB0aGUgXCJ0b2tlblwiIHF1ZXJ5IHBhcmFtZXRlclxuICAgIHRva2VuID0gcXVlcnlzdHJpbmcucGFyc2UoZGF0YVsxXSlbJy8/dG9rZW4nXTtcbiAgfVxuXG4gIGNvbnN0IHdpdGhCcm93c2VyQWN0aW9uVGltZW91dCA9IChtaWxsaXMsIHByb21pc2UpID0+IHtcbiAgICBjb25zdCB0aW1lb3V0ID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT5cbiAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICgpID0+IHJlamVjdChgQnJvd3NlciBhY3Rpb24gdGltZWQgb3V0IGFmdGVyICR7YnJvd3NlckFjdGlvblRpbWVvdXR9IG1zLmApLFxuICAgICAgICBtaWxsaXMpKTtcbiAgICByZXR1cm4gUHJvbWlzZS5yYWNlKFtcbiAgICAgIHByb21pc2UsXG4gICAgICB0aW1lb3V0XG4gICAgXSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0aFdlYjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_web.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/authentication/authentication.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/authentication/authentication.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const AuthDefault = __webpack_require__(/*! ./auth_default */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_default.js\");\nconst AuthWeb = __webpack_require__(/*! ./auth_web */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_web.js\");\nconst AuthKeypair = __webpack_require__(/*! ./auth_keypair */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_keypair.js\");\nconst AuthOauth = __webpack_require__(/*! ./auth_oauth */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_oauth.js\");\nconst AuthOkta = __webpack_require__(/*! ./auth_okta */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_okta.js\");\nconst AuthIDToken = __webpack_require__(/*! ./auth_idtoken */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_idtoken.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ./authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/authentication_types.js\");\n\n/**\n * Returns the JSON body to be sent when connecting.\n *\n * @param {String} authenticator\n * @param {String} account\n * @param {String} username\n * @param {String} clientType\n * @param {String} clientVersion\n * @param {Object} clientEnv\n *\n * @returns {JSON}\n */\nexports.formAuthJSON = function formAuthJSON(\n  authenticator,\n  account,\n  username,\n  clientType,\n  clientVersion,\n  clientEnv\n) {\n  const body = {\n    data: {\n      ACCOUNT_NAME: account,\n      CLIENT_APP_ID: clientType,\n      CLIENT_APP_VERSION: clientVersion,\n      CLIENT_ENVIRONMENT:\n        {\n          OS: clientEnv.OS,\n          OS_VERSION: clientEnv.OS_VERSION,\n          OCSP_MODE: clientEnv.OCSP_MODE\n        }\n    }\n  };\n  if (!this.isOktaAuth(authenticator)) {\n    body['data']['AUTHENTICATOR'] = authenticator;\n    body['data']['LOGIN_NAME'] = username;\n  }\n\n  return body;\n};\n\n/**\n * Returns the authenticator to use base on the connection configuration.\n *\n * @param {Object} connectionConfig\n * @param httpClient\n *\n * @returns {Object} the authenticator.\n */\nexports.getAuthenticator = function getAuthenticator(connectionConfig, httpClient) {\n  const authType = connectionConfig.getAuthenticator();\n  const openExternalBrowserCallback = connectionConfig.openExternalBrowserCallback; // Important for SSO in the Snowflake VS Code extension\n  let auth;\n  if (authType === AuthenticationTypes.DEFAULT_AUTHENTICATOR || authType === AuthenticationTypes.USER_PWD_MFA_AUTHENTICATOR) {\n    auth = new AuthDefault(connectionConfig);\n  } else if (authType === AuthenticationTypes.EXTERNAL_BROWSER_AUTHENTICATOR) {\n    if (connectionConfig.getClientStoreTemporaryCredential() && !!connectionConfig.idToken) {\n      auth = new AuthIDToken(connectionConfig, httpClient, openExternalBrowserCallback);\n    } else {\n      auth = new AuthWeb(connectionConfig, httpClient, openExternalBrowserCallback);\n    }\n  } else if (authType === AuthenticationTypes.KEY_PAIR_AUTHENTICATOR) {\n    auth = new AuthKeypair(connectionConfig);\n  } else if (authType === AuthenticationTypes.OAUTH_AUTHENTICATOR) {\n    auth = new AuthOauth(connectionConfig.getToken());\n  } else if (this.isOktaAuth(authType)) {\n    auth = new AuthOkta(connectionConfig, httpClient);\n  } else {\n    // Authenticator specified does not exist\n    Logger.getInstance().warn(`No authenticator found for '${authType}'. Using default authenticator as a fallback`);\n    auth = new AuthDefault(connectionConfig);\n  }\n  return auth;\n};\n\n/**\n * Returns the boolean describing if the provided authenticator is okta or not.\n *\n * @param {String} authenticator\n * @returns {boolean}\n */\nexports.isOktaAuth = function isOktaAuth(authenticator) {\n  return authenticator.toUpperCase().startsWith('HTTPS://');\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQUEsb0JBQW9CLG1CQUFPLENBQUMsNkZBQWdCO0FBQzVDLGdCQUFnQixtQkFBTyxDQUFDLHFGQUFZO0FBQ3BDLG9CQUFvQixtQkFBTyxDQUFDLDZGQUFnQjtBQUM1QyxrQkFBa0IsbUJBQU8sQ0FBQyx5RkFBYztBQUN4QyxpQkFBaUIsbUJBQU8sQ0FBQyx1RkFBYTtBQUN0QyxvQkFBb0IsbUJBQU8sQ0FBQyw2RkFBZ0I7QUFDNUMsZUFBZSxtQkFBTyxDQUFDLG1FQUFXO0FBQ2xDLDRCQUE0QixtQkFBTyxDQUFDLDZHQUF3Qjs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxvRkFBb0Y7QUFDcEY7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBLDZEQUE2RCxTQUFTO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBBdXRoRGVmYXVsdCA9IHJlcXVpcmUoJy4vYXV0aF9kZWZhdWx0Jyk7XG5jb25zdCBBdXRoV2ViID0gcmVxdWlyZSgnLi9hdXRoX3dlYicpO1xuY29uc3QgQXV0aEtleXBhaXIgPSByZXF1aXJlKCcuL2F1dGhfa2V5cGFpcicpO1xuY29uc3QgQXV0aE9hdXRoID0gcmVxdWlyZSgnLi9hdXRoX29hdXRoJyk7XG5jb25zdCBBdXRoT2t0YSA9IHJlcXVpcmUoJy4vYXV0aF9va3RhJyk7XG5jb25zdCBBdXRoSURUb2tlbiA9IHJlcXVpcmUoJy4vYXV0aF9pZHRva2VuJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbmNvbnN0IEF1dGhlbnRpY2F0aW9uVHlwZXMgPSByZXF1aXJlKCcuL2F1dGhlbnRpY2F0aW9uX3R5cGVzJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgSlNPTiBib2R5IHRvIGJlIHNlbnQgd2hlbiBjb25uZWN0aW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdXRoZW50aWNhdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudFxuICogQHBhcmFtIHtTdHJpbmd9IHVzZXJuYW1lXG4gKiBAcGFyYW0ge1N0cmluZ30gY2xpZW50VHlwZVxuICogQHBhcmFtIHtTdHJpbmd9IGNsaWVudFZlcnNpb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBjbGllbnRFbnZcbiAqXG4gKiBAcmV0dXJucyB7SlNPTn1cbiAqL1xuZXhwb3J0cy5mb3JtQXV0aEpTT04gPSBmdW5jdGlvbiBmb3JtQXV0aEpTT04oXG4gIGF1dGhlbnRpY2F0b3IsXG4gIGFjY291bnQsXG4gIHVzZXJuYW1lLFxuICBjbGllbnRUeXBlLFxuICBjbGllbnRWZXJzaW9uLFxuICBjbGllbnRFbnZcbikge1xuICBjb25zdCBib2R5ID0ge1xuICAgIGRhdGE6IHtcbiAgICAgIEFDQ09VTlRfTkFNRTogYWNjb3VudCxcbiAgICAgIENMSUVOVF9BUFBfSUQ6IGNsaWVudFR5cGUsXG4gICAgICBDTElFTlRfQVBQX1ZFUlNJT046IGNsaWVudFZlcnNpb24sXG4gICAgICBDTElFTlRfRU5WSVJPTk1FTlQ6XG4gICAgICAgIHtcbiAgICAgICAgICBPUzogY2xpZW50RW52Lk9TLFxuICAgICAgICAgIE9TX1ZFUlNJT046IGNsaWVudEVudi5PU19WRVJTSU9OLFxuICAgICAgICAgIE9DU1BfTU9ERTogY2xpZW50RW52Lk9DU1BfTU9ERVxuICAgICAgICB9XG4gICAgfVxuICB9O1xuICBpZiAoIXRoaXMuaXNPa3RhQXV0aChhdXRoZW50aWNhdG9yKSkge1xuICAgIGJvZHlbJ2RhdGEnXVsnQVVUSEVOVElDQVRPUiddID0gYXV0aGVudGljYXRvcjtcbiAgICBib2R5WydkYXRhJ11bJ0xPR0lOX05BTUUnXSA9IHVzZXJuYW1lO1xuICB9XG5cbiAgcmV0dXJuIGJvZHk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGF1dGhlbnRpY2F0b3IgdG8gdXNlIGJhc2Ugb24gdGhlIGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICogQHBhcmFtIGh0dHBDbGllbnRcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgYXV0aGVudGljYXRvci5cbiAqL1xuZXhwb3J0cy5nZXRBdXRoZW50aWNhdG9yID0gZnVuY3Rpb24gZ2V0QXV0aGVudGljYXRvcihjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50KSB7XG4gIGNvbnN0IGF1dGhUeXBlID0gY29ubmVjdGlvbkNvbmZpZy5nZXRBdXRoZW50aWNhdG9yKCk7XG4gIGNvbnN0IG9wZW5FeHRlcm5hbEJyb3dzZXJDYWxsYmFjayA9IGNvbm5lY3Rpb25Db25maWcub3BlbkV4dGVybmFsQnJvd3NlckNhbGxiYWNrOyAvLyBJbXBvcnRhbnQgZm9yIFNTTyBpbiB0aGUgU25vd2ZsYWtlIFZTIENvZGUgZXh0ZW5zaW9uXG4gIGxldCBhdXRoO1xuICBpZiAoYXV0aFR5cGUgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuREVGQVVMVF9BVVRIRU5USUNBVE9SIHx8IGF1dGhUeXBlID09PSBBdXRoZW50aWNhdGlvblR5cGVzLlVTRVJfUFdEX01GQV9BVVRIRU5USUNBVE9SKSB7XG4gICAgYXV0aCA9IG5ldyBBdXRoRGVmYXVsdChjb25uZWN0aW9uQ29uZmlnKTtcbiAgfSBlbHNlIGlmIChhdXRoVHlwZSA9PT0gQXV0aGVudGljYXRpb25UeXBlcy5FWFRFUk5BTF9CUk9XU0VSX0FVVEhFTlRJQ0FUT1IpIHtcbiAgICBpZiAoY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwoKSAmJiAhIWNvbm5lY3Rpb25Db25maWcuaWRUb2tlbikge1xuICAgICAgYXV0aCA9IG5ldyBBdXRoSURUb2tlbihjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50LCBvcGVuRXh0ZXJuYWxCcm93c2VyQ2FsbGJhY2spO1xuICAgIH0gZWxzZSB7XG4gICAgICBhdXRoID0gbmV3IEF1dGhXZWIoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCwgb3BlbkV4dGVybmFsQnJvd3NlckNhbGxiYWNrKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoYXV0aFR5cGUgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuS0VZX1BBSVJfQVVUSEVOVElDQVRPUikge1xuICAgIGF1dGggPSBuZXcgQXV0aEtleXBhaXIoY29ubmVjdGlvbkNvbmZpZyk7XG4gIH0gZWxzZSBpZiAoYXV0aFR5cGUgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuT0FVVEhfQVVUSEVOVElDQVRPUikge1xuICAgIGF1dGggPSBuZXcgQXV0aE9hdXRoKGNvbm5lY3Rpb25Db25maWcuZ2V0VG9rZW4oKSk7XG4gIH0gZWxzZSBpZiAodGhpcy5pc09rdGFBdXRoKGF1dGhUeXBlKSkge1xuICAgIGF1dGggPSBuZXcgQXV0aE9rdGEoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gQXV0aGVudGljYXRvciBzcGVjaWZpZWQgZG9lcyBub3QgZXhpc3RcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBObyBhdXRoZW50aWNhdG9yIGZvdW5kIGZvciAnJHthdXRoVHlwZX0nLiBVc2luZyBkZWZhdWx0IGF1dGhlbnRpY2F0b3IgYXMgYSBmYWxsYmFja2ApO1xuICAgIGF1dGggPSBuZXcgQXV0aERlZmF1bHQoY29ubmVjdGlvbkNvbmZpZyk7XG4gIH1cbiAgcmV0dXJuIGF1dGg7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGJvb2xlYW4gZGVzY3JpYmluZyBpZiB0aGUgcHJvdmlkZWQgYXV0aGVudGljYXRvciBpcyBva3RhIG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gYXV0aGVudGljYXRvclxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNPa3RhQXV0aCA9IGZ1bmN0aW9uIGlzT2t0YUF1dGgoYXV0aGVudGljYXRvcikge1xuICByZXR1cm4gYXV0aGVudGljYXRvci50b1VwcGVyQ2FzZSgpLnN0YXJ0c1dpdGgoJ0hUVFBTOi8vJyk7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/authentication/authentication.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/authentication/authentication_types.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/authentication/authentication_types.js ***!
  \*******************************************************************************/
/***/ ((module) => {

eval("const AuthenticationTypes =\n{\n  DEFAULT_AUTHENTICATOR: 'SNOWFLAKE', // default authenticator name\n  EXTERNAL_BROWSER_AUTHENTICATOR: 'EXTERNALBROWSER',\n  KEY_PAIR_AUTHENTICATOR: 'SNOWFLAKE_JWT',\n  OAUTH_AUTHENTICATOR: 'OAUTH',\n  USER_PWD_MFA_AUTHENTICATOR: 'USERNAME_PASSWORD_MFA',\n  ID_TOKEN_AUTHENTICATOR: 'ID_TOKEN',\n};\n\nmodule.exports = AuthenticationTypes;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb25fdHlwZXMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uX3R5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEF1dGhlbnRpY2F0aW9uVHlwZXMgPVxue1xuICBERUZBVUxUX0FVVEhFTlRJQ0FUT1I6ICdTTk9XRkxBS0UnLCAvLyBkZWZhdWx0IGF1dGhlbnRpY2F0b3IgbmFtZVxuICBFWFRFUk5BTF9CUk9XU0VSX0FVVEhFTlRJQ0FUT1I6ICdFWFRFUk5BTEJST1dTRVInLFxuICBLRVlfUEFJUl9BVVRIRU5USUNBVE9SOiAnU05PV0ZMQUtFX0pXVCcsXG4gIE9BVVRIX0FVVEhFTlRJQ0FUT1I6ICdPQVVUSCcsXG4gIFVTRVJfUFdEX01GQV9BVVRIRU5USUNBVE9SOiAnVVNFUk5BTUVfUEFTU1dPUkRfTUZBJyxcbiAgSURfVE9LRU5fQVVUSEVOVElDQVRPUjogJ0lEX1RPS0VOJyxcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQXV0aGVudGljYXRpb25UeXBlczsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/authentication/authentication_types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/authentication/secure_storage/json_credential_manager.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/authentication/secure_storage/json_credential_manager.js ***!
  \*************************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const path = __webpack_require__(/*! path */ \"path\");\nconst Logger = __webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst fs = __webpack_require__(/*! node:fs/promises */ \"node:fs/promises\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst { validateOnlyUserReadWritePermissionAndOwner } = __webpack_require__(/*! ../../file_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\");\n\nfunction JsonCredentialManager(credentialCacheDir) {\n  \n  this.getTokenDir = async function () {\n    let tokenDir = credentialCacheDir;\n    if (!Util.exists(tokenDir)) {\n      tokenDir = os.homedir();\n    } else {\n      Logger.getInstance().info(`The credential cache directory is configured by the user. The token will be saved at ${tokenDir}`);\n    }\n\n    if (!Util.exists(tokenDir)) {\n      throw new Error(`Temporary credential cache directory is invalid, and the driver is unable to use the default location(home). \n      Please set 'credentialCacheDir' connection configuration option to enable the default credential manager.`);\n    }\n\n    const tokenCacheFile = path.join(tokenDir, 'temporary_credential.json');\n    await validateOnlyUserReadWritePermissionAndOwner(tokenCacheFile);\n    return tokenCacheFile;\n  };\n   \n  this.readJsonCredentialFile = async function () {\n    try {\n      const cred = await fs.readFile(await this.getTokenDir(), 'utf8');\n      return JSON.parse(cred);\n    } catch (err) {\n      Logger.getInstance().warn('Failed to read token data from the file. Err: %s', err.message);\n      return null;\n    }\n  };\n  \n  this.write = async function (key, token) {\n    if (!validateTokenCacheOption(key)) {\n      return null;\n    }\n  \n    const jsonCredential = await this.readJsonCredentialFile() || {};\n    jsonCredential[key] = token;\n   \n    try {\n      await fs.writeFile(await this.getTokenDir(), JSON.stringify(jsonCredential), { mode: 0o600 });\n    } catch (err) {\n      throw new Error(`Failed to write token data. Please check the permission or the file format of the token. ${err.message}`);\n    }\n  };\n  \n  this.read = async function (key) {\n    if (!validateTokenCacheOption(key)) {\n      return null;\n    }\n\n    const jsonCredential = await this.readJsonCredentialFile();\n    if (!!jsonCredential && jsonCredential[key]){\n      return jsonCredential[key];\n    } else {\n      return null;\n    }\n  };\n  \n  this.remove = async function (key) {\n    if (!validateTokenCacheOption(key)) {\n      return null;\n    }\n    const jsonCredential = await this.readJsonCredentialFile();\n    \n    if (jsonCredential && jsonCredential[key]) {\n      try {\n        jsonCredential[key] = null;\n        await fs.writeFile(await this.getTokenDir(), JSON.stringify(jsonCredential), { mode: 0o600 });\n      } catch (err) {\n        throw new Error(`Failed to write token data from the file in ${await this.getTokenDir()}. Please check the permission or the file format of the token. ${err.message}`);\n      } \n    }\n  };\n\n  function validateTokenCacheOption(key) {\n    return Util.checkParametersDefined(key); \n  }\n}\n\nmodule.exports = JsonCredentialManager;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYXV0aGVudGljYXRpb24vc2VjdXJlX3N0b3JhZ2UvanNvbl9jcmVkZW50aWFsX21hbmFnZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxzRUFBYztBQUNyQyxXQUFXLG1CQUFPLENBQUMsMENBQWtCO0FBQ3JDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxrRUFBWTtBQUNqQyxRQUFRLDhDQUE4QyxFQUFFLG1CQUFPLENBQUMsNEVBQWlCOztBQUVqRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sd0hBQXdILFNBQVM7QUFDakk7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsYUFBYTtBQUNsRyxNQUFNO0FBQ04sa0hBQWtILFlBQVk7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGLGFBQWE7QUFDcEcsUUFBUTtBQUNSLHVFQUF1RSx5QkFBeUIsaUVBQWlFLFlBQVk7QUFDN0s7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2F1dGhlbnRpY2F0aW9uL3NlY3VyZV9zdG9yYWdlL2pzb25fY3JlZGVudGlhbF9tYW5hZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi8uLi9sb2dnZXInKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnbm9kZTpmcy9wcm9taXNlcycpO1xuY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbmNvbnN0IHsgdmFsaWRhdGVPbmx5VXNlclJlYWRXcml0ZVBlcm1pc3Npb25BbmRPd25lciB9ID0gcmVxdWlyZSgnLi4vLi4vZmlsZV91dGlsJyk7XG5cbmZ1bmN0aW9uIEpzb25DcmVkZW50aWFsTWFuYWdlcihjcmVkZW50aWFsQ2FjaGVEaXIpIHtcbiAgXG4gIHRoaXMuZ2V0VG9rZW5EaXIgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgbGV0IHRva2VuRGlyID0gY3JlZGVudGlhbENhY2hlRGlyO1xuICAgIGlmICghVXRpbC5leGlzdHModG9rZW5EaXIpKSB7XG4gICAgICB0b2tlbkRpciA9IG9zLmhvbWVkaXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbyhgVGhlIGNyZWRlbnRpYWwgY2FjaGUgZGlyZWN0b3J5IGlzIGNvbmZpZ3VyZWQgYnkgdGhlIHVzZXIuIFRoZSB0b2tlbiB3aWxsIGJlIHNhdmVkIGF0ICR7dG9rZW5EaXJ9YCk7XG4gICAgfVxuXG4gICAgaWYgKCFVdGlsLmV4aXN0cyh0b2tlbkRpcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGVtcG9yYXJ5IGNyZWRlbnRpYWwgY2FjaGUgZGlyZWN0b3J5IGlzIGludmFsaWQsIGFuZCB0aGUgZHJpdmVyIGlzIHVuYWJsZSB0byB1c2UgdGhlIGRlZmF1bHQgbG9jYXRpb24oaG9tZSkuIFxuICAgICAgUGxlYXNlIHNldCAnY3JlZGVudGlhbENhY2hlRGlyJyBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gb3B0aW9uIHRvIGVuYWJsZSB0aGUgZGVmYXVsdCBjcmVkZW50aWFsIG1hbmFnZXIuYCk7XG4gICAgfVxuXG4gICAgY29uc3QgdG9rZW5DYWNoZUZpbGUgPSBwYXRoLmpvaW4odG9rZW5EaXIsICd0ZW1wb3JhcnlfY3JlZGVudGlhbC5qc29uJyk7XG4gICAgYXdhaXQgdmFsaWRhdGVPbmx5VXNlclJlYWRXcml0ZVBlcm1pc3Npb25BbmRPd25lcih0b2tlbkNhY2hlRmlsZSk7XG4gICAgcmV0dXJuIHRva2VuQ2FjaGVGaWxlO1xuICB9O1xuICAgXG4gIHRoaXMucmVhZEpzb25DcmVkZW50aWFsRmlsZSA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgY3JlZCA9IGF3YWl0IGZzLnJlYWRGaWxlKGF3YWl0IHRoaXMuZ2V0VG9rZW5EaXIoKSwgJ3V0ZjgnKTtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGNyZWQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignRmFpbGVkIHRvIHJlYWQgdG9rZW4gZGF0YSBmcm9tIHRoZSBmaWxlLiBFcnI6ICVzJywgZXJyLm1lc3NhZ2UpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9O1xuICBcbiAgdGhpcy53cml0ZSA9IGFzeW5jIGZ1bmN0aW9uIChrZXksIHRva2VuKSB7XG4gICAgaWYgKCF2YWxpZGF0ZVRva2VuQ2FjaGVPcHRpb24oa2V5KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICBcbiAgICBjb25zdCBqc29uQ3JlZGVudGlhbCA9IGF3YWl0IHRoaXMucmVhZEpzb25DcmVkZW50aWFsRmlsZSgpIHx8IHt9O1xuICAgIGpzb25DcmVkZW50aWFsW2tleV0gPSB0b2tlbjtcbiAgIFxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBmcy53cml0ZUZpbGUoYXdhaXQgdGhpcy5nZXRUb2tlbkRpcigpLCBKU09OLnN0cmluZ2lmeShqc29uQ3JlZGVudGlhbCksIHsgbW9kZTogMG82MDAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB3cml0ZSB0b2tlbiBkYXRhLiBQbGVhc2UgY2hlY2sgdGhlIHBlcm1pc3Npb24gb3IgdGhlIGZpbGUgZm9ybWF0IG9mIHRoZSB0b2tlbi4gJHtlcnIubWVzc2FnZX1gKTtcbiAgICB9XG4gIH07XG4gIFxuICB0aGlzLnJlYWQgPSBhc3luYyBmdW5jdGlvbiAoa2V5KSB7XG4gICAgaWYgKCF2YWxpZGF0ZVRva2VuQ2FjaGVPcHRpb24oa2V5KSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QganNvbkNyZWRlbnRpYWwgPSBhd2FpdCB0aGlzLnJlYWRKc29uQ3JlZGVudGlhbEZpbGUoKTtcbiAgICBpZiAoISFqc29uQ3JlZGVudGlhbCAmJiBqc29uQ3JlZGVudGlhbFtrZXldKXtcbiAgICAgIHJldHVybiBqc29uQ3JlZGVudGlhbFtrZXldO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH07XG4gIFxuICB0aGlzLnJlbW92ZSA9IGFzeW5jIGZ1bmN0aW9uIChrZXkpIHtcbiAgICBpZiAoIXZhbGlkYXRlVG9rZW5DYWNoZU9wdGlvbihrZXkpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QganNvbkNyZWRlbnRpYWwgPSBhd2FpdCB0aGlzLnJlYWRKc29uQ3JlZGVudGlhbEZpbGUoKTtcbiAgICBcbiAgICBpZiAoanNvbkNyZWRlbnRpYWwgJiYganNvbkNyZWRlbnRpYWxba2V5XSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAganNvbkNyZWRlbnRpYWxba2V5XSA9IG51bGw7XG4gICAgICAgIGF3YWl0IGZzLndyaXRlRmlsZShhd2FpdCB0aGlzLmdldFRva2VuRGlyKCksIEpTT04uc3RyaW5naWZ5KGpzb25DcmVkZW50aWFsKSwgeyBtb2RlOiAwbzYwMCB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byB3cml0ZSB0b2tlbiBkYXRhIGZyb20gdGhlIGZpbGUgaW4gJHthd2FpdCB0aGlzLmdldFRva2VuRGlyKCl9LiBQbGVhc2UgY2hlY2sgdGhlIHBlcm1pc3Npb24gb3IgdGhlIGZpbGUgZm9ybWF0IG9mIHRoZSB0b2tlbi4gJHtlcnIubWVzc2FnZX1gKTtcbiAgICAgIH0gXG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlVG9rZW5DYWNoZU9wdGlvbihrZXkpIHtcbiAgICByZXR1cm4gVXRpbC5jaGVja1BhcmFtZXRlcnNEZWZpbmVkKGtleSk7IFxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gSnNvbkNyZWRlbnRpYWxNYW5hZ2VyOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/authentication/secure_storage/json_credential_manager.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/authentication/sso_url_provider.js":
/*!***************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/authentication/sso_url_provider.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst { rest } = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/lib/global_config.js\");\n\n/**\n * Creates a new instance of an SsoUrlProvider.\n *\n * @param {Object} httpClient\n * @constructor\n */\nfunction SsoUrlProvider(httpClient) {\n\n  Errors.assertInternal(Util.isObject(httpClient));\n\n  const port = rest.HTTPS_PORT;\n  const protocol = rest.HTTPS_PROTOCOL;\n\n  /**\n   * Get SSO URL through POST request.\n   *\n   * @param {String} authenticator\n   * @param {String} serviceName\n   * @param {String} account\n   * @param {Number} callbackPort\n   * @param {String} user\n   * @param {String} host\n   *\n   * @returns {String} the SSO URL.\n   */\n  this.getSSOURL = function (authenticator, serviceName, account, callbackPort, user, host) {\n    // Create URL to send POST request to\n    const url = protocol + '://' + host + '/session/authenticator-request';\n\n    let header;\n    if (serviceName) {\n      header = {\n        'HTTP_HEADER_SERVICE_NAME': serviceName\n      };\n    }\n    const body = {\n      'data': {\n        'ACCOUNT_NAME': account,\n        'LOGIN_NAME': user,\n        'PORT': port,\n        'PROTOCOL': protocol,\n        'AUTHENTICATOR': authenticator,\n        'BROWSER_MODE_REDIRECT_PORT': callbackPort.toString()\n      }\n    };\n\n    const requestOptions =\n      {\n        method: 'post',\n        url: url,\n        headers: header,\n        data: body,\n        responseType: 'json'\n      };\n\n    // Post request to get the SSO URL\n    return httpClient.requestAsync(requestOptions)\n      .then((response) => {\n        const data = response['data']['data'];\n        return data;\n      })\n      .catch(requestErr => {\n        throw requestErr;\n      });\n  };\n}\n\nmodule.exports = SsoUrlProvider;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvYXV0aGVudGljYXRpb24vc3NvX3VybF9wcm92aWRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsK0RBQVM7QUFDOUIsZUFBZSxtQkFBTyxDQUFDLG1FQUFXO0FBQ2xDLFFBQVEsT0FBTyxFQUFFLG1CQUFPLENBQUMsaUZBQWtCOztBQUUzQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9hdXRoZW50aWNhdGlvbi9zc29fdXJsX3Byb3ZpZGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IHsgcmVzdCB9ID0gcmVxdWlyZSgnLi4vZ2xvYmFsX2NvbmZpZycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgYW4gU3NvVXJsUHJvdmlkZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGh0dHBDbGllbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTc29VcmxQcm92aWRlcihodHRwQ2xpZW50KSB7XG5cbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoaHR0cENsaWVudCkpO1xuXG4gIGNvbnN0IHBvcnQgPSByZXN0LkhUVFBTX1BPUlQ7XG4gIGNvbnN0IHByb3RvY29sID0gcmVzdC5IVFRQU19QUk9UT0NPTDtcblxuICAvKipcbiAgICogR2V0IFNTTyBVUkwgdGhyb3VnaCBQT1NUIHJlcXVlc3QuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBhdXRoZW50aWNhdG9yXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzZXJ2aWNlTmFtZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gYWNjb3VudFxuICAgKiBAcGFyYW0ge051bWJlcn0gY2FsbGJhY2tQb3J0XG4gICAqIEBwYXJhbSB7U3RyaW5nfSB1c2VyXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBob3N0XG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBTU08gVVJMLlxuICAgKi9cbiAgdGhpcy5nZXRTU09VUkwgPSBmdW5jdGlvbiAoYXV0aGVudGljYXRvciwgc2VydmljZU5hbWUsIGFjY291bnQsIGNhbGxiYWNrUG9ydCwgdXNlciwgaG9zdCkge1xuICAgIC8vIENyZWF0ZSBVUkwgdG8gc2VuZCBQT1NUIHJlcXVlc3QgdG9cbiAgICBjb25zdCB1cmwgPSBwcm90b2NvbCArICc6Ly8nICsgaG9zdCArICcvc2Vzc2lvbi9hdXRoZW50aWNhdG9yLXJlcXVlc3QnO1xuXG4gICAgbGV0IGhlYWRlcjtcbiAgICBpZiAoc2VydmljZU5hbWUpIHtcbiAgICAgIGhlYWRlciA9IHtcbiAgICAgICAgJ0hUVFBfSEVBREVSX1NFUlZJQ0VfTkFNRSc6IHNlcnZpY2VOYW1lXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBib2R5ID0ge1xuICAgICAgJ2RhdGEnOiB7XG4gICAgICAgICdBQ0NPVU5UX05BTUUnOiBhY2NvdW50LFxuICAgICAgICAnTE9HSU5fTkFNRSc6IHVzZXIsXG4gICAgICAgICdQT1JUJzogcG9ydCxcbiAgICAgICAgJ1BST1RPQ09MJzogcHJvdG9jb2wsXG4gICAgICAgICdBVVRIRU5USUNBVE9SJzogYXV0aGVudGljYXRvcixcbiAgICAgICAgJ0JST1dTRVJfTU9ERV9SRURJUkVDVF9QT1JUJzogY2FsbGJhY2tQb3J0LnRvU3RyaW5nKClcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPVxuICAgICAge1xuICAgICAgICBtZXRob2Q6ICdwb3N0JyxcbiAgICAgICAgdXJsOiB1cmwsXG4gICAgICAgIGhlYWRlcnM6IGhlYWRlcixcbiAgICAgICAgZGF0YTogYm9keSxcbiAgICAgICAgcmVzcG9uc2VUeXBlOiAnanNvbidcbiAgICAgIH07XG5cbiAgICAvLyBQb3N0IHJlcXVlc3QgdG8gZ2V0IHRoZSBTU08gVVJMXG4gICAgcmV0dXJuIGh0dHBDbGllbnQucmVxdWVzdEFzeW5jKHJlcXVlc3RPcHRpb25zKVxuICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZVsnZGF0YSddWydkYXRhJ107XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfSlcbiAgICAgIC5jYXRjaChyZXF1ZXN0RXJyID0+IHtcbiAgICAgICAgdGhyb3cgcmVxdWVzdEVycjtcbiAgICAgIH0pO1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNzb1VybFByb3ZpZGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/authentication/sso_url_provider.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/configuration/client_configuration.js":
/*!******************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/configuration/client_configuration.js ***!
  \******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { isString, exists, getDriverDirectory } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst { isFileNotWritableByGroupOrOthers } = __webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\");\nconst clientConfigFileName = 'sf_client_config.json';\n\nconst Levels = Object.freeze({\n  Off: 'OFF',\n  Error: 'ERROR',\n  Warn: 'WARN',\n  Info: 'INFO',\n  Debug: 'DEBUG',\n  Trace: 'TRACE'\n});\n\nconst defaultDirectories = getDefaultDirectories();\n\nfunction getDefaultDirectories() {\n  const directories = [];\n\n  const driverDirectory = getDriverDirectory();\n  Logger.getInstance().debug(`Detected driver directory: ${driverDirectory}`);\n\n  if (driverDirectory) {\n    directories.push(\n      {\n        dir: driverDirectory,\n        dirDescription: 'driver'\n      }\n    );\n  } else {\n    Logger.getInstance().warn('Driver directory is not defined');\n  }\n\n  const homedir = os.homedir();\n  Logger.getInstance().debug(`Detected home directory: ${homedir}`);\n\n  if (exists(homedir)) {\n    directories.push(\n      {\n        dir: homedir,\n        dirDescription: 'home'\n      }\n    );\n  } else {\n    Logger.getInstance().warn('Home directory of the user is not defined');\n  }\n\n  Logger.getInstance().debug(`Detected default directories: ${driverDirectory}`);\n  return directories;\n}\n\nconst knownCommonEntries = ['log_level', 'log_path'];\nconst allLevels = Object.values(Levels);\n\nclass ClientConfig {\n  constructor(filePath, loggingConfig) {\n    this.configPath = filePath;\n    this.loggingConfig = loggingConfig;\n  }\n}\n\nclass ClientLoggingConfig {\n  constructor(logLevel, logPath) {\n    this.logLevel = logLevel;\n    this.logPath = logPath;\n  }\n}\n\nclass ConfigurationError extends Error {\n  name = 'ConfigurationError';\n\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  toString() {\n    return this.message + ': ' + this.cause.toString();\n  }\n}\n\n/**\n * @param value {String} Log level.\n * @return {String} normalized log level value.\n * @throws {Error} Error for unknown value.\n */\nfunction levelFromString(value) {\n  const level = value.toUpperCase();\n  if (!allLevels.includes(level)) {\n\n    Logger.getInstance().error(`Tried to create unsupported log level from string: ${value}`);\n    throw new Error('Unknown log level: ' + value);\n  }\n  return level;\n}\n\n/**\n * @param fsPromisesModule {module} filestream module\n * @param processModule {processModule} process module\n */\nfunction ConfigurationUtil(fsPromisesModule, processModule) {\n\n  const fsPromises = typeof fsPromisesModule !== 'undefined' ? fsPromisesModule : __webpack_require__(/*! fs/promises */ \"fs/promises\");\n  const process = typeof processModule !== 'undefined' ? processModule : __webpack_require__(/*! process */ \"process\");\n\n  /**\n   * @param configFilePath {String} A path to a client config file.\n   * @return {Promise<ClientConfig>} Client configuration.\n   */\n  this.getClientConfig = async function (configFilePath) {\n    Logger.getInstance().debug('Retrieving client config');\n\n    const path = await findConfig(configFilePath);\n    if (!exists(path) || path === '') {\n      Logger.getInstance().info('No config file path found. Client config will not be used.');\n      return null;\n    }\n\n    const isFileOk = await isFileNotWritableByGroupOrOthers(path, fsPromises).catch(err => {\n      Logger.getInstance().warn('Failed to inspect config file path permissions. Client config will not be used.');\n      throw new ConfigurationError('Finding client configuration failed', err);\n    });\n\n    if (!isFileOk) {\n      Logger.getInstance().warn(`Config file path permissions are invalid. File: ${path} can be modified by group or others. Client config will not be used.`);\n      throw new ConfigurationError(`Configuration file: ${path} can be modified by group or others`, 'IncorrectPerms');\n    }\n    Logger.getInstance().debug(`Config file path permissions are valid. Path: ${path}`);\n\n    const configFileContents = await readFileConfig(path);\n    Logger.getInstance().info('Using client configuration from path: %s', path);\n\n    return configFileContents == null ? null : parseConfigFile(path, configFileContents);\n  };\n\n  function readFileConfig(filePath) {\n    Logger.getInstance().debug(`Reading config file. Path: ${filePath}`);\n\n    if (!filePath) {\n      Logger.getInstance().trace(`Path of config file is not specified. Nothing to read. Path: ${filePath}`);\n      return Promise.resolve(null);\n    }\n    return fsPromises.readFile(filePath, { encoding: 'utf8' })\n      .catch(err => {\n        Logger.getInstance().debug(`Reading configuration from the file failed. Path: ${filePath}`);\n        throw new ConfigurationError('Finding client configuration failed', err);\n      });\n  }\n\n  function parseConfigFile(path, configurationJson) {\n    Logger.getInstance().debug('Parsing config file: %s', path);\n    try {\n      const parsedConfiguration = JSON.parse(configurationJson);\n      Logger.getInstance().trace('Config file contains correct JSON structure. Validating the input.');\n\n      checkUnknownEntries(parsedConfiguration);\n      validate(parsedConfiguration);\n\n      Logger.getInstance().debug('Config file contains valid configuration input.');\n\n      const clientConfig = new ClientConfig(\n        path,\n        new ClientLoggingConfig(\n          getLogLevel(parsedConfiguration),\n          getLogPath(parsedConfiguration)\n        )\n      );\n\n      Logger.getInstance().info('Client Configuration created with Log Level: %s and Log Path: %s', clientConfig.loggingConfig.logLevel, clientConfig.loggingConfig.logPath);\n      return clientConfig;\n\n    } catch (err) {\n      Logger.getInstance().error('Parsing client configuration failed. Used config file from path: %s', path);\n      throw new ConfigurationError('Parsing client configuration failed', err);\n    }\n  }\n\n  function checkUnknownEntries(config) {\n    for (const key in config.common) {\n      if (!knownCommonEntries.includes(key.toLowerCase())) {\n        Logger.getInstance().warn('Unknown configuration entry: %s with value: %s', key, config.common[key]);\n      }\n    }\n  }\n\n  function validate(configuration) {\n    validateLogLevel(configuration);\n    validateLogPath(configuration);\n  }\n\n  function validateLogLevel(configuration) {\n    const logLevel = getLogLevel(configuration);\n    if (logLevel == null) {\n      Logger.getInstance().debug('Log level is not specified.');\n      return;\n    }\n    if (!isString(logLevel)) {\n      const errorMessage = 'Log level is not a string.';\n      Logger.getInstance().error(errorMessage);\n      throw new Error(errorMessage);\n    }\n    levelFromString(logLevel);\n  }\n\n  function validateLogPath(configuration) {\n    const logPath = getLogPath(configuration);\n    if (logPath == null) {\n      Logger.getInstance().debug('Log path is not specified');\n      return;\n    }\n    if (!isString(logPath)) {\n      const errorMessage = 'Log path is not a string.';\n      Logger.getInstance().error(errorMessage);\n      throw new Error(errorMessage);\n    }\n  }\n\n  function getLogLevel(configuration) {\n    return configuration.common.log_level;\n  }\n\n  function getLogPath(configuration) {\n    return configuration.common.log_path;\n  }\n\n  async function findConfig(filePathFromConnectionString) {\n    Logger.getInstance().trace(`findConfig() called with param: ${filePathFromConnectionString}`);\n    if (exists(filePathFromConnectionString)) {\n      Logger.getInstance().info('Found client configuration path in a connection string. Path: %s', filePathFromConnectionString);\n      return filePathFromConnectionString;\n    }\n    const filePathFromEnvVariable = await getFilePathFromEnvironmentVariable();\n    if (exists(filePathFromEnvVariable)) {\n      Logger.getInstance().info('Found client configuration path in an environment variable. Path: %s', filePathFromEnvVariable);\n      return filePathFromEnvVariable;\n    }\n    const fileFromDefDirs = await searchForConfigInDefaultDirectories();\n    if (exists(fileFromDefDirs)) {\n      Logger.getInstance().info('Found client configuration path in %s directory. Path: %s', fileFromDefDirs.dirDescription, fileFromDefDirs.configPath);\n      return fileFromDefDirs.configPath;\n    }\n    Logger.getInstance().info('No client config detected.');\n    return null;\n  }\n\n  async function verifyNotEmpty(filePath) {\n    return filePath ? filePath : null;\n  }\n\n  function getFilePathFromEnvironmentVariable() {\n    return verifyNotEmpty(process.env.SF_CLIENT_CONFIG_FILE);\n  }\n\n  async function searchForConfigInDefaultDirectories() {\n    Logger.getInstance().debug(`Searching for config in default directories: ${JSON.stringify(defaultDirectories)}`);\n    for (const directory of defaultDirectories) {\n      const configPath = await searchForConfigInDictionary(directory.dir, directory.dirDescription);\n      if (exists(configPath)) {\n        Logger.getInstance().debug(`Config found in the default directory: ${directory.dir}. Path: ${configPath}`);\n        return { configPath: configPath, dirDescription: directory.dirDescription };\n      }\n    }\n    Logger.getInstance().debug('Unable to find config in any default directory.');\n    return null;\n  }\n\n  async function searchForConfigInDictionary(directory, directoryDescription) {\n    try {\n      const filePath = path.join(directory, clientConfigFileName);\n      return await onlyIfFileExists(filePath);\n    } catch (e) {\n      Logger.getInstance().error('Error while searching for the client config in %s directory: %s', directoryDescription, e);\n      return null;\n    }\n  }\n\n  async function onlyIfFileExists(filePath) {\n    return await fsPromises.access(filePath, fs.constants.F_OK)\n      .then(() => filePath)\n      .catch(() => null);\n  }\n}\n\nexports.Levels = Levels;\nexports.levelFromString = levelFromString;\nexports.ConfigurationUtil = ConfigurationUtil;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29uZmlndXJhdGlvbi9jbGllbnRfY29uZmlndXJhdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsUUFBUSx1Q0FBdUMsRUFBRSxtQkFBTyxDQUFDLCtEQUFTO0FBQ2xFLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVztBQUNsQyxRQUFRLG1DQUFtQyxFQUFFLG1CQUFPLENBQUMseUVBQWM7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyREFBMkQsZ0JBQWdCOztBQUUzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EseURBQXlELFFBQVE7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsOERBQThELGdCQUFnQjtBQUM5RTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QixZQUFZLFFBQVE7QUFDcEIsWUFBWSxPQUFPO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFGQUFxRixNQUFNO0FBQzNGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLFFBQVE7QUFDcEMseUJBQXlCLGVBQWU7QUFDeEM7QUFDQTs7QUFFQSxrRkFBa0YsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN2Ryx5RUFBeUUsbUJBQU8sQ0FBQyx3QkFBUzs7QUFFMUY7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQyxjQUFjLHVCQUF1QjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsbUZBQW1GLE1BQU07QUFDekYsMERBQTBELE1BQU07QUFDaEU7QUFDQSxnRkFBZ0YsS0FBSzs7QUFFckY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkRBQTZELFNBQVM7O0FBRXRFO0FBQ0EsaUdBQWlHLFNBQVM7QUFDMUc7QUFDQTtBQUNBLDJDQUEyQyxrQkFBa0I7QUFDN0Q7QUFDQSx3RkFBd0YsU0FBUztBQUNqRztBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrRUFBa0UsNkJBQTZCO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtFQUErRSxtQ0FBbUM7QUFDbEg7QUFDQTtBQUNBO0FBQ0EsNkVBQTZFLGNBQWMsVUFBVSxXQUFXO0FBQ2hILGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjO0FBQ2QsdUJBQXVCO0FBQ3ZCLHlCQUF5QiIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9jb25maWd1cmF0aW9uL2NsaWVudF9jb25maWd1cmF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IGlzU3RyaW5nLCBleGlzdHMsIGdldERyaXZlckRpcmVjdG9yeSB9ID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCB7IGlzRmlsZU5vdFdyaXRhYmxlQnlHcm91cE9yT3RoZXJzIH0gPSByZXF1aXJlKCcuLi9maWxlX3V0aWwnKTtcbmNvbnN0IGNsaWVudENvbmZpZ0ZpbGVOYW1lID0gJ3NmX2NsaWVudF9jb25maWcuanNvbic7XG5cbmNvbnN0IExldmVscyA9IE9iamVjdC5mcmVlemUoe1xuICBPZmY6ICdPRkYnLFxuICBFcnJvcjogJ0VSUk9SJyxcbiAgV2FybjogJ1dBUk4nLFxuICBJbmZvOiAnSU5GTycsXG4gIERlYnVnOiAnREVCVUcnLFxuICBUcmFjZTogJ1RSQUNFJ1xufSk7XG5cbmNvbnN0IGRlZmF1bHREaXJlY3RvcmllcyA9IGdldERlZmF1bHREaXJlY3RvcmllcygpO1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlyZWN0b3JpZXMoKSB7XG4gIGNvbnN0IGRpcmVjdG9yaWVzID0gW107XG5cbiAgY29uc3QgZHJpdmVyRGlyZWN0b3J5ID0gZ2V0RHJpdmVyRGlyZWN0b3J5KCk7XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBEZXRlY3RlZCBkcml2ZXIgZGlyZWN0b3J5OiAke2RyaXZlckRpcmVjdG9yeX1gKTtcblxuICBpZiAoZHJpdmVyRGlyZWN0b3J5KSB7XG4gICAgZGlyZWN0b3JpZXMucHVzaChcbiAgICAgIHtcbiAgICAgICAgZGlyOiBkcml2ZXJEaXJlY3RvcnksXG4gICAgICAgIGRpckRlc2NyaXB0aW9uOiAnZHJpdmVyJ1xuICAgICAgfVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignRHJpdmVyIGRpcmVjdG9yeSBpcyBub3QgZGVmaW5lZCcpO1xuICB9XG5cbiAgY29uc3QgaG9tZWRpciA9IG9zLmhvbWVkaXIoKTtcbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYERldGVjdGVkIGhvbWUgZGlyZWN0b3J5OiAke2hvbWVkaXJ9YCk7XG5cbiAgaWYgKGV4aXN0cyhob21lZGlyKSkge1xuICAgIGRpcmVjdG9yaWVzLnB1c2goXG4gICAgICB7XG4gICAgICAgIGRpcjogaG9tZWRpcixcbiAgICAgICAgZGlyRGVzY3JpcHRpb246ICdob21lJ1xuICAgICAgfVxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignSG9tZSBkaXJlY3Rvcnkgb2YgdGhlIHVzZXIgaXMgbm90IGRlZmluZWQnKTtcbiAgfVxuXG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBEZXRlY3RlZCBkZWZhdWx0IGRpcmVjdG9yaWVzOiAke2RyaXZlckRpcmVjdG9yeX1gKTtcbiAgcmV0dXJuIGRpcmVjdG9yaWVzO1xufVxuXG5jb25zdCBrbm93bkNvbW1vbkVudHJpZXMgPSBbJ2xvZ19sZXZlbCcsICdsb2dfcGF0aCddO1xuY29uc3QgYWxsTGV2ZWxzID0gT2JqZWN0LnZhbHVlcyhMZXZlbHMpO1xuXG5jbGFzcyBDbGllbnRDb25maWcge1xuICBjb25zdHJ1Y3RvcihmaWxlUGF0aCwgbG9nZ2luZ0NvbmZpZykge1xuICAgIHRoaXMuY29uZmlnUGF0aCA9IGZpbGVQYXRoO1xuICAgIHRoaXMubG9nZ2luZ0NvbmZpZyA9IGxvZ2dpbmdDb25maWc7XG4gIH1cbn1cblxuY2xhc3MgQ2xpZW50TG9nZ2luZ0NvbmZpZyB7XG4gIGNvbnN0cnVjdG9yKGxvZ0xldmVsLCBsb2dQYXRoKSB7XG4gICAgdGhpcy5sb2dMZXZlbCA9IGxvZ0xldmVsO1xuICAgIHRoaXMubG9nUGF0aCA9IGxvZ1BhdGg7XG4gIH1cbn1cblxuY2xhc3MgQ29uZmlndXJhdGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBuYW1lID0gJ0NvbmZpZ3VyYXRpb25FcnJvcic7XG5cbiAgY29uc3RydWN0b3IobWVzc2FnZSwgY2F1c2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgdGhpcy5jb25zdHJ1Y3Rvcik7XG4gIH1cblxuICB0b1N0cmluZygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlICsgJzogJyArIHRoaXMuY2F1c2UudG9TdHJpbmcoKTtcbiAgfVxufVxuXG4vKipcbiAqIEBwYXJhbSB2YWx1ZSB7U3RyaW5nfSBMb2cgbGV2ZWwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IG5vcm1hbGl6ZWQgbG9nIGxldmVsIHZhbHVlLlxuICogQHRocm93cyB7RXJyb3J9IEVycm9yIGZvciB1bmtub3duIHZhbHVlLlxuICovXG5mdW5jdGlvbiBsZXZlbEZyb21TdHJpbmcodmFsdWUpIHtcbiAgY29uc3QgbGV2ZWwgPSB2YWx1ZS50b1VwcGVyQ2FzZSgpO1xuICBpZiAoIWFsbExldmVscy5pbmNsdWRlcyhsZXZlbCkpIHtcblxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKGBUcmllZCB0byBjcmVhdGUgdW5zdXBwb3J0ZWQgbG9nIGxldmVsIGZyb20gc3RyaW5nOiAke3ZhbHVlfWApO1xuICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBsb2cgbGV2ZWw6ICcgKyB2YWx1ZSk7XG4gIH1cbiAgcmV0dXJuIGxldmVsO1xufVxuXG4vKipcbiAqIEBwYXJhbSBmc1Byb21pc2VzTW9kdWxlIHttb2R1bGV9IGZpbGVzdHJlYW0gbW9kdWxlXG4gKiBAcGFyYW0gcHJvY2Vzc01vZHVsZSB7cHJvY2Vzc01vZHVsZX0gcHJvY2VzcyBtb2R1bGVcbiAqL1xuZnVuY3Rpb24gQ29uZmlndXJhdGlvblV0aWwoZnNQcm9taXNlc01vZHVsZSwgcHJvY2Vzc01vZHVsZSkge1xuXG4gIGNvbnN0IGZzUHJvbWlzZXMgPSB0eXBlb2YgZnNQcm9taXNlc01vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBmc1Byb21pc2VzTW9kdWxlIDogcmVxdWlyZSgnZnMvcHJvbWlzZXMnKTtcbiAgY29uc3QgcHJvY2VzcyA9IHR5cGVvZiBwcm9jZXNzTW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IHByb2Nlc3NNb2R1bGUgOiByZXF1aXJlKCdwcm9jZXNzJyk7XG5cbiAgLyoqXG4gICAqIEBwYXJhbSBjb25maWdGaWxlUGF0aCB7U3RyaW5nfSBBIHBhdGggdG8gYSBjbGllbnQgY29uZmlnIGZpbGUuXG4gICAqIEByZXR1cm4ge1Byb21pc2U8Q2xpZW50Q29uZmlnPn0gQ2xpZW50IGNvbmZpZ3VyYXRpb24uXG4gICAqL1xuICB0aGlzLmdldENsaWVudENvbmZpZyA9IGFzeW5jIGZ1bmN0aW9uIChjb25maWdGaWxlUGF0aCkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdSZXRyaWV2aW5nIGNsaWVudCBjb25maWcnKTtcblxuICAgIGNvbnN0IHBhdGggPSBhd2FpdCBmaW5kQ29uZmlnKGNvbmZpZ0ZpbGVQYXRoKTtcbiAgICBpZiAoIWV4aXN0cyhwYXRoKSB8fCBwYXRoID09PSAnJykge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnTm8gY29uZmlnIGZpbGUgcGF0aCBmb3VuZC4gQ2xpZW50IGNvbmZpZyB3aWxsIG5vdCBiZSB1c2VkLicpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgaXNGaWxlT2sgPSBhd2FpdCBpc0ZpbGVOb3RXcml0YWJsZUJ5R3JvdXBPck90aGVycyhwYXRoLCBmc1Byb21pc2VzKS5jYXRjaChlcnIgPT4ge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybignRmFpbGVkIHRvIGluc3BlY3QgY29uZmlnIGZpbGUgcGF0aCBwZXJtaXNzaW9ucy4gQ2xpZW50IGNvbmZpZyB3aWxsIG5vdCBiZSB1c2VkLicpO1xuICAgICAgdGhyb3cgbmV3IENvbmZpZ3VyYXRpb25FcnJvcignRmluZGluZyBjbGllbnQgY29uZmlndXJhdGlvbiBmYWlsZWQnLCBlcnIpO1xuICAgIH0pO1xuXG4gICAgaWYgKCFpc0ZpbGVPaykge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihgQ29uZmlnIGZpbGUgcGF0aCBwZXJtaXNzaW9ucyBhcmUgaW52YWxpZC4gRmlsZTogJHtwYXRofSBjYW4gYmUgbW9kaWZpZWQgYnkgZ3JvdXAgb3Igb3RoZXJzLiBDbGllbnQgY29uZmlnIHdpbGwgbm90IGJlIHVzZWQuYCk7XG4gICAgICB0aHJvdyBuZXcgQ29uZmlndXJhdGlvbkVycm9yKGBDb25maWd1cmF0aW9uIGZpbGU6ICR7cGF0aH0gY2FuIGJlIG1vZGlmaWVkIGJ5IGdyb3VwIG9yIG90aGVyc2AsICdJbmNvcnJlY3RQZXJtcycpO1xuICAgIH1cbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgQ29uZmlnIGZpbGUgcGF0aCBwZXJtaXNzaW9ucyBhcmUgdmFsaWQuIFBhdGg6ICR7cGF0aH1gKTtcblxuICAgIGNvbnN0IGNvbmZpZ0ZpbGVDb250ZW50cyA9IGF3YWl0IHJlYWRGaWxlQ29uZmlnKHBhdGgpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ1VzaW5nIGNsaWVudCBjb25maWd1cmF0aW9uIGZyb20gcGF0aDogJXMnLCBwYXRoKTtcblxuICAgIHJldHVybiBjb25maWdGaWxlQ29udGVudHMgPT0gbnVsbCA/IG51bGwgOiBwYXJzZUNvbmZpZ0ZpbGUocGF0aCwgY29uZmlnRmlsZUNvbnRlbnRzKTtcbiAgfTtcblxuICBmdW5jdGlvbiByZWFkRmlsZUNvbmZpZyhmaWxlUGF0aCkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBSZWFkaW5nIGNvbmZpZyBmaWxlLiBQYXRoOiAke2ZpbGVQYXRofWApO1xuXG4gICAgaWYgKCFmaWxlUGF0aCkge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFBhdGggb2YgY29uZmlnIGZpbGUgaXMgbm90IHNwZWNpZmllZC4gTm90aGluZyB0byByZWFkLiBQYXRoOiAke2ZpbGVQYXRofWApO1xuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShudWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIGZzUHJvbWlzZXMucmVhZEZpbGUoZmlsZVBhdGgsIHsgZW5jb2Rpbmc6ICd1dGY4JyB9KVxuICAgICAgLmNhdGNoKGVyciA9PiB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBSZWFkaW5nIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgZmlsZSBmYWlsZWQuIFBhdGg6ICR7ZmlsZVBhdGh9YCk7XG4gICAgICAgIHRocm93IG5ldyBDb25maWd1cmF0aW9uRXJyb3IoJ0ZpbmRpbmcgY2xpZW50IGNvbmZpZ3VyYXRpb24gZmFpbGVkJywgZXJyKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VDb25maWdGaWxlKHBhdGgsIGNvbmZpZ3VyYXRpb25Kc29uKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1BhcnNpbmcgY29uZmlnIGZpbGU6ICVzJywgcGF0aCk7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHBhcnNlZENvbmZpZ3VyYXRpb24gPSBKU09OLnBhcnNlKGNvbmZpZ3VyYXRpb25Kc29uKTtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25maWcgZmlsZSBjb250YWlucyBjb3JyZWN0IEpTT04gc3RydWN0dXJlLiBWYWxpZGF0aW5nIHRoZSBpbnB1dC4nKTtcblxuICAgICAgY2hlY2tVbmtub3duRW50cmllcyhwYXJzZWRDb25maWd1cmF0aW9uKTtcbiAgICAgIHZhbGlkYXRlKHBhcnNlZENvbmZpZ3VyYXRpb24pO1xuXG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29uZmlnIGZpbGUgY29udGFpbnMgdmFsaWQgY29uZmlndXJhdGlvbiBpbnB1dC4nKTtcblxuICAgICAgY29uc3QgY2xpZW50Q29uZmlnID0gbmV3IENsaWVudENvbmZpZyhcbiAgICAgICAgcGF0aCxcbiAgICAgICAgbmV3IENsaWVudExvZ2dpbmdDb25maWcoXG4gICAgICAgICAgZ2V0TG9nTGV2ZWwocGFyc2VkQ29uZmlndXJhdGlvbiksXG4gICAgICAgICAgZ2V0TG9nUGF0aChwYXJzZWRDb25maWd1cmF0aW9uKVxuICAgICAgICApXG4gICAgICApO1xuXG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDbGllbnQgQ29uZmlndXJhdGlvbiBjcmVhdGVkIHdpdGggTG9nIExldmVsOiAlcyBhbmQgTG9nIFBhdGg6ICVzJywgY2xpZW50Q29uZmlnLmxvZ2dpbmdDb25maWcubG9nTGV2ZWwsIGNsaWVudENvbmZpZy5sb2dnaW5nQ29uZmlnLmxvZ1BhdGgpO1xuICAgICAgcmV0dXJuIGNsaWVudENvbmZpZztcblxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ1BhcnNpbmcgY2xpZW50IGNvbmZpZ3VyYXRpb24gZmFpbGVkLiBVc2VkIGNvbmZpZyBmaWxlIGZyb20gcGF0aDogJXMnLCBwYXRoKTtcbiAgICAgIHRocm93IG5ldyBDb25maWd1cmF0aW9uRXJyb3IoJ1BhcnNpbmcgY2xpZW50IGNvbmZpZ3VyYXRpb24gZmFpbGVkJywgZXJyKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja1Vua25vd25FbnRyaWVzKGNvbmZpZykge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNvbmZpZy5jb21tb24pIHtcbiAgICAgIGlmICgha25vd25Db21tb25FbnRyaWVzLmluY2x1ZGVzKGtleS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdVbmtub3duIGNvbmZpZ3VyYXRpb24gZW50cnk6ICVzIHdpdGggdmFsdWU6ICVzJywga2V5LCBjb25maWcuY29tbW9uW2tleV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlKGNvbmZpZ3VyYXRpb24pIHtcbiAgICB2YWxpZGF0ZUxvZ0xldmVsKGNvbmZpZ3VyYXRpb24pO1xuICAgIHZhbGlkYXRlTG9nUGF0aChjb25maWd1cmF0aW9uKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHZhbGlkYXRlTG9nTGV2ZWwoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvZ0xldmVsID0gZ2V0TG9nTGV2ZWwoY29uZmlndXJhdGlvbik7XG4gICAgaWYgKGxvZ0xldmVsID09IG51bGwpIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdMb2cgbGV2ZWwgaXMgbm90IHNwZWNpZmllZC4nKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFpc1N0cmluZyhsb2dMZXZlbCkpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdMb2cgbGV2ZWwgaXMgbm90IGEgc3RyaW5nLic7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcihlcnJvck1lc3NhZ2UpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgfVxuICAgIGxldmVsRnJvbVN0cmluZyhsb2dMZXZlbCk7XG4gIH1cblxuICBmdW5jdGlvbiB2YWxpZGF0ZUxvZ1BhdGgoY29uZmlndXJhdGlvbikge1xuICAgIGNvbnN0IGxvZ1BhdGggPSBnZXRMb2dQYXRoKGNvbmZpZ3VyYXRpb24pO1xuICAgIGlmIChsb2dQYXRoID09IG51bGwpIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdMb2cgcGF0aCBpcyBub3Qgc3BlY2lmaWVkJyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNTdHJpbmcobG9nUGF0aCkpIHtcbiAgICAgIGNvbnN0IGVycm9yTWVzc2FnZSA9ICdMb2cgcGF0aCBpcyBub3QgYSBzdHJpbmcuJztcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKGVycm9yTWVzc2FnZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JNZXNzYWdlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRMb2dMZXZlbChjb25maWd1cmF0aW9uKSB7XG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb24uY29tbW9uLmxvZ19sZXZlbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldExvZ1BhdGgoY29uZmlndXJhdGlvbikge1xuICAgIHJldHVybiBjb25maWd1cmF0aW9uLmNvbW1vbi5sb2dfcGF0aDtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGZpbmRDb25maWcoZmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZykge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKGBmaW5kQ29uZmlnKCkgY2FsbGVkIHdpdGggcGFyYW06ICR7ZmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZ31gKTtcbiAgICBpZiAoZXhpc3RzKGZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmcpKSB7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdGb3VuZCBjbGllbnQgY29uZmlndXJhdGlvbiBwYXRoIGluIGEgY29ubmVjdGlvbiBzdHJpbmcuIFBhdGg6ICVzJywgZmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZyk7XG4gICAgICByZXR1cm4gZmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZztcbiAgICB9XG4gICAgY29uc3QgZmlsZVBhdGhGcm9tRW52VmFyaWFibGUgPSBhd2FpdCBnZXRGaWxlUGF0aEZyb21FbnZpcm9ubWVudFZhcmlhYmxlKCk7XG4gICAgaWYgKGV4aXN0cyhmaWxlUGF0aEZyb21FbnZWYXJpYWJsZSkpIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0ZvdW5kIGNsaWVudCBjb25maWd1cmF0aW9uIHBhdGggaW4gYW4gZW52aXJvbm1lbnQgdmFyaWFibGUuIFBhdGg6ICVzJywgZmlsZVBhdGhGcm9tRW52VmFyaWFibGUpO1xuICAgICAgcmV0dXJuIGZpbGVQYXRoRnJvbUVudlZhcmlhYmxlO1xuICAgIH1cbiAgICBjb25zdCBmaWxlRnJvbURlZkRpcnMgPSBhd2FpdCBzZWFyY2hGb3JDb25maWdJbkRlZmF1bHREaXJlY3RvcmllcygpO1xuICAgIGlmIChleGlzdHMoZmlsZUZyb21EZWZEaXJzKSkge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnRm91bmQgY2xpZW50IGNvbmZpZ3VyYXRpb24gcGF0aCBpbiAlcyBkaXJlY3RvcnkuIFBhdGg6ICVzJywgZmlsZUZyb21EZWZEaXJzLmRpckRlc2NyaXB0aW9uLCBmaWxlRnJvbURlZkRpcnMuY29uZmlnUGF0aCk7XG4gICAgICByZXR1cm4gZmlsZUZyb21EZWZEaXJzLmNvbmZpZ1BhdGg7XG4gICAgfVxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ05vIGNsaWVudCBjb25maWcgZGV0ZWN0ZWQuJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiB2ZXJpZnlOb3RFbXB0eShmaWxlUGF0aCkge1xuICAgIHJldHVybiBmaWxlUGF0aCA/IGZpbGVQYXRoIDogbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZpbGVQYXRoRnJvbUVudmlyb25tZW50VmFyaWFibGUoKSB7XG4gICAgcmV0dXJuIHZlcmlmeU5vdEVtcHR5KHByb2Nlc3MuZW52LlNGX0NMSUVOVF9DT05GSUdfRklMRSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBzZWFyY2hGb3JDb25maWdJbkRlZmF1bHREaXJlY3RvcmllcygpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgU2VhcmNoaW5nIGZvciBjb25maWcgaW4gZGVmYXVsdCBkaXJlY3RvcmllczogJHtKU09OLnN0cmluZ2lmeShkZWZhdWx0RGlyZWN0b3JpZXMpfWApO1xuICAgIGZvciAoY29uc3QgZGlyZWN0b3J5IG9mIGRlZmF1bHREaXJlY3Rvcmllcykge1xuICAgICAgY29uc3QgY29uZmlnUGF0aCA9IGF3YWl0IHNlYXJjaEZvckNvbmZpZ0luRGljdGlvbmFyeShkaXJlY3RvcnkuZGlyLCBkaXJlY3RvcnkuZGlyRGVzY3JpcHRpb24pO1xuICAgICAgaWYgKGV4aXN0cyhjb25maWdQYXRoKSkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgQ29uZmlnIGZvdW5kIGluIHRoZSBkZWZhdWx0IGRpcmVjdG9yeTogJHtkaXJlY3RvcnkuZGlyfS4gUGF0aDogJHtjb25maWdQYXRofWApO1xuICAgICAgICByZXR1cm4geyBjb25maWdQYXRoOiBjb25maWdQYXRoLCBkaXJEZXNjcmlwdGlvbjogZGlyZWN0b3J5LmRpckRlc2NyaXB0aW9uIH07XG4gICAgICB9XG4gICAgfVxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdVbmFibGUgdG8gZmluZCBjb25maWcgaW4gYW55IGRlZmF1bHQgZGlyZWN0b3J5LicpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgYXN5bmMgZnVuY3Rpb24gc2VhcmNoRm9yQ29uZmlnSW5EaWN0aW9uYXJ5KGRpcmVjdG9yeSwgZGlyZWN0b3J5RGVzY3JpcHRpb24pIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBwYXRoLmpvaW4oZGlyZWN0b3J5LCBjbGllbnRDb25maWdGaWxlTmFtZSk7XG4gICAgICByZXR1cm4gYXdhaXQgb25seUlmRmlsZUV4aXN0cyhmaWxlUGF0aCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Vycm9yIHdoaWxlIHNlYXJjaGluZyBmb3IgdGhlIGNsaWVudCBjb25maWcgaW4gJXMgZGlyZWN0b3J5OiAlcycsIGRpcmVjdG9yeURlc2NyaXB0aW9uLCBlKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIG9ubHlJZkZpbGVFeGlzdHMoZmlsZVBhdGgpIHtcbiAgICByZXR1cm4gYXdhaXQgZnNQcm9taXNlcy5hY2Nlc3MoZmlsZVBhdGgsIGZzLmNvbnN0YW50cy5GX09LKVxuICAgICAgLnRoZW4oKCkgPT4gZmlsZVBhdGgpXG4gICAgICAuY2F0Y2goKCkgPT4gbnVsbCk7XG4gIH1cbn1cblxuZXhwb3J0cy5MZXZlbHMgPSBMZXZlbHM7XG5leHBvcnRzLmxldmVsRnJvbVN0cmluZyA9IGxldmVsRnJvbVN0cmluZztcbmV4cG9ydHMuQ29uZmlndXJhdGlvblV0aWwgPSBDb25maWd1cmF0aW9uVXRpbDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/configuration/client_configuration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/configuration/connection_configuration.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/configuration/connection_configuration.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const toml = __webpack_require__(/*! toml */ \"(rsc)/./node_modules/toml/index.js\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { validateOnlyUserReadWritePermissionAndOwner, generateChecksum } = __webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ../authentication/authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/authentication_types.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\n\nfunction defaultIfNotSet(value, defaultValue) {\n  if (value === null || typeof value === 'undefined' || value === '') {\n    return defaultValue;\n  } else {\n    return value;\n  }\n}\n\nfunction shouldReadTokenFromFile(fixedConfiguration) {\n  return fixedConfiguration && fixedConfiguration.authenticator &&\n    fixedConfiguration.authenticator.toUpperCase() === AuthenticationTypes.OAUTH_AUTHENTICATOR &&\n    !Util.string.isNotNullOrEmpty(fixedConfiguration.token);\n}\n\nfunction readTokenFromFile(fixedConfiguration) {\n  const tokenFilePath = fixedConfiguration.token_file_path ? fixedConfiguration.token_file_path : '/snowflake/session/token';\n  const resolvedPath = fs.realpathSync(tokenFilePath);\n  Logger.getInstance().trace('Token file path is : %s', tokenFilePath);\n  validateOnlyUserReadWritePermissionAndOwner(resolvedPath);\n  fixedConfiguration.token = fs.readFileSync(resolvedPath, 'utf-8').trim();\n  if (!fixedConfiguration.token) {\n    Logger.getInstance().error('The token does not exist or has empty value.');\n    throw new Error('The token does not exist or has empty value');\n  }\n  const tokenChecksum = generateChecksum(fixedConfiguration.token);\n  Logger.getInstance().info('Token used in connection has been read from file: %s. Checksum: %s', resolvedPath, tokenChecksum);\n}\n\nfunction loadConnectionConfiguration() {\n  Logger.getInstance().trace('Loading connection configuration from the local files...');\n  const snowflakeConfigDir = defaultIfNotSet(process.env.SNOWFLAKE_HOME, path.join(os.homedir(), '.snowflake'));\n  Logger.getInstance().trace('Looking for connection file in directory %s', snowflakeConfigDir);\n  const filePath = path.join(snowflakeConfigDir, 'connections.toml');\n  const resolvedPath = fs.realpathSync(filePath);\n  Logger.getInstance().trace('Connection configuration file found under the path %s. Validating file access.', resolvedPath);\n\n  validateOnlyUserReadWritePermissionAndOwner(resolvedPath);\n  const str = fs.readFileSync(resolvedPath, { encoding: 'utf8' });\n  const configurationChecksum = generateChecksum(str);\n  Logger.getInstance().info('Connection configuration file is read from path: %s. Checksum: %s', resolvedPath, configurationChecksum);\n  Logger.getInstance().trace('Trying to parse the config file');\n  const parsingResult = toml.parse(str);\n\n  const configurationName = defaultIfNotSet(process.env.SNOWFLAKE_DEFAULT_CONNECTION_NAME, 'default');\n\n  if (parsingResult[configurationName] !== undefined) {\n    const fixedConfiguration = fixUserKey(parsingResult[configurationName]);\n    if (shouldReadTokenFromFile(fixedConfiguration)) {\n      Logger.getInstance().info('Trying to read token from config file.');\n      readTokenFromFile(fixedConfiguration);\n    }\n    return fixedConfiguration;\n  } else {\n    Logger.getInstance().error('Connection configuration with name %s does not exist in the file %s', configurationName, resolvedPath);\n    throw new Error(`Connection configuration with name ${configurationName} does not exist`);\n  }\n}\n\nfunction fixUserKey(parsingResult) {\n  Logger.getInstance().trace('Empty Username field will be filled with \\'User\\' field value.');\n  if (parsingResult['username'] === undefined && parsingResult['user'] !== undefined){\n    parsingResult['username'] = parsingResult['user'];\n  }\n  return parsingResult;\n}\n\nexports.loadConnectionConfiguration = loadConnectionConfiguration;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29uZmlndXJhdGlvbi9jb25uZWN0aW9uX2NvbmZpZ3VyYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLGdEQUFNO0FBQzNCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFFBQVEsZ0VBQWdFLEVBQUUsbUJBQU8sQ0FBQyx5RUFBYztBQUNoRyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsZUFBZSxtQkFBTyxDQUFDLG1FQUFXO0FBQ2xDLDRCQUE0QixtQkFBTyxDQUFDLDZIQUF3QztBQUM1RSxhQUFhLG1CQUFPLENBQUMsK0RBQVM7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhDQUE4QyxrQkFBa0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSwwREFBMEQsbUJBQW1CO0FBQzdFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUNBQW1DIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2NvbmZpZ3VyYXRpb24vY29ubmVjdGlvbl9jb25maWd1cmF0aW9uLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHRvbWwgPSByZXF1aXJlKCd0b21sJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IHZhbGlkYXRlT25seVVzZXJSZWFkV3JpdGVQZXJtaXNzaW9uQW5kT3duZXIsIGdlbmVyYXRlQ2hlY2tzdW0gfSA9IHJlcXVpcmUoJy4uL2ZpbGVfdXRpbCcpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgQXV0aGVudGljYXRpb25UeXBlcyA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uX3R5cGVzJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5mdW5jdGlvbiBkZWZhdWx0SWZOb3RTZXQodmFsdWUsIGRlZmF1bHRWYWx1ZSkge1xuICBpZiAodmFsdWUgPT09IG51bGwgfHwgdHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyB8fCB2YWx1ZSA9PT0gJycpIHtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRSZWFkVG9rZW5Gcm9tRmlsZShmaXhlZENvbmZpZ3VyYXRpb24pIHtcbiAgcmV0dXJuIGZpeGVkQ29uZmlndXJhdGlvbiAmJiBmaXhlZENvbmZpZ3VyYXRpb24uYXV0aGVudGljYXRvciAmJlxuICAgIGZpeGVkQ29uZmlndXJhdGlvbi5hdXRoZW50aWNhdG9yLnRvVXBwZXJDYXNlKCkgPT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuT0FVVEhfQVVUSEVOVElDQVRPUiAmJlxuICAgICFVdGlsLnN0cmluZy5pc05vdE51bGxPckVtcHR5KGZpeGVkQ29uZmlndXJhdGlvbi50b2tlbik7XG59XG5cbmZ1bmN0aW9uIHJlYWRUb2tlbkZyb21GaWxlKGZpeGVkQ29uZmlndXJhdGlvbikge1xuICBjb25zdCB0b2tlbkZpbGVQYXRoID0gZml4ZWRDb25maWd1cmF0aW9uLnRva2VuX2ZpbGVfcGF0aCA/IGZpeGVkQ29uZmlndXJhdGlvbi50b2tlbl9maWxlX3BhdGggOiAnL3Nub3dmbGFrZS9zZXNzaW9uL3Rva2VuJztcbiAgY29uc3QgcmVzb2x2ZWRQYXRoID0gZnMucmVhbHBhdGhTeW5jKHRva2VuRmlsZVBhdGgpO1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnVG9rZW4gZmlsZSBwYXRoIGlzIDogJXMnLCB0b2tlbkZpbGVQYXRoKTtcbiAgdmFsaWRhdGVPbmx5VXNlclJlYWRXcml0ZVBlcm1pc3Npb25BbmRPd25lcihyZXNvbHZlZFBhdGgpO1xuICBmaXhlZENvbmZpZ3VyYXRpb24udG9rZW4gPSBmcy5yZWFkRmlsZVN5bmMocmVzb2x2ZWRQYXRoLCAndXRmLTgnKS50cmltKCk7XG4gIGlmICghZml4ZWRDb25maWd1cmF0aW9uLnRva2VuKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ1RoZSB0b2tlbiBkb2VzIG5vdCBleGlzdCBvciBoYXMgZW1wdHkgdmFsdWUuJyk7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgdG9rZW4gZG9lcyBub3QgZXhpc3Qgb3IgaGFzIGVtcHR5IHZhbHVlJyk7XG4gIH1cbiAgY29uc3QgdG9rZW5DaGVja3N1bSA9IGdlbmVyYXRlQ2hlY2tzdW0oZml4ZWRDb25maWd1cmF0aW9uLnRva2VuKTtcbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnVG9rZW4gdXNlZCBpbiBjb25uZWN0aW9uIGhhcyBiZWVuIHJlYWQgZnJvbSBmaWxlOiAlcy4gQ2hlY2tzdW06ICVzJywgcmVzb2x2ZWRQYXRoLCB0b2tlbkNoZWNrc3VtKTtcbn1cblxuZnVuY3Rpb24gbG9hZENvbm5lY3Rpb25Db25maWd1cmF0aW9uKCkge1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnTG9hZGluZyBjb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gZnJvbSB0aGUgbG9jYWwgZmlsZXMuLi4nKTtcbiAgY29uc3Qgc25vd2ZsYWtlQ29uZmlnRGlyID0gZGVmYXVsdElmTm90U2V0KHByb2Nlc3MuZW52LlNOT1dGTEFLRV9IT01FLCBwYXRoLmpvaW4ob3MuaG9tZWRpcigpLCAnLnNub3dmbGFrZScpKTtcbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0xvb2tpbmcgZm9yIGNvbm5lY3Rpb24gZmlsZSBpbiBkaXJlY3RvcnkgJXMnLCBzbm93Zmxha2VDb25maWdEaXIpO1xuICBjb25zdCBmaWxlUGF0aCA9IHBhdGguam9pbihzbm93Zmxha2VDb25maWdEaXIsICdjb25uZWN0aW9ucy50b21sJyk7XG4gIGNvbnN0IHJlc29sdmVkUGF0aCA9IGZzLnJlYWxwYXRoU3luYyhmaWxlUGF0aCk7XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gZmlsZSBmb3VuZCB1bmRlciB0aGUgcGF0aCAlcy4gVmFsaWRhdGluZyBmaWxlIGFjY2Vzcy4nLCByZXNvbHZlZFBhdGgpO1xuXG4gIHZhbGlkYXRlT25seVVzZXJSZWFkV3JpdGVQZXJtaXNzaW9uQW5kT3duZXIocmVzb2x2ZWRQYXRoKTtcbiAgY29uc3Qgc3RyID0gZnMucmVhZEZpbGVTeW5jKHJlc29sdmVkUGF0aCwgeyBlbmNvZGluZzogJ3V0ZjgnIH0pO1xuICBjb25zdCBjb25maWd1cmF0aW9uQ2hlY2tzdW0gPSBnZW5lcmF0ZUNoZWNrc3VtKHN0cik7XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb24gY29uZmlndXJhdGlvbiBmaWxlIGlzIHJlYWQgZnJvbSBwYXRoOiAlcy4gQ2hlY2tzdW06ICVzJywgcmVzb2x2ZWRQYXRoLCBjb25maWd1cmF0aW9uQ2hlY2tzdW0pO1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnVHJ5aW5nIHRvIHBhcnNlIHRoZSBjb25maWcgZmlsZScpO1xuICBjb25zdCBwYXJzaW5nUmVzdWx0ID0gdG9tbC5wYXJzZShzdHIpO1xuXG4gIGNvbnN0IGNvbmZpZ3VyYXRpb25OYW1lID0gZGVmYXVsdElmTm90U2V0KHByb2Nlc3MuZW52LlNOT1dGTEFLRV9ERUZBVUxUX0NPTk5FQ1RJT05fTkFNRSwgJ2RlZmF1bHQnKTtcblxuICBpZiAocGFyc2luZ1Jlc3VsdFtjb25maWd1cmF0aW9uTmFtZV0gIT09IHVuZGVmaW5lZCkge1xuICAgIGNvbnN0IGZpeGVkQ29uZmlndXJhdGlvbiA9IGZpeFVzZXJLZXkocGFyc2luZ1Jlc3VsdFtjb25maWd1cmF0aW9uTmFtZV0pO1xuICAgIGlmIChzaG91bGRSZWFkVG9rZW5Gcm9tRmlsZShmaXhlZENvbmZpZ3VyYXRpb24pKSB7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdUcnlpbmcgdG8gcmVhZCB0b2tlbiBmcm9tIGNvbmZpZyBmaWxlLicpO1xuICAgICAgcmVhZFRva2VuRnJvbUZpbGUoZml4ZWRDb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpeGVkQ29uZmlndXJhdGlvbjtcbiAgfSBlbHNlIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQ29ubmVjdGlvbiBjb25maWd1cmF0aW9uIHdpdGggbmFtZSAlcyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgZmlsZSAlcycsIGNvbmZpZ3VyYXRpb25OYW1lLCByZXNvbHZlZFBhdGgpO1xuICAgIHRocm93IG5ldyBFcnJvcihgQ29ubmVjdGlvbiBjb25maWd1cmF0aW9uIHdpdGggbmFtZSAke2NvbmZpZ3VyYXRpb25OYW1lfSBkb2VzIG5vdCBleGlzdGApO1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpeFVzZXJLZXkocGFyc2luZ1Jlc3VsdCkge1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnRW1wdHkgVXNlcm5hbWUgZmllbGQgd2lsbCBiZSBmaWxsZWQgd2l0aCBcXCdVc2VyXFwnIGZpZWxkIHZhbHVlLicpO1xuICBpZiAocGFyc2luZ1Jlc3VsdFsndXNlcm5hbWUnXSA9PT0gdW5kZWZpbmVkICYmIHBhcnNpbmdSZXN1bHRbJ3VzZXInXSAhPT0gdW5kZWZpbmVkKXtcbiAgICBwYXJzaW5nUmVzdWx0Wyd1c2VybmFtZSddID0gcGFyc2luZ1Jlc3VsdFsndXNlciddO1xuICB9XG4gIHJldHVybiBwYXJzaW5nUmVzdWx0O1xufVxuXG5leHBvcnRzLmxvYWRDb25uZWN0aW9uQ29uZmlndXJhdGlvbiA9IGxvYWRDb25uZWN0aW9uQ29uZmlndXJhdGlvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/configuration/connection_configuration.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/bind_uploader.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/bind_uploader.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\n\nconst fs = __webpack_require__(/*! fs */ \"fs\");\n\nconst Statement = __webpack_require__(/*! ./statement */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/statement.js\");\nconst { isString } = __webpack_require__(/*! util */ \"util\");\n\nconst STAGE_NAME = 'SYSTEM$BIND';\nconst CREATE_STAGE_STMT = 'CREATE OR REPLACE TEMPORARY STAGE '\n\t+ STAGE_NAME\n\t+ ' file_format=( type=csv field_optionally_enclosed_by=\\'\"\\')';\n\t\n/**\n * Creates a new BindUploader.\n *\n * @param {Object} options\n * @param {Object} services\n * @param {Object} connectionConfig\n * @param {*} requestId \n *\n * @constructor\n */\n \nfunction BindUploader(options, services, connectionConfig, requestId) {\n  const MAX_BUFFER_SIZE = 1024 * 1024 * 100;\n\n  Logger.getInstance().debug('BindUploaders');\n  this.options = options;\n  this.services = services;\n  this.connectionConfig = connectionConfig;\n  this.requestId = requestId;\n  this.stagePath = '@' + STAGE_NAME + '/' + requestId;\n  Logger.getInstance().debug('token = %s', connectionConfig.getToken());\n\n  this.createStage = async function () {\n    const createStageOptions = { sqlText: GetCreateStageStmt() };\n    const newContext = Statement.createContext(createStageOptions, this.services, this.connectionConfig);\n    if (this.connectionConfig.getForceStageBindError() === 0) {\n      throw new Error('Failed to create stage');\n    }\n    const ret = await Statement.sendRequest(newContext);\n    if (ret['status'] !== 200) {\n      throw new Error('Failed to create stage');\n    }\n  };\n\n  this.uploadFilestream = async function (fileName, fileData) {\n    Logger.getInstance().debug('BindUploaders::uploadFilestream');\n    const stageName = this.stagePath;\n    if (stageName == null) {\n      throw new Error('Stage name is null.');\n    }\n    if (fileName == null) {\n      throw new Error('File name is null.');\n    }\n    if (this.connectionConfig.getForceStageBindError() === 1) {\n      throw new Error('Failed to upload file');\n    }\n\n    await new Promise((resolve, reject) => {\n      const putStmt = 'PUT file://' + fileName + '\\'' + stageName + '\\' overwrite=true auto_compress=false source_compression=gzip';\n      const uploadFileOptions = {\n        sqlText: putStmt, fileStream: fileData,\n        complete: function (err, stmt) {\n          if (err) {\n            Logger.getInstance().debug('err ' + err);\n            reject(err);\n          }\n          Logger.getInstance().debug('uploadFiles done ');\n          resolve(stmt.streamRows());\n        }\n      };\n      Statement.createStatementPreExec(uploadFileOptions, this.services, this.connectionConfig);\n    });\n  };\n\n  this.Upload = async function (bindings) {\n    Logger.getInstance().debug('BindUploaders::Upload');\n\t\n    if (bindings == null) {\n      return null; \n    }\n    if (!this.services.sf.isStageCreated) {\n      await this.createStage();\n      this.services.sf.isStageCreated = true;\n    }\n\t\n    let fileCount = 0;\n    let strbuffer = '';\n\t\t\n    for (let i = 0; i < bindings.length; i++) {\n      for (let j = 0; j < bindings[i].length; j++) {\n        if (j > 0) {\n          strbuffer += ','; \n        }\n        const value = this.cvsData(bindings[i][j]);\n        strbuffer += value;\n      }\n      strbuffer += '\\n';\n\n      if ((strbuffer.length >= MAX_BUFFER_SIZE) || (i === bindings.length - 1)) {\n        const fileName = (++fileCount).toString();\n        Logger.getInstance().debug('fileName=' + fileName);\n        await this.uploadFilestream(fileName, strbuffer);\n        strbuffer = '';\n      }\n    }\n  };\n\t\n  this.cvsData = function (data) {\n    if (data == null || data.toString() === '') {\n      return '\"\"'; \n    }\n    if (!isString(data)) {\n      if (data instanceof Date) {\n        data = data.toJSON();\n      } else {\n        data = JSON.stringify(data);\n      }\n    }\n    if (data.toString().indexOf('\"') >= 0\n\t\t\t|| data.toString().indexOf(',') >= 0\t\n\t\t\t|| data.toString().indexOf('\\\\') >= 0\n\t\t\t|| data.toString().indexOf('\\n') >= 0\n\t\t\t|| data.toString().indexOf('\\t') >= 0) {\n      return '\"' + data.toString().replaceAll('\"', '\"\"') + '\"'; \n    } else {\n      return data; \n    }\n  };\n}\n\nfunction GetCreateStageStmt() {\n  return CREATE_STAGE_STMT;\n}\n\nfunction GetStageName(requestId) {\n  return '@' + STAGE_NAME + '/' + requestId;\n}\n\nfunction CleanFile(fileName) {\n  try {\n    if (fs.existsSync(fileName)) {\n      fs.unlinkSync(fileName);\n    }\n  } catch (err) {\n    Logger.getInstance().debug('Delete file failed: %s', fileName);\n  }\n}\n\nmodule.exports = { BindUploader, GetCreateStageStmt, GetStageName, CleanFile };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9iaW5kX3VwbG9hZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVzs7QUFFbEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7O0FBRXZCLGtCQUFrQixtQkFBTyxDQUFDLG1GQUFhO0FBQ3ZDLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsa0JBQU07O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLEdBQUc7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IscUJBQXFCO0FBQ3pDLHNCQUFzQix3QkFBd0I7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2Nvbm5lY3Rpb24vYmluZF91cGxvYWRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcblxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuXG5jb25zdCBTdGF0ZW1lbnQgPSByZXF1aXJlKCcuL3N0YXRlbWVudCcpO1xuY29uc3QgeyBpc1N0cmluZyB9ID0gcmVxdWlyZSgndXRpbCcpO1xuXG5jb25zdCBTVEFHRV9OQU1FID0gJ1NZU1RFTSRCSU5EJztcbmNvbnN0IENSRUFURV9TVEFHRV9TVE1UID0gJ0NSRUFURSBPUiBSRVBMQUNFIFRFTVBPUkFSWSBTVEFHRSAnXG5cdCsgU1RBR0VfTkFNRVxuXHQrICcgZmlsZV9mb3JtYXQ9KCB0eXBlPWNzdiBmaWVsZF9vcHRpb25hbGx5X2VuY2xvc2VkX2J5PVxcJ1wiXFwnKSc7XG5cdFxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEJpbmRVcGxvYWRlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IHNlcnZpY2VzXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICogQHBhcmFtIHsqfSByZXF1ZXN0SWQgXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbiBcbmZ1bmN0aW9uIEJpbmRVcGxvYWRlcihvcHRpb25zLCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZywgcmVxdWVzdElkKSB7XG4gIGNvbnN0IE1BWF9CVUZGRVJfU0laRSA9IDEwMjQgKiAxMDI0ICogMTAwO1xuXG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdCaW5kVXBsb2FkZXJzJyk7XG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gIHRoaXMuc2VydmljZXMgPSBzZXJ2aWNlcztcbiAgdGhpcy5jb25uZWN0aW9uQ29uZmlnID0gY29ubmVjdGlvbkNvbmZpZztcbiAgdGhpcy5yZXF1ZXN0SWQgPSByZXF1ZXN0SWQ7XG4gIHRoaXMuc3RhZ2VQYXRoID0gJ0AnICsgU1RBR0VfTkFNRSArICcvJyArIHJlcXVlc3RJZDtcbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ3Rva2VuID0gJXMnLCBjb25uZWN0aW9uQ29uZmlnLmdldFRva2VuKCkpO1xuXG4gIHRoaXMuY3JlYXRlU3RhZ2UgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgY3JlYXRlU3RhZ2VPcHRpb25zID0geyBzcWxUZXh0OiBHZXRDcmVhdGVTdGFnZVN0bXQoKSB9O1xuICAgIGNvbnN0IG5ld0NvbnRleHQgPSBTdGF0ZW1lbnQuY3JlYXRlQ29udGV4dChjcmVhdGVTdGFnZU9wdGlvbnMsIHRoaXMuc2VydmljZXMsIHRoaXMuY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgaWYgKHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRGb3JjZVN0YWdlQmluZEVycm9yKCkgPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignRmFpbGVkIHRvIGNyZWF0ZSBzdGFnZScpO1xuICAgIH1cbiAgICBjb25zdCByZXQgPSBhd2FpdCBTdGF0ZW1lbnQuc2VuZFJlcXVlc3QobmV3Q29udGV4dCk7XG4gICAgaWYgKHJldFsnc3RhdHVzJ10gIT09IDIwMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY3JlYXRlIHN0YWdlJyk7XG4gICAgfVxuICB9O1xuXG4gIHRoaXMudXBsb2FkRmlsZXN0cmVhbSA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlTmFtZSwgZmlsZURhdGEpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQmluZFVwbG9hZGVyczo6dXBsb2FkRmlsZXN0cmVhbScpO1xuICAgIGNvbnN0IHN0YWdlTmFtZSA9IHRoaXMuc3RhZ2VQYXRoO1xuICAgIGlmIChzdGFnZU5hbWUgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGFnZSBuYW1lIGlzIG51bGwuJyk7XG4gICAgfVxuICAgIGlmIChmaWxlTmFtZSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgbmFtZSBpcyBudWxsLicpO1xuICAgIH1cbiAgICBpZiAodGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldEZvcmNlU3RhZ2VCaW5kRXJyb3IoKSA9PT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gdXBsb2FkIGZpbGUnKTtcbiAgICB9XG5cbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBjb25zdCBwdXRTdG10ID0gJ1BVVCBmaWxlOi8vJyArIGZpbGVOYW1lICsgJ1xcJycgKyBzdGFnZU5hbWUgKyAnXFwnIG92ZXJ3cml0ZT10cnVlIGF1dG9fY29tcHJlc3M9ZmFsc2Ugc291cmNlX2NvbXByZXNzaW9uPWd6aXAnO1xuICAgICAgY29uc3QgdXBsb2FkRmlsZU9wdGlvbnMgPSB7XG4gICAgICAgIHNxbFRleHQ6IHB1dFN0bXQsIGZpbGVTdHJlYW06IGZpbGVEYXRhLFxuICAgICAgICBjb21wbGV0ZTogZnVuY3Rpb24gKGVyciwgc3RtdCkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdlcnIgJyArIGVycik7XG4gICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ3VwbG9hZEZpbGVzIGRvbmUgJyk7XG4gICAgICAgICAgcmVzb2x2ZShzdG10LnN0cmVhbVJvd3MoKSk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBTdGF0ZW1lbnQuY3JlYXRlU3RhdGVtZW50UHJlRXhlYyh1cGxvYWRGaWxlT3B0aW9ucywgdGhpcy5zZXJ2aWNlcywgdGhpcy5jb25uZWN0aW9uQ29uZmlnKTtcbiAgICB9KTtcbiAgfTtcblxuICB0aGlzLlVwbG9hZCA9IGFzeW5jIGZ1bmN0aW9uIChiaW5kaW5ncykge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdCaW5kVXBsb2FkZXJzOjpVcGxvYWQnKTtcblx0XG4gICAgaWYgKGJpbmRpbmdzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsOyBcbiAgICB9XG4gICAgaWYgKCF0aGlzLnNlcnZpY2VzLnNmLmlzU3RhZ2VDcmVhdGVkKSB7XG4gICAgICBhd2FpdCB0aGlzLmNyZWF0ZVN0YWdlKCk7XG4gICAgICB0aGlzLnNlcnZpY2VzLnNmLmlzU3RhZ2VDcmVhdGVkID0gdHJ1ZTtcbiAgICB9XG5cdFxuICAgIGxldCBmaWxlQ291bnQgPSAwO1xuICAgIGxldCBzdHJidWZmZXIgPSAnJztcblx0XHRcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJpbmRpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGJpbmRpbmdzW2ldLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChqID4gMCkge1xuICAgICAgICAgIHN0cmJ1ZmZlciArPSAnLCc7IFxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5jdnNEYXRhKGJpbmRpbmdzW2ldW2pdKTtcbiAgICAgICAgc3RyYnVmZmVyICs9IHZhbHVlO1xuICAgICAgfVxuICAgICAgc3RyYnVmZmVyICs9ICdcXG4nO1xuXG4gICAgICBpZiAoKHN0cmJ1ZmZlci5sZW5ndGggPj0gTUFYX0JVRkZFUl9TSVpFKSB8fCAoaSA9PT0gYmluZGluZ3MubGVuZ3RoIC0gMSkpIHtcbiAgICAgICAgY29uc3QgZmlsZU5hbWUgPSAoKytmaWxlQ291bnQpLnRvU3RyaW5nKCk7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdmaWxlTmFtZT0nICsgZmlsZU5hbWUpO1xuICAgICAgICBhd2FpdCB0aGlzLnVwbG9hZEZpbGVzdHJlYW0oZmlsZU5hbWUsIHN0cmJ1ZmZlcik7XG4gICAgICAgIHN0cmJ1ZmZlciA9ICcnO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblx0XG4gIHRoaXMuY3ZzRGF0YSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhLnRvU3RyaW5nKCkgPT09ICcnKSB7XG4gICAgICByZXR1cm4gJ1wiXCInOyBcbiAgICB9XG4gICAgaWYgKCFpc1N0cmluZyhkYXRhKSkge1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIGRhdGEgPSBkYXRhLnRvSlNPTigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZGF0YS50b1N0cmluZygpLmluZGV4T2YoJ1wiJykgPj0gMFxuXHRcdFx0fHwgZGF0YS50b1N0cmluZygpLmluZGV4T2YoJywnKSA+PSAwXHRcblx0XHRcdHx8IGRhdGEudG9TdHJpbmcoKS5pbmRleE9mKCdcXFxcJykgPj0gMFxuXHRcdFx0fHwgZGF0YS50b1N0cmluZygpLmluZGV4T2YoJ1xcbicpID49IDBcblx0XHRcdHx8IGRhdGEudG9TdHJpbmcoKS5pbmRleE9mKCdcXHQnKSA+PSAwKSB7XG4gICAgICByZXR1cm4gJ1wiJyArIGRhdGEudG9TdHJpbmcoKS5yZXBsYWNlQWxsKCdcIicsICdcIlwiJykgKyAnXCInOyBcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRhdGE7IFxuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gR2V0Q3JlYXRlU3RhZ2VTdG10KCkge1xuICByZXR1cm4gQ1JFQVRFX1NUQUdFX1NUTVQ7XG59XG5cbmZ1bmN0aW9uIEdldFN0YWdlTmFtZShyZXF1ZXN0SWQpIHtcbiAgcmV0dXJuICdAJyArIFNUQUdFX05BTUUgKyAnLycgKyByZXF1ZXN0SWQ7XG59XG5cbmZ1bmN0aW9uIENsZWFuRmlsZShmaWxlTmFtZSkge1xuICB0cnkge1xuICAgIGlmIChmcy5leGlzdHNTeW5jKGZpbGVOYW1lKSkge1xuICAgICAgZnMudW5saW5rU3luYyhmaWxlTmFtZSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnRGVsZXRlIGZpbGUgZmFpbGVkOiAlcycsIGZpbGVOYW1lKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgQmluZFVwbG9hZGVyLCBHZXRDcmVhdGVTdGFnZVN0bXQsIEdldFN0YWdlTmFtZSwgQ2xlYW5GaWxlIH07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/bind_uploader.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/connection.js":
/*!*****************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/connection.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { v4: uuidv4 } = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\");\nconst Url = __webpack_require__(/*! url */ \"url\");\nconst QueryString = __webpack_require__(/*! querystring */ \"querystring\");\nconst QueryStatus = __webpack_require__(/*! ../constants/query_status */ \"(rsc)/./node_modules/snowflake-sdk/lib/constants/query_status.js\");\n\nconst LoggingUtil = __webpack_require__(/*! ../logger/logging_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger/logging_util.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Statement = __webpack_require__(/*! ./statement */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/statement.js\");\nconst Parameters = __webpack_require__(/*! ../parameters */ \"(rsc)/./node_modules/snowflake-sdk/lib/parameters.js\");\nconst Authenticator = __webpack_require__(/*! ../authentication/authentication */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/authentication.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ../authentication/authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/authentication_types.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst { isOktaAuth } = __webpack_require__(/*! ../authentication/authentication */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/authentication.js\");\nconst { init: initEasyLogging } = __webpack_require__(/*! ../logger/easy_logging_starter */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger/easy_logging_starter.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/lib/global_config.js\");\nconst JsonCredentialManager = __webpack_require__(/*! ../authentication/secure_storage/json_credential_manager */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/secure_storage/json_credential_manager.js\");\nconst ExecutionTimer = __webpack_require__(/*! ../logger/execution_timer */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger/execution_timer.js\");\n\n/**\n * Creates a new Connection instance.\n *\n * @param {ConnectionContext} context\n *\n * @returns {Object}\n */\nfunction Connection(context) {\n  // validate input\n  Logger.getInstance().trace('Connection object is being constructed');\n  Errors.assertInternal(Util.isObject(context));\n\n  const services = context.getServices();\n  const connectionConfig = context.getConnectionConfig();\n\n  // generate an id for the connection\n  const id = uuidv4();\n  Logger.getInstance().trace('Generated connection id: %s', id);\n\n  Logger.getInstance().info(\n    'Creating Connection[id: %s] with %s, password is %s, region: %s, '\n    + 'authenticator: %s, ocsp mode: %s, os: %s, os version: %s',\n    id,\n    connectionConfig.describeIdentityAttributes(),\n    LoggingUtil.describePresence(connectionConfig.password),\n    connectionConfig.region, connectionConfig.getAuthenticator(),\n    connectionConfig.getClientEnvironment().OCSP_MODE,\n    connectionConfig.getClientEnvironment().OS,\n    connectionConfig.getClientEnvironment().OS_VERSION);\n\n  // Log was split due to possibility of exceeding the max message length of the logger\n  Logger.getInstance().info(\n    'Connection[id: %s] additional details: '\n    + 'passcode in password is %s, passcode is %s, private key is %s, '\n    + 'application: %s, client name: %s, client version: %s, retry timeout: %s, '\n    + 'private key path: %s, private key pass is %s, '\n    + 'client store temporary credential: %s, browser response timeout: %s',\n    id,\n    LoggingUtil.describePresence(connectionConfig.getPasscodeInPassword()),\n    LoggingUtil.describePresence(connectionConfig.getPasscode()),\n    LoggingUtil.describePresence(connectionConfig.getPrivateKey()),\n    connectionConfig.getClientApplication(), connectionConfig.getClientName(),\n    connectionConfig.getClientVersion(), connectionConfig.getRetryTimeout(),\n    connectionConfig.getPrivateKeyPath(),\n    LoggingUtil.describePresence(connectionConfig.getPrivateKeyPass()),\n    connectionConfig.getClientStoreTemporaryCredential(),\n    connectionConfig.getBrowserActionTimeout());\n\n\n  // async max retry and retry pattern from python connector\n  const asyncNoDataMaxRetry = 24;\n  const asyncRetryPattern = [1, 1, 2, 3, 4, 8, 10];\n  const asyncRetryInMilliseconds = 500;\n\n  // Custom regex based on uuid validate\n  // Unable to directly use uuid validate because the queryId returned from the server doesn't match the regex\n  const queryIdRegex = new RegExp(/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);\n\n  //Make session tokens available for testing\n  this.getTokens = function () {\n    if (connectionConfig._qaMode) {\n      return services.sf.getConfig() && services.sf.getConfig().tokenInfo;\n    }\n    return {};\n  };\n  /**\n   * Returns true if the connection is active otherwise false\n   *\n   * @returns {boolean}\n   */\n  this.isUp = function () {\n    const isUp = services.sf.isConnected();\n    Logger.getInstance().trace('Connection[id: %s] - isUp called. Returning: %s', this.getId(), isUp);\n    return isUp;\n  };\n\n  /**\n  * Returns true if the session token and master token are valid\n  *\n  * @returns {boolean}\n  */\n  this.isTokenValid = function () {\n    Logger.getInstance().trace('Connection[id: %s] - isTokenValid called', this.getId());\n    const tokenInfo = services.sf.getConfig().tokenInfo;\n\n    const sessionTokenExpirationTime = tokenInfo.sessionTokenExpirationTime;\n    const isSessionValid = sessionTokenExpirationTime > Date.now();\n    Logger.getInstance().trace('Connection[id: %s] - isSessionTokenValid: %s', this.getId(), isSessionValid);\n\n\n    const masterTokenExpirationTime = tokenInfo.masterTokenExpirationTime;\n    const isMasterValid = masterTokenExpirationTime > Date.now();\n    Logger.getInstance().trace('Connection[id: %s] - isMasterTokenValid: %s', this.getId(), isMasterValid);\n\n    const areTokensValid = (isSessionValid && isMasterValid);\n    Logger.getInstance().trace('Connection[id: %s] - isTokenValid returned: %s', this.getId(), areTokensValid);\n    return areTokensValid;\n  };\n\n  this.getServiceName = function () {\n    return services.sf.getServiceName();\n  };\n\n  this.getClientSessionKeepAlive = function () {\n    return services.sf.getClientSessionKeepAlive();\n  };\n\n  this.getClientSessionKeepAliveHeartbeatFrequency = function () {\n    return services.sf.getClientSessionKeepAliveHeartbeatFrequency();\n  };\n\n  this.getJsTreatIntegerAsBigInt = function () {\n    return services.sf.getJsTreatIntegerAsBigInt();\n  };\n\n  /**\n   * Returns the connection id.\n   *\n   * @returns {String}\n   */\n  this.getId = function () {\n    return id;\n  };\n\n  this.heartbeat = callback => {\n    Logger.getInstance().trace('Issuing heartbeat call');\n    const requestId = uuidv4();\n\n    services.sf.request(\n      {\n        method: 'POST',\n        url: Url.format(\n          {\n            pathname: '/session/heartbeat',\n            search: QueryString.stringify(\n              {\n                requestId: requestId\n              })\n          }),\n        callback: Util.isFunction(callback) ? callback : function (err, body) {\n          if (err) {\n            Logger.getInstance().error('Error issuing heartbeat call: %s', err.message);\n          } else {\n            Logger.getInstance().trace('Heartbeat response %s', JSON.stringify(body));\n          }\n        }\n      }\n    );\n  };\n\n  this.heartbeatAsync = () => {\n    return new Promise((resolve, reject) => {\n      // previous version of driver called `select 1;` which result in `[ { '1': 1 } ]`\n      Logger.getInstance().trace('Issuing async heartbeat call');\n      this.heartbeat((err) => err ? reject(err) : resolve([{ '1': 1 }]));\n    });\n  };\n\n  /**\n   * @return {Promise<boolean>}\n   */\n  this.isValidAsync = async () => {\n    Logger.getInstance().trace('Connection[id: %s] - isValidAsync called', this.getId());\n    if (!this.isUp()) {\n      return false;\n    }\n    try {\n      await this.heartbeatAsync();\n      return true;\n    } catch (e) {\n      Logger.getInstance().debug('Connection[id: %s] - heartbeat failed: %s', this.getId(), JSON.stringify(e, Object.getOwnPropertyNames(e)));\n      return false;\n    }\n  };\n\n  /**\n  * Set the private link as the OCSP cache server's URL.\n  *\n  * @param {String} host\n  *\n  * @returns {null}\n  */\n  this.setupOcspPrivateLink = function (host) {\n    process.env.SF_OCSP_RESPONSE_CACHE_SERVER_URL = Util.createOcspResponseCacheServerUrl(host);\n  };\n\n  /**\n   * Method returning callback function for connect() - used to establish a connection.\n   *\n   * @param self\n   * @param {Function} callback\n   *\n   * @returns {function}\n   */\n  function connectCallback(self, callback) {\n    return function (err) {\n      if (Parameters.getValue(Parameters.names.CLIENT_SESSION_KEEP_ALIVE)) {\n        const SECONDS_TO_MILLISECONDS_MULTIPLIER = 1000;\n        const KEEP_ALIVE_HEARTBEAT_FREQUENCY_IN_MS = Parameters.getValue(Parameters.names.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY) * SECONDS_TO_MILLISECONDS_MULTIPLIER;\n        self.keepalive = setInterval(self.heartbeat, KEEP_ALIVE_HEARTBEAT_FREQUENCY_IN_MS, self);\n        Logger.getInstance().trace('Connection[id: %s] - keepAlive internal created', id);\n      }\n      if (Util.isFunction(callback)) {\n        callback(Errors.externalize(err), self);\n      }\n    };\n  }\n\n  this.determineConnectionDomain = () => connectionConfig.accessUrl && connectionConfig.accessUrl.includes('snowflakecomputing.cn') ? 'CHINA' : 'GLOBAL';\n\n  /**\n   * Establishes a connection if we aren't in a fatal state.\n   *\n   * @param {Function} callback\n   *\n   * @returns {Object} the connection object.\n   */\n  this.connect = function (callback) {\n    const timer = new ExecutionTimer().start();\n    const connectionDomain = this.determineConnectionDomain();\n    Logger.getInstance().info('Connection[id: %s] - connecting. Associated Snowflake domain: %s', this.getId(), connectionDomain);\n    // invalid callback\n    Errors.checkArgumentValid(\n      !Util.exists(callback) || Util.isFunction(callback),\n      ErrorCodes.ERR_CONN_CONNECT_INVALID_CALLBACK);\n\n    if (Util.exists(connectionConfig.host) && Util.isPrivateLink(connectionConfig.host)) {\n      Logger.getInstance().info('Connection[id: %s] - setting up private link', this.getId());\n      this.setupOcspPrivateLink(connectionConfig.host);\n    }\n\n    // connect to the snowflake service and provide our own callback so that\n    // the connection can be passed in when invoking the connection.connect()\n    // callback\n    const self = this;\n\n    const authenticationType = connectionConfig.getAuthenticator();\n    Logger.getInstance().debug('Connection[id: %s] - using authentication type: %s', this.getId(), authenticationType);\n\n    // check if authentication type is compatible with connect()\n    // external browser and okta are not compatible with connect() due to their usage of async functions\n    if (authenticationType === AuthenticationTypes.EXTERNAL_BROWSER_AUTHENTICATOR ||\n      isOktaAuth(authenticationType)) {\n      const connectingDuration = timer.getDuration();\n      Logger.getInstance().error('Connection[id: %s] - connecting failed after %s milliseconds.' +\n          'Error: External browser and Okta are not compatible with connection process', this.getId(), connectingDuration\n      );\n      throw Errors.createClientError(\n        ErrorCodes.ERR_CONN_CREATE_INVALID_AUTH_CONNECT);\n    }\n\n    // Get authenticator to use\n    Logger.getInstance().debug('Connection[id: %s] - retrieving authenticator', this.getId());\n    const auth = services.sf.getAuthenticator();\n\n    Logger.getInstance().debug('Connection[id: %s] - trying to authenticate', this.getId());\n    auth.authenticate(connectionConfig.getAuthenticator(),\n      connectionConfig.getServiceName(),\n      connectionConfig.account,\n      connectionConfig.username).then(() => {\n      Logger.getInstance().info('Connection[id: %s] - authentication successful using: %s', this.getId(), connectionConfig.getAuthenticator());\n      // JSON for connection\n      const body = Authenticator.formAuthJSON(connectionConfig.getAuthenticator(),\n        connectionConfig.account,\n        connectionConfig.username,\n        connectionConfig.getClientType(),\n        connectionConfig.getClientVersion(),\n        connectionConfig.getClientEnvironment());\n\n      // Update JSON body with the authentication values\n      auth.updateBody(body);\n\n      Logger.getInstance().debug('Connection[id: %s] - initializing easyLogging', this.getId());\n      initEasyLogging(connectionConfig.clientConfigFile)\n        .then(() => {\n          Logger.getInstance().debug('Connection[id: %s] - easyLogging initialized', this.getId());\n          try {\n            Logger.getInstance().debug('Connection[id: %s] - connecting through service', this.getId());\n            services.sf.connect({\n              callback: connectCallback(self, callback),\n              json: body\n            });\n\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().info(\n              'Connection[id: %s] - connected successfully after %s milliseconds',\n              this.getId(), connectingDuration\n            );\n            return this;\n          } catch (e) {\n            // we don't expect an error here since callback method should be called\n            const connectingDuration = timer.getDuration();\n            Logger.getInstance().info('Connection[id: %s] - failed to connect after %s milliseconds. ' +\n                'Error: Unexpected error from calling connectCallback function in snowflake service - %s', this.getId(), connectingDuration, e);\n          }\n        },\n        ()  => {\n          const connectingDuration = timer.getDuration();\n          Logger.getInstance().error('Connection[id: %s] - failed to initialize easyLogging. ' +\n              'Connecting failed after %s milliseconds', this.getId(), connectingDuration);\n          callback(Errors.createClientError(ErrorCodes.ERR_CONN_CONNECT_INVALID_CLIENT_CONFIG, true), self);\n        });\n    },\n    (err) => {\n      const connectingDuration = timer.getDuration();\n      Logger.getInstance().error('Connection[id: %s] - authentication failed. Error: %s. ' +\n            'Connecting failed after %s milliseconds', this.getId(), err, connectingDuration);\n      callback(err, self);\n    });\n\n    return this;\n  };\n\n\n  /**\n   * Establishes a connection if we aren't in a fatal state.\n   *\n   * @param {Function} callback\n   *\n   * @returns {Object} the connection object.\n   */\n  this.connectAsync = async function (callback) {\n    const timer = new ExecutionTimer().start();\n    const connectingDomain = this.determineConnectionDomain();\n    Logger.getInstance().info('Connection[id: %s] - async connecting. Associated Snowflake domain: %s', this.getId(), connectingDomain);\n\n    // invalid callback\n    Errors.checkArgumentValid(\n      !Util.exists(callback) || Util.isFunction(callback),\n      ErrorCodes.ERR_CONN_CONNECT_INVALID_CALLBACK);\n\n    if (Util.isPrivateLink(connectionConfig.host)) {\n      this.setupOcspPrivateLink(connectionConfig.host);\n      Logger.getInstance().info('Connection[id: %s] - setting up private link', this.getId());\n    }\n\n    // connect to the snowflake service and provide our own callback so that\n    // the connection can be passed in when invoking the connection.connect()\n    // callback\n    \n    const self = this;\n\n    if (connectionConfig.getClientStoreTemporaryCredential()) {\n      Logger.getInstance().debug('Connection[id: %s] - storing temporary credential of client', this.getId());\n      const key = Util.buildCredentialCacheKey(connectionConfig.host,\n        connectionConfig.username, AuthenticationTypes.ID_TOKEN_AUTHENTICATOR);\n      if (GlobalConfig.getCredentialManager() === null) {\n        Logger.getInstance().debug('Connection[id: %s] - using default json credential manager', this.getId());\n        GlobalConfig.setCustomCredentialManager(new JsonCredentialManager(connectionConfig.getCredentialCacheDir()));\n      }\n      Logger.getInstance().debug('Connection[id: %s] - reading idToken using credential manager', this.getId());\n      connectionConfig.idToken = await GlobalConfig.getCredentialManager().read(key);\n    }\n\n    if (connectionConfig.getClientRequestMFAToken()) {\n      Logger.getInstance().debug('Connection[id: %s] - extracting mfaToken of client', this.getId());\n      const key = Util.buildCredentialCacheKey(connectionConfig.host,\n        connectionConfig.username, AuthenticationTypes.USER_PWD_MFA_AUTHENTICATOR);\n      if (GlobalConfig.getCredentialManager() === null) {\n        Logger.getInstance().debug('Connection[id: %s] - using default json credential manager', this.getId());\n        GlobalConfig.setCustomCredentialManager(new JsonCredentialManager(connectionConfig.getCredentialCacheDir()));\n      }\n      Logger.getInstance().debug('Connection[id: %s] - reading mfaToken using credential manager', this.getId());\n      connectionConfig.mfaToken = await GlobalConfig.getCredentialManager().read(key);\n    }\n   \n    // Get authenticator to use\n    Logger.getInstance().debug('Connection[id: %s] - retrieving authenticator', this.getId());\n    const auth = Authenticator.getAuthenticator(connectionConfig, context.getHttpClient());\n    services.sf.authenticator = auth;\n\n    try {\n      Logger.getInstance().debug('Connection[id: %s] - initializing easyLogging', this.getId());\n      await initEasyLogging(connectionConfig.clientConfigFile);\n    } catch (err) {\n      const connectingDuration = timer.getDuration();\n      Logger.getInstance().error('Connection[id: %s] - failed to initialize easyLogging. ' +\n          'Connecting failed after %s milliseconds', this.getId(), connectingDuration);\n      throw Errors.createClientError(ErrorCodes.ERR_CONN_CONNECT_INVALID_CLIENT_CONFIG, true);\n    }\n\n    let body = null;\n    try {\n      Logger.getInstance().debug('Connection[id: %s] - using authentication type: %s', this.getId(), connectionConfig.getAuthenticator());\n\n      Logger.getInstance().debug('Connection[id: %s] - trying to authenticate', this.getId());\n      await auth.authenticate(connectionConfig.getAuthenticator(),\n        connectionConfig.getServiceName(),\n        connectionConfig.account,\n        connectionConfig.username);\n\n      Logger.getInstance().info('Connection[id: %s] - authentication successful using: %s', this.getId(), connectionConfig.getAuthenticator());\n\n      // JSON for connection\n      body = Authenticator.formAuthJSON(connectionConfig.getAuthenticator(),\n        connectionConfig.account,\n        connectionConfig.username,\n        connectionConfig.getClientType(),\n        connectionConfig.getClientVersion(),\n        connectionConfig.getClientEnvironment());\n    \n      // Update JSON body with the authentication values\n      auth.updateBody(body);\n    } catch (authErr) {\n      const connectingDuration = timer.getDuration();\n      Logger.getInstance().info('Connection[id: %s] - failed to connect async after %s milliseconds.' +\n          'Failed during authentication. Error: %s', this.getId(), connectingDuration, authErr);\n\n      Logger.getInstance().error('Connection[id: %s] - failed during authentication. Error: %s', this.getId(), authErr);\n      callback(authErr);\n      return this;\n    }\n\n    try {\n      // Request connection\n      Logger.getInstance().debug('Connection[id: %s] - connecting through service', this.getId());\n      services.sf.connect({\n        callback: connectCallback(self, callback),\n        json: body,\n      });\n      // return the connection to facilitate chaining\n      const connectingDuration = timer.getDuration();\n      Logger.getInstance().info('Connection[id: %s] - connected successfully after %s milliseconds', this.getId(), connectingDuration);\n\n    } catch (callbackErr) {\n      const connectingDuration = timer.getDuration();\n      Logger.getInstance().info('Connection[id: %s] - failed to connect async after %s milliseconds.' +\n          'Error: Unexpected error from calling connectCallback function in snowflake service - %s', this.getId(), connectingDuration, callbackErr);\n      callback(callbackErr);\n      return this;\n    }\n\n    return this;\n  };\n\n  /**\n   * Executes a statement.\n   *\n   * @param {Object} options\n   *\n   * @returns {Object}\n   */\n  this.execute = function (options) {\n    Logger.getInstance().trace('Connection[id: %s] - execute called with options.', this.getId());\n    return Statement.createStatementPreExec(\n      options, services, connectionConfig);\n  };\n\n  /**\n   * Fetches the result of a previously issued statement.\n   *\n   * @param {Object} options\n   *\n   * @returns {Object}\n   */\n  this.fetchResult = function (options) {\n    Logger.getInstance().trace('Connection[id: %s] - fetchResult called with options', this.getId());\n    return Statement.createStatementPostExec(\n      options, services, connectionConfig);\n  };\n\n  /**\n   * Immediately terminates the connection without waiting for currently\n   * executing statements to complete.\n   *\n   * @param {Function} callback\n   *\n   * @returns {Object} the connection object.\n   */\n  this.destroy = function (callback) {\n    // invalid callback\n    Logger.getInstance().trace('Connection[id: %s] - destroy called', this.getId());\n    Errors.checkArgumentValid(\n      !Util.exists(callback) || Util.isFunction(callback),\n      ErrorCodes.ERR_CONN_DESTROY_INVALID_CALLBACK);\n\n    // log out of the snowflake service and provide our own callback so that\n    // the connection can be passed in when invoking the connection.destroy()\n    // callback\n    Logger.getInstance().trace('Connection[id: %s] - destroying through service', this.getId());\n    const self = this;\n    services.sf.destroy(\n      {\n        callback: function (err) {\n          if (Util.exists(self.keepalive)) {\n            clearInterval(self.keepalive);\n            Logger.getInstance().trace('Connection[id: %s] - keepAlive interval cleared', self.getId());\n          }\n\n          if (Util.isFunction(callback)) {\n            callback(Errors.externalize(err), self);\n          }\n        }\n      });\n\n    Logger.getInstance().trace('Connection[id: %s] - connection destroyed successfully', this.getId());\n    // return the connection to facilitate chaining\n    return this;\n  };\n\n  /**\n   * Gets the response containing the status of the query based on queryId.\n   *\n   * @param {String} queryId\n   *\n   * @returns {Object} the query response\n   */\n  async function getQueryResponse(queryId) {\n    Logger.getInstance().trace('Connection[id: %s] - requested query response for Query[id: %s]', id, queryId);\n    // Check if queryId exists and is valid uuid\n    Errors.checkArgumentExists(Util.exists(queryId),\n      ErrorCodes.ERR_CONN_FETCH_RESULT_MISSING_QUERY_ID);\n    Errors.checkArgumentValid(queryIdRegex.test(queryId),\n      ErrorCodes.ERR_GET_RESPONSE_QUERY_INVALID_UUID, queryId);\n    Logger.getInstance().debug('Connection[id: %s] - Query[id: %s] is valid', id, queryId);\n\n    // Form the request options\n    const options =\n    {\n      method: 'GET',\n      url: Url.format(\n        {\n          pathname: `/monitoring/queries/${queryId}`\n        }),\n    };\n\n    Logger.getInstance().debug('Connection[id: %s] - fetching query response for Query[id: %s]', id, queryId);\n    const timer = new ExecutionTimer().start();\n    // Get the response containing the query status\n    const response = await services.sf.requestAsync(options);\n    const fetchingDuration = timer.getDuration();\n    Logger.getInstance().debug('Connection[id: %s] - query response for Query[id: %s] fetched successfully after: %s milliseconds', id, queryId, fetchingDuration);\n\n    return response['data'];\n  }\n\n  /**\n   * Extracts the status of the query from the query response.\n   *\n   * @param {Object} queryResponse\n   *\n   * @returns {String} the query status.\n   */\n  function extractQueryStatus(queryResponse) {\n    const queries = queryResponse['data']['queries'];\n    let status = QueryStatus.code.NO_QUERY_DATA; // default status\n    if ( queries.length > 0) {\n      status =  queries[0]['status'];\n    }\n\n    Logger.getInstance().trace('Connection[id: %s] - Extracted query status: %s', status);\n    return status;\n  }\n\n  /**\n   * Gets the status of the query based on queryId.\n   *\n   * @param {String} queryId\n   *\n   * @returns {String} the query status.\n   */\n  this.getQueryStatus = async function (queryId) {\n    Logger.getInstance().trace('Connection[id: %s] - getQueryStatus called for Query[id: %s]', this.getId(), queryId);\n    return extractQueryStatus(await getQueryResponse(queryId));\n  };\n\n  /**\n   * Gets the status of the query based on queryId and throws if there's an error.\n   *\n   * @param {String} queryId\n   *\n   * @returns {String} the query status.\n   */\n  this.getQueryStatusThrowIfError = async function (queryId) {\n    Logger.getInstance().trace('Connection[id: %s] - getQueryStatusThrowIfError called for Query[id: %s]', this.getId(), queryId);\n    const response = await getQueryResponse(queryId);\n    const status =  extractQueryStatus(response);\n    let sqlState = null;\n\n    if (this.isAnError(status) ) {\n      let message = response['message'] || '';\n      const code = response['code'] || -1;\n\n      if (response['data']) {\n        message += response['data']['queries'].length > 0 ? response['data']['queries'][0]['errorMessage'] : '';\n        sqlState = response['data']['sqlState'];\n      }\n\n      Logger.getInstance().debug('Connection[id: %s] - query error for Query[id: %s]. Error: %s. SQLState: %s', this.getId(), queryId, message, sqlState);\n      throw Errors.createOperationFailedError(\n        code, response, message, sqlState);\n    }\n\n    return status;\n  };\n\n  /**\n   * Gets the results from a previously ran query based on queryId\n   *\n   * @param {Object} options\n   *\n   * @returns {Object}\n   */\n  this.getResultsFromQueryId = async function (options) {\n    const queryId = options.queryId;\n    Logger.getInstance().trace('Connection[id: %s] - getResultsFromQueryId called for Query[id: %s].', this.getId(), queryId);\n\n    let status, noDataCounter = 0, retryPatternPos = 0;\n\n    // Wait until query has finished executing\n    let queryStillExecuting = true;\n    while (queryStillExecuting) {\n      Logger.getInstance().trace('Connection[id: %s] - checking if Query[id: %s] is still executing. Retries with no data count: %d', this.getId(), queryId, noDataCounter);\n      // Check if query is still running.\n      // Trigger exception if it failed or there is no query data in the server.\n      status = await this.getQueryStatusThrowIfError(queryId);\n      queryStillExecuting = this.isStillRunning(status);\n      if (!queryStillExecuting || status === QueryStatus.code.NO_QUERY_DATA) {\n        Logger.getInstance().trace('Connection[id: %s] - end of waiting for Query[id: %s] to finish executing. ' +\n            queryStillExecuting ? 'Query is no longer executing. ' : 0, this.getId(), queryId, status);\n        break;\n      }\n\n      // Timeout based on query status retry rules\n      await new Promise((resolve) => {\n        setTimeout(() => resolve(), asyncRetryInMilliseconds * asyncRetryPattern[retryPatternPos]);\n      });\n\n      // If no data, increment the no data counter\n      if (QueryStatus.code[status] === QueryStatus.code.NO_DATA) {\n        noDataCounter++;\n        Logger.getInstance().trace('Connection[id: %s] - no data returned for Query[id: %s]. Retries with no data count: %d', this.getId(), queryId, noDataCounter);\n        // Check if retry for no data is exceeded\n        if (noDataCounter > asyncNoDataMaxRetry) {\n          Logger.getInstance().error('Connection[id: %s] - no data returned for Query[id: %s]. Retry limit: %s reached.', this.getId(), queryId, asyncNoDataMaxRetry);\n          throw Errors.createClientError(\n            ErrorCodes.ERR_GET_RESULTS_QUERY_ID_NO_DATA, true, queryId);\n        }\n      }\n\n      if (retryPatternPos < asyncRetryPattern.length - 1) {\n        retryPatternPos++;\n      }\n    }\n\n    if (QueryStatus.code[status] === QueryStatus.code.NO_QUERY_DATA) {\n      Logger.getInstance().error('Connection[id: %s] - Query[id: %s] did not succeed. Final status: %s', this.getId(), queryId, status);\n      throw Errors.createClientError(\n        ErrorCodes.ERR_GET_RESULTS_QUERY_ID_NO_DATA, true, queryId, status);\n    }\n\n    if (QueryStatus.code[status] !== QueryStatus.code.SUCCESS) {\n      Logger.getInstance().error('Connection[id: %s] - Query[id: %s] did not succeed. Final status: %s', this.getId(), queryId, status);\n      throw Errors.createClientError(\n        ErrorCodes.ERR_GET_RESULTS_QUERY_ID_NOT_SUCCESS_STATUS, true, queryId, status);\n    }\n\n    Logger.getInstance().debug('Connection[id: %s] - Query[id: %s] succeeded. Fetching the result.', this.getId(), queryId);\n    return this.fetchResult(options);\n  };\n\n  /**\n   * Checks whether the given status is currently running.\n   *\n   * @param {String} status\n   *\n   * @returns {Boolean}\n   */\n  this.isStillRunning = function (status) {\n    Logger.getInstance().trace('Connection[id: %s] - checking if status %s is still running', this.getId(), status);\n    return QueryStatus.runningStatuses.includes(QueryStatus.code[status]);\n  };\n\n  /**\n   * Checks whether the given status means that there has been an error.\n   *\n   * @param {String} status\n   *\n   * @returns {Boolean}\n   */\n  this.isAnError = function (status) {\n    return QueryStatus.errorStatuses.includes(QueryStatus.code[status]);\n  };\n\n  /**\n   * Returns a serialized version of this connection.\n   *\n   * @returns {String}\n   */\n  this.serialize = function () {\n    Logger.getInstance().trace('Connection[id: %s] - serialize called', this.getId());\n    return JSON.stringify(context.getConfig());\n  };\n\n  EventEmitter.call(this);\n}\n\nUtil.inherits(Connection, EventEmitter);\n\nmodule.exports = Connection;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9jb25uZWN0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsOERBQU07QUFDckMsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLG9CQUFvQixtQkFBTyxDQUFDLGdDQUFhO0FBQ3pDLG9CQUFvQixtQkFBTyxDQUFDLG1HQUEyQjs7QUFFdkQsb0JBQW9CLG1CQUFPLENBQUMsNkZBQXdCO0FBQ3BELGFBQWEsbUJBQU8sQ0FBQywrREFBUztBQUM5QixlQUFlLG1CQUFPLENBQUMsbUVBQVc7QUFDbEM7QUFDQSxxQkFBcUIsMERBQThCO0FBQ25ELGtCQUFrQixtQkFBTyxDQUFDLG1GQUFhO0FBQ3ZDLG1CQUFtQixtQkFBTyxDQUFDLDJFQUFlO0FBQzFDLHNCQUFzQixtQkFBTyxDQUFDLGlIQUFrQztBQUNoRSw0QkFBNEIsbUJBQU8sQ0FBQyw2SEFBd0M7QUFDNUUsZUFBZSxtQkFBTyxDQUFDLG1FQUFXO0FBQ2xDLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMsaUhBQWtDO0FBQ2pFLFFBQVEsd0JBQXdCLEVBQUUsbUJBQU8sQ0FBQyw2R0FBZ0M7QUFDMUUscUJBQXFCLG1CQUFPLENBQUMsaUZBQWtCO0FBQy9DLDhCQUE4QixtQkFBTyxDQUFDLGlLQUEwRDtBQUNoRyx1QkFBdUIsbUJBQU8sQ0FBQyxtR0FBMkI7O0FBRTFEO0FBQ0E7QUFDQTtBQUNBLFdBQVcsbUJBQW1CO0FBQzlCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdEQUFnRCxFQUFFLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsR0FBRzs7QUFFbkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2YsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRCx1QkFBdUIsU0FBUztBQUNyRjtBQUNBLDZEQUE2RCxRQUFRO0FBQ3JFLEtBQUs7QUFDTDs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSxDQUN0QztBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2Nvbm5lY3Rpb24vY29ubmVjdGlvbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IHY0OiB1dWlkdjQgfSA9IHJlcXVpcmUoJ3V1aWQnKTtcbmNvbnN0IFVybCA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgUXVlcnlTdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuY29uc3QgUXVlcnlTdGF0dXMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvcXVlcnlfc3RhdHVzJyk7XG5cbmNvbnN0IExvZ2dpbmdVdGlsID0gcmVxdWlyZSgnLi4vbG9nZ2VyL2xvZ2dpbmdfdXRpbCcpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2RlcztcbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IFN0YXRlbWVudCA9IHJlcXVpcmUoJy4vc3RhdGVtZW50Jyk7XG5jb25zdCBQYXJhbWV0ZXJzID0gcmVxdWlyZSgnLi4vcGFyYW1ldGVycycpO1xuY29uc3QgQXV0aGVudGljYXRvciA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uJyk7XG5jb25zdCBBdXRoZW50aWNhdGlvblR5cGVzID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb25fdHlwZXMnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgeyBpc09rdGFBdXRoIH0gPSByZXF1aXJlKCcuLi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbicpO1xuY29uc3QgeyBpbml0OiBpbml0RWFzeUxvZ2dpbmcgfSA9IHJlcXVpcmUoJy4uL2xvZ2dlci9lYXN5X2xvZ2dpbmdfc3RhcnRlcicpO1xuY29uc3QgR2xvYmFsQ29uZmlnID0gcmVxdWlyZSgnLi4vZ2xvYmFsX2NvbmZpZycpO1xuY29uc3QgSnNvbkNyZWRlbnRpYWxNYW5hZ2VyID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vc2VjdXJlX3N0b3JhZ2UvanNvbl9jcmVkZW50aWFsX21hbmFnZXInKTtcbmNvbnN0IEV4ZWN1dGlvblRpbWVyID0gcmVxdWlyZSgnLi4vbG9nZ2VyL2V4ZWN1dGlvbl90aW1lcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgQ29ubmVjdGlvbiBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb25Db250ZXh0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gQ29ubmVjdGlvbihjb250ZXh0KSB7XG4gIC8vIHZhbGlkYXRlIGlucHV0XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uIG9iamVjdCBpcyBiZWluZyBjb25zdHJ1Y3RlZCcpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjb250ZXh0KSk7XG5cbiAgY29uc3Qgc2VydmljZXMgPSBjb250ZXh0LmdldFNlcnZpY2VzKCk7XG4gIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPSBjb250ZXh0LmdldENvbm5lY3Rpb25Db25maWcoKTtcblxuICAvLyBnZW5lcmF0ZSBhbiBpZCBmb3IgdGhlIGNvbm5lY3Rpb25cbiAgY29uc3QgaWQgPSB1dWlkdjQoKTtcbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0dlbmVyYXRlZCBjb25uZWN0aW9uIGlkOiAlcycsIGlkKTtcblxuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKFxuICAgICdDcmVhdGluZyBDb25uZWN0aW9uW2lkOiAlc10gd2l0aCAlcywgcGFzc3dvcmQgaXMgJXMsIHJlZ2lvbjogJXMsICdcbiAgICArICdhdXRoZW50aWNhdG9yOiAlcywgb2NzcCBtb2RlOiAlcywgb3M6ICVzLCBvcyB2ZXJzaW9uOiAlcycsXG4gICAgaWQsXG4gICAgY29ubmVjdGlvbkNvbmZpZy5kZXNjcmliZUlkZW50aXR5QXR0cmlidXRlcygpLFxuICAgIExvZ2dpbmdVdGlsLmRlc2NyaWJlUHJlc2VuY2UoY29ubmVjdGlvbkNvbmZpZy5wYXNzd29yZCksXG4gICAgY29ubmVjdGlvbkNvbmZpZy5yZWdpb24sIGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpLFxuICAgIGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50RW52aXJvbm1lbnQoKS5PQ1NQX01PREUsXG4gICAgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRFbnZpcm9ubWVudCgpLk9TLFxuICAgIGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50RW52aXJvbm1lbnQoKS5PU19WRVJTSU9OKTtcblxuICAvLyBMb2cgd2FzIHNwbGl0IGR1ZSB0byBwb3NzaWJpbGl0eSBvZiBleGNlZWRpbmcgdGhlIG1heCBtZXNzYWdlIGxlbmd0aCBvZiB0aGUgbG9nZ2VyXG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oXG4gICAgJ0Nvbm5lY3Rpb25baWQ6ICVzXSBhZGRpdGlvbmFsIGRldGFpbHM6ICdcbiAgICArICdwYXNzY29kZSBpbiBwYXNzd29yZCBpcyAlcywgcGFzc2NvZGUgaXMgJXMsIHByaXZhdGUga2V5IGlzICVzLCAnXG4gICAgKyAnYXBwbGljYXRpb246ICVzLCBjbGllbnQgbmFtZTogJXMsIGNsaWVudCB2ZXJzaW9uOiAlcywgcmV0cnkgdGltZW91dDogJXMsICdcbiAgICArICdwcml2YXRlIGtleSBwYXRoOiAlcywgcHJpdmF0ZSBrZXkgcGFzcyBpcyAlcywgJ1xuICAgICsgJ2NsaWVudCBzdG9yZSB0ZW1wb3JhcnkgY3JlZGVudGlhbDogJXMsIGJyb3dzZXIgcmVzcG9uc2UgdGltZW91dDogJXMnLFxuICAgIGlkLFxuICAgIExvZ2dpbmdVdGlsLmRlc2NyaWJlUHJlc2VuY2UoY29ubmVjdGlvbkNvbmZpZy5nZXRQYXNzY29kZUluUGFzc3dvcmQoKSksXG4gICAgTG9nZ2luZ1V0aWwuZGVzY3JpYmVQcmVzZW5jZShjb25uZWN0aW9uQ29uZmlnLmdldFBhc3Njb2RlKCkpLFxuICAgIExvZ2dpbmdVdGlsLmRlc2NyaWJlUHJlc2VuY2UoY29ubmVjdGlvbkNvbmZpZy5nZXRQcml2YXRlS2V5KCkpLFxuICAgIGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50QXBwbGljYXRpb24oKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnROYW1lKCksXG4gICAgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRWZXJzaW9uKCksIGNvbm5lY3Rpb25Db25maWcuZ2V0UmV0cnlUaW1lb3V0KCksXG4gICAgY29ubmVjdGlvbkNvbmZpZy5nZXRQcml2YXRlS2V5UGF0aCgpLFxuICAgIExvZ2dpbmdVdGlsLmRlc2NyaWJlUHJlc2VuY2UoY29ubmVjdGlvbkNvbmZpZy5nZXRQcml2YXRlS2V5UGFzcygpKSxcbiAgICBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCgpLFxuICAgIGNvbm5lY3Rpb25Db25maWcuZ2V0QnJvd3NlckFjdGlvblRpbWVvdXQoKSk7XG5cblxuICAvLyBhc3luYyBtYXggcmV0cnkgYW5kIHJldHJ5IHBhdHRlcm4gZnJvbSBweXRob24gY29ubmVjdG9yXG4gIGNvbnN0IGFzeW5jTm9EYXRhTWF4UmV0cnkgPSAyNDtcbiAgY29uc3QgYXN5bmNSZXRyeVBhdHRlcm4gPSBbMSwgMSwgMiwgMywgNCwgOCwgMTBdO1xuICBjb25zdCBhc3luY1JldHJ5SW5NaWxsaXNlY29uZHMgPSA1MDA7XG5cbiAgLy8gQ3VzdG9tIHJlZ2V4IGJhc2VkIG9uIHV1aWQgdmFsaWRhdGVcbiAgLy8gVW5hYmxlIHRvIGRpcmVjdGx5IHVzZSB1dWlkIHZhbGlkYXRlIGJlY2F1c2UgdGhlIHF1ZXJ5SWQgcmV0dXJuZWQgZnJvbSB0aGUgc2VydmVyIGRvZXNuJ3QgbWF0Y2ggdGhlIHJlZ2V4XG4gIGNvbnN0IHF1ZXJ5SWRSZWdleCA9IG5ldyBSZWdFeHAoL14oPzpbMC05YS1mXXs4fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXs0fS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaSk7XG5cbiAgLy9NYWtlIHNlc3Npb24gdG9rZW5zIGF2YWlsYWJsZSBmb3IgdGVzdGluZ1xuICB0aGlzLmdldFRva2VucyA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY29ubmVjdGlvbkNvbmZpZy5fcWFNb2RlKSB7XG4gICAgICByZXR1cm4gc2VydmljZXMuc2YuZ2V0Q29uZmlnKCkgJiYgc2VydmljZXMuc2YuZ2V0Q29uZmlnKCkudG9rZW5JbmZvO1xuICAgIH1cbiAgICByZXR1cm4ge307XG4gIH07XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvbm5lY3Rpb24gaXMgYWN0aXZlIG90aGVyd2lzZSBmYWxzZVxuICAgKlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHRoaXMuaXNVcCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCBpc1VwID0gc2VydmljZXMuc2YuaXNDb25uZWN0ZWQoKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gaXNVcCBjYWxsZWQuIFJldHVybmluZzogJXMnLCB0aGlzLmdldElkKCksIGlzVXApO1xuICAgIHJldHVybiBpc1VwO1xuICB9O1xuXG4gIC8qKlxuICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgc2Vzc2lvbiB0b2tlbiBhbmQgbWFzdGVyIHRva2VuIGFyZSB2YWxpZFxuICAqXG4gICogQHJldHVybnMge2Jvb2xlYW59XG4gICovXG4gIHRoaXMuaXNUb2tlblZhbGlkID0gZnVuY3Rpb24gKCkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBpc1Rva2VuVmFsaWQgY2FsbGVkJywgdGhpcy5nZXRJZCgpKTtcbiAgICBjb25zdCB0b2tlbkluZm8gPSBzZXJ2aWNlcy5zZi5nZXRDb25maWcoKS50b2tlbkluZm87XG5cbiAgICBjb25zdCBzZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZSA9IHRva2VuSW5mby5zZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZTtcbiAgICBjb25zdCBpc1Nlc3Npb25WYWxpZCA9IHNlc3Npb25Ub2tlbkV4cGlyYXRpb25UaW1lID4gRGF0ZS5ub3coKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gaXNTZXNzaW9uVG9rZW5WYWxpZDogJXMnLCB0aGlzLmdldElkKCksIGlzU2Vzc2lvblZhbGlkKTtcblxuXG4gICAgY29uc3QgbWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZSA9IHRva2VuSW5mby5tYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lO1xuICAgIGNvbnN0IGlzTWFzdGVyVmFsaWQgPSBtYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lID4gRGF0ZS5ub3coKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gaXNNYXN0ZXJUb2tlblZhbGlkOiAlcycsIHRoaXMuZ2V0SWQoKSwgaXNNYXN0ZXJWYWxpZCk7XG5cbiAgICBjb25zdCBhcmVUb2tlbnNWYWxpZCA9IChpc1Nlc3Npb25WYWxpZCAmJiBpc01hc3RlclZhbGlkKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gaXNUb2tlblZhbGlkIHJldHVybmVkOiAlcycsIHRoaXMuZ2V0SWQoKSwgYXJlVG9rZW5zVmFsaWQpO1xuICAgIHJldHVybiBhcmVUb2tlbnNWYWxpZDtcbiAgfTtcblxuICB0aGlzLmdldFNlcnZpY2VOYW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZXJ2aWNlcy5zZi5nZXRTZXJ2aWNlTmFtZSgpO1xuICB9O1xuXG4gIHRoaXMuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2VydmljZXMuc2YuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZSgpO1xuICB9O1xuXG4gIHRoaXMuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2VydmljZXMuc2YuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSgpO1xuICB9O1xuXG4gIHRoaXMuZ2V0SnNUcmVhdEludGVnZXJBc0JpZ0ludCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2VydmljZXMuc2YuZ2V0SnNUcmVhdEludGVnZXJBc0JpZ0ludCgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb25uZWN0aW9uIGlkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy5nZXRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaWQ7XG4gIH07XG5cbiAgdGhpcy5oZWFydGJlYXQgPSBjYWxsYmFjayA9PiB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0lzc3VpbmcgaGVhcnRiZWF0IGNhbGwnKTtcbiAgICBjb25zdCByZXF1ZXN0SWQgPSB1dWlkdjQoKTtcblxuICAgIHNlcnZpY2VzLnNmLnJlcXVlc3QoXG4gICAgICB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICB1cmw6IFVybC5mb3JtYXQoXG4gICAgICAgICAge1xuICAgICAgICAgICAgcGF0aG5hbWU6ICcvc2Vzc2lvbi9oZWFydGJlYXQnLFxuICAgICAgICAgICAgc2VhcmNoOiBRdWVyeVN0cmluZy5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0SWQ6IHJlcXVlc3RJZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgIH0pLFxuICAgICAgICBjYWxsYmFjazogVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSA/IGNhbGxiYWNrIDogZnVuY3Rpb24gKGVyciwgYm9keSkge1xuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdFcnJvciBpc3N1aW5nIGhlYXJ0YmVhdCBjYWxsOiAlcycsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0hlYXJ0YmVhdCByZXNwb25zZSAlcycsIEpTT04uc3RyaW5naWZ5KGJvZHkpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICApO1xuICB9O1xuXG4gIHRoaXMuaGVhcnRiZWF0QXN5bmMgPSAoKSA9PiB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIC8vIHByZXZpb3VzIHZlcnNpb24gb2YgZHJpdmVyIGNhbGxlZCBgc2VsZWN0IDE7YCB3aGljaCByZXN1bHQgaW4gYFsgeyAnMSc6IDEgfSBdYFxuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0lzc3VpbmcgYXN5bmMgaGVhcnRiZWF0IGNhbGwnKTtcbiAgICAgIHRoaXMuaGVhcnRiZWF0KChlcnIpID0+IGVyciA/IHJlamVjdChlcnIpIDogcmVzb2x2ZShbeyAnMSc6IDEgfV0pKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQHJldHVybiB7UHJvbWlzZTxib29sZWFuPn1cbiAgICovXG4gIHRoaXMuaXNWYWxpZEFzeW5jID0gYXN5bmMgKCkgPT4ge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBpc1ZhbGlkQXN5bmMgY2FsbGVkJywgdGhpcy5nZXRJZCgpKTtcbiAgICBpZiAoIXRoaXMuaXNVcCgpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBhd2FpdCB0aGlzLmhlYXJ0YmVhdEFzeW5jKCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gaGVhcnRiZWF0IGZhaWxlZDogJXMnLCB0aGlzLmdldElkKCksIEpTT04uc3RyaW5naWZ5KGUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGUpKSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAqIFNldCB0aGUgcHJpdmF0ZSBsaW5rIGFzIHRoZSBPQ1NQIGNhY2hlIHNlcnZlcidzIFVSTC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBob3N0XG4gICpcbiAgKiBAcmV0dXJucyB7bnVsbH1cbiAgKi9cbiAgdGhpcy5zZXR1cE9jc3BQcml2YXRlTGluayA9IGZ1bmN0aW9uIChob3N0KSB7XG4gICAgcHJvY2Vzcy5lbnYuU0ZfT0NTUF9SRVNQT05TRV9DQUNIRV9TRVJWRVJfVVJMID0gVXRpbC5jcmVhdGVPY3NwUmVzcG9uc2VDYWNoZVNlcnZlclVybChob3N0KTtcbiAgfTtcblxuICAvKipcbiAgICogTWV0aG9kIHJldHVybmluZyBjYWxsYmFjayBmdW5jdGlvbiBmb3IgY29ubmVjdCgpIC0gdXNlZCB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gc2VsZlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gICAqL1xuICBmdW5jdGlvbiBjb25uZWN0Q2FsbGJhY2soc2VsZiwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKFBhcmFtZXRlcnMuZ2V0VmFsdWUoUGFyYW1ldGVycy5uYW1lcy5DTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFKSkge1xuICAgICAgICBjb25zdCBTRUNPTkRTX1RPX01JTExJU0VDT05EU19NVUxUSVBMSUVSID0gMTAwMDtcbiAgICAgICAgY29uc3QgS0VFUF9BTElWRV9IRUFSVEJFQVRfRlJFUVVFTkNZX0lOX01TID0gUGFyYW1ldGVycy5nZXRWYWx1ZShQYXJhbWV0ZXJzLm5hbWVzLkNMSUVOVF9TRVNTSU9OX0tFRVBfQUxJVkVfSEVBUlRCRUFUX0ZSRVFVRU5DWSkgKiBTRUNPTkRTX1RPX01JTExJU0VDT05EU19NVUxUSVBMSUVSO1xuICAgICAgICBzZWxmLmtlZXBhbGl2ZSA9IHNldEludGVydmFsKHNlbGYuaGVhcnRiZWF0LCBLRUVQX0FMSVZFX0hFQVJUQkVBVF9GUkVRVUVOQ1lfSU5fTVMsIHNlbGYpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0ga2VlcEFsaXZlIGludGVybmFsIGNyZWF0ZWQnLCBpZCk7XG4gICAgICB9XG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICBjYWxsYmFjayhFcnJvcnMuZXh0ZXJuYWxpemUoZXJyKSwgc2VsZik7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHRoaXMuZGV0ZXJtaW5lQ29ubmVjdGlvbkRvbWFpbiA9ICgpID0+IGNvbm5lY3Rpb25Db25maWcuYWNjZXNzVXJsICYmIGNvbm5lY3Rpb25Db25maWcuYWNjZXNzVXJsLmluY2x1ZGVzKCdzbm93Zmxha2Vjb21wdXRpbmcuY24nKSA/ICdDSElOQScgOiAnR0xPQkFMJztcblxuICAvKipcbiAgICogRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIGlmIHdlIGFyZW4ndCBpbiBhIGZhdGFsIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgY29ubmVjdGlvbiBvYmplY3QuXG4gICAqL1xuICB0aGlzLmNvbm5lY3QgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBjb25zdCB0aW1lciA9IG5ldyBFeGVjdXRpb25UaW1lcigpLnN0YXJ0KCk7XG4gICAgY29uc3QgY29ubmVjdGlvbkRvbWFpbiA9IHRoaXMuZGV0ZXJtaW5lQ29ubmVjdGlvbkRvbWFpbigpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNvbm5lY3RpbmcuIEFzc29jaWF0ZWQgU25vd2ZsYWtlIGRvbWFpbjogJXMnLCB0aGlzLmdldElkKCksIGNvbm5lY3Rpb25Eb21haW4pO1xuICAgIC8vIGludmFsaWQgY2FsbGJhY2tcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFxuICAgICAgIVV0aWwuZXhpc3RzKGNhbGxiYWNrKSB8fCBVdGlsLmlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DT05ORUNUX0lOVkFMSURfQ0FMTEJBQ0spO1xuXG4gICAgaWYgKFV0aWwuZXhpc3RzKGNvbm5lY3Rpb25Db25maWcuaG9zdCkgJiYgVXRpbC5pc1ByaXZhdGVMaW5rKGNvbm5lY3Rpb25Db25maWcuaG9zdCkpIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHNldHRpbmcgdXAgcHJpdmF0ZSBsaW5rJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgIHRoaXMuc2V0dXBPY3NwUHJpdmF0ZUxpbmsoY29ubmVjdGlvbkNvbmZpZy5ob3N0KTtcbiAgICB9XG5cbiAgICAvLyBjb25uZWN0IHRvIHRoZSBzbm93Zmxha2Ugc2VydmljZSBhbmQgcHJvdmlkZSBvdXIgb3duIGNhbGxiYWNrIHNvIHRoYXRcbiAgICAvLyB0aGUgY29ubmVjdGlvbiBjYW4gYmUgcGFzc2VkIGluIHdoZW4gaW52b2tpbmcgdGhlIGNvbm5lY3Rpb24uY29ubmVjdCgpXG4gICAgLy8gY2FsbGJhY2tcbiAgICBjb25zdCBzZWxmID0gdGhpcztcblxuICAgIGNvbnN0IGF1dGhlbnRpY2F0aW9uVHlwZSA9IGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSB1c2luZyBhdXRoZW50aWNhdGlvbiB0eXBlOiAlcycsIHRoaXMuZ2V0SWQoKSwgYXV0aGVudGljYXRpb25UeXBlKTtcblxuICAgIC8vIGNoZWNrIGlmIGF1dGhlbnRpY2F0aW9uIHR5cGUgaXMgY29tcGF0aWJsZSB3aXRoIGNvbm5lY3QoKVxuICAgIC8vIGV4dGVybmFsIGJyb3dzZXIgYW5kIG9rdGEgYXJlIG5vdCBjb21wYXRpYmxlIHdpdGggY29ubmVjdCgpIGR1ZSB0byB0aGVpciB1c2FnZSBvZiBhc3luYyBmdW5jdGlvbnNcbiAgICBpZiAoYXV0aGVudGljYXRpb25UeXBlID09PSBBdXRoZW50aWNhdGlvblR5cGVzLkVYVEVSTkFMX0JST1dTRVJfQVVUSEVOVElDQVRPUiB8fFxuICAgICAgaXNPa3RhQXV0aChhdXRoZW50aWNhdGlvblR5cGUpKSB7XG4gICAgICBjb25zdCBjb25uZWN0aW5nRHVyYXRpb24gPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNvbm5lY3RpbmcgZmFpbGVkIGFmdGVyICVzIG1pbGxpc2Vjb25kcy4nICtcbiAgICAgICAgICAnRXJyb3I6IEV4dGVybmFsIGJyb3dzZXIgYW5kIE9rdGEgYXJlIG5vdCBjb21wYXRpYmxlIHdpdGggY29ubmVjdGlvbiBwcm9jZXNzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW5nRHVyYXRpb25cbiAgICAgICk7XG4gICAgICB0aHJvdyBFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoXG4gICAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQVVUSF9DT05ORUNUKTtcbiAgICB9XG5cbiAgICAvLyBHZXQgYXV0aGVudGljYXRvciB0byB1c2VcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gcmV0cmlldmluZyBhdXRoZW50aWNhdG9yJywgdGhpcy5nZXRJZCgpKTtcbiAgICBjb25zdCBhdXRoID0gc2VydmljZXMuc2YuZ2V0QXV0aGVudGljYXRvcigpO1xuXG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHRyeWluZyB0byBhdXRoZW50aWNhdGUnLCB0aGlzLmdldElkKCkpO1xuICAgIGF1dGguYXV0aGVudGljYXRlKGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpLFxuICAgICAgY29ubmVjdGlvbkNvbmZpZy5nZXRTZXJ2aWNlTmFtZSgpLFxuICAgICAgY29ubmVjdGlvbkNvbmZpZy5hY2NvdW50LFxuICAgICAgY29ubmVjdGlvbkNvbmZpZy51c2VybmFtZSkudGhlbigoKSA9PiB7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uW2lkOiAlc10gLSBhdXRoZW50aWNhdGlvbiBzdWNjZXNzZnVsIHVzaW5nOiAlcycsIHRoaXMuZ2V0SWQoKSwgY29ubmVjdGlvbkNvbmZpZy5nZXRBdXRoZW50aWNhdG9yKCkpO1xuICAgICAgLy8gSlNPTiBmb3IgY29ubmVjdGlvblxuICAgICAgY29uc3QgYm9keSA9IEF1dGhlbnRpY2F0b3IuZm9ybUF1dGhKU09OKGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpLFxuICAgICAgICBjb25uZWN0aW9uQ29uZmlnLmFjY291bnQsXG4gICAgICAgIGNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUsXG4gICAgICAgIGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VHlwZSgpLFxuICAgICAgICBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFZlcnNpb24oKSxcbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRFbnZpcm9ubWVudCgpKTtcblxuICAgICAgLy8gVXBkYXRlIEpTT04gYm9keSB3aXRoIHRoZSBhdXRoZW50aWNhdGlvbiB2YWx1ZXNcbiAgICAgIGF1dGgudXBkYXRlQm9keShib2R5KTtcblxuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGluaXRpYWxpemluZyBlYXN5TG9nZ2luZycsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICBpbml0RWFzeUxvZ2dpbmcoY29ubmVjdGlvbkNvbmZpZy5jbGllbnRDb25maWdGaWxlKVxuICAgICAgICAudGhlbigoKSA9PiB7XG4gICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGVhc3lMb2dnaW5nIGluaXRpYWxpemVkJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNvbm5lY3RpbmcgdGhyb3VnaCBzZXJ2aWNlJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgICAgIHNlcnZpY2VzLnNmLmNvbm5lY3Qoe1xuICAgICAgICAgICAgICBjYWxsYmFjazogY29ubmVjdENhbGxiYWNrKHNlbGYsIGNhbGxiYWNrKSxcbiAgICAgICAgICAgICAganNvbjogYm9keVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGNvbnN0IGNvbm5lY3RpbmdEdXJhdGlvbiA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKFxuICAgICAgICAgICAgICAnQ29ubmVjdGlvbltpZDogJXNdIC0gY29ubmVjdGVkIHN1Y2Nlc3NmdWxseSBhZnRlciAlcyBtaWxsaXNlY29uZHMnLFxuICAgICAgICAgICAgICB0aGlzLmdldElkKCksIGNvbm5lY3RpbmdEdXJhdGlvblxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8vIHdlIGRvbid0IGV4cGVjdCBhbiBlcnJvciBoZXJlIHNpbmNlIGNhbGxiYWNrIG1ldGhvZCBzaG91bGQgYmUgY2FsbGVkXG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW5nRHVyYXRpb24gPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnQ29ubmVjdGlvbltpZDogJXNdIC0gZmFpbGVkIHRvIGNvbm5lY3QgYWZ0ZXIgJXMgbWlsbGlzZWNvbmRzLiAnICtcbiAgICAgICAgICAgICAgICAnRXJyb3I6IFVuZXhwZWN0ZWQgZXJyb3IgZnJvbSBjYWxsaW5nIGNvbm5lY3RDYWxsYmFjayBmdW5jdGlvbiBpbiBzbm93Zmxha2Ugc2VydmljZSAtICVzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW5nRHVyYXRpb24sIGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgKCkgID0+IHtcbiAgICAgICAgICBjb25zdCBjb25uZWN0aW5nRHVyYXRpb24gPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDb25uZWN0aW9uW2lkOiAlc10gLSBmYWlsZWQgdG8gaW5pdGlhbGl6ZSBlYXN5TG9nZ2luZy4gJyArXG4gICAgICAgICAgICAgICdDb25uZWN0aW5nIGZhaWxlZCBhZnRlciAlcyBtaWxsaXNlY29uZHMnLCB0aGlzLmdldElkKCksIGNvbm5lY3RpbmdEdXJhdGlvbik7XG4gICAgICAgICAgY2FsbGJhY2soRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKEVycm9yQ29kZXMuRVJSX0NPTk5fQ09OTkVDVF9JTlZBTElEX0NMSUVOVF9DT05GSUcsIHRydWUpLCBzZWxmKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICAoZXJyKSA9PiB7XG4gICAgICBjb25zdCBjb25uZWN0aW5nRHVyYXRpb24gPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGF1dGhlbnRpY2F0aW9uIGZhaWxlZC4gRXJyb3I6ICVzLiAnICtcbiAgICAgICAgICAgICdDb25uZWN0aW5nIGZhaWxlZCBhZnRlciAlcyBtaWxsaXNlY29uZHMnLCB0aGlzLmdldElkKCksIGVyciwgY29ubmVjdGluZ0R1cmF0aW9uKTtcbiAgICAgIGNhbGxiYWNrKGVyciwgc2VsZik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuXG4gIC8qKlxuICAgKiBFc3RhYmxpc2hlcyBhIGNvbm5lY3Rpb24gaWYgd2UgYXJlbid0IGluIGEgZmF0YWwgc3RhdGUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBjb25uZWN0aW9uIG9iamVjdC5cbiAgICovXG4gIHRoaXMuY29ubmVjdEFzeW5jID0gYXN5bmMgZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgY29uc3QgdGltZXIgPSBuZXcgRXhlY3V0aW9uVGltZXIoKS5zdGFydCgpO1xuICAgIGNvbnN0IGNvbm5lY3RpbmdEb21haW4gPSB0aGlzLmRldGVybWluZUNvbm5lY3Rpb25Eb21haW4oKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uW2lkOiAlc10gLSBhc3luYyBjb25uZWN0aW5nLiBBc3NvY2lhdGVkIFNub3dmbGFrZSBkb21haW46ICVzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW5nRG9tYWluKTtcblxuICAgIC8vIGludmFsaWQgY2FsbGJhY2tcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFxuICAgICAgIVV0aWwuZXhpc3RzKGNhbGxiYWNrKSB8fCBVdGlsLmlzRnVuY3Rpb24oY2FsbGJhY2spLFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DT05ORUNUX0lOVkFMSURfQ0FMTEJBQ0spO1xuXG4gICAgaWYgKFV0aWwuaXNQcml2YXRlTGluayhjb25uZWN0aW9uQ29uZmlnLmhvc3QpKSB7XG4gICAgICB0aGlzLnNldHVwT2NzcFByaXZhdGVMaW5rKGNvbm5lY3Rpb25Db25maWcuaG9zdCk7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uW2lkOiAlc10gLSBzZXR0aW5nIHVwIHByaXZhdGUgbGluaycsIHRoaXMuZ2V0SWQoKSk7XG4gICAgfVxuXG4gICAgLy8gY29ubmVjdCB0byB0aGUgc25vd2ZsYWtlIHNlcnZpY2UgYW5kIHByb3ZpZGUgb3VyIG93biBjYWxsYmFjayBzbyB0aGF0XG4gICAgLy8gdGhlIGNvbm5lY3Rpb24gY2FuIGJlIHBhc3NlZCBpbiB3aGVuIGludm9raW5nIHRoZSBjb25uZWN0aW9uLmNvbm5lY3QoKVxuICAgIC8vIGNhbGxiYWNrXG4gICAgXG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgICBpZiAoY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwoKSkge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHN0b3JpbmcgdGVtcG9yYXJ5IGNyZWRlbnRpYWwgb2YgY2xpZW50JywgdGhpcy5nZXRJZCgpKTtcbiAgICAgIGNvbnN0IGtleSA9IFV0aWwuYnVpbGRDcmVkZW50aWFsQ2FjaGVLZXkoY29ubmVjdGlvbkNvbmZpZy5ob3N0LFxuICAgICAgICBjb25uZWN0aW9uQ29uZmlnLnVzZXJuYW1lLCBBdXRoZW50aWNhdGlvblR5cGVzLklEX1RPS0VOX0FVVEhFTlRJQ0FUT1IpO1xuICAgICAgaWYgKEdsb2JhbENvbmZpZy5nZXRDcmVkZW50aWFsTWFuYWdlcigpID09PSBudWxsKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSB1c2luZyBkZWZhdWx0IGpzb24gY3JlZGVudGlhbCBtYW5hZ2VyJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgR2xvYmFsQ29uZmlnLnNldEN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyKG5ldyBKc29uQ3JlZGVudGlhbE1hbmFnZXIoY29ubmVjdGlvbkNvbmZpZy5nZXRDcmVkZW50aWFsQ2FjaGVEaXIoKSkpO1xuICAgICAgfVxuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHJlYWRpbmcgaWRUb2tlbiB1c2luZyBjcmVkZW50aWFsIG1hbmFnZXInLCB0aGlzLmdldElkKCkpO1xuICAgICAgY29ubmVjdGlvbkNvbmZpZy5pZFRva2VuID0gYXdhaXQgR2xvYmFsQ29uZmlnLmdldENyZWRlbnRpYWxNYW5hZ2VyKCkucmVhZChrZXkpO1xuICAgIH1cblxuICAgIGlmIChjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFJlcXVlc3RNRkFUb2tlbigpKSB7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gZXh0cmFjdGluZyBtZmFUb2tlbiBvZiBjbGllbnQnLCB0aGlzLmdldElkKCkpO1xuICAgICAgY29uc3Qga2V5ID0gVXRpbC5idWlsZENyZWRlbnRpYWxDYWNoZUtleShjb25uZWN0aW9uQ29uZmlnLmhvc3QsXG4gICAgICAgIGNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUsIEF1dGhlbnRpY2F0aW9uVHlwZXMuVVNFUl9QV0RfTUZBX0FVVEhFTlRJQ0FUT1IpO1xuICAgICAgaWYgKEdsb2JhbENvbmZpZy5nZXRDcmVkZW50aWFsTWFuYWdlcigpID09PSBudWxsKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSB1c2luZyBkZWZhdWx0IGpzb24gY3JlZGVudGlhbCBtYW5hZ2VyJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgICAgR2xvYmFsQ29uZmlnLnNldEN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyKG5ldyBKc29uQ3JlZGVudGlhbE1hbmFnZXIoY29ubmVjdGlvbkNvbmZpZy5nZXRDcmVkZW50aWFsQ2FjaGVEaXIoKSkpO1xuICAgICAgfVxuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHJlYWRpbmcgbWZhVG9rZW4gdXNpbmcgY3JlZGVudGlhbCBtYW5hZ2VyJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgIGNvbm5lY3Rpb25Db25maWcubWZhVG9rZW4gPSBhd2FpdCBHbG9iYWxDb25maWcuZ2V0Q3JlZGVudGlhbE1hbmFnZXIoKS5yZWFkKGtleSk7XG4gICAgfVxuICAgXG4gICAgLy8gR2V0IGF1dGhlbnRpY2F0b3IgdG8gdXNlXG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHJldHJpZXZpbmcgYXV0aGVudGljYXRvcicsIHRoaXMuZ2V0SWQoKSk7XG4gICAgY29uc3QgYXV0aCA9IEF1dGhlbnRpY2F0b3IuZ2V0QXV0aGVudGljYXRvcihjb25uZWN0aW9uQ29uZmlnLCBjb250ZXh0LmdldEh0dHBDbGllbnQoKSk7XG4gICAgc2VydmljZXMuc2YuYXV0aGVudGljYXRvciA9IGF1dGg7XG5cbiAgICB0cnkge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGluaXRpYWxpemluZyBlYXN5TG9nZ2luZycsIHRoaXMuZ2V0SWQoKSk7XG4gICAgICBhd2FpdCBpbml0RWFzeUxvZ2dpbmcoY29ubmVjdGlvbkNvbmZpZy5jbGllbnRDb25maWdGaWxlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGNvbnN0IGNvbm5lY3RpbmdEdXJhdGlvbiA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQ29ubmVjdGlvbltpZDogJXNdIC0gZmFpbGVkIHRvIGluaXRpYWxpemUgZWFzeUxvZ2dpbmcuICcgK1xuICAgICAgICAgICdDb25uZWN0aW5nIGZhaWxlZCBhZnRlciAlcyBtaWxsaXNlY29uZHMnLCB0aGlzLmdldElkKCksIGNvbm5lY3RpbmdEdXJhdGlvbik7XG4gICAgICB0aHJvdyBFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoRXJyb3JDb2Rlcy5FUlJfQ09OTl9DT05ORUNUX0lOVkFMSURfQ0xJRU5UX0NPTkZJRywgdHJ1ZSk7XG4gICAgfVxuXG4gICAgbGV0IGJvZHkgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gdXNpbmcgYXV0aGVudGljYXRpb24gdHlwZTogJXMnLCB0aGlzLmdldElkKCksIGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpKTtcblxuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHRyeWluZyB0byBhdXRoZW50aWNhdGUnLCB0aGlzLmdldElkKCkpO1xuICAgICAgYXdhaXQgYXV0aC5hdXRoZW50aWNhdGUoY29ubmVjdGlvbkNvbmZpZy5nZXRBdXRoZW50aWNhdG9yKCksXG4gICAgICAgIGNvbm5lY3Rpb25Db25maWcuZ2V0U2VydmljZU5hbWUoKSxcbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZy5hY2NvdW50LFxuICAgICAgICBjb25uZWN0aW9uQ29uZmlnLnVzZXJuYW1lKTtcblxuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnQ29ubmVjdGlvbltpZDogJXNdIC0gYXV0aGVudGljYXRpb24gc3VjY2Vzc2Z1bCB1c2luZzogJXMnLCB0aGlzLmdldElkKCksIGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpKTtcblxuICAgICAgLy8gSlNPTiBmb3IgY29ubmVjdGlvblxuICAgICAgYm9keSA9IEF1dGhlbnRpY2F0b3IuZm9ybUF1dGhKU09OKGNvbm5lY3Rpb25Db25maWcuZ2V0QXV0aGVudGljYXRvcigpLFxuICAgICAgICBjb25uZWN0aW9uQ29uZmlnLmFjY291bnQsXG4gICAgICAgIGNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUsXG4gICAgICAgIGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VHlwZSgpLFxuICAgICAgICBjb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFZlcnNpb24oKSxcbiAgICAgICAgY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRFbnZpcm9ubWVudCgpKTtcbiAgICBcbiAgICAgIC8vIFVwZGF0ZSBKU09OIGJvZHkgd2l0aCB0aGUgYXV0aGVudGljYXRpb24gdmFsdWVzXG4gICAgICBhdXRoLnVwZGF0ZUJvZHkoYm9keSk7XG4gICAgfSBjYXRjaCAoYXV0aEVycikge1xuICAgICAgY29uc3QgY29ubmVjdGluZ0R1cmF0aW9uID0gdGltZXIuZ2V0RHVyYXRpb24oKTtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGZhaWxlZCB0byBjb25uZWN0IGFzeW5jIGFmdGVyICVzIG1pbGxpc2Vjb25kcy4nICtcbiAgICAgICAgICAnRmFpbGVkIGR1cmluZyBhdXRoZW50aWNhdGlvbi4gRXJyb3I6ICVzJywgdGhpcy5nZXRJZCgpLCBjb25uZWN0aW5nRHVyYXRpb24sIGF1dGhFcnIpO1xuXG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQ29ubmVjdGlvbltpZDogJXNdIC0gZmFpbGVkIGR1cmluZyBhdXRoZW50aWNhdGlvbi4gRXJyb3I6ICVzJywgdGhpcy5nZXRJZCgpLCBhdXRoRXJyKTtcbiAgICAgIGNhbGxiYWNrKGF1dGhFcnIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIC8vIFJlcXVlc3QgY29ubmVjdGlvblxuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNvbm5lY3RpbmcgdGhyb3VnaCBzZXJ2aWNlJywgdGhpcy5nZXRJZCgpKTtcbiAgICAgIHNlcnZpY2VzLnNmLmNvbm5lY3Qoe1xuICAgICAgICBjYWxsYmFjazogY29ubmVjdENhbGxiYWNrKHNlbGYsIGNhbGxiYWNrKSxcbiAgICAgICAganNvbjogYm9keSxcbiAgICAgIH0pO1xuICAgICAgLy8gcmV0dXJuIHRoZSBjb25uZWN0aW9uIHRvIGZhY2lsaXRhdGUgY2hhaW5pbmdcbiAgICAgIGNvbnN0IGNvbm5lY3RpbmdEdXJhdGlvbiA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uW2lkOiAlc10gLSBjb25uZWN0ZWQgc3VjY2Vzc2Z1bGx5IGFmdGVyICVzIG1pbGxpc2Vjb25kcycsIHRoaXMuZ2V0SWQoKSwgY29ubmVjdGluZ0R1cmF0aW9uKTtcblxuICAgIH0gY2F0Y2ggKGNhbGxiYWNrRXJyKSB7XG4gICAgICBjb25zdCBjb25uZWN0aW5nRHVyYXRpb24gPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnQ29ubmVjdGlvbltpZDogJXNdIC0gZmFpbGVkIHRvIGNvbm5lY3QgYXN5bmMgYWZ0ZXIgJXMgbWlsbGlzZWNvbmRzLicgK1xuICAgICAgICAgICdFcnJvcjogVW5leHBlY3RlZCBlcnJvciBmcm9tIGNhbGxpbmcgY29ubmVjdENhbGxiYWNrIGZ1bmN0aW9uIGluIHNub3dmbGFrZSBzZXJ2aWNlIC0gJXMnLCB0aGlzLmdldElkKCksIGNvbm5lY3RpbmdEdXJhdGlvbiwgY2FsbGJhY2tFcnIpO1xuICAgICAgY2FsbGJhY2soY2FsbGJhY2tFcnIpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIGEgc3RhdGVtZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgdGhpcy5leGVjdXRlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gZXhlY3V0ZSBjYWxsZWQgd2l0aCBvcHRpb25zLicsIHRoaXMuZ2V0SWQoKSk7XG4gICAgcmV0dXJuIFN0YXRlbWVudC5jcmVhdGVTdGF0ZW1lbnRQcmVFeGVjKFxuICAgICAgb3B0aW9ucywgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSByZXN1bHQgb2YgYSBwcmV2aW91c2x5IGlzc3VlZCBzdGF0ZW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmZldGNoUmVzdWx0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gZmV0Y2hSZXN1bHQgY2FsbGVkIHdpdGggb3B0aW9ucycsIHRoaXMuZ2V0SWQoKSk7XG4gICAgcmV0dXJuIFN0YXRlbWVudC5jcmVhdGVTdGF0ZW1lbnRQb3N0RXhlYyhcbiAgICAgIG9wdGlvbnMsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcbiAgfTtcblxuICAvKipcbiAgICogSW1tZWRpYXRlbHkgdGVybWluYXRlcyB0aGUgY29ubmVjdGlvbiB3aXRob3V0IHdhaXRpbmcgZm9yIGN1cnJlbnRseVxuICAgKiBleGVjdXRpbmcgc3RhdGVtZW50cyB0byBjb21wbGV0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH0gdGhlIGNvbm5lY3Rpb24gb2JqZWN0LlxuICAgKi9cbiAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgLy8gaW52YWxpZCBjYWxsYmFja1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBkZXN0cm95IGNhbGxlZCcsIHRoaXMuZ2V0SWQoKSk7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChcbiAgICAgICFVdGlsLmV4aXN0cyhjYWxsYmFjaykgfHwgVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fREVTVFJPWV9JTlZBTElEX0NBTExCQUNLKTtcblxuICAgIC8vIGxvZyBvdXQgb2YgdGhlIHNub3dmbGFrZSBzZXJ2aWNlIGFuZCBwcm92aWRlIG91ciBvd24gY2FsbGJhY2sgc28gdGhhdFxuICAgIC8vIHRoZSBjb25uZWN0aW9uIGNhbiBiZSBwYXNzZWQgaW4gd2hlbiBpbnZva2luZyB0aGUgY29ubmVjdGlvbi5kZXN0cm95KClcbiAgICAvLyBjYWxsYmFja1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBkZXN0cm95aW5nIHRocm91Z2ggc2VydmljZScsIHRoaXMuZ2V0SWQoKSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgc2VydmljZXMuc2YuZGVzdHJveShcbiAgICAgIHtcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoVXRpbC5leGlzdHMoc2VsZi5rZWVwYWxpdmUpKSB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHNlbGYua2VlcGFsaXZlKTtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBrZWVwQWxpdmUgaW50ZXJ2YWwgY2xlYXJlZCcsIHNlbGYuZ2V0SWQoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKFV0aWwuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKEVycm9ycy5leHRlcm5hbGl6ZShlcnIpLCBzZWxmKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNvbm5lY3Rpb24gZGVzdHJveWVkIHN1Y2Nlc3NmdWxseScsIHRoaXMuZ2V0SWQoKSk7XG4gICAgLy8gcmV0dXJuIHRoZSBjb25uZWN0aW9uIHRvIGZhY2lsaXRhdGUgY2hhaW5pbmdcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogR2V0cyB0aGUgcmVzcG9uc2UgY29udGFpbmluZyB0aGUgc3RhdHVzIG9mIHRoZSBxdWVyeSBiYXNlZCBvbiBxdWVyeUlkLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcXVlcnlJZFxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcXVlcnkgcmVzcG9uc2VcbiAgICovXG4gIGFzeW5jIGZ1bmN0aW9uIGdldFF1ZXJ5UmVzcG9uc2UocXVlcnlJZCkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSByZXF1ZXN0ZWQgcXVlcnkgcmVzcG9uc2UgZm9yIFF1ZXJ5W2lkOiAlc10nLCBpZCwgcXVlcnlJZCk7XG4gICAgLy8gQ2hlY2sgaWYgcXVlcnlJZCBleGlzdHMgYW5kIGlzIHZhbGlkIHV1aWRcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhxdWVyeUlkKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX01JU1NJTkdfUVVFUllfSUQpO1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQocXVlcnlJZFJlZ2V4LnRlc3QocXVlcnlJZCksXG4gICAgICBFcnJvckNvZGVzLkVSUl9HRVRfUkVTUE9OU0VfUVVFUllfSU5WQUxJRF9VVUlELCBxdWVyeUlkKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gUXVlcnlbaWQ6ICVzXSBpcyB2YWxpZCcsIGlkLCBxdWVyeUlkKTtcblxuICAgIC8vIEZvcm0gdGhlIHJlcXVlc3Qgb3B0aW9uc1xuICAgIGNvbnN0IG9wdGlvbnMgPVxuICAgIHtcbiAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICB1cmw6IFVybC5mb3JtYXQoXG4gICAgICAgIHtcbiAgICAgICAgICBwYXRobmFtZTogYC9tb25pdG9yaW5nL3F1ZXJpZXMvJHtxdWVyeUlkfWBcbiAgICAgICAgfSksXG4gICAgfTtcblxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBmZXRjaGluZyBxdWVyeSByZXNwb25zZSBmb3IgUXVlcnlbaWQ6ICVzXScsIGlkLCBxdWVyeUlkKTtcbiAgICBjb25zdCB0aW1lciA9IG5ldyBFeGVjdXRpb25UaW1lcigpLnN0YXJ0KCk7XG4gICAgLy8gR2V0IHRoZSByZXNwb25zZSBjb250YWluaW5nIHRoZSBxdWVyeSBzdGF0dXNcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHNlcnZpY2VzLnNmLnJlcXVlc3RBc3luYyhvcHRpb25zKTtcbiAgICBjb25zdCBmZXRjaGluZ0R1cmF0aW9uID0gdGltZXIuZ2V0RHVyYXRpb24oKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gcXVlcnkgcmVzcG9uc2UgZm9yIFF1ZXJ5W2lkOiAlc10gZmV0Y2hlZCBzdWNjZXNzZnVsbHkgYWZ0ZXI6ICVzIG1pbGxpc2Vjb25kcycsIGlkLCBxdWVyeUlkLCBmZXRjaGluZ0R1cmF0aW9uKTtcblxuICAgIHJldHVybiByZXNwb25zZVsnZGF0YSddO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSBzdGF0dXMgb2YgdGhlIHF1ZXJ5IGZyb20gdGhlIHF1ZXJ5IHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcXVlcnlSZXNwb25zZVxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgcXVlcnkgc3RhdHVzLlxuICAgKi9cbiAgZnVuY3Rpb24gZXh0cmFjdFF1ZXJ5U3RhdHVzKHF1ZXJ5UmVzcG9uc2UpIHtcbiAgICBjb25zdCBxdWVyaWVzID0gcXVlcnlSZXNwb25zZVsnZGF0YSddWydxdWVyaWVzJ107XG4gICAgbGV0IHN0YXR1cyA9IFF1ZXJ5U3RhdHVzLmNvZGUuTk9fUVVFUllfREFUQTsgLy8gZGVmYXVsdCBzdGF0dXNcbiAgICBpZiAoIHF1ZXJpZXMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdHVzID0gIHF1ZXJpZXNbMF1bJ3N0YXR1cyddO1xuICAgIH1cblxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBFeHRyYWN0ZWQgcXVlcnkgc3RhdHVzOiAlcycsIHN0YXR1cyk7XG4gICAgcmV0dXJuIHN0YXR1cztcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdGF0dXMgb2YgdGhlIHF1ZXJ5IGJhc2VkIG9uIHF1ZXJ5SWQuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeUlkXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IHRoZSBxdWVyeSBzdGF0dXMuXG4gICAqL1xuICB0aGlzLmdldFF1ZXJ5U3RhdHVzID0gYXN5bmMgZnVuY3Rpb24gKHF1ZXJ5SWQpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gZ2V0UXVlcnlTdGF0dXMgY2FsbGVkIGZvciBRdWVyeVtpZDogJXNdJywgdGhpcy5nZXRJZCgpLCBxdWVyeUlkKTtcbiAgICByZXR1cm4gZXh0cmFjdFF1ZXJ5U3RhdHVzKGF3YWl0IGdldFF1ZXJ5UmVzcG9uc2UocXVlcnlJZCkpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzdGF0dXMgb2YgdGhlIHF1ZXJ5IGJhc2VkIG9uIHF1ZXJ5SWQgYW5kIHRocm93cyBpZiB0aGVyZSdzIGFuIGVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcXVlcnlJZFxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgcXVlcnkgc3RhdHVzLlxuICAgKi9cbiAgdGhpcy5nZXRRdWVyeVN0YXR1c1Rocm93SWZFcnJvciA9IGFzeW5jIGZ1bmN0aW9uIChxdWVyeUlkKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGdldFF1ZXJ5U3RhdHVzVGhyb3dJZkVycm9yIGNhbGxlZCBmb3IgUXVlcnlbaWQ6ICVzXScsIHRoaXMuZ2V0SWQoKSwgcXVlcnlJZCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBnZXRRdWVyeVJlc3BvbnNlKHF1ZXJ5SWQpO1xuICAgIGNvbnN0IHN0YXR1cyA9ICBleHRyYWN0UXVlcnlTdGF0dXMocmVzcG9uc2UpO1xuICAgIGxldCBzcWxTdGF0ZSA9IG51bGw7XG5cbiAgICBpZiAodGhpcy5pc0FuRXJyb3Ioc3RhdHVzKSApIHtcbiAgICAgIGxldCBtZXNzYWdlID0gcmVzcG9uc2VbJ21lc3NhZ2UnXSB8fCAnJztcbiAgICAgIGNvbnN0IGNvZGUgPSByZXNwb25zZVsnY29kZSddIHx8IC0xO1xuXG4gICAgICBpZiAocmVzcG9uc2VbJ2RhdGEnXSkge1xuICAgICAgICBtZXNzYWdlICs9IHJlc3BvbnNlWydkYXRhJ11bJ3F1ZXJpZXMnXS5sZW5ndGggPiAwID8gcmVzcG9uc2VbJ2RhdGEnXVsncXVlcmllcyddWzBdWydlcnJvck1lc3NhZ2UnXSA6ICcnO1xuICAgICAgICBzcWxTdGF0ZSA9IHJlc3BvbnNlWydkYXRhJ11bJ3NxbFN0YXRlJ107XG4gICAgICB9XG5cbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBxdWVyeSBlcnJvciBmb3IgUXVlcnlbaWQ6ICVzXS4gRXJyb3I6ICVzLiBTUUxTdGF0ZTogJXMnLCB0aGlzLmdldElkKCksIHF1ZXJ5SWQsIG1lc3NhZ2UsIHNxbFN0YXRlKTtcbiAgICAgIHRocm93IEVycm9ycy5jcmVhdGVPcGVyYXRpb25GYWlsZWRFcnJvcihcbiAgICAgICAgY29kZSwgcmVzcG9uc2UsIG1lc3NhZ2UsIHNxbFN0YXRlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gc3RhdHVzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSByZXN1bHRzIGZyb20gYSBwcmV2aW91c2x5IHJhbiBxdWVyeSBiYXNlZCBvbiBxdWVyeUlkXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmdldFJlc3VsdHNGcm9tUXVlcnlJZCA9IGFzeW5jIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgY29uc3QgcXVlcnlJZCA9IG9wdGlvbnMucXVlcnlJZDtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbltpZDogJXNdIC0gZ2V0UmVzdWx0c0Zyb21RdWVyeUlkIGNhbGxlZCBmb3IgUXVlcnlbaWQ6ICVzXS4nLCB0aGlzLmdldElkKCksIHF1ZXJ5SWQpO1xuXG4gICAgbGV0IHN0YXR1cywgbm9EYXRhQ291bnRlciA9IDAsIHJldHJ5UGF0dGVyblBvcyA9IDA7XG5cbiAgICAvLyBXYWl0IHVudGlsIHF1ZXJ5IGhhcyBmaW5pc2hlZCBleGVjdXRpbmdcbiAgICBsZXQgcXVlcnlTdGlsbEV4ZWN1dGluZyA9IHRydWU7XG4gICAgd2hpbGUgKHF1ZXJ5U3RpbGxFeGVjdXRpbmcpIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBjaGVja2luZyBpZiBRdWVyeVtpZDogJXNdIGlzIHN0aWxsIGV4ZWN1dGluZy4gUmV0cmllcyB3aXRoIG5vIGRhdGEgY291bnQ6ICVkJywgdGhpcy5nZXRJZCgpLCBxdWVyeUlkLCBub0RhdGFDb3VudGVyKTtcbiAgICAgIC8vIENoZWNrIGlmIHF1ZXJ5IGlzIHN0aWxsIHJ1bm5pbmcuXG4gICAgICAvLyBUcmlnZ2VyIGV4Y2VwdGlvbiBpZiBpdCBmYWlsZWQgb3IgdGhlcmUgaXMgbm8gcXVlcnkgZGF0YSBpbiB0aGUgc2VydmVyLlxuICAgICAgc3RhdHVzID0gYXdhaXQgdGhpcy5nZXRRdWVyeVN0YXR1c1Rocm93SWZFcnJvcihxdWVyeUlkKTtcbiAgICAgIHF1ZXJ5U3RpbGxFeGVjdXRpbmcgPSB0aGlzLmlzU3RpbGxSdW5uaW5nKHN0YXR1cyk7XG4gICAgICBpZiAoIXF1ZXJ5U3RpbGxFeGVjdXRpbmcgfHwgc3RhdHVzID09PSBRdWVyeVN0YXR1cy5jb2RlLk5PX1FVRVJZX0RBVEEpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGVuZCBvZiB3YWl0aW5nIGZvciBRdWVyeVtpZDogJXNdIHRvIGZpbmlzaCBleGVjdXRpbmcuICcgK1xuICAgICAgICAgICAgcXVlcnlTdGlsbEV4ZWN1dGluZyA/ICdRdWVyeSBpcyBubyBsb25nZXIgZXhlY3V0aW5nLiAnIDogJycgK1xuICAgICAgICAgICAgJ1F1ZXJ5IHN0YXR1czogJXMuJywgdGhpcy5nZXRJZCgpLCBxdWVyeUlkLCBzdGF0dXMpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gVGltZW91dCBiYXNlZCBvbiBxdWVyeSBzdGF0dXMgcmV0cnkgcnVsZXNcbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gcmVzb2x2ZSgpLCBhc3luY1JldHJ5SW5NaWxsaXNlY29uZHMgKiBhc3luY1JldHJ5UGF0dGVybltyZXRyeVBhdHRlcm5Qb3NdKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBJZiBubyBkYXRhLCBpbmNyZW1lbnQgdGhlIG5vIGRhdGEgY291bnRlclxuICAgICAgaWYgKFF1ZXJ5U3RhdHVzLmNvZGVbc3RhdHVzXSA9PT0gUXVlcnlTdGF0dXMuY29kZS5OT19EQVRBKSB7XG4gICAgICAgIG5vRGF0YUNvdW50ZXIrKztcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIG5vIGRhdGEgcmV0dXJuZWQgZm9yIFF1ZXJ5W2lkOiAlc10uIFJldHJpZXMgd2l0aCBubyBkYXRhIGNvdW50OiAlZCcsIHRoaXMuZ2V0SWQoKSwgcXVlcnlJZCwgbm9EYXRhQ291bnRlcik7XG4gICAgICAgIC8vIENoZWNrIGlmIHJldHJ5IGZvciBubyBkYXRhIGlzIGV4Y2VlZGVkXG4gICAgICAgIGlmIChub0RhdGFDb3VudGVyID4gYXN5bmNOb0RhdGFNYXhSZXRyeSkge1xuICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDb25uZWN0aW9uW2lkOiAlc10gLSBubyBkYXRhIHJldHVybmVkIGZvciBRdWVyeVtpZDogJXNdLiBSZXRyeSBsaW1pdDogJXMgcmVhY2hlZC4nLCB0aGlzLmdldElkKCksIHF1ZXJ5SWQsIGFzeW5jTm9EYXRhTWF4UmV0cnkpO1xuICAgICAgICAgIHRocm93IEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihcbiAgICAgICAgICAgIEVycm9yQ29kZXMuRVJSX0dFVF9SRVNVTFRTX1FVRVJZX0lEX05PX0RBVEEsIHRydWUsIHF1ZXJ5SWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChyZXRyeVBhdHRlcm5Qb3MgPCBhc3luY1JldHJ5UGF0dGVybi5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHJ5UGF0dGVyblBvcysrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChRdWVyeVN0YXR1cy5jb2RlW3N0YXR1c10gPT09IFF1ZXJ5U3RhdHVzLmNvZGUuTk9fUVVFUllfREFUQSkge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIFF1ZXJ5W2lkOiAlc10gZGlkIG5vdCBzdWNjZWVkLiBGaW5hbCBzdGF0dXM6ICVzJywgdGhpcy5nZXRJZCgpLCBxdWVyeUlkLCBzdGF0dXMpO1xuICAgICAgdGhyb3cgRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKFxuICAgICAgICBFcnJvckNvZGVzLkVSUl9HRVRfUkVTVUxUU19RVUVSWV9JRF9OT19EQVRBLCB0cnVlLCBxdWVyeUlkLCBzdGF0dXMpO1xuICAgIH1cblxuICAgIGlmIChRdWVyeVN0YXR1cy5jb2RlW3N0YXR1c10gIT09IFF1ZXJ5U3RhdHVzLmNvZGUuU1VDQ0VTUykge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIFF1ZXJ5W2lkOiAlc10gZGlkIG5vdCBzdWNjZWVkLiBGaW5hbCBzdGF0dXM6ICVzJywgdGhpcy5nZXRJZCgpLCBxdWVyeUlkLCBzdGF0dXMpO1xuICAgICAgdGhyb3cgRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKFxuICAgICAgICBFcnJvckNvZGVzLkVSUl9HRVRfUkVTVUxUU19RVUVSWV9JRF9OT1RfU1VDQ0VTU19TVEFUVVMsIHRydWUsIHF1ZXJ5SWQsIHN0YXR1cyk7XG4gICAgfVxuXG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIFF1ZXJ5W2lkOiAlc10gc3VjY2VlZGVkLiBGZXRjaGluZyB0aGUgcmVzdWx0LicsIHRoaXMuZ2V0SWQoKSwgcXVlcnlJZCk7XG4gICAgcmV0dXJuIHRoaXMuZmV0Y2hSZXN1bHQob3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBzdGF0dXMgaXMgY3VycmVudGx5IHJ1bm5pbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBzdGF0dXNcbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmlzU3RpbGxSdW5uaW5nID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBjaGVja2luZyBpZiBzdGF0dXMgJXMgaXMgc3RpbGwgcnVubmluZycsIHRoaXMuZ2V0SWQoKSwgc3RhdHVzKTtcbiAgICByZXR1cm4gUXVlcnlTdGF0dXMucnVubmluZ1N0YXR1c2VzLmluY2x1ZGVzKFF1ZXJ5U3RhdHVzLmNvZGVbc3RhdHVzXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENoZWNrcyB3aGV0aGVyIHRoZSBnaXZlbiBzdGF0dXMgbWVhbnMgdGhhdCB0aGVyZSBoYXMgYmVlbiBhbiBlcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0YXR1c1xuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHRoaXMuaXNBbkVycm9yID0gZnVuY3Rpb24gKHN0YXR1cykge1xuICAgIHJldHVybiBRdWVyeVN0YXR1cy5lcnJvclN0YXR1c2VzLmluY2x1ZGVzKFF1ZXJ5U3RhdHVzLmNvZGVbc3RhdHVzXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhpcyBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy5zZXJpYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIHNlcmlhbGl6ZSBjYWxsZWQnLCB0aGlzLmdldElkKCkpO1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShjb250ZXh0LmdldENvbmZpZygpKTtcbiAgfTtcblxuICBFdmVudEVtaXR0ZXIuY2FsbCh0aGlzKTtcbn1cblxuVXRpbC5pbmhlcml0cyhDb25uZWN0aW9uLCBFdmVudEVtaXR0ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IENvbm5lY3Rpb247XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/connection_config.js":
/*!************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/connection_config.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const os = __webpack_require__(/*! os */ \"os\");\nconst url = __webpack_require__(/*! url */ \"url\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/proxy_util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst ConnectionConstants = __webpack_require__(/*! ../constants/connection_constants */ \"(rsc)/./node_modules/snowflake-sdk/lib/constants/connection_constants.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst ErrorCodes = Errors.codes;\nconst NativeTypes = (__webpack_require__(/*! ./result/data_types */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/data_types.js\").NativeTypes);\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/lib/global_config.js\");\nconst AuthenticationTypes = __webpack_require__(/*! ../authentication/authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/authentication_types.js\");\nconst levenshtein = __webpack_require__(/*! fastest-levenshtein */ \"(rsc)/./node_modules/fastest-levenshtein/esm/mod.js\");\nconst RowMode = __webpack_require__(/*! ./../constants/row_mode */ \"(rsc)/./node_modules/snowflake-sdk/lib/constants/row_mode.js\");\nconst DataTypes = __webpack_require__(/*! ./result/data_types */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/data_types.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst WAIT_FOR_BROWSER_ACTION_TIMEOUT = 120000;\nconst DEFAULT_PARAMS =\n[\n  'account',\n  'application',\n  'region',\n  'host',\n  'accessUrl',\n  'username',\n  'password',\n  'authenticator',\n  'proxyHost',\n  'proxyPort',\n  'serviceName',\n  'privateKey',\n  'privateKeyPath',\n  'privateKeyPass',\n  'token',\n  'warehouse',\n  'database',\n  'schema',\n  'role',\n  'rowMode',\n  'streamResult',\n  'fetchAsString',\n  'clientSessionKeepAlive',\n  'clientSessionKeepAliveHeartbeatFrequency',\n  'jsTreatIntegerAsBigInt',\n  'sessionToken',\n  'masterToken',\n  'sessionTokenExpirationTime',\n  'masterTokenExpirationTime',\n  'agentClass',\n  'validateDefaultParameters',\n  'arrayBindingThreshold',\n  'gcsUseDownscopedCredential',\n  'forceStageBindError',\n  'includeRetryReason',\n  'disableQueryContextCache',\n  'retryTimeout',\n  'clientRequestMFAToken',\n  'clientStoreTemporaryCredential',\n  'disableConsoleLogin',\n  'forceGCPUseDownscopedCredential',\n  'representNullAsStringNull',\n  'disableSamlURLCheck',\n  'credentialCacheDir',\n  'passcodeInPassword',\n  'passcode',\n];\n\nfunction consolidateHostAndAccount(options) {\n  let dotPos = -1;\n  let realAccount = undefined;\n  let realRegion = undefined;\n  const protocol = options.protocol || 'https';\n  const port = Util.exists(options.port) ? Util.format(':%s', options.port) : '';\n\n\n  if (Util.exists(options.region)) {\n    Errors.checkArgumentValid(Util.isCorrectSubdomain(options.region), ErrorCodes.ERR_CONN_CREATE_INVALID_REGION_REGEX);\n    realRegion = options.region;\n  }\n\n  if (Util.exists(options.account)) {\n    Errors.checkArgumentValid(Util.isString(options.account), ErrorCodes.ERR_CONN_CREATE_INVALID_ACCOUNT);\n    Errors.checkArgumentValid(Util.isCorrectSubdomain(options.account), ErrorCodes.ERR_CONN_CREATE_INVALID_ACCOUNT_REGEX);\n    dotPos = options.account.indexOf('.');\n    realAccount = options.account;\n    if (dotPos > 0) {\n      realRegion = realAccount.substring(dotPos + 1);\n      realAccount = realAccount.substring(0, dotPos);\n    }\n  }\n\n  if (Util.exists(options.accessUrl)) { //accessUrl is set in configuration\n    try {\n      const parsedUrl = url.parse(options.accessUrl);\n      Errors.checkArgumentValid(Util.exists(parsedUrl.hostname), ErrorCodes.ERR_CONN_CREATE_INVALID_ACCESS_URL);\n      if (!Util.exists(options.host)) {\n        options.host = parsedUrl.hostname;\n      }\n      const dotPos = parsedUrl.hostname.indexOf('.');\n      if (dotPos > 0 && !Util.exists(options.account)) {\n        realAccount = parsedUrl.hostname.substring(0, dotPos);\n      }\n    } catch (e) {\n      Errors.checkArgumentValid(\n        false, ErrorCodes.ERR_CONN_CREATE_MISSING_ACCOUNT);\n    }\n  } else if (Util.exists(options.host)) { //host is set in configuration\n    options.accessUrl = Util.format('%s://%s%s', protocol, options.host, port);\n    const dotPos = options.host.indexOf('.');\n    if (dotPos > 0 && !Util.exists(options.account)) {\n      realAccount = options.host.substring(0, dotPos);\n    } else {\n      realAccount = options.account;\n    }\n  } else if (Util.exists(options.account)) { //only account() is set in configuration\n    if (options.region === 'us-west-2') {\n      options.region = '';\n    }\n    options.host = Util.constructHostname(realRegion, realAccount);\n    options.accessUrl = Util.format('%s://%s%s', protocol, options.host, port);\n  }\n\n  if (Util.exists(realAccount) && options.accessUrl.includes('global.snowflakecomputing')) {\n    const dashPos = realAccount.indexOf('-');\n    if (dashPos > 0) {\n      // global URL\n      realAccount = realAccount.substring(0, dashPos);\n    }\n  }\n  options.account = realAccount;\n  options.region = realRegion;\n\n  // check for missing accessURL\n  Errors.checkArgumentExists(Util.exists(options.account), ErrorCodes.ERR_CONN_CREATE_MISSING_ACCOUNT);\n  // check for missing account\n  Errors.checkArgumentExists(Util.exists(options.accessUrl), ErrorCodes.ERR_CONN_CREATE_MISSING_ACCESS_URL);\n}\n\n/**\n * A Connection configuration object that should be available to all stateful\n * objects in the driver.\n *\n * @param {Object} options\n * @param {Boolean} [validateCredentials]\n * @param {Boolean} [qaMode]\n * @param {Object} [clientInfo]\n *\n * @constructor\n */\nfunction ConnectionConfig(options, validateCredentials, qaMode, clientInfo) {\n  // if no value is specified for the validate credentials flag, default to true\n  if (!Util.exists(validateCredentials)) {\n    validateCredentials = true;\n  }\n\n  // check for missing options\n  Errors.checkArgumentExists(Util.exists(options),\n    ErrorCodes.ERR_CONN_CREATE_MISSING_OPTIONS);\n\n  // check for invalid options\n  Errors.checkArgumentValid(Util.isObject(options),\n    ErrorCodes.ERR_CONN_CREATE_INVALID_OPTIONS);\n\n  // only validate credentials if necessary\n  if (validateCredentials) {\n    // username is not required for oauth and external browser authenticators\n    if (!Util.exists(options.authenticator) ||\n      (options.authenticator.toUpperCase() !== AuthenticationTypes.OAUTH_AUTHENTICATOR &&\n        options.authenticator.toUpperCase() !== AuthenticationTypes.EXTERNAL_BROWSER_AUTHENTICATOR)) {\n      // check for missing username\n      Errors.checkArgumentExists(Util.exists(options.username),\n        ErrorCodes.ERR_CONN_CREATE_MISSING_USERNAME);\n    }\n\n    if (Util.exists(options.username)) {\n      // check for invalid username\n      Errors.checkArgumentValid(Util.isString(options.username),\n        ErrorCodes.ERR_CONN_CREATE_INVALID_USERNAME);\n    }\n\n    // password is only required for default authenticator\n    if (!Util.exists(options.authenticator) ||\n      options.authenticator === AuthenticationTypes.DEFAULT_AUTHENTICATOR) {\n      // check for missing password\n      Errors.checkArgumentExists(Util.exists(options.password),\n        ErrorCodes.ERR_CONN_CREATE_MISSING_PASSWORD);\n\n      // check for invalid password\n      Errors.checkArgumentValid(Util.isString(options.password),\n        ErrorCodes.ERR_CONN_CREATE_INVALID_PASSWORD);\n    }\n\n    consolidateHostAndAccount(options);\n  }\n\n  // check for missing accessUrl\n  Errors.checkArgumentExists(Util.exists(options.accessUrl),\n    ErrorCodes.ERR_CONN_CREATE_MISSING_ACCESS_URL);\n\n  // check for invalid accessUrl\n  Errors.checkArgumentValid(Util.isString(options.accessUrl),\n    ErrorCodes.ERR_CONN_CREATE_INVALID_ACCESS_URL);\n\n  const proxyHost = options.proxyHost;\n  const proxyPort = options.proxyPort;\n  const proxyUser = options.proxyUser;\n  const proxyPassword = options.proxyPassword;\n  const proxyProtocol = options.proxyProtocol || 'http';\n  const noProxy = options.noProxy;\n\n  // if we're running in node and some proxy information is specified\n  let proxy;\n  if (Util.isNode() && (Util.exists(proxyHost) || Util.exists(proxyPort))) {\n    proxy =\n    {\n      host: proxyHost,\n      port: proxyPort,\n      user: proxyUser,\n      password: proxyPassword,\n      protocol: proxyProtocol,\n      noProxy: noProxy\n    };\n    ProxyUtil.validateProxy(proxy);\n  }\n\n  const serviceName = options.serviceName;\n  let authenticator = options.authenticator;\n\n  // if no value is specified for authenticator, default to Snowflake\n  if (!Util.exists(authenticator)) {\n    authenticator = AuthenticationTypes.DEFAULT_AUTHENTICATOR;\n  } else {\n    authenticator = authenticator.toUpperCase();\n  }\n\n  let browserActionTimeout = options.browserActionTimeout;\n  if (Util.exists(options.browserActionTimeout)) {\n    Errors.checkArgumentValid(Util.number.isPositiveInteger(browserActionTimeout),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_BROWSER_TIMEOUT);\n  } else {\n    browserActionTimeout = WAIT_FOR_BROWSER_ACTION_TIMEOUT;\n  }\n\n  const privateKey = options.privateKey;\n  if (Util.exists(options.privateKey)) {\n    Errors.checkArgumentValid((Util.isString(privateKey) && Util.isPrivateKey(privateKey)),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_PRIVATE_KEY);\n  }\n\n  const privateKeyPath = options.privateKeyPath;\n  if (Util.exists(options.privateKeyPath)) {\n    Errors.checkArgumentValid(Util.isString(privateKeyPath),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PATH);\n  }\n\n  const privateKeyPass = options.privateKeyPass;\n  if (Util.exists(options.privateKeyPass)) {\n    Errors.checkArgumentValid(Util.isString(privateKeyPass),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PASS);\n  }\n\n  const token = options.token;\n  if (Util.exists(token)) {\n    Errors.checkArgumentValid(Util.isString(token),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_OAUTH_TOKEN);\n  }\n\n  const warehouse = options.warehouse;\n  const database = options.database;\n  const schema = options.schema;\n  const role = options.role;\n\n  // check for invalid warehouse\n  if (Util.exists(warehouse)) {\n    Errors.checkArgumentValid(Util.isString(warehouse),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_WAREHOUSE);\n  }\n\n  // check for invalid database\n  if (Util.exists(database)) {\n    Errors.checkArgumentValid(Util.isString(database),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_DATABASE);\n  }\n\n  // check for invalid schema\n  if (Util.exists(schema)) {\n    Errors.checkArgumentValid(Util.isString(schema),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_SCHEMA);\n  }\n\n  // check for invalid role\n  if (Util.exists(role)) {\n    Errors.checkArgumentValid(Util.isString(role),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_ROLE);\n  }\n\n  // check for invalid streamResult\n  const streamResult = options.streamResult;\n  if (Util.exists(streamResult)) {\n    Errors.checkArgumentValid(Util.isBoolean(streamResult),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_STREAM_RESULT);\n  }\n\n  // check for invalid fetchAsString\n  const fetchAsString = options.fetchAsString;\n  if (Util.exists(fetchAsString)) {\n    // check that the value is an array\n    Errors.checkArgumentValid(Util.isArray(fetchAsString),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_FETCH_AS_STRING);\n\n    // check that all the array elements are valid\n    const invalidValueIndex = NativeTypes.findInvalidValue(fetchAsString);\n    Errors.checkArgumentValid(invalidValueIndex === -1,\n      ErrorCodes.ERR_CONN_CREATE_INVALID_FETCH_AS_STRING_VALUES,\n      JSON.stringify(fetchAsString[invalidValueIndex]));\n  }\n  // Row mode is optional, can be undefined\n  const rowMode = options.rowMode;\n  if (Util.exists(rowMode)) {\n    RowMode.checkRowModeValid(rowMode);\n  }\n\n  // check for invalid clientSessionKeepAlive\n  const clientSessionKeepAlive = options.clientSessionKeepAlive;\n  if (Util.exists(clientSessionKeepAlive)) {\n    Errors.checkArgumentValid(Util.isBoolean(clientSessionKeepAlive),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_KEEP_ALIVE);\n  }\n\n  // check for invalid clientSessionKeepAliveHeartbeatFrequency\n  let clientSessionKeepAliveHeartbeatFrequency = options.clientSessionKeepAliveHeartbeatFrequency;\n  if (Util.exists(clientSessionKeepAliveHeartbeatFrequency)) {\n    Errors.checkArgumentValid(Util.isNumber(clientSessionKeepAliveHeartbeatFrequency),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_KEEP_ALIVE_HEARTBEAT_FREQ);\n    clientSessionKeepAliveHeartbeatFrequency =\n      Util.validateClientSessionKeepAliveHeartbeatFrequency(clientSessionKeepAliveHeartbeatFrequency, ConnectionConstants.HEARTBEAT_FREQUENCY_MASTER_VALIDITY);\n  }\n\n  const jsTreatIntegerAsBigInt = options.jsTreatIntegerAsBigInt;\n  if (Util.exists(jsTreatIntegerAsBigInt)) {\n    Errors.checkArgumentValid(Util.isBoolean(jsTreatIntegerAsBigInt),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_TREAT_INTEGER_AS_BIGINT);\n  }\n\n  const gcsUseDownscopedCredential = options.gcsUseDownscopedCredential;\n  if (Util.exists(gcsUseDownscopedCredential)) {\n    Errors.checkArgumentValid(Util.isBoolean(gcsUseDownscopedCredential),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_GCS_USE_DOWNSCOPED_CREDENTIAL);\n  }\n\n  const clientConfigFile = options.clientConfigFile;\n  if (Util.exists(clientConfigFile)) {\n    Errors.checkArgumentValid(Util.isString(clientConfigFile), ErrorCodes.ERR_CONN_CREATE_INVALID_CLIENT_CONFIG_FILE);\n  }\n\n  // remember if we're in qa mode\n  this._qaMode = qaMode;\n\n  // if a client-info argument is specified, validate it\n  const clientType = 'JavaScript';\n  let clientName;\n  let clientVersion;\n  let clientEnvironment;\n  if (Util.exists(clientInfo)) {\n    Errors.assertInternal(Util.isObject(clientInfo));\n    Errors.assertInternal(Util.isString(clientInfo.version));\n    Errors.assertInternal(Util.isObject(clientInfo.environment));\n\n    clientName = clientInfo.name;\n    clientVersion = clientInfo.version;\n    clientEnvironment = clientInfo.environment;\n    clientEnvironment.OS = os.platform();\n    clientEnvironment.OS_VERSION = os.release();\n    clientEnvironment.OCSP_MODE = GlobalConfig.getOcspMode();\n  }\n\n  const clientApplication = options.application;\n  if (Util.exists(clientApplication)) {\n    Errors.checkArgumentValid(Util.isString(clientApplication),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_APPLICATION);\n\n    const APPLICATION_PATTERN = new RegExp(String.raw`^[A-Za-z]([A-Za-z0-9.\\-_]){1,50}$`,\n      'gi');\n\n    Errors.checkArgumentValid(APPLICATION_PATTERN.test(clientApplication),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_APPLICATION);\n  }\n\n  let validateDefaultParameters = false;\n  if (Util.exists(options.validateDefaultParameters)) {\n    // check for invalid validateDefaultParameters\n    Errors.checkArgumentValid(Util.isBoolean(options.validateDefaultParameters),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_VALIDATE_DEFAULT_PARAMETERS);\n\n    validateDefaultParameters = options.validateDefaultParameters;\n  }\n\n  let bindThreshold = null;\n  if (Util.exists(options.arrayBindingThreshold)) {\n    // check for invalid arrayBindingThreshold\n    Errors.checkArgumentValid(Util.isNumber(options.arrayBindingThreshold),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_ARRAY_BINDING_THRESHOLD);\n\n    bindThreshold = options.arrayBindingThreshold;\n  }\n\n  let forceStageBindError = null;\n  if (Util.exists(options.forceStageBindError)) {\n    // check for invalid forceStageBindError\n    Errors.checkArgumentValid(Util.isNumber(options.forceStageBindError),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_FORCE_STAGE_BIND_ERROR);\n\n    forceStageBindError = options.forceStageBindError;\n  }\n\n  let disableQueryContextCache = false;\n  if (Util.exists(options.disableQueryContextCache)) {\n    Errors.checkArgumentValid(Util.isBoolean(options.disableQueryContextCache),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_DISABLED_QUERY_CONTEXT_CACHE);\n\n    disableQueryContextCache = options.disableQueryContextCache;\n  }\n\n  let retryTimeout = 300;\n  if (Util.exists(options.retryTimeout)) {\n    Errors.checkArgumentValid(Util.isNumber(options.retryTimeout),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_MAX_RETRY_TIMEOUT);\n\n    retryTimeout = options.retryTimeout !== 0 ? Math.max(retryTimeout, options.retryTimeout) : 0;\n  }\n\n  let includeRetryReason = true;\n  if (Util.exists(options.includeRetryReason)) {\n    Errors.checkArgumentValid(Util.isBoolean(options.includeRetryReason),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_INCLUDE_RETRY_REASON);\n\n    includeRetryReason = options.includeRetryReason;\n  }\n\n  let clientRequestMFAToken = false;\n  if (Util.exists(options.clientRequestMFAToken)) {\n    Errors.checkArgumentValid(Util.isBoolean(options.clientRequestMFAToken),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_CLIENT_REQUEST_MFA_TOKEN);\n\n    clientRequestMFAToken = options.clientRequestMFAToken;\n  }\n\n  let disableConsoleLogin = true;\n  if (Util.exists(options.disableConsoleLogin)) {\n    Errors.checkArgumentValid(Util.isBoolean(options.disableConsoleLogin),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_DISABLE_CONSOLE_LOGIN);\n\n    disableConsoleLogin = options.disableConsoleLogin;\n  }\n\n  if (Util.exists(options.forceGCPUseDownscopedCredential)) {\n    Errors.checkArgumentValid(Util.isBoolean(options.forceGCPUseDownscopedCredential),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL);\n\n    process.env.SNOWFLAKE_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL = options.forceGCPUseDownscopedCredential;\n  } else {\n    process.env.SNOWFLAKE_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL = false;\n  }\n\n  if (Util.exists(options.representNullAsStringNull)) {\n    Errors.checkArgumentValid(Util.isBoolean(options.representNullAsStringNull),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_REPRESENT_NULL_AS_STRING_NULL);\n\n    DataTypes.setIsRepresentNullAsStringNull(options.representNullAsStringNull);\n  }\n\n  let disableSamlURLCheck = false;\n  if (Util.exists(options.disableSamlURLCheck)) {\n    Errors.checkArgumentValid(Util.isBoolean(options.disableSamlURLCheck),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_DISABLE_SAML_URL_CHECK);\n\n    disableSamlURLCheck = options.disableSamlURLCheck;\n  }\n\n  let clientStoreTemporaryCredential = false;\n  if (Util.exists(options.clientStoreTemporaryCredential)) {\n    Errors.checkArgumentValid(Util.isBoolean(options.clientStoreTemporaryCredential),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_CLIENT_STORE_TEMPORARY_CREDENTIAL);\n\n    clientStoreTemporaryCredential = options.clientStoreTemporaryCredential;\n  }\n\n  let credentialCacheDir = null;\n  if (Util.exists(options.credentialCacheDir)) {\n    const absolutePath = path.resolve(options.credentialCacheDir);\n    Errors.checkArgumentValid(Util.validatePath(absolutePath),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_CREDENTIAL_CACHE_DIR);\n\n    credentialCacheDir = absolutePath;\n  }\n\n  let passcodeInPassword = false;\n  if (Util.exists(options.passcodeInPassword)) {\n    Errors.checkArgumentValid(Util.isBoolean(options.passcodeInPassword), \n      ErrorCodes.ERR_CONN_CREATE_INVALID_PASSCODE_IN_PASSWORD);\n\n    passcodeInPassword = options.passcodeInPassword;\n  }\n\n  let passcode = null;\n  if (Util.exists(options.passcode)) {\n    Errors.checkArgumentValid(Util.isString(options.passcode),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_PASSCODE);\n\n    passcode = options.passcode;\n  }\n  \n  if (validateDefaultParameters) {\n    for (const [key] of Object.entries(options)) {\n      if (!DEFAULT_PARAMS.includes(key)) {\n        const result = levenshtein.closest(key, DEFAULT_PARAMS);\n        Logger.getInstance().error(`'${key}' is an unknown connection parameter. Did you mean '${result}'?`);\n      }\n    }\n  }\n\n  /**\n   * Returns an object that contains information about the proxy hostname, port,\n   * etc. for when http requests are made.\n   *\n   * @returns {Object}\n   */\n  this.getProxy = function () {\n    return proxy;\n  };\n\n  /**\n   * Returns the warehouse to automatically use once a connection has been\n   * established.\n   *\n   * @returns {String}\n   */\n  this.getWarehouse = function () {\n    return warehouse;\n  };\n\n  /**\n   * Returns the database to automatically use once a connection has been\n   * established.\n   *\n   * @returns {String}\n   */\n  this.getDatabase = function () {\n    return database;\n  };\n\n  /**\n   * Returns the schema to automatically use once a connection has been\n   * established.\n   *\n   * @returns {String}\n   */\n  this.getSchema = function () {\n    return schema;\n  };\n\n  /**\n   * Returns the role to automatically use once a connection has been\n   * established.\n   *\n   * @returns {String}\n   */\n  this.getRole = function () {\n    return role;\n  };\n\n  /**\n   * Returns the service name.\n   *\n   * @returns {String}\n   */\n  this.getServiceName = function () {\n    return serviceName;\n  };\n\n  /**\n   * Returns the authenticator to use for establishing a connection.\n   *\n   * @returns {String}\n   */\n  this.getAuthenticator = function () {\n    return authenticator;\n  };\n\n  /**\n   * Returns the timeout in millis used for authentication by external browser.\n   *\n   * @returns {String}\n   */\n  this.getBrowserActionTimeout = function () {\n    return browserActionTimeout;\n  };\n\n  /**\n   * Returns the private key string.\n   *\n   * @returns {String}\n   */\n  this.getPrivateKey = function () {\n    return privateKey;\n  };\n\n  /**\n   * Returns the private key file location.\n   *\n   * @returns {String}\n   */\n  this.getPrivateKeyPath = function () {\n    return privateKeyPath;\n  };\n\n  /**\n   * Returns the private key passphrase.\n   *\n   * @returns {String}\n   */\n  this.getPrivateKeyPass = function () {\n    return privateKeyPass;\n  };\n\n  /**\n   * Returns the OAuth token.\n   *\n   * @returns {String}\n   */\n  this.getToken = function () {\n    return token;\n  };\n\n  /**\n   * Returns the streamResult flag.\n   *\n   * @returns {boolean}\n   */\n  this.getStreamResult = function () {\n    return streamResult;\n  };\n\n  /**\n   * Returns the fetchAsString array.\n   *\n   * @returns {String[]}\n   */\n  this.getFetchAsString = function () {\n    return fetchAsString;\n  };\n\n  /**\n   * Returns the rowMode string value ('array', 'object' or 'object_with_renamed_duplicated_columns'). Could be null or undefined.\n   *\n   * @returns  {String}\n   */\n  this.getRowMode = function () {\n    return rowMode;\n  };\n\n  /**\n   * Returns the client type.\n   *\n   * @returns {String}\n   */\n  this.getClientType = function () {\n    return clientType;\n  };\n\n  /**\n   * Returns the client name.\n   *\n   * @returns {String}\n   */\n  this.getClientName = function () {\n    return clientName;\n  };\n\n  /**\n   * Returns the client version.\n   *\n   * @returns {String}\n   */\n  this.getClientVersion = function () {\n    return clientVersion;\n  };\n\n  /**\n   * Returns the client application.\n   *\n   * @returns {String}\n   */\n  this.getClientApplication = function () {\n    return clientApplication;\n  };\n\n  /**\n   * Returns a JSON object containing version information for all the various\n   * components of the runtime, e.g. node, v8, openssl, etc.\n   *\n   * @returns {Object}\n   */\n  this.getClientEnvironment = function () {\n    return clientEnvironment;\n  };\n\n  /**\n   * Returns the client session keep alive setting.\n   *\n   * @returns {String}\n   */\n  this.getClientSessionKeepAlive = function () {\n    return clientSessionKeepAlive;\n  };\n\n  /**\n   * Returns the client session keep alive heartbeat frequency setting.\n   *\n   * @returns {String}\n   */\n  this.getClientSessionKeepAliveHeartbeatFrequency = function () {\n    return clientSessionKeepAliveHeartbeatFrequency;\n  };\n\n  /**\n   * Returns the client treat integer as setting\n   *\n   * @returns {String}\n   */\n  this.getJsTreatIntegerAsBigInt = function () {\n    return jsTreatIntegerAsBigInt;\n  };\n\n  /**\n   * Returns the setting for the GCS_USE_DOWNSCOPED_CREDENTIAL session parameter\n   *\n   * @returns {String}\n   */\n  this.getGcsUseDownscopedCredential = function () {\n    return gcsUseDownscopedCredential;\n  };\n\n  /**\n   * Returns the bind threshold\n   *\n   * @returns {string}\n   */\n  this.getbindThreshold = function () {\n    return bindThreshold;\n  };\n\n  /**\n   * Returns the force stage bind error\n   *\n   * @returns {string}\n   */\n  this.getForceStageBindError = function () {\n    return forceStageBindError;\n  };\n\n  /**\n   * Returns whether the Retry reason is included or not in the retry url\n   *\n   * @returns {Boolean}\n   */\n  this.getIncludeRetryReason = function () {\n    return includeRetryReason;\n  };\n\n  /**\n   * Returns whether the Query Context Cache is enabled or not by the configuration\n   *\n   * @returns {Boolean}\n   */\n  this.getDisableQueryContextCache = function () {\n    return disableQueryContextCache;\n  };\n\n  /**\n   * Returns the client config file\n   *\n   * @returns {String}\n   */\n  this.getClientConfigFile = function () {\n    return clientConfigFile;\n  };\n\n  /**\n   * Returns the max login timeout\n   *\n   * @returns {Number}\n   */\n  this.getRetryTimeout = function () {\n    return retryTimeout;\n  };\n\n  this.getDisableConsoleLogin = function () {\n    return disableConsoleLogin;\n  };\n\n  /**\n   * Returns whether the SAML URL check is enabled or not.\n   *\n   * @returns {Boolean}\n   */\n  this.getDisableSamlURLCheck = function () {\n    return disableSamlURLCheck;\n  };\n\n  this.getCredentialCacheDir = function () {\n    return credentialCacheDir;\n  };\n\n  this.getClientRequestMFAToken = function () {\n    return clientRequestMFAToken;\n  };\n  /** \n   * Returns whether the auth token saves on the local machine or not. \n   *\n   * @returns {Boolean}\n   */\n  this.getClientStoreTemporaryCredential = function () {\n    return clientStoreTemporaryCredential;\n  };\n\n  this.getPasscodeInPassword = function () {\n    return passcodeInPassword;\n  };\n\n  this.getPasscode = function () {\n    return passcode;\n  };\n\n  /**\n   * Returns attributes of Connection Config object that can be used to identify\n   * the connection, when ID is not available in the scope. This is not sufficient set,\n   * since multiple connections can be instantiated for the same config, but can be treated as a hint.\n   *\n   * @returns {string}\n   */\n  this.describeIdentityAttributes = function () {\n    return `host: ${this.host}, account: ${this.account}, accessUrl: ${this.accessUrl}, `\n        + `user: ${this.username}, role: ${this.getRole()}, database: ${this.getDatabase()}, `\n        + `schema: ${this.getSchema()}, warehouse: ${this.getWarehouse()}, ` + ProxyUtil.describeProxy(this.getProxy());\n  };\n\n  // save config options\n  this.username = options.username;\n  this.password = options.password;\n  this.accessUrl = options.accessUrl;\n  this.region = options.region;\n  this.account = options.account;\n  this.host = options.host;\n  this.sessionToken = options.sessionToken;\n  this.masterToken = options.masterToken;\n  this.masterTokenExpirationTime = options.masterTokenExpirationTime;\n  this.sessionTokenExpirationTime = options.sessionTokenExpirationTime;\n  this.clientConfigFile = options.clientConfigFile;\n  this.openExternalBrowserCallback = options.openExternalBrowserCallback;\n\n  // create the parameters array\n  const parameters = createParameters();\n\n  // create a map in which the keys are the parameter names and the values are\n  // the corresponding parameters\n  const mapParameters = {};\n  let index, length, parameter;\n  for (index = 0, length = parameters.length; index < length; index++) {\n    parameter = parameters[index];\n    mapParameters[parameter.name] = parameter;\n\n    // initialize the value to the default\n    parameter.value = parameter.defaultValue;\n  }\n\n  // for each property in the options object that matches a known parameter name\n  let propertyName, propertyValue;\n  for (propertyName in options) {\n    if (Object.prototype.hasOwnProperty.call(options, propertyName) &&\n      Object.prototype.hasOwnProperty.call(mapParameters, propertyName)) {\n      // if the parameter matching the property is external and the specified\n      // value is valid for the parameter, update the parameter value\n      propertyValue = options[propertyName];\n      parameter = mapParameters[propertyName];\n      if (parameter.external && parameter.validate(propertyValue)) {\n        parameter.value = propertyValue;\n      }\n    }\n  }\n\n  // save the parameters map\n  this._mapParameters = mapParameters;\n\n  // custom agent class, test only\n  this.agentClass = options.agentClass;\n}\n\n/**\n * Determines if qa-mode is on.\n *\n * @returns {Boolean}\n */\nConnectionConfig.prototype.isQaMode = function () {\n  return this._qaMode;\n};\n\n/**\n * Clears all credential-related information.\n */\nConnectionConfig.prototype.clearCredentials = function () {\n  // clear the password\n  this.password = null;\n\n  // TODO: clear passcode and other credential-related information as well\n};\n\nconst PARAM_TIMEOUT = 'timeout';\nconst PARAM_RESULT_PREFETCH = 'resultPrefetch';\nconst PARAM_RESULT_STREAM_INTERRUPTS = 'resultStreamInterrupts';\nconst PARAM_RESULT_CHUNK_CACHE_SIZE = 'resultChunkCacheSize';\nconst PARAM_RESULT_PROCESSING_BATCH_SIZE = 'resultProcessingBatchSize';\nconst PARAM_RESULT_PROCESSING_BATCH_DURATION = 'resultProcessingBatchDuration';\nconst PARAM_ROW_STREAM_HIGH_WATER_MARK = 'rowStreamHighWaterMark';\nconst PARAM_RETRY_LARGE_RESULT_SET_MAX_NUM_RETRIES = 'largeResultSetRetryMaxNumRetries';\nconst PARAM_RETRY_LARGE_RESULT_SET_MAX_SLEEP_TIME = 'largeResultSetRetryMaxSleepTime';\nconst PARAM_RETRY_SF_MAX_LOGIN_RETRIES = 'sfRetryMaxLoginRetries';\nconst PARAM_RETRY_SF_MAX_NUM_RETRIES = 'sfRetryMaxNumRetries';\nconst PARAM_RETRY_SF_STARTING_SLEEP_TIME = 'sfRetryStartingSleepTime';\nconst PARAM_RETRY_SF_MAX_SLEEP_TIME = 'sfRetryMaxSleepTime';\n\n/**\n * Creates the list of known parameters. If a parameter is marked as external,\n * its value can be overridden by adding the appropriate name-value mapping to\n * the ConnectionConfig options.\n *\n * @returns {Object[]}\n */\nfunction createParameters() {\n  const isNonNegativeInteger = Util.number.isNonNegativeInteger.bind(Util.number);\n  const isPositiveInteger = Util.number.isPositiveInteger.bind(Util.number);\n  const isNonNegativeNumber = Util.number.isNonNegative.bind(Util.number);\n\n  return [\n    {\n      name: PARAM_TIMEOUT,\n      defaultValue: 90 * 1000,\n      external: true,\n      validate: isPositiveInteger\n    },\n    {\n      name: PARAM_RESULT_PREFETCH,\n      defaultValue: 2,\n      external: true,\n      validate: isPositiveInteger\n    },\n    {\n      name: PARAM_RESULT_STREAM_INTERRUPTS,\n      defaultValue: 3,\n      validate: isPositiveInteger\n    },\n    // for now we set chunk cache size to 1, which is same as \n    // disabling the chunk cache. Otherwise, cache will explode\n    // memory when fetching large result set \n    {\n      name: PARAM_RESULT_CHUNK_CACHE_SIZE,\n      defaultValue: 1,\n      validate: isPositiveInteger\n    },\n    {\n      name: PARAM_RESULT_PROCESSING_BATCH_SIZE,\n      defaultValue: 1000,\n      validate: isPositiveInteger\n    },\n    {\n      name: PARAM_RESULT_PROCESSING_BATCH_DURATION,\n      defaultValue: 100,\n      validate: isPositiveInteger\n    },\n    {\n      name: PARAM_ROW_STREAM_HIGH_WATER_MARK,\n      defaultValue: 10,\n      validate: isPositiveInteger\n    },\n    {\n      name: PARAM_RETRY_LARGE_RESULT_SET_MAX_NUM_RETRIES,\n      defaultValue: 10,\n      validate: isNonNegativeInteger\n    },\n    {\n      name: PARAM_RETRY_LARGE_RESULT_SET_MAX_SLEEP_TIME,\n      defaultValue: 16,\n      validate: isNonNegativeInteger\n    },\n    {\n      name: PARAM_RETRY_SF_MAX_LOGIN_RETRIES,\n      defaultValue: 7,\n      external: true,\n      validate: isNonNegativeInteger\n    },\n    {\n      name: PARAM_RETRY_SF_MAX_NUM_RETRIES,\n      defaultValue: 1000,\n      validate: isNonNegativeInteger\n    },\n    {\n      name: PARAM_RETRY_SF_STARTING_SLEEP_TIME,\n      defaultValue: 1,\n      validate: isNonNegativeNumber\n    },\n    {\n      name: PARAM_RETRY_SF_MAX_SLEEP_TIME,\n      defaultValue: 16,\n      validate: isNonNegativeNumber\n    }\n  ];\n}\n\nConnectionConfig.prototype.getTimeout = function () {\n  return this._getParameterValue(PARAM_TIMEOUT);\n};\n\nConnectionConfig.prototype.getResultPrefetch = function () {\n  return this._getParameterValue(PARAM_RESULT_PREFETCH);\n};\n\nConnectionConfig.prototype.getResultStreamInterrupts = function () {\n  return this._getParameterValue(PARAM_RESULT_STREAM_INTERRUPTS);\n};\n\nConnectionConfig.prototype.getResultChunkCacheSize = function () {\n  return this._getParameterValue(PARAM_RESULT_CHUNK_CACHE_SIZE);\n};\n\nConnectionConfig.prototype.getResultProcessingBatchSize = function () {\n  return this._getParameterValue(PARAM_RESULT_PROCESSING_BATCH_SIZE);\n};\n\nConnectionConfig.prototype.getResultProcessingBatchDuration = function () {\n  return this._getParameterValue(PARAM_RESULT_PROCESSING_BATCH_DURATION);\n};\n\nConnectionConfig.prototype.getRowStreamHighWaterMark = function () {\n  return this._getParameterValue(PARAM_ROW_STREAM_HIGH_WATER_MARK);\n};\n\nConnectionConfig.prototype.getRetryLargeResultSetMaxNumRetries = function () {\n  return this._getParameterValue(PARAM_RETRY_LARGE_RESULT_SET_MAX_NUM_RETRIES);\n};\n\nConnectionConfig.prototype.getRetryLargeResultSetMaxSleepTime = function () {\n  return this._getParameterValue(PARAM_RETRY_LARGE_RESULT_SET_MAX_SLEEP_TIME);\n};\n\nConnectionConfig.prototype.getRetrySfMaxNumRetries = function () {\n  return this._getParameterValue(PARAM_RETRY_SF_MAX_NUM_RETRIES);\n};\n\nConnectionConfig.prototype.getRetrySfMaxLoginRetries = function () {\n  return this._getParameterValue(PARAM_RETRY_SF_MAX_LOGIN_RETRIES);\n};\n\nConnectionConfig.prototype.getRetrySfStartingSleepTime = function () {\n  return this._getParameterValue(PARAM_RETRY_SF_STARTING_SLEEP_TIME);\n};\n\nConnectionConfig.prototype.getRetrySfMaxSleepTime = function () {\n  return this._getParameterValue(PARAM_RETRY_SF_MAX_SLEEP_TIME);\n};\n\n/**\n * Returns the value of a given connection config parameter.\n *\n * @param parameterName\n *\n * @returns {Object}\n * @private\n */\nConnectionConfig.prototype._getParameterValue = function (parameterName) {\n  const parameter = this._mapParameters[parameterName];\n  return parameter ? parameter.value : undefined;\n};\n\nmodule.exports = ConnectionConfig;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9jb25uZWN0aW9uX2NvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsYUFBYSxtQkFBTyxDQUFDLCtEQUFTO0FBQzlCLGtCQUFrQixtQkFBTyxDQUFDLDJFQUFlO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVztBQUNsQyw0QkFBNEIsbUJBQU8sQ0FBQyxtSEFBbUM7QUFDdkUsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCO0FBQ0Esb0JBQW9CLHNJQUEwQztBQUM5RCxxQkFBcUIsbUJBQU8sQ0FBQyxpRkFBa0I7QUFDL0MsNEJBQTRCLG1CQUFPLENBQUMsNkhBQXdDO0FBQzVFLG9CQUFvQixtQkFBTyxDQUFDLGdGQUFxQjtBQUNqRCxnQkFBZ0IsbUJBQU8sQ0FBQyw2RkFBeUI7QUFDakQsa0JBQWtCLG1CQUFPLENBQUMsbUdBQXFCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUksc0NBQXNDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJLHlDQUF5QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUZBQWlGLEtBQUs7QUFDdEY7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsSUFBSSxzREFBc0QsT0FBTztBQUN4RztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0Esb0JBQW9CLFVBQVUsYUFBYSxhQUFhLGVBQWUsZUFBZTtBQUN0RixtQkFBbUIsY0FBYyxVQUFVLGVBQWUsY0FBYyxtQkFBbUI7QUFDM0YscUJBQXFCLGlCQUFpQixlQUFlLG9CQUFvQjtBQUN6RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9jb25uZWN0aW9uX2NvbmZpZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCB1cmwgPSByZXF1aXJlKCd1cmwnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBQcm94eVV0aWwgPSByZXF1aXJlKCcuLi9wcm94eV91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IENvbm5lY3Rpb25Db25zdGFudHMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvY29ubmVjdGlvbl9jb25zdGFudHMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBFcnJvckNvZGVzID0gRXJyb3JzLmNvZGVzO1xuY29uc3QgTmF0aXZlVHlwZXMgPSByZXF1aXJlKCcuL3Jlc3VsdC9kYXRhX3R5cGVzJykuTmF0aXZlVHlwZXM7XG5jb25zdCBHbG9iYWxDb25maWcgPSByZXF1aXJlKCcuLi9nbG9iYWxfY29uZmlnJyk7XG5jb25zdCBBdXRoZW50aWNhdGlvblR5cGVzID0gcmVxdWlyZSgnLi4vYXV0aGVudGljYXRpb24vYXV0aGVudGljYXRpb25fdHlwZXMnKTtcbmNvbnN0IGxldmVuc2h0ZWluID0gcmVxdWlyZSgnZmFzdGVzdC1sZXZlbnNodGVpbicpO1xuY29uc3QgUm93TW9kZSA9IHJlcXVpcmUoJy4vLi4vY29uc3RhbnRzL3Jvd19tb2RlJyk7XG5jb25zdCBEYXRhVHlwZXMgPSByZXF1aXJlKCcuL3Jlc3VsdC9kYXRhX3R5cGVzJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbmNvbnN0IFdBSVRfRk9SX0JST1dTRVJfQUNUSU9OX1RJTUVPVVQgPSAxMjAwMDA7XG5jb25zdCBERUZBVUxUX1BBUkFNUyA9XG5bXG4gICdhY2NvdW50JyxcbiAgJ2FwcGxpY2F0aW9uJyxcbiAgJ3JlZ2lvbicsXG4gICdob3N0JyxcbiAgJ2FjY2Vzc1VybCcsXG4gICd1c2VybmFtZScsXG4gICdwYXNzd29yZCcsXG4gICdhdXRoZW50aWNhdG9yJyxcbiAgJ3Byb3h5SG9zdCcsXG4gICdwcm94eVBvcnQnLFxuICAnc2VydmljZU5hbWUnLFxuICAncHJpdmF0ZUtleScsXG4gICdwcml2YXRlS2V5UGF0aCcsXG4gICdwcml2YXRlS2V5UGFzcycsXG4gICd0b2tlbicsXG4gICd3YXJlaG91c2UnLFxuICAnZGF0YWJhc2UnLFxuICAnc2NoZW1hJyxcbiAgJ3JvbGUnLFxuICAncm93TW9kZScsXG4gICdzdHJlYW1SZXN1bHQnLFxuICAnZmV0Y2hBc1N0cmluZycsXG4gICdjbGllbnRTZXNzaW9uS2VlcEFsaXZlJyxcbiAgJ2NsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3knLFxuICAnanNUcmVhdEludGVnZXJBc0JpZ0ludCcsXG4gICdzZXNzaW9uVG9rZW4nLFxuICAnbWFzdGVyVG9rZW4nLFxuICAnc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWUnLFxuICAnbWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZScsXG4gICdhZ2VudENsYXNzJyxcbiAgJ3ZhbGlkYXRlRGVmYXVsdFBhcmFtZXRlcnMnLFxuICAnYXJyYXlCaW5kaW5nVGhyZXNob2xkJyxcbiAgJ2djc1VzZURvd25zY29wZWRDcmVkZW50aWFsJyxcbiAgJ2ZvcmNlU3RhZ2VCaW5kRXJyb3InLFxuICAnaW5jbHVkZVJldHJ5UmVhc29uJyxcbiAgJ2Rpc2FibGVRdWVyeUNvbnRleHRDYWNoZScsXG4gICdyZXRyeVRpbWVvdXQnLFxuICAnY2xpZW50UmVxdWVzdE1GQVRva2VuJyxcbiAgJ2NsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCcsXG4gICdkaXNhYmxlQ29uc29sZUxvZ2luJyxcbiAgJ2ZvcmNlR0NQVXNlRG93bnNjb3BlZENyZWRlbnRpYWwnLFxuICAncmVwcmVzZW50TnVsbEFzU3RyaW5nTnVsbCcsXG4gICdkaXNhYmxlU2FtbFVSTENoZWNrJyxcbiAgJ2NyZWRlbnRpYWxDYWNoZURpcicsXG4gICdwYXNzY29kZUluUGFzc3dvcmQnLFxuICAncGFzc2NvZGUnLFxuXTtcblxuZnVuY3Rpb24gY29uc29saWRhdGVIb3N0QW5kQWNjb3VudChvcHRpb25zKSB7XG4gIGxldCBkb3RQb3MgPSAtMTtcbiAgbGV0IHJlYWxBY2NvdW50ID0gdW5kZWZpbmVkO1xuICBsZXQgcmVhbFJlZ2lvbiA9IHVuZGVmaW5lZDtcbiAgY29uc3QgcHJvdG9jb2wgPSBvcHRpb25zLnByb3RvY29sIHx8ICdodHRwcyc7XG4gIGNvbnN0IHBvcnQgPSBVdGlsLmV4aXN0cyhvcHRpb25zLnBvcnQpID8gVXRpbC5mb3JtYXQoJzolcycsIG9wdGlvbnMucG9ydCkgOiAnJztcblxuXG4gIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLnJlZ2lvbikpIHtcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNDb3JyZWN0U3ViZG9tYWluKG9wdGlvbnMucmVnaW9uKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9SRUdJT05fUkVHRVgpO1xuICAgIHJlYWxSZWdpb24gPSBvcHRpb25zLnJlZ2lvbjtcbiAgfVxuXG4gIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmFjY291bnQpKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKG9wdGlvbnMuYWNjb3VudCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQUNDT1VOVCk7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQ29ycmVjdFN1YmRvbWFpbihvcHRpb25zLmFjY291bnQpLCBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FDQ09VTlRfUkVHRVgpO1xuICAgIGRvdFBvcyA9IG9wdGlvbnMuYWNjb3VudC5pbmRleE9mKCcuJyk7XG4gICAgcmVhbEFjY291bnQgPSBvcHRpb25zLmFjY291bnQ7XG4gICAgaWYgKGRvdFBvcyA+IDApIHtcbiAgICAgIHJlYWxSZWdpb24gPSByZWFsQWNjb3VudC5zdWJzdHJpbmcoZG90UG9zICsgMSk7XG4gICAgICByZWFsQWNjb3VudCA9IHJlYWxBY2NvdW50LnN1YnN0cmluZygwLCBkb3RQb3MpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmFjY2Vzc1VybCkpIHsgLy9hY2Nlc3NVcmwgaXMgc2V0IGluIGNvbmZpZ3VyYXRpb25cbiAgICB0cnkge1xuICAgICAgY29uc3QgcGFyc2VkVXJsID0gdXJsLnBhcnNlKG9wdGlvbnMuYWNjZXNzVXJsKTtcbiAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5leGlzdHMocGFyc2VkVXJsLmhvc3RuYW1lKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BQ0NFU1NfVVJMKTtcbiAgICAgIGlmICghVXRpbC5leGlzdHMob3B0aW9ucy5ob3N0KSkge1xuICAgICAgICBvcHRpb25zLmhvc3QgPSBwYXJzZWRVcmwuaG9zdG5hbWU7XG4gICAgICB9XG4gICAgICBjb25zdCBkb3RQb3MgPSBwYXJzZWRVcmwuaG9zdG5hbWUuaW5kZXhPZignLicpO1xuICAgICAgaWYgKGRvdFBvcyA+IDAgJiYgIVV0aWwuZXhpc3RzKG9wdGlvbnMuYWNjb3VudCkpIHtcbiAgICAgICAgcmVhbEFjY291bnQgPSBwYXJzZWRVcmwuaG9zdG5hbWUuc3Vic3RyaW5nKDAsIGRvdFBvcyk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChcbiAgICAgICAgZmFsc2UsIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfQUNDT1VOVCk7XG4gICAgfVxuICB9IGVsc2UgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuaG9zdCkpIHsgLy9ob3N0IGlzIHNldCBpbiBjb25maWd1cmF0aW9uXG4gICAgb3B0aW9ucy5hY2Nlc3NVcmwgPSBVdGlsLmZvcm1hdCgnJXM6Ly8lcyVzJywgcHJvdG9jb2wsIG9wdGlvbnMuaG9zdCwgcG9ydCk7XG4gICAgY29uc3QgZG90UG9zID0gb3B0aW9ucy5ob3N0LmluZGV4T2YoJy4nKTtcbiAgICBpZiAoZG90UG9zID4gMCAmJiAhVXRpbC5leGlzdHMob3B0aW9ucy5hY2NvdW50KSkge1xuICAgICAgcmVhbEFjY291bnQgPSBvcHRpb25zLmhvc3Quc3Vic3RyaW5nKDAsIGRvdFBvcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlYWxBY2NvdW50ID0gb3B0aW9ucy5hY2NvdW50O1xuICAgIH1cbiAgfSBlbHNlIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmFjY291bnQpKSB7IC8vb25seSBhY2NvdW50KCkgaXMgc2V0IGluIGNvbmZpZ3VyYXRpb25cbiAgICBpZiAob3B0aW9ucy5yZWdpb24gPT09ICd1cy13ZXN0LTInKSB7XG4gICAgICBvcHRpb25zLnJlZ2lvbiA9ICcnO1xuICAgIH1cbiAgICBvcHRpb25zLmhvc3QgPSBVdGlsLmNvbnN0cnVjdEhvc3RuYW1lKHJlYWxSZWdpb24sIHJlYWxBY2NvdW50KTtcbiAgICBvcHRpb25zLmFjY2Vzc1VybCA9IFV0aWwuZm9ybWF0KCclczovLyVzJXMnLCBwcm90b2NvbCwgb3B0aW9ucy5ob3N0LCBwb3J0KTtcbiAgfVxuXG4gIGlmIChVdGlsLmV4aXN0cyhyZWFsQWNjb3VudCkgJiYgb3B0aW9ucy5hY2Nlc3NVcmwuaW5jbHVkZXMoJ2dsb2JhbC5zbm93Zmxha2Vjb21wdXRpbmcnKSkge1xuICAgIGNvbnN0IGRhc2hQb3MgPSByZWFsQWNjb3VudC5pbmRleE9mKCctJyk7XG4gICAgaWYgKGRhc2hQb3MgPiAwKSB7XG4gICAgICAvLyBnbG9iYWwgVVJMXG4gICAgICByZWFsQWNjb3VudCA9IHJlYWxBY2NvdW50LnN1YnN0cmluZygwLCBkYXNoUG9zKTtcbiAgICB9XG4gIH1cbiAgb3B0aW9ucy5hY2NvdW50ID0gcmVhbEFjY291bnQ7XG4gIG9wdGlvbnMucmVnaW9uID0gcmVhbFJlZ2lvbjtcblxuICAvLyBjaGVjayBmb3IgbWlzc2luZyBhY2Nlc3NVUkxcbiAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMob3B0aW9ucy5hY2NvdW50KSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19BQ0NPVU5UKTtcbiAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgYWNjb3VudFxuICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zLmFjY2Vzc1VybCksIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfQUNDRVNTX1VSTCk7XG59XG5cbi8qKlxuICogQSBDb25uZWN0aW9uIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHRoYXQgc2hvdWxkIGJlIGF2YWlsYWJsZSB0byBhbGwgc3RhdGVmdWxcbiAqIG9iamVjdHMgaW4gdGhlIGRyaXZlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbdmFsaWRhdGVDcmVkZW50aWFsc11cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW3FhTW9kZV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbY2xpZW50SW5mb11cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ29ubmVjdGlvbkNvbmZpZyhvcHRpb25zLCB2YWxpZGF0ZUNyZWRlbnRpYWxzLCBxYU1vZGUsIGNsaWVudEluZm8pIHtcbiAgLy8gaWYgbm8gdmFsdWUgaXMgc3BlY2lmaWVkIGZvciB0aGUgdmFsaWRhdGUgY3JlZGVudGlhbHMgZmxhZywgZGVmYXVsdCB0byB0cnVlXG4gIGlmICghVXRpbC5leGlzdHModmFsaWRhdGVDcmVkZW50aWFscykpIHtcbiAgICB2YWxpZGF0ZUNyZWRlbnRpYWxzID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBtaXNzaW5nIG9wdGlvbnNcbiAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMob3B0aW9ucyksXG4gICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19PUFRJT05TKTtcblxuICAvLyBjaGVjayBmb3IgaW52YWxpZCBvcHRpb25zXG4gIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc09iamVjdChvcHRpb25zKSxcbiAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09QVElPTlMpO1xuXG4gIC8vIG9ubHkgdmFsaWRhdGUgY3JlZGVudGlhbHMgaWYgbmVjZXNzYXJ5XG4gIGlmICh2YWxpZGF0ZUNyZWRlbnRpYWxzKSB7XG4gICAgLy8gdXNlcm5hbWUgaXMgbm90IHJlcXVpcmVkIGZvciBvYXV0aCBhbmQgZXh0ZXJuYWwgYnJvd3NlciBhdXRoZW50aWNhdG9yc1xuICAgIGlmICghVXRpbC5leGlzdHMob3B0aW9ucy5hdXRoZW50aWNhdG9yKSB8fFxuICAgICAgKG9wdGlvbnMuYXV0aGVudGljYXRvci50b1VwcGVyQ2FzZSgpICE9PSBBdXRoZW50aWNhdGlvblR5cGVzLk9BVVRIX0FVVEhFTlRJQ0FUT1IgJiZcbiAgICAgICAgb3B0aW9ucy5hdXRoZW50aWNhdG9yLnRvVXBwZXJDYXNlKCkgIT09IEF1dGhlbnRpY2F0aW9uVHlwZXMuRVhURVJOQUxfQlJPV1NFUl9BVVRIRU5USUNBVE9SKSkge1xuICAgICAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgdXNlcm5hbWVcbiAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKG9wdGlvbnMudXNlcm5hbWUpLFxuICAgICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX1VTRVJOQU1FKTtcbiAgICB9XG5cbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy51c2VybmFtZSkpIHtcbiAgICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHVzZXJuYW1lXG4gICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcob3B0aW9ucy51c2VybmFtZSksXG4gICAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfVVNFUk5BTUUpO1xuICAgIH1cblxuICAgIC8vIHBhc3N3b3JkIGlzIG9ubHkgcmVxdWlyZWQgZm9yIGRlZmF1bHQgYXV0aGVudGljYXRvclxuICAgIGlmICghVXRpbC5leGlzdHMob3B0aW9ucy5hdXRoZW50aWNhdG9yKSB8fFxuICAgICAgb3B0aW9ucy5hdXRoZW50aWNhdG9yID09PSBBdXRoZW50aWNhdGlvblR5cGVzLkRFRkFVTFRfQVVUSEVOVElDQVRPUikge1xuICAgICAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgcGFzc3dvcmRcbiAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKG9wdGlvbnMucGFzc3dvcmQpLFxuICAgICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX1BBU1NXT1JEKTtcblxuICAgICAgLy8gY2hlY2sgZm9yIGludmFsaWQgcGFzc3dvcmRcbiAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhvcHRpb25zLnBhc3N3b3JkKSxcbiAgICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QQVNTV09SRCk7XG4gICAgfVxuXG4gICAgY29uc29saWRhdGVIb3N0QW5kQWNjb3VudChvcHRpb25zKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBtaXNzaW5nIGFjY2Vzc1VybFxuICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zLmFjY2Vzc1VybCksXG4gICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19BQ0NFU1NfVVJMKTtcblxuICAvLyBjaGVjayBmb3IgaW52YWxpZCBhY2Nlc3NVcmxcbiAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKG9wdGlvbnMuYWNjZXNzVXJsKSxcbiAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FDQ0VTU19VUkwpO1xuXG4gIGNvbnN0IHByb3h5SG9zdCA9IG9wdGlvbnMucHJveHlIb3N0O1xuICBjb25zdCBwcm94eVBvcnQgPSBvcHRpb25zLnByb3h5UG9ydDtcbiAgY29uc3QgcHJveHlVc2VyID0gb3B0aW9ucy5wcm94eVVzZXI7XG4gIGNvbnN0IHByb3h5UGFzc3dvcmQgPSBvcHRpb25zLnByb3h5UGFzc3dvcmQ7XG4gIGNvbnN0IHByb3h5UHJvdG9jb2wgPSBvcHRpb25zLnByb3h5UHJvdG9jb2wgfHwgJ2h0dHAnO1xuICBjb25zdCBub1Byb3h5ID0gb3B0aW9ucy5ub1Byb3h5O1xuXG4gIC8vIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gbm9kZSBhbmQgc29tZSBwcm94eSBpbmZvcm1hdGlvbiBpcyBzcGVjaWZpZWRcbiAgbGV0IHByb3h5O1xuICBpZiAoVXRpbC5pc05vZGUoKSAmJiAoVXRpbC5leGlzdHMocHJveHlIb3N0KSB8fCBVdGlsLmV4aXN0cyhwcm94eVBvcnQpKSkge1xuICAgIHByb3h5ID1cbiAgICB7XG4gICAgICBob3N0OiBwcm94eUhvc3QsXG4gICAgICBwb3J0OiBwcm94eVBvcnQsXG4gICAgICB1c2VyOiBwcm94eVVzZXIsXG4gICAgICBwYXNzd29yZDogcHJveHlQYXNzd29yZCxcbiAgICAgIHByb3RvY29sOiBwcm94eVByb3RvY29sLFxuICAgICAgbm9Qcm94eTogbm9Qcm94eVxuICAgIH07XG4gICAgUHJveHlVdGlsLnZhbGlkYXRlUHJveHkocHJveHkpO1xuICB9XG5cbiAgY29uc3Qgc2VydmljZU5hbWUgPSBvcHRpb25zLnNlcnZpY2VOYW1lO1xuICBsZXQgYXV0aGVudGljYXRvciA9IG9wdGlvbnMuYXV0aGVudGljYXRvcjtcblxuICAvLyBpZiBubyB2YWx1ZSBpcyBzcGVjaWZpZWQgZm9yIGF1dGhlbnRpY2F0b3IsIGRlZmF1bHQgdG8gU25vd2ZsYWtlXG4gIGlmICghVXRpbC5leGlzdHMoYXV0aGVudGljYXRvcikpIHtcbiAgICBhdXRoZW50aWNhdG9yID0gQXV0aGVudGljYXRpb25UeXBlcy5ERUZBVUxUX0FVVEhFTlRJQ0FUT1I7XG4gIH0gZWxzZSB7XG4gICAgYXV0aGVudGljYXRvciA9IGF1dGhlbnRpY2F0b3IudG9VcHBlckNhc2UoKTtcbiAgfVxuXG4gIGxldCBicm93c2VyQWN0aW9uVGltZW91dCA9IG9wdGlvbnMuYnJvd3NlckFjdGlvblRpbWVvdXQ7XG4gIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmJyb3dzZXJBY3Rpb25UaW1lb3V0KSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5udW1iZXIuaXNQb3NpdGl2ZUludGVnZXIoYnJvd3NlckFjdGlvblRpbWVvdXQpLFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9CUk9XU0VSX1RJTUVPVVQpO1xuICB9IGVsc2Uge1xuICAgIGJyb3dzZXJBY3Rpb25UaW1lb3V0ID0gV0FJVF9GT1JfQlJPV1NFUl9BQ1RJT05fVElNRU9VVDtcbiAgfVxuXG4gIGNvbnN0IHByaXZhdGVLZXkgPSBvcHRpb25zLnByaXZhdGVLZXk7XG4gIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLnByaXZhdGVLZXkpKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZCgoVXRpbC5pc1N0cmluZyhwcml2YXRlS2V5KSAmJiBVdGlsLmlzUHJpdmF0ZUtleShwcml2YXRlS2V5KSksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BSSVZBVEVfS0VZKTtcbiAgfVxuXG4gIGNvbnN0IHByaXZhdGVLZXlQYXRoID0gb3B0aW9ucy5wcml2YXRlS2V5UGF0aDtcbiAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMucHJpdmF0ZUtleVBhdGgpKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHByaXZhdGVLZXlQYXRoKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJJVkFURV9LRVlfUEFUSCk7XG4gIH1cblxuICBjb25zdCBwcml2YXRlS2V5UGFzcyA9IG9wdGlvbnMucHJpdmF0ZUtleVBhc3M7XG4gIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLnByaXZhdGVLZXlQYXNzKSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhwcml2YXRlS2V5UGFzcyksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BSSVZBVEVfS0VZX1BBU1MpO1xuICB9XG5cbiAgY29uc3QgdG9rZW4gPSBvcHRpb25zLnRva2VuO1xuICBpZiAoVXRpbC5leGlzdHModG9rZW4pKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHRva2VuKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfT0FVVEhfVE9LRU4pO1xuICB9XG5cbiAgY29uc3Qgd2FyZWhvdXNlID0gb3B0aW9ucy53YXJlaG91c2U7XG4gIGNvbnN0IGRhdGFiYXNlID0gb3B0aW9ucy5kYXRhYmFzZTtcbiAgY29uc3Qgc2NoZW1hID0gb3B0aW9ucy5zY2hlbWE7XG4gIGNvbnN0IHJvbGUgPSBvcHRpb25zLnJvbGU7XG5cbiAgLy8gY2hlY2sgZm9yIGludmFsaWQgd2FyZWhvdXNlXG4gIGlmIChVdGlsLmV4aXN0cyh3YXJlaG91c2UpKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHdhcmVob3VzZSksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1dBUkVIT1VTRSk7XG4gIH1cblxuICAvLyBjaGVjayBmb3IgaW52YWxpZCBkYXRhYmFzZVxuICBpZiAoVXRpbC5leGlzdHMoZGF0YWJhc2UpKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKGRhdGFiYXNlKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfREFUQUJBU0UpO1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIGludmFsaWQgc2NoZW1hXG4gIGlmIChVdGlsLmV4aXN0cyhzY2hlbWEpKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHNjaGVtYSksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1NDSEVNQSk7XG4gIH1cblxuICAvLyBjaGVjayBmb3IgaW52YWxpZCByb2xlXG4gIGlmIChVdGlsLmV4aXN0cyhyb2xlKSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhyb2xlKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUk9MRSk7XG4gIH1cblxuICAvLyBjaGVjayBmb3IgaW52YWxpZCBzdHJlYW1SZXN1bHRcbiAgY29uc3Qgc3RyZWFtUmVzdWx0ID0gb3B0aW9ucy5zdHJlYW1SZXN1bHQ7XG4gIGlmIChVdGlsLmV4aXN0cyhzdHJlYW1SZXN1bHQpKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihzdHJlYW1SZXN1bHQpLFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9TVFJFQU1fUkVTVUxUKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBpbnZhbGlkIGZldGNoQXNTdHJpbmdcbiAgY29uc3QgZmV0Y2hBc1N0cmluZyA9IG9wdGlvbnMuZmV0Y2hBc1N0cmluZztcbiAgaWYgKFV0aWwuZXhpc3RzKGZldGNoQXNTdHJpbmcpKSB7XG4gICAgLy8gY2hlY2sgdGhhdCB0aGUgdmFsdWUgaXMgYW4gYXJyYXlcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNBcnJheShmZXRjaEFzU3RyaW5nKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HKTtcblxuICAgIC8vIGNoZWNrIHRoYXQgYWxsIHRoZSBhcnJheSBlbGVtZW50cyBhcmUgdmFsaWRcbiAgICBjb25zdCBpbnZhbGlkVmFsdWVJbmRleCA9IE5hdGl2ZVR5cGVzLmZpbmRJbnZhbGlkVmFsdWUoZmV0Y2hBc1N0cmluZyk7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChpbnZhbGlkVmFsdWVJbmRleCA9PT0gLTEsXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0ZFVENIX0FTX1NUUklOR19WQUxVRVMsXG4gICAgICBKU09OLnN0cmluZ2lmeShmZXRjaEFzU3RyaW5nW2ludmFsaWRWYWx1ZUluZGV4XSkpO1xuICB9XG4gIC8vIFJvdyBtb2RlIGlzIG9wdGlvbmFsLCBjYW4gYmUgdW5kZWZpbmVkXG4gIGNvbnN0IHJvd01vZGUgPSBvcHRpb25zLnJvd01vZGU7XG4gIGlmIChVdGlsLmV4aXN0cyhyb3dNb2RlKSkge1xuICAgIFJvd01vZGUuY2hlY2tSb3dNb2RlVmFsaWQocm93TW9kZSk7XG4gIH1cblxuICAvLyBjaGVjayBmb3IgaW52YWxpZCBjbGllbnRTZXNzaW9uS2VlcEFsaXZlXG4gIGNvbnN0IGNsaWVudFNlc3Npb25LZWVwQWxpdmUgPSBvcHRpb25zLmNsaWVudFNlc3Npb25LZWVwQWxpdmU7XG4gIGlmIChVdGlsLmV4aXN0cyhjbGllbnRTZXNzaW9uS2VlcEFsaXZlKSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4oY2xpZW50U2Vzc2lvbktlZXBBbGl2ZSksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0tFRVBfQUxJVkUpO1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIGludmFsaWQgY2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeVxuICBsZXQgY2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSA9IG9wdGlvbnMuY2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeTtcbiAgaWYgKFV0aWwuZXhpc3RzKGNsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3kpKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzTnVtYmVyKGNsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3kpLFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9LRUVQX0FMSVZFX0hFQVJUQkVBVF9GUkVRKTtcbiAgICBjbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5ID1cbiAgICAgIFV0aWwudmFsaWRhdGVDbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5KGNsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3ksIENvbm5lY3Rpb25Db25zdGFudHMuSEVBUlRCRUFUX0ZSRVFVRU5DWV9NQVNURVJfVkFMSURJVFkpO1xuICB9XG5cbiAgY29uc3QganNUcmVhdEludGVnZXJBc0JpZ0ludCA9IG9wdGlvbnMuanNUcmVhdEludGVnZXJBc0JpZ0ludDtcbiAgaWYgKFV0aWwuZXhpc3RzKGpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQpKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihqc1RyZWF0SW50ZWdlckFzQmlnSW50KSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfVFJFQVRfSU5URUdFUl9BU19CSUdJTlQpO1xuICB9XG5cbiAgY29uc3QgZ2NzVXNlRG93bnNjb3BlZENyZWRlbnRpYWwgPSBvcHRpb25zLmdjc1VzZURvd25zY29wZWRDcmVkZW50aWFsO1xuICBpZiAoVXRpbC5leGlzdHMoZ2NzVXNlRG93bnNjb3BlZENyZWRlbnRpYWwpKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihnY3NVc2VEb3duc2NvcGVkQ3JlZGVudGlhbCksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0dDU19VU0VfRE9XTlNDT1BFRF9DUkVERU5USUFMKTtcbiAgfVxuXG4gIGNvbnN0IGNsaWVudENvbmZpZ0ZpbGUgPSBvcHRpb25zLmNsaWVudENvbmZpZ0ZpbGU7XG4gIGlmIChVdGlsLmV4aXN0cyhjbGllbnRDb25maWdGaWxlKSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhjbGllbnRDb25maWdGaWxlKSwgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9DTElFTlRfQ09ORklHX0ZJTEUpO1xuICB9XG5cbiAgLy8gcmVtZW1iZXIgaWYgd2UncmUgaW4gcWEgbW9kZVxuICB0aGlzLl9xYU1vZGUgPSBxYU1vZGU7XG5cbiAgLy8gaWYgYSBjbGllbnQtaW5mbyBhcmd1bWVudCBpcyBzcGVjaWZpZWQsIHZhbGlkYXRlIGl0XG4gIGNvbnN0IGNsaWVudFR5cGUgPSAnSmF2YVNjcmlwdCc7XG4gIGxldCBjbGllbnROYW1lO1xuICBsZXQgY2xpZW50VmVyc2lvbjtcbiAgbGV0IGNsaWVudEVudmlyb25tZW50O1xuICBpZiAoVXRpbC5leGlzdHMoY2xpZW50SW5mbykpIHtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjbGllbnRJbmZvKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNTdHJpbmcoY2xpZW50SW5mby52ZXJzaW9uKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoY2xpZW50SW5mby5lbnZpcm9ubWVudCkpO1xuXG4gICAgY2xpZW50TmFtZSA9IGNsaWVudEluZm8ubmFtZTtcbiAgICBjbGllbnRWZXJzaW9uID0gY2xpZW50SW5mby52ZXJzaW9uO1xuICAgIGNsaWVudEVudmlyb25tZW50ID0gY2xpZW50SW5mby5lbnZpcm9ubWVudDtcbiAgICBjbGllbnRFbnZpcm9ubWVudC5PUyA9IG9zLnBsYXRmb3JtKCk7XG4gICAgY2xpZW50RW52aXJvbm1lbnQuT1NfVkVSU0lPTiA9IG9zLnJlbGVhc2UoKTtcbiAgICBjbGllbnRFbnZpcm9ubWVudC5PQ1NQX01PREUgPSBHbG9iYWxDb25maWcuZ2V0T2NzcE1vZGUoKTtcbiAgfVxuXG4gIGNvbnN0IGNsaWVudEFwcGxpY2F0aW9uID0gb3B0aW9ucy5hcHBsaWNhdGlvbjtcbiAgaWYgKFV0aWwuZXhpc3RzKGNsaWVudEFwcGxpY2F0aW9uKSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhjbGllbnRBcHBsaWNhdGlvbiksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FQUExJQ0FUSU9OKTtcblxuICAgIGNvbnN0IEFQUExJQ0FUSU9OX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFN0cmluZy5yYXdgXltBLVphLXpdKFtBLVphLXowLTkuXFwtX10pezEsNTB9JGAsXG4gICAgICAnZ2knKTtcblxuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoQVBQTElDQVRJT05fUEFUVEVSTi50ZXN0KGNsaWVudEFwcGxpY2F0aW9uKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQVBQTElDQVRJT04pO1xuICB9XG5cbiAgbGV0IHZhbGlkYXRlRGVmYXVsdFBhcmFtZXRlcnMgPSBmYWxzZTtcbiAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMudmFsaWRhdGVEZWZhdWx0UGFyYW1ldGVycykpIHtcbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCB2YWxpZGF0ZURlZmF1bHRQYXJhbWV0ZXJzXG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihvcHRpb25zLnZhbGlkYXRlRGVmYXVsdFBhcmFtZXRlcnMpLFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9WQUxJREFURV9ERUZBVUxUX1BBUkFNRVRFUlMpO1xuXG4gICAgdmFsaWRhdGVEZWZhdWx0UGFyYW1ldGVycyA9IG9wdGlvbnMudmFsaWRhdGVEZWZhdWx0UGFyYW1ldGVycztcbiAgfVxuXG4gIGxldCBiaW5kVGhyZXNob2xkID0gbnVsbDtcbiAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuYXJyYXlCaW5kaW5nVGhyZXNob2xkKSkge1xuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIGFycmF5QmluZGluZ1RocmVzaG9sZFxuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc051bWJlcihvcHRpb25zLmFycmF5QmluZGluZ1RocmVzaG9sZCksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FSUkFZX0JJTkRJTkdfVEhSRVNIT0xEKTtcblxuICAgIGJpbmRUaHJlc2hvbGQgPSBvcHRpb25zLmFycmF5QmluZGluZ1RocmVzaG9sZDtcbiAgfVxuXG4gIGxldCBmb3JjZVN0YWdlQmluZEVycm9yID0gbnVsbDtcbiAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuZm9yY2VTdGFnZUJpbmRFcnJvcikpIHtcbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBmb3JjZVN0YWdlQmluZEVycm9yXG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzTnVtYmVyKG9wdGlvbnMuZm9yY2VTdGFnZUJpbmRFcnJvciksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0ZPUkNFX1NUQUdFX0JJTkRfRVJST1IpO1xuXG4gICAgZm9yY2VTdGFnZUJpbmRFcnJvciA9IG9wdGlvbnMuZm9yY2VTdGFnZUJpbmRFcnJvcjtcbiAgfVxuXG4gIGxldCBkaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUgPSBmYWxzZTtcbiAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuZGlzYWJsZVF1ZXJ5Q29udGV4dENhY2hlKSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy5kaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUpLFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9ESVNBQkxFRF9RVUVSWV9DT05URVhUX0NBQ0hFKTtcblxuICAgIGRpc2FibGVRdWVyeUNvbnRleHRDYWNoZSA9IG9wdGlvbnMuZGlzYWJsZVF1ZXJ5Q29udGV4dENhY2hlO1xuICB9XG5cbiAgbGV0IHJldHJ5VGltZW91dCA9IDMwMDtcbiAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMucmV0cnlUaW1lb3V0KSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc051bWJlcihvcHRpb25zLnJldHJ5VGltZW91dCksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX01BWF9SRVRSWV9USU1FT1VUKTtcblxuICAgIHJldHJ5VGltZW91dCA9IG9wdGlvbnMucmV0cnlUaW1lb3V0ICE9PSAwID8gTWF0aC5tYXgocmV0cnlUaW1lb3V0LCBvcHRpb25zLnJldHJ5VGltZW91dCkgOiAwO1xuICB9XG5cbiAgbGV0IGluY2x1ZGVSZXRyeVJlYXNvbiA9IHRydWU7XG4gIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmluY2x1ZGVSZXRyeVJlYXNvbikpIHtcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKG9wdGlvbnMuaW5jbHVkZVJldHJ5UmVhc29uKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfSU5DTFVERV9SRVRSWV9SRUFTT04pO1xuXG4gICAgaW5jbHVkZVJldHJ5UmVhc29uID0gb3B0aW9ucy5pbmNsdWRlUmV0cnlSZWFzb247XG4gIH1cblxuICBsZXQgY2xpZW50UmVxdWVzdE1GQVRva2VuID0gZmFsc2U7XG4gIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmNsaWVudFJlcXVlc3RNRkFUb2tlbikpIHtcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKG9wdGlvbnMuY2xpZW50UmVxdWVzdE1GQVRva2VuKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQ0xJRU5UX1JFUVVFU1RfTUZBX1RPS0VOKTtcblxuICAgIGNsaWVudFJlcXVlc3RNRkFUb2tlbiA9IG9wdGlvbnMuY2xpZW50UmVxdWVzdE1GQVRva2VuO1xuICB9XG5cbiAgbGV0IGRpc2FibGVDb25zb2xlTG9naW4gPSB0cnVlO1xuICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5kaXNhYmxlQ29uc29sZUxvZ2luKSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy5kaXNhYmxlQ29uc29sZUxvZ2luKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRElTQUJMRV9DT05TT0xFX0xPR0lOKTtcblxuICAgIGRpc2FibGVDb25zb2xlTG9naW4gPSBvcHRpb25zLmRpc2FibGVDb25zb2xlTG9naW47XG4gIH1cblxuICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5mb3JjZUdDUFVzZURvd25zY29wZWRDcmVkZW50aWFsKSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy5mb3JjZUdDUFVzZURvd25zY29wZWRDcmVkZW50aWFsKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRk9SQ0VfR0NQX1VTRV9ET1dOU0NPUEVEX0NSRURFTlRJQUwpO1xuXG4gICAgcHJvY2Vzcy5lbnYuU05PV0ZMQUtFX0ZPUkNFX0dDUF9VU0VfRE9XTlNDT1BFRF9DUkVERU5USUFMID0gb3B0aW9ucy5mb3JjZUdDUFVzZURvd25zY29wZWRDcmVkZW50aWFsO1xuICB9IGVsc2Uge1xuICAgIHByb2Nlc3MuZW52LlNOT1dGTEFLRV9GT1JDRV9HQ1BfVVNFX0RPV05TQ09QRURfQ1JFREVOVElBTCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMucmVwcmVzZW50TnVsbEFzU3RyaW5nTnVsbCkpIHtcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKG9wdGlvbnMucmVwcmVzZW50TnVsbEFzU3RyaW5nTnVsbCksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1JFUFJFU0VOVF9OVUxMX0FTX1NUUklOR19OVUxMKTtcblxuICAgIERhdGFUeXBlcy5zZXRJc1JlcHJlc2VudE51bGxBc1N0cmluZ051bGwob3B0aW9ucy5yZXByZXNlbnROdWxsQXNTdHJpbmdOdWxsKTtcbiAgfVxuXG4gIGxldCBkaXNhYmxlU2FtbFVSTENoZWNrID0gZmFsc2U7XG4gIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmRpc2FibGVTYW1sVVJMQ2hlY2spKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihvcHRpb25zLmRpc2FibGVTYW1sVVJMQ2hlY2spLFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9ESVNBQkxFX1NBTUxfVVJMX0NIRUNLKTtcblxuICAgIGRpc2FibGVTYW1sVVJMQ2hlY2sgPSBvcHRpb25zLmRpc2FibGVTYW1sVVJMQ2hlY2s7XG4gIH1cblxuICBsZXQgY2xpZW50U3RvcmVUZW1wb3JhcnlDcmVkZW50aWFsID0gZmFsc2U7XG4gIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmNsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCkpIHtcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKG9wdGlvbnMuY2xpZW50U3RvcmVUZW1wb3JhcnlDcmVkZW50aWFsKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQ0xJRU5UX1NUT1JFX1RFTVBPUkFSWV9DUkVERU5USUFMKTtcblxuICAgIGNsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbCA9IG9wdGlvbnMuY2xpZW50U3RvcmVUZW1wb3JhcnlDcmVkZW50aWFsO1xuICB9XG5cbiAgbGV0IGNyZWRlbnRpYWxDYWNoZURpciA9IG51bGw7XG4gIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLmNyZWRlbnRpYWxDYWNoZURpcikpIHtcbiAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXRoLnJlc29sdmUob3B0aW9ucy5jcmVkZW50aWFsQ2FjaGVEaXIpO1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC52YWxpZGF0ZVBhdGgoYWJzb2x1dGVQYXRoKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQ1JFREVOVElBTF9DQUNIRV9ESVIpO1xuXG4gICAgY3JlZGVudGlhbENhY2hlRGlyID0gYWJzb2x1dGVQYXRoO1xuICB9XG5cbiAgbGV0IHBhc3Njb2RlSW5QYXNzd29yZCA9IGZhbHNlO1xuICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5wYXNzY29kZUluUGFzc3dvcmQpKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihvcHRpb25zLnBhc3Njb2RlSW5QYXNzd29yZCksIFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QQVNTQ09ERV9JTl9QQVNTV09SRCk7XG5cbiAgICBwYXNzY29kZUluUGFzc3dvcmQgPSBvcHRpb25zLnBhc3Njb2RlSW5QYXNzd29yZDtcbiAgfVxuXG4gIGxldCBwYXNzY29kZSA9IG51bGw7XG4gIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zLnBhc3Njb2RlKSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhvcHRpb25zLnBhc3Njb2RlKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUEFTU0NPREUpO1xuXG4gICAgcGFzc2NvZGUgPSBvcHRpb25zLnBhc3Njb2RlO1xuICB9XG4gIFxuICBpZiAodmFsaWRhdGVEZWZhdWx0UGFyYW1ldGVycykge1xuICAgIGZvciAoY29uc3QgW2tleV0gb2YgT2JqZWN0LmVudHJpZXMob3B0aW9ucykpIHtcbiAgICAgIGlmICghREVGQVVMVF9QQVJBTVMuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBsZXZlbnNodGVpbi5jbG9zZXN0KGtleSwgREVGQVVMVF9QQVJBTVMpO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcihgJyR7a2V5fScgaXMgYW4gdW5rbm93biBjb25uZWN0aW9uIHBhcmFtZXRlci4gRGlkIHlvdSBtZWFuICcke3Jlc3VsdH0nP2ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGluZm9ybWF0aW9uIGFib3V0IHRoZSBwcm94eSBob3N0bmFtZSwgcG9ydCxcbiAgICogZXRjLiBmb3Igd2hlbiBodHRwIHJlcXVlc3RzIGFyZSBtYWRlLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgdGhpcy5nZXRQcm94eSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcHJveHk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHdhcmVob3VzZSB0byBhdXRvbWF0aWNhbGx5IHVzZSBvbmNlIGEgY29ubmVjdGlvbiBoYXMgYmVlblxuICAgKiBlc3RhYmxpc2hlZC5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRoaXMuZ2V0V2FyZWhvdXNlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB3YXJlaG91c2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRhdGFiYXNlIHRvIGF1dG9tYXRpY2FsbHkgdXNlIG9uY2UgYSBjb25uZWN0aW9uIGhhcyBiZWVuXG4gICAqIGVzdGFibGlzaGVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy5nZXREYXRhYmFzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGF0YWJhc2U7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNjaGVtYSB0byBhdXRvbWF0aWNhbGx5IHVzZSBvbmNlIGEgY29ubmVjdGlvbiBoYXMgYmVlblxuICAgKiBlc3RhYmxpc2hlZC5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRoaXMuZ2V0U2NoZW1hID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzY2hlbWE7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvbGUgdG8gYXV0b21hdGljYWxseSB1c2Ugb25jZSBhIGNvbm5lY3Rpb24gaGFzIGJlZW5cbiAgICogZXN0YWJsaXNoZWQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICB0aGlzLmdldFJvbGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHJvbGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNlcnZpY2UgbmFtZS5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRoaXMuZ2V0U2VydmljZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNlcnZpY2VOYW1lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBhdXRoZW50aWNhdG9yIHRvIHVzZSBmb3IgZXN0YWJsaXNoaW5nIGEgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRoaXMuZ2V0QXV0aGVudGljYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gYXV0aGVudGljYXRvcjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGltZW91dCBpbiBtaWxsaXMgdXNlZCBmb3IgYXV0aGVudGljYXRpb24gYnkgZXh0ZXJuYWwgYnJvd3Nlci5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRoaXMuZ2V0QnJvd3NlckFjdGlvblRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGJyb3dzZXJBY3Rpb25UaW1lb3V0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwcml2YXRlIGtleSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICB0aGlzLmdldFByaXZhdGVLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByaXZhdGVLZXk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByaXZhdGUga2V5IGZpbGUgbG9jYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICB0aGlzLmdldFByaXZhdGVLZXlQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcml2YXRlS2V5UGF0aDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcHJpdmF0ZSBrZXkgcGFzc3BocmFzZS5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRoaXMuZ2V0UHJpdmF0ZUtleVBhc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHByaXZhdGVLZXlQYXNzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBPQXV0aCB0b2tlbi5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRoaXMuZ2V0VG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRva2VuO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzdHJlYW1SZXN1bHQgZmxhZy5cbiAgICpcbiAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmdldFN0cmVhbVJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc3RyZWFtUmVzdWx0O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBmZXRjaEFzU3RyaW5nIGFycmF5LlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nW119XG4gICAqL1xuICB0aGlzLmdldEZldGNoQXNTdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZldGNoQXNTdHJpbmc7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHJvd01vZGUgc3RyaW5nIHZhbHVlICgnYXJyYXknLCAnb2JqZWN0JyBvciAnb2JqZWN0X3dpdGhfcmVuYW1lZF9kdXBsaWNhdGVkX2NvbHVtbnMnKS4gQ291bGQgYmUgbnVsbCBvciB1bmRlZmluZWQuXG4gICAqXG4gICAqIEByZXR1cm5zICB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy5nZXRSb3dNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByb3dNb2RlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgdHlwZS5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRoaXMuZ2V0Q2xpZW50VHlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2xpZW50VHlwZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY2xpZW50IG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICB0aGlzLmdldENsaWVudE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNsaWVudE5hbWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsaWVudCB2ZXJzaW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy5nZXRDbGllbnRWZXJzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjbGllbnRWZXJzaW9uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgYXBwbGljYXRpb24uXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICB0aGlzLmdldENsaWVudEFwcGxpY2F0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjbGllbnRBcHBsaWNhdGlvbjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIEpTT04gb2JqZWN0IGNvbnRhaW5pbmcgdmVyc2lvbiBpbmZvcm1hdGlvbiBmb3IgYWxsIHRoZSB2YXJpb3VzXG4gICAqIGNvbXBvbmVudHMgb2YgdGhlIHJ1bnRpbWUsIGUuZy4gbm9kZSwgdjgsIG9wZW5zc2wsIGV0Yy5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHRoaXMuZ2V0Q2xpZW50RW52aXJvbm1lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNsaWVudEVudmlyb25tZW50O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgc2Vzc2lvbiBrZWVwIGFsaXZlIHNldHRpbmcuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICB0aGlzLmdldENsaWVudFNlc3Npb25LZWVwQWxpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNsaWVudFNlc3Npb25LZWVwQWxpdmU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNsaWVudCBzZXNzaW9uIGtlZXAgYWxpdmUgaGVhcnRiZWF0IGZyZXF1ZW5jeSBzZXR0aW5nLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy5nZXRDbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5O1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgdHJlYXQgaW50ZWdlciBhcyBzZXR0aW5nXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICB0aGlzLmdldEpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHNldHRpbmcgZm9yIHRoZSBHQ1NfVVNFX0RPV05TQ09QRURfQ1JFREVOVElBTCBzZXNzaW9uIHBhcmFtZXRlclxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy5nZXRHY3NVc2VEb3duc2NvcGVkQ3JlZGVudGlhbCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZ2NzVXNlRG93bnNjb3BlZENyZWRlbnRpYWw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJpbmQgdGhyZXNob2xkXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLmdldGJpbmRUaHJlc2hvbGQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGJpbmRUaHJlc2hvbGQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGZvcmNlIHN0YWdlIGJpbmQgZXJyb3JcbiAgICpcbiAgICogQHJldHVybnMge3N0cmluZ31cbiAgICovXG4gIHRoaXMuZ2V0Rm9yY2VTdGFnZUJpbmRFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZm9yY2VTdGFnZUJpbmRFcnJvcjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBSZXRyeSByZWFzb24gaXMgaW5jbHVkZWQgb3Igbm90IGluIHRoZSByZXRyeSB1cmxcbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmdldEluY2x1ZGVSZXRyeVJlYXNvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gaW5jbHVkZVJldHJ5UmVhc29uO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFF1ZXJ5IENvbnRleHQgQ2FjaGUgaXMgZW5hYmxlZCBvciBub3QgYnkgdGhlIGNvbmZpZ3VyYXRpb25cbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmdldERpc2FibGVRdWVyeUNvbnRleHRDYWNoZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGlzYWJsZVF1ZXJ5Q29udGV4dENhY2hlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjbGllbnQgY29uZmlnIGZpbGVcbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRoaXMuZ2V0Q2xpZW50Q29uZmlnRmlsZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY2xpZW50Q29uZmlnRmlsZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWF4IGxvZ2luIHRpbWVvdXRcbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIHRoaXMuZ2V0UmV0cnlUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiByZXRyeVRpbWVvdXQ7XG4gIH07XG5cbiAgdGhpcy5nZXREaXNhYmxlQ29uc29sZUxvZ2luID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBkaXNhYmxlQ29uc29sZUxvZ2luO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhlIFNBTUwgVVJMIGNoZWNrIGlzIGVuYWJsZWQgb3Igbm90LlxuICAgKlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICovXG4gIHRoaXMuZ2V0RGlzYWJsZVNhbWxVUkxDaGVjayA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gZGlzYWJsZVNhbWxVUkxDaGVjaztcbiAgfTtcblxuICB0aGlzLmdldENyZWRlbnRpYWxDYWNoZURpciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY3JlZGVudGlhbENhY2hlRGlyO1xuICB9O1xuXG4gIHRoaXMuZ2V0Q2xpZW50UmVxdWVzdE1GQVRva2VuID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjbGllbnRSZXF1ZXN0TUZBVG9rZW47XG4gIH07XG4gIC8qKiBcbiAgICogUmV0dXJucyB3aGV0aGVyIHRoZSBhdXRoIHRva2VuIHNhdmVzIG9uIHRoZSBsb2NhbCBtYWNoaW5lIG9yIG5vdC4gXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgdGhpcy5nZXRDbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNsaWVudFN0b3JlVGVtcG9yYXJ5Q3JlZGVudGlhbDtcbiAgfTtcblxuICB0aGlzLmdldFBhc3Njb2RlSW5QYXNzd29yZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gcGFzc2NvZGVJblBhc3N3b3JkO1xuICB9O1xuXG4gIHRoaXMuZ2V0UGFzc2NvZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHBhc3Njb2RlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIGF0dHJpYnV0ZXMgb2YgQ29ubmVjdGlvbiBDb25maWcgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnlcbiAgICogdGhlIGNvbm5lY3Rpb24sIHdoZW4gSUQgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgc2NvcGUuIFRoaXMgaXMgbm90IHN1ZmZpY2llbnQgc2V0LFxuICAgKiBzaW5jZSBtdWx0aXBsZSBjb25uZWN0aW9ucyBjYW4gYmUgaW5zdGFudGlhdGVkIGZvciB0aGUgc2FtZSBjb25maWcsIGJ1dCBjYW4gYmUgdHJlYXRlZCBhcyBhIGhpbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICB0aGlzLmRlc2NyaWJlSWRlbnRpdHlBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBgaG9zdDogJHt0aGlzLmhvc3R9LCBhY2NvdW50OiAke3RoaXMuYWNjb3VudH0sIGFjY2Vzc1VybDogJHt0aGlzLmFjY2Vzc1VybH0sIGBcbiAgICAgICAgKyBgdXNlcjogJHt0aGlzLnVzZXJuYW1lfSwgcm9sZTogJHt0aGlzLmdldFJvbGUoKX0sIGRhdGFiYXNlOiAke3RoaXMuZ2V0RGF0YWJhc2UoKX0sIGBcbiAgICAgICAgKyBgc2NoZW1hOiAke3RoaXMuZ2V0U2NoZW1hKCl9LCB3YXJlaG91c2U6ICR7dGhpcy5nZXRXYXJlaG91c2UoKX0sIGAgKyBQcm94eVV0aWwuZGVzY3JpYmVQcm94eSh0aGlzLmdldFByb3h5KCkpO1xuICB9O1xuXG4gIC8vIHNhdmUgY29uZmlnIG9wdGlvbnNcbiAgdGhpcy51c2VybmFtZSA9IG9wdGlvbnMudXNlcm5hbWU7XG4gIHRoaXMucGFzc3dvcmQgPSBvcHRpb25zLnBhc3N3b3JkO1xuICB0aGlzLmFjY2Vzc1VybCA9IG9wdGlvbnMuYWNjZXNzVXJsO1xuICB0aGlzLnJlZ2lvbiA9IG9wdGlvbnMucmVnaW9uO1xuICB0aGlzLmFjY291bnQgPSBvcHRpb25zLmFjY291bnQ7XG4gIHRoaXMuaG9zdCA9IG9wdGlvbnMuaG9zdDtcbiAgdGhpcy5zZXNzaW9uVG9rZW4gPSBvcHRpb25zLnNlc3Npb25Ub2tlbjtcbiAgdGhpcy5tYXN0ZXJUb2tlbiA9IG9wdGlvbnMubWFzdGVyVG9rZW47XG4gIHRoaXMubWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZSA9IG9wdGlvbnMubWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZTtcbiAgdGhpcy5zZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZSA9IG9wdGlvbnMuc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWU7XG4gIHRoaXMuY2xpZW50Q29uZmlnRmlsZSA9IG9wdGlvbnMuY2xpZW50Q29uZmlnRmlsZTtcbiAgdGhpcy5vcGVuRXh0ZXJuYWxCcm93c2VyQ2FsbGJhY2sgPSBvcHRpb25zLm9wZW5FeHRlcm5hbEJyb3dzZXJDYWxsYmFjaztcblxuICAvLyBjcmVhdGUgdGhlIHBhcmFtZXRlcnMgYXJyYXlcbiAgY29uc3QgcGFyYW1ldGVycyA9IGNyZWF0ZVBhcmFtZXRlcnMoKTtcblxuICAvLyBjcmVhdGUgYSBtYXAgaW4gd2hpY2ggdGhlIGtleXMgYXJlIHRoZSBwYXJhbWV0ZXIgbmFtZXMgYW5kIHRoZSB2YWx1ZXMgYXJlXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHBhcmFtZXRlcnNcbiAgY29uc3QgbWFwUGFyYW1ldGVycyA9IHt9O1xuICBsZXQgaW5kZXgsIGxlbmd0aCwgcGFyYW1ldGVyO1xuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gcGFyYW1ldGVycy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgcGFyYW1ldGVyID0gcGFyYW1ldGVyc1tpbmRleF07XG4gICAgbWFwUGFyYW1ldGVyc1twYXJhbWV0ZXIubmFtZV0gPSBwYXJhbWV0ZXI7XG5cbiAgICAvLyBpbml0aWFsaXplIHRoZSB2YWx1ZSB0byB0aGUgZGVmYXVsdFxuICAgIHBhcmFtZXRlci52YWx1ZSA9IHBhcmFtZXRlci5kZWZhdWx0VmFsdWU7XG4gIH1cblxuICAvLyBmb3IgZWFjaCBwcm9wZXJ0eSBpbiB0aGUgb3B0aW9ucyBvYmplY3QgdGhhdCBtYXRjaGVzIGEga25vd24gcGFyYW1ldGVyIG5hbWVcbiAgbGV0IHByb3BlcnR5TmFtZSwgcHJvcGVydHlWYWx1ZTtcbiAgZm9yIChwcm9wZXJ0eU5hbWUgaW4gb3B0aW9ucykge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgcHJvcGVydHlOYW1lKSAmJlxuICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1hcFBhcmFtZXRlcnMsIHByb3BlcnR5TmFtZSkpIHtcbiAgICAgIC8vIGlmIHRoZSBwYXJhbWV0ZXIgbWF0Y2hpbmcgdGhlIHByb3BlcnR5IGlzIGV4dGVybmFsIGFuZCB0aGUgc3BlY2lmaWVkXG4gICAgICAvLyB2YWx1ZSBpcyB2YWxpZCBmb3IgdGhlIHBhcmFtZXRlciwgdXBkYXRlIHRoZSBwYXJhbWV0ZXIgdmFsdWVcbiAgICAgIHByb3BlcnR5VmFsdWUgPSBvcHRpb25zW3Byb3BlcnR5TmFtZV07XG4gICAgICBwYXJhbWV0ZXIgPSBtYXBQYXJhbWV0ZXJzW3Byb3BlcnR5TmFtZV07XG4gICAgICBpZiAocGFyYW1ldGVyLmV4dGVybmFsICYmIHBhcmFtZXRlci52YWxpZGF0ZShwcm9wZXJ0eVZhbHVlKSkge1xuICAgICAgICBwYXJhbWV0ZXIudmFsdWUgPSBwcm9wZXJ0eVZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNhdmUgdGhlIHBhcmFtZXRlcnMgbWFwXG4gIHRoaXMuX21hcFBhcmFtZXRlcnMgPSBtYXBQYXJhbWV0ZXJzO1xuXG4gIC8vIGN1c3RvbSBhZ2VudCBjbGFzcywgdGVzdCBvbmx5XG4gIHRoaXMuYWdlbnRDbGFzcyA9IG9wdGlvbnMuYWdlbnRDbGFzcztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIHFhLW1vZGUgaXMgb24uXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmlzUWFNb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcWFNb2RlO1xufTtcblxuLyoqXG4gKiBDbGVhcnMgYWxsIGNyZWRlbnRpYWwtcmVsYXRlZCBpbmZvcm1hdGlvbi5cbiAqL1xuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuY2xlYXJDcmVkZW50aWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gY2xlYXIgdGhlIHBhc3N3b3JkXG4gIHRoaXMucGFzc3dvcmQgPSBudWxsO1xuXG4gIC8vIFRPRE86IGNsZWFyIHBhc3Njb2RlIGFuZCBvdGhlciBjcmVkZW50aWFsLXJlbGF0ZWQgaW5mb3JtYXRpb24gYXMgd2VsbFxufTtcblxuY29uc3QgUEFSQU1fVElNRU9VVCA9ICd0aW1lb3V0JztcbmNvbnN0IFBBUkFNX1JFU1VMVF9QUkVGRVRDSCA9ICdyZXN1bHRQcmVmZXRjaCc7XG5jb25zdCBQQVJBTV9SRVNVTFRfU1RSRUFNX0lOVEVSUlVQVFMgPSAncmVzdWx0U3RyZWFtSW50ZXJydXB0cyc7XG5jb25zdCBQQVJBTV9SRVNVTFRfQ0hVTktfQ0FDSEVfU0laRSA9ICdyZXN1bHRDaHVua0NhY2hlU2l6ZSc7XG5jb25zdCBQQVJBTV9SRVNVTFRfUFJPQ0VTU0lOR19CQVRDSF9TSVpFID0gJ3Jlc3VsdFByb2Nlc3NpbmdCYXRjaFNpemUnO1xuY29uc3QgUEFSQU1fUkVTVUxUX1BST0NFU1NJTkdfQkFUQ0hfRFVSQVRJT04gPSAncmVzdWx0UHJvY2Vzc2luZ0JhdGNoRHVyYXRpb24nO1xuY29uc3QgUEFSQU1fUk9XX1NUUkVBTV9ISUdIX1dBVEVSX01BUksgPSAncm93U3RyZWFtSGlnaFdhdGVyTWFyayc7XG5jb25zdCBQQVJBTV9SRVRSWV9MQVJHRV9SRVNVTFRfU0VUX01BWF9OVU1fUkVUUklFUyA9ICdsYXJnZVJlc3VsdFNldFJldHJ5TWF4TnVtUmV0cmllcyc7XG5jb25zdCBQQVJBTV9SRVRSWV9MQVJHRV9SRVNVTFRfU0VUX01BWF9TTEVFUF9USU1FID0gJ2xhcmdlUmVzdWx0U2V0UmV0cnlNYXhTbGVlcFRpbWUnO1xuY29uc3QgUEFSQU1fUkVUUllfU0ZfTUFYX0xPR0lOX1JFVFJJRVMgPSAnc2ZSZXRyeU1heExvZ2luUmV0cmllcyc7XG5jb25zdCBQQVJBTV9SRVRSWV9TRl9NQVhfTlVNX1JFVFJJRVMgPSAnc2ZSZXRyeU1heE51bVJldHJpZXMnO1xuY29uc3QgUEFSQU1fUkVUUllfU0ZfU1RBUlRJTkdfU0xFRVBfVElNRSA9ICdzZlJldHJ5U3RhcnRpbmdTbGVlcFRpbWUnO1xuY29uc3QgUEFSQU1fUkVUUllfU0ZfTUFYX1NMRUVQX1RJTUUgPSAnc2ZSZXRyeU1heFNsZWVwVGltZSc7XG5cbi8qKlxuICogQ3JlYXRlcyB0aGUgbGlzdCBvZiBrbm93biBwYXJhbWV0ZXJzLiBJZiBhIHBhcmFtZXRlciBpcyBtYXJrZWQgYXMgZXh0ZXJuYWwsXG4gKiBpdHMgdmFsdWUgY2FuIGJlIG92ZXJyaWRkZW4gYnkgYWRkaW5nIHRoZSBhcHByb3ByaWF0ZSBuYW1lLXZhbHVlIG1hcHBpbmcgdG9cbiAqIHRoZSBDb25uZWN0aW9uQ29uZmlnIG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMge09iamVjdFtdfVxuICovXG5mdW5jdGlvbiBjcmVhdGVQYXJhbWV0ZXJzKCkge1xuICBjb25zdCBpc05vbk5lZ2F0aXZlSW50ZWdlciA9IFV0aWwubnVtYmVyLmlzTm9uTmVnYXRpdmVJbnRlZ2VyLmJpbmQoVXRpbC5udW1iZXIpO1xuICBjb25zdCBpc1Bvc2l0aXZlSW50ZWdlciA9IFV0aWwubnVtYmVyLmlzUG9zaXRpdmVJbnRlZ2VyLmJpbmQoVXRpbC5udW1iZXIpO1xuICBjb25zdCBpc05vbk5lZ2F0aXZlTnVtYmVyID0gVXRpbC5udW1iZXIuaXNOb25OZWdhdGl2ZS5iaW5kKFV0aWwubnVtYmVyKTtcblxuICByZXR1cm4gW1xuICAgIHtcbiAgICAgIG5hbWU6IFBBUkFNX1RJTUVPVVQsXG4gICAgICBkZWZhdWx0VmFsdWU6IDkwICogMTAwMCxcbiAgICAgIGV4dGVybmFsOiB0cnVlLFxuICAgICAgdmFsaWRhdGU6IGlzUG9zaXRpdmVJbnRlZ2VyXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBQQVJBTV9SRVNVTFRfUFJFRkVUQ0gsXG4gICAgICBkZWZhdWx0VmFsdWU6IDIsXG4gICAgICBleHRlcm5hbDogdHJ1ZSxcbiAgICAgIHZhbGlkYXRlOiBpc1Bvc2l0aXZlSW50ZWdlclxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogUEFSQU1fUkVTVUxUX1NUUkVBTV9JTlRFUlJVUFRTLFxuICAgICAgZGVmYXVsdFZhbHVlOiAzLFxuICAgICAgdmFsaWRhdGU6IGlzUG9zaXRpdmVJbnRlZ2VyXG4gICAgfSxcbiAgICAvLyBmb3Igbm93IHdlIHNldCBjaHVuayBjYWNoZSBzaXplIHRvIDEsIHdoaWNoIGlzIHNhbWUgYXMgXG4gICAgLy8gZGlzYWJsaW5nIHRoZSBjaHVuayBjYWNoZS4gT3RoZXJ3aXNlLCBjYWNoZSB3aWxsIGV4cGxvZGVcbiAgICAvLyBtZW1vcnkgd2hlbiBmZXRjaGluZyBsYXJnZSByZXN1bHQgc2V0IFxuICAgIHtcbiAgICAgIG5hbWU6IFBBUkFNX1JFU1VMVF9DSFVOS19DQUNIRV9TSVpFLFxuICAgICAgZGVmYXVsdFZhbHVlOiAxLFxuICAgICAgdmFsaWRhdGU6IGlzUG9zaXRpdmVJbnRlZ2VyXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBQQVJBTV9SRVNVTFRfUFJPQ0VTU0lOR19CQVRDSF9TSVpFLFxuICAgICAgZGVmYXVsdFZhbHVlOiAxMDAwLFxuICAgICAgdmFsaWRhdGU6IGlzUG9zaXRpdmVJbnRlZ2VyXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBQQVJBTV9SRVNVTFRfUFJPQ0VTU0lOR19CQVRDSF9EVVJBVElPTixcbiAgICAgIGRlZmF1bHRWYWx1ZTogMTAwLFxuICAgICAgdmFsaWRhdGU6IGlzUG9zaXRpdmVJbnRlZ2VyXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBQQVJBTV9ST1dfU1RSRUFNX0hJR0hfV0FURVJfTUFSSyxcbiAgICAgIGRlZmF1bHRWYWx1ZTogMTAsXG4gICAgICB2YWxpZGF0ZTogaXNQb3NpdGl2ZUludGVnZXJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFBBUkFNX1JFVFJZX0xBUkdFX1JFU1VMVF9TRVRfTUFYX05VTV9SRVRSSUVTLFxuICAgICAgZGVmYXVsdFZhbHVlOiAxMCxcbiAgICAgIHZhbGlkYXRlOiBpc05vbk5lZ2F0aXZlSW50ZWdlclxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogUEFSQU1fUkVUUllfTEFSR0VfUkVTVUxUX1NFVF9NQVhfU0xFRVBfVElNRSxcbiAgICAgIGRlZmF1bHRWYWx1ZTogMTYsXG4gICAgICB2YWxpZGF0ZTogaXNOb25OZWdhdGl2ZUludGVnZXJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFBBUkFNX1JFVFJZX1NGX01BWF9MT0dJTl9SRVRSSUVTLFxuICAgICAgZGVmYXVsdFZhbHVlOiA3LFxuICAgICAgZXh0ZXJuYWw6IHRydWUsXG4gICAgICB2YWxpZGF0ZTogaXNOb25OZWdhdGl2ZUludGVnZXJcbiAgICB9LFxuICAgIHtcbiAgICAgIG5hbWU6IFBBUkFNX1JFVFJZX1NGX01BWF9OVU1fUkVUUklFUyxcbiAgICAgIGRlZmF1bHRWYWx1ZTogMTAwMCxcbiAgICAgIHZhbGlkYXRlOiBpc05vbk5lZ2F0aXZlSW50ZWdlclxuICAgIH0sXG4gICAge1xuICAgICAgbmFtZTogUEFSQU1fUkVUUllfU0ZfU1RBUlRJTkdfU0xFRVBfVElNRSxcbiAgICAgIGRlZmF1bHRWYWx1ZTogMSxcbiAgICAgIHZhbGlkYXRlOiBpc05vbk5lZ2F0aXZlTnVtYmVyXG4gICAgfSxcbiAgICB7XG4gICAgICBuYW1lOiBQQVJBTV9SRVRSWV9TRl9NQVhfU0xFRVBfVElNRSxcbiAgICAgIGRlZmF1bHRWYWx1ZTogMTYsXG4gICAgICB2YWxpZGF0ZTogaXNOb25OZWdhdGl2ZU51bWJlclxuICAgIH1cbiAgXTtcbn1cblxuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuZ2V0VGltZW91dCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1RJTUVPVVQpO1xufTtcblxuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuZ2V0UmVzdWx0UHJlZmV0Y2ggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXJWYWx1ZShQQVJBTV9SRVNVTFRfUFJFRkVUQ0gpO1xufTtcblxuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuZ2V0UmVzdWx0U3RyZWFtSW50ZXJydXB0cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JFU1VMVF9TVFJFQU1fSU5URVJSVVBUUyk7XG59O1xuXG5Db25uZWN0aW9uQ29uZmlnLnByb3RvdHlwZS5nZXRSZXN1bHRDaHVua0NhY2hlU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JFU1VMVF9DSFVOS19DQUNIRV9TSVpFKTtcbn07XG5cbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmdldFJlc3VsdFByb2Nlc3NpbmdCYXRjaFNpemUgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXJWYWx1ZShQQVJBTV9SRVNVTFRfUFJPQ0VTU0lOR19CQVRDSF9TSVpFKTtcbn07XG5cbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmdldFJlc3VsdFByb2Nlc3NpbmdCYXRjaER1cmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZ2V0UGFyYW1ldGVyVmFsdWUoUEFSQU1fUkVTVUxUX1BST0NFU1NJTkdfQkFUQ0hfRFVSQVRJT04pO1xufTtcblxuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuZ2V0Um93U3RyZWFtSGlnaFdhdGVyTWFyayA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JPV19TVFJFQU1fSElHSF9XQVRFUl9NQVJLKTtcbn07XG5cbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmdldFJldHJ5TGFyZ2VSZXN1bHRTZXRNYXhOdW1SZXRyaWVzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZ2V0UGFyYW1ldGVyVmFsdWUoUEFSQU1fUkVUUllfTEFSR0VfUkVTVUxUX1NFVF9NQVhfTlVNX1JFVFJJRVMpO1xufTtcblxuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuZ2V0UmV0cnlMYXJnZVJlc3VsdFNldE1heFNsZWVwVGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JFVFJZX0xBUkdFX1JFU1VMVF9TRVRfTUFYX1NMRUVQX1RJTUUpO1xufTtcblxuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuZ2V0UmV0cnlTZk1heE51bVJldHJpZXMgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9nZXRQYXJhbWV0ZXJWYWx1ZShQQVJBTV9SRVRSWV9TRl9NQVhfTlVNX1JFVFJJRVMpO1xufTtcblxuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuZ2V0UmV0cnlTZk1heExvZ2luUmV0cmllcyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JFVFJZX1NGX01BWF9MT0dJTl9SRVRSSUVTKTtcbn07XG5cbkNvbm5lY3Rpb25Db25maWcucHJvdG90eXBlLmdldFJldHJ5U2ZTdGFydGluZ1NsZWVwVGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JFVFJZX1NGX1NUQVJUSU5HX1NMRUVQX1RJTUUpO1xufTtcblxuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuZ2V0UmV0cnlTZk1heFNsZWVwVGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2dldFBhcmFtZXRlclZhbHVlKFBBUkFNX1JFVFJZX1NGX01BWF9TTEVFUF9USU1FKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgYSBnaXZlbiBjb25uZWN0aW9uIGNvbmZpZyBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHBhcmFtZXRlck5hbWVcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQHByaXZhdGVcbiAqL1xuQ29ubmVjdGlvbkNvbmZpZy5wcm90b3R5cGUuX2dldFBhcmFtZXRlclZhbHVlID0gZnVuY3Rpb24gKHBhcmFtZXRlck5hbWUpIHtcbiAgY29uc3QgcGFyYW1ldGVyID0gdGhpcy5fbWFwUGFyYW1ldGVyc1twYXJhbWV0ZXJOYW1lXTtcbiAgcmV0dXJuIHBhcmFtZXRlciA/IHBhcmFtZXRlci52YWx1ZSA6IHVuZGVmaW5lZDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbkNvbmZpZztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/connection_config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/connection_context.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/connection_context.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst SfService = __webpack_require__(/*! ../services/sf */ \"(rsc)/./node_modules/snowflake-sdk/lib/services/sf.js\");\nconst LargeResultSetService = __webpack_require__(/*! ../services/large_result_set */ \"(rsc)/./node_modules/snowflake-sdk/lib/services/large_result_set.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\n\n/**\n * Creates a new ConnectionContext.\n *\n * @param {ConnectionConfig} connectionConfig\n * @param {Object} httpClient\n * @param {Object} config\n *\n * @constructor\n */\nfunction ConnectionContext(connectionConfig, httpClient, config) {\n  // validate input\n  Logger.getInstance().trace('Creating ConnectionContext object.');\n  Errors.assertInternal(Util.isObject(connectionConfig));\n  Errors.assertInternal(Util.isObject(httpClient));\n\n  // if a config object was specified, verify\n  // that it has all the information we need\n  let sfServiceConfig;\n  if (Util.exists(config)) {\n    Logger.getInstance().trace('ConnectionContext - validating received config.');\n\n    Errors.assertInternal(Util.isObject(config));\n    Errors.assertInternal(Util.isObject(config.services));\n    Errors.assertInternal(Util.isObject(config.services.sf));\n\n    sfServiceConfig = config.services.sf;\n  }\n  Logger.getInstance().debug('ConnectionContext - received data was validated.');\n\n  // create a map that contains all the services we'll be using\n  const services =\n    {\n      sf: new SfService(connectionConfig, httpClient, sfServiceConfig),\n      largeResultSet: new LargeResultSetService(connectionConfig, httpClient)\n    };\n  Logger.getInstance().debug('ConnectionContext - services were instantiated.');\n\n  /**\n   * Returns the ConnectionConfig for use by the connection.\n   *\n   * @returns {ConnectionConfig}\n   */\n  this.getConnectionConfig = function () {\n    return connectionConfig;\n  };\n\n  /**\n   * Returns a map that contains all the available services.\n   *\n   * @returns {Object}\n   */\n  this.getServices = function () {\n    return services;\n  };\n\n  /**\n   * Returns a configuration object that can be passed as an optional argument\n   * to the ConnectionContext constructor to create a new object that has the\n   * same state as this ConnectionContext instance.\n   *\n   * @returns {Object}\n   */\n  this.getConfig = function () {\n    return {\n      services:\n        {\n          sf: services.sf.getConfig()\n        }\n    };\n  };\n  /**\n   * Returns instance of httpClient\n   *\n   * @returns {NodeHttpClient}\n   */\n  this.getHttpClient = function () {\n    return httpClient;\n  };\n}\n\nmodule.exports = ConnectionContext;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9jb25uZWN0aW9uX2NvbnRleHQuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLCtEQUFTO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVztBQUNsQyxrQkFBa0IsbUJBQU8sQ0FBQyw2RUFBZ0I7QUFDMUMsOEJBQThCLG1CQUFPLENBQUMseUdBQThCO0FBQ3BFLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0IsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9jb25uZWN0aW9uX2NvbnRleHQuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgU2ZTZXJ2aWNlID0gcmVxdWlyZSgnLi4vc2VydmljZXMvc2YnKTtcbmNvbnN0IExhcmdlUmVzdWx0U2V0U2VydmljZSA9IHJlcXVpcmUoJy4uL3NlcnZpY2VzL2xhcmdlX3Jlc3VsdF9zZXQnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgQ29ubmVjdGlvbkNvbnRleHQuXG4gKlxuICogQHBhcmFtIHtDb25uZWN0aW9uQ29uZmlnfSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAcGFyYW0ge09iamVjdH0gaHR0cENsaWVudFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDb25uZWN0aW9uQ29udGV4dChjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50LCBjb25maWcpIHtcbiAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0NyZWF0aW5nIENvbm5lY3Rpb25Db250ZXh0IG9iamVjdC4nKTtcbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoY29ubmVjdGlvbkNvbmZpZykpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChodHRwQ2xpZW50KSk7XG5cbiAgLy8gaWYgYSBjb25maWcgb2JqZWN0IHdhcyBzcGVjaWZpZWQsIHZlcmlmeVxuICAvLyB0aGF0IGl0IGhhcyBhbGwgdGhlIGluZm9ybWF0aW9uIHdlIG5lZWRcbiAgbGV0IHNmU2VydmljZUNvbmZpZztcbiAgaWYgKFV0aWwuZXhpc3RzKGNvbmZpZykpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ29ubmVjdGlvbkNvbnRleHQgLSB2YWxpZGF0aW5nIHJlY2VpdmVkIGNvbmZpZy4nKTtcblxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGNvbmZpZykpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGNvbmZpZy5zZXJ2aWNlcykpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGNvbmZpZy5zZXJ2aWNlcy5zZikpO1xuXG4gICAgc2ZTZXJ2aWNlQ29uZmlnID0gY29uZmlnLnNlcnZpY2VzLnNmO1xuICB9XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uQ29udGV4dCAtIHJlY2VpdmVkIGRhdGEgd2FzIHZhbGlkYXRlZC4nKTtcblxuICAvLyBjcmVhdGUgYSBtYXAgdGhhdCBjb250YWlucyBhbGwgdGhlIHNlcnZpY2VzIHdlJ2xsIGJlIHVzaW5nXG4gIGNvbnN0IHNlcnZpY2VzID1cbiAgICB7XG4gICAgICBzZjogbmV3IFNmU2VydmljZShjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50LCBzZlNlcnZpY2VDb25maWcpLFxuICAgICAgbGFyZ2VSZXN1bHRTZXQ6IG5ldyBMYXJnZVJlc3VsdFNldFNlcnZpY2UoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudClcbiAgICB9O1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbkNvbnRleHQgLSBzZXJ2aWNlcyB3ZXJlIGluc3RhbnRpYXRlZC4nKTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgQ29ubmVjdGlvbkNvbmZpZyBmb3IgdXNlIGJ5IHRoZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcmV0dXJucyB7Q29ubmVjdGlvbkNvbmZpZ31cbiAgICovXG4gIHRoaXMuZ2V0Q29ubmVjdGlvbkNvbmZpZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29ubmVjdGlvbkNvbmZpZztcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIG1hcCB0aGF0IGNvbnRhaW5zIGFsbCB0aGUgYXZhaWxhYmxlIHNlcnZpY2VzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgdGhpcy5nZXRTZXJ2aWNlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2VydmljZXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjb25maWd1cmF0aW9uIG9iamVjdCB0aGF0IGNhbiBiZSBwYXNzZWQgYXMgYW4gb3B0aW9uYWwgYXJndW1lbnRcbiAgICogdG8gdGhlIENvbm5lY3Rpb25Db250ZXh0IGNvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIG5ldyBvYmplY3QgdGhhdCBoYXMgdGhlXG4gICAqIHNhbWUgc3RhdGUgYXMgdGhpcyBDb25uZWN0aW9uQ29udGV4dCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHRoaXMuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzZXJ2aWNlczpcbiAgICAgICAge1xuICAgICAgICAgIHNmOiBzZXJ2aWNlcy5zZi5nZXRDb25maWcoKVxuICAgICAgICB9XG4gICAgfTtcbiAgfTtcbiAgLyoqXG4gICAqIFJldHVybnMgaW5zdGFuY2Ugb2YgaHR0cENsaWVudFxuICAgKlxuICAgKiBAcmV0dXJucyB7Tm9kZUh0dHBDbGllbnR9XG4gICAqL1xuICB0aGlzLmdldEh0dHBDbGllbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGh0dHBDbGllbnQ7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29ubmVjdGlvbkNvbnRleHQ7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/connection_context.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/result/chunk.js":
/*!*******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/result/chunk.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\n\n/**\n * Creates a new Chunk.\n *\n * @param options\n * @constructor\n */\nfunction Chunk(options) {\n  // make sure the options object contains all the necessary information\n  Errors.assertInternal(Util.isObject(options));\n  Errors.assertInternal(Util.isObject(options.statement));\n  Errors.assertInternal(Util.isObject(options.services));\n  Errors.assertInternal(Util.isNumber(options.startIndex));\n  Errors.assertInternal(Util.isArray(options.columns));\n  Errors.assertInternal(Util.isObject(options.mapColumnNameToIndices));\n  Errors.assertInternal(Util.isObject(options.statementParameters));\n  Errors.assertInternal(Util.isString(options.resultVersion));\n  Errors.assertInternal(Util.isNumber(options.rowCount));\n\n  // if the result is small (i.e. not persisted on S3/Blob), there's no\n  // compressed and uncompressed size, so default to -1\n  this._compressedSize = options.compressedSize || -1;\n  this._uncompressedSize = options.uncompressedSize || -1;\n\n  // copy out other information from the options object and save it\n  this._statement = options.statement;\n  this._services = options.services;\n  this._startIndex = options.startIndex;\n  this._url = options.url;\n  this._columns = options.columns;\n  this._mapColumnNameToIndices = options.mapColumnNameToIndices;\n  this._chunkHeaders = options.chunkHeaders;\n  this._rowset = options.rowset;\n\n  // use the start index and row count to compute the end index\n  this._endIndex = this._startIndex + options.rowCount - 1;\n\n  // use the start and end index to build an id for this chunk\n  this._id = buildId(this._startIndex, this._endIndex);\n}\n\nUtil.inherits(Chunk, EventEmitter);\n\n/**\n * Returns the compressed size of this chunk's contents on S3/Blob.\n * A value of -1 means the contents of this chunk are not stored on S3/Blob.\n *\n * @returns {Number}\n */\nChunk.prototype.getCompressedSize = function () {\n  return this._compressedSize;\n};\n\n/**\n * Returns the uncompressed size of this chunk's contents on S3/Blob.\n * A value of -1 means the contents of this chunk are not stored on S3/Blob.\n *\n * @returns {Number}\n */\nChunk.prototype.getUncompressedSize = function () {\n  return this._uncompressedSize;\n};\n\n/**\n * Returns the row index of the first row in this chunk.\n *\n * @returns {Number}\n */\nChunk.prototype.getStartIndex = function () {\n  return this._startIndex;\n};\n\n/**\n * Returns the row index of the last row in this chunk.\n *\n * @returns {Number}\n */\nChunk.prototype.getEndIndex = function () {\n  return this._endIndex;\n};\n\n/**\n * Returns the id of this chunk.\n *\n * @returns {String}\n */\nChunk.prototype.getId = function () {\n  return this._id;\n};\n\n/**\n * Determines if this chunk overlaps with a given window.\n *\n * @param {Number} start The start index of the window.\n * @param {Number} end The end index of the window.\n *\n * @returns {Boolean}\n */\nChunk.prototype.overlapsWithWindow = function (start, end) {\n  const chunkStart = this._startIndex, chunkEnd = this._endIndex;\n\n  // check if the window overlaps with the chunk from the left or\n  // from the right or from both sides\n  return ((end <= chunkEnd && end >= chunkStart) ||\n    (start >= chunkStart && start <= chunkEnd) ||\n    (start <= chunkStart && end >= chunkEnd));\n};\n\n/**\n * Returns the rows in this chunk.\n *\n * @returns {Object[]}\n */\nChunk.prototype.getRows = function () {\n  // if we don't already have a valid value for the rows\n  if (!Util.isArray(this._rows)) {\n    // if we have a string version of the rowset\n    if (Util.string.isNotNullOrEmpty(this._rowsetAsString)) {\n      // add square brackets on either side and do a json-parse to get the\n      // rowset\n      this._rowset = JSON.parse('[' + this._rowsetAsString + ']');\n\n      // we don't need the string version of the rowset anymore\n      this._rowsetAsString = undefined;\n    }\n\n    // if we have a valid value for the rowset\n    if (Util.isArray(this._rowset)) {\n      // convert the rowset to an array of rows\n      this._rows = convertRowsetToRows(\n        this._statement,\n        this._startIndex,\n        this._rowset,\n        this._columns,\n        this._mapColumnNameToIndices);\n\n      // clear out the rowset because we don't need it anymore\n      this._rowset = undefined;\n    }\n  }\n\n  return this._rows;\n};\n\n/**\n * Clears out the rows in this chunk if it has a valid url or if the force flag\n * is true.\n *\n * @param force\n */\nChunk.prototype.clearRows = function (force) {\n  if (Util.string.isNotNullOrEmpty(this._url) || force) {\n    // clear out all row and rowset related fields\n    this._rowsetAsString = this._rowset = this._rows = undefined;\n  }\n};\n\n/**\n * Updates this chunk's url.\n *\n * @param url\n */\nChunk.prototype.setUrl = function (url) {\n  this._url = url;\n};\n\n/**\n * Returns true if this chunk's contents are loaded, false otherwise.\n *\n * @returns {Boolean}\n */\nChunk.prototype.isLoaded = function () {\n  // the chunk is considered loaded if we have valid values for\n  // _rowsetAsString, _rowset or _rows\n  return Util.string.isNotNullOrEmpty(this._rowsetAsString) ||\n    Util.isArray(this._rowset) || Util.isArray(this._rows);\n};\n\n/**\n * Returns true if this chunk is currently in the process of loading its\n * contents, false otherwise.\n *\n * @returns {Boolean}\n */\nChunk.prototype.isLoading = function () {\n  return this._isLoading;\n};\n\n/**\n * Loads the contents of this chunk.\n *\n * @param callback\n */\nChunk.prototype.load = function (callback) {\n  // we've started loading\n  this._isLoading = true;\n\n  const self = this;\n\n  /**\n   * Completes the chunk load.\n   *\n   * @param err\n   */\n  const completeLoad = function (err) {\n    // we're done loading\n    self._isLoading = false;\n\n    // emit an event to notify subscribers\n    self.emit('loadcomplete', err, self);\n\n    // invoke the callback if one was specified\n    if (Util.isFunction(callback)) {\n      callback(err, self);\n    }\n  };\n\n  // If the chunk is already loaded, complete the load asynchronously.\n  // This ensure that we are streaming chunks the right order even if the data was received before\n  // another chunk.\n  if (this.isLoaded()) {\n    process.nextTick(completeLoad);\n  } else {\n    // issue a request to load the chunk's contents from S3/Blob\n    this._services.largeResultSet.getObject(\n      {\n        url: this._url,\n        headers: this._chunkHeaders,\n        callback: function (err, body) {\n          // if the request succeeded, save the\n          // body as a string version of the rowset\n          if (!err) {\n            self._rowsetAsString = body;\n          }\n\n          // complete the load\n          completeLoad(err);\n        }\n      });\n  }\n};\n\n/**\n * Builds an id for a chunk from its start and end index.\n *\n * @param startIndex The row index of the first chunk row.\n * @param endIndex The row index of the last chunk row.\n *\n * @returns {String}\n * @private\n */\nfunction buildId(startIndex, endIndex) {\n  return Util.format('s=%d, e=%d', startIndex, endIndex);\n}\n\n/**\n * Converts a rowset to an array of records.\n *\n * @param statement\n * @param startIndex the chunk start index.\n * @param rowset\n * @param columns\n * @param mapColumnNameToIndices\n *\n * @returns {Array}\n * @private\n */\nfunction convertRowsetToRows(\n  statement,\n  startIndex,\n  rowset,\n  columns,\n  mapColumnNameToIndices) {\n  // assert that rowset and columns are arrays\n  Errors.assertInternal(Util.isArray(rowset));\n  Errors.assertInternal(Util.isArray(columns));\n\n\n  ///////////////////////////////////////////////////////////////////////////\n  ////     Create functions that will be used as row methods             ////\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Returns the index of this row in the result.\n   *\n   * @returns {Number}\n   */\n  const getRowIndex = function () {\n    return this.rowIndex;\n  };\n\n  /**\n   * Returns the statement that produced this row.\n   *\n   * @returns {*}\n   */\n  const getStatement = function getStatement() {\n    return statement;\n  };\n\n  /**\n   * Returns the value of a column.\n   *\n   * @param {String | Number} columnIdentifier this can be either the column\n   *   name or the column index.\n   *\n   * @returns {*}\n   */\n  const getColumnValue = function getColumnValue(columnIdentifier) {\n    // resolve the column identifier to the correct column if possible\n    const column = resolveColumnIdentifierToColumn(\n      columns, columnIdentifier, mapColumnNameToIndices);\n\n    return column ? column.getRowValue(this) : undefined;\n  };\n\n  /**\n   * Returns the value of a column as a String.\n   *\n   * @param {String | Number} columnIdentifier this can be either the column\n   *   name or the column index.\n   *\n   * @returns {*}\n   */\n  const getColumnValueAsString = function getColumnValueAsString(columnIdentifier) {\n    // resolve the column identifier to the correct column if possible\n    const column = resolveColumnIdentifierToColumn(\n      columns, columnIdentifier, mapColumnNameToIndices);\n\n    return column ? column.getRowValueAsString(this) : undefined;\n  };\n\n\n  ///////////////////////////////////////////////////////////////////////////\n  ////     Convert the rowset to an array of row objects                 ////\n  ///////////////////////////////////////////////////////////////////////////\n\n  // create a new array to store the processed rows\n  const length = rowset.length;\n  const rows = new Array(length);\n  for (let index = 0; index < length; index++) {\n    // add a new item to the rows array\n    rows[index] =\n      {\n        _arrayProcessedColumns: [],\n\n        values: rowset[index],\n        rowIndex: startIndex + index,\n        getRowIndex: getRowIndex,\n        getStatement: getStatement,\n        getColumnValue: getColumnValue,\n        getColumnValueAsString: getColumnValueAsString\n      };\n  }\n\n  return rows;\n}\n\n/**\n * Resolves a column identifier to the corresponding column if possible. The\n * column identifier can be a column name or a column index. If an invalid\n * column identifier is specified, we return undefined.\n *\n * @param {Object[]} columns\n * @param {String | Number} columnIdentifier\n * @param {Object} mapColumnNameToIndices\n *\n * @returns {*}\n */\nfunction resolveColumnIdentifierToColumn(\n  columns, columnIdentifier, mapColumnNameToIndices) {\n  let columnIndex;\n\n  // if the column identifier is a string, treat it as a column\n  // name and use it to get the index of the specified column\n  if (Util.isString(columnIdentifier)) {\n    // if a valid column name was specified, get the index of the first column\n    // with the specified name\n    if (Object.prototype.hasOwnProperty.call(mapColumnNameToIndices, columnIdentifier)) {\n      columnIndex = mapColumnNameToIndices[columnIdentifier][0];\n    }\n  } else if (Util.isNumber(columnIdentifier)) {\n    // if the column identifier is a number, treat it as a column index\n    columnIndex = columnIdentifier;\n  }\n\n  return columns[columnIndex];\n}\n\nmodule.exports = Chunk;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvY2h1bmsuanMiLCJtYXBwaW5ncyI6IkFBQUEscUJBQXFCLDBEQUE4QjtBQUNuRCxhQUFhLG1CQUFPLENBQUMsa0VBQVk7QUFDakMsZUFBZSxtQkFBTyxDQUFDLHNFQUFjOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGlCQUFpQjtBQUM5QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixnQkFBZ0I7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFVBQVU7QUFDckIsV0FBVyxpQkFBaUI7QUFDNUIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvY2h1bmsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgQ2h1bmsuXG4gKlxuICogQHBhcmFtIG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBDaHVuayhvcHRpb25zKSB7XG4gIC8vIG1ha2Ugc3VyZSB0aGUgb3B0aW9ucyBvYmplY3QgY29udGFpbnMgYWxsIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb25cbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucykpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zLnN0YXRlbWVudCkpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zLnNlcnZpY2VzKSk7XG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzTnVtYmVyKG9wdGlvbnMuc3RhcnRJbmRleCkpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0FycmF5KG9wdGlvbnMuY29sdW1ucykpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zLm1hcENvbHVtbk5hbWVUb0luZGljZXMpKTtcbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucy5zdGF0ZW1lbnRQYXJhbWV0ZXJzKSk7XG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzU3RyaW5nKG9wdGlvbnMucmVzdWx0VmVyc2lvbikpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc051bWJlcihvcHRpb25zLnJvd0NvdW50KSk7XG5cbiAgLy8gaWYgdGhlIHJlc3VsdCBpcyBzbWFsbCAoaS5lLiBub3QgcGVyc2lzdGVkIG9uIFMzL0Jsb2IpLCB0aGVyZSdzIG5vXG4gIC8vIGNvbXByZXNzZWQgYW5kIHVuY29tcHJlc3NlZCBzaXplLCBzbyBkZWZhdWx0IHRvIC0xXG4gIHRoaXMuX2NvbXByZXNzZWRTaXplID0gb3B0aW9ucy5jb21wcmVzc2VkU2l6ZSB8fCAtMTtcbiAgdGhpcy5fdW5jb21wcmVzc2VkU2l6ZSA9IG9wdGlvbnMudW5jb21wcmVzc2VkU2l6ZSB8fCAtMTtcblxuICAvLyBjb3B5IG91dCBvdGhlciBpbmZvcm1hdGlvbiBmcm9tIHRoZSBvcHRpb25zIG9iamVjdCBhbmQgc2F2ZSBpdFxuICB0aGlzLl9zdGF0ZW1lbnQgPSBvcHRpb25zLnN0YXRlbWVudDtcbiAgdGhpcy5fc2VydmljZXMgPSBvcHRpb25zLnNlcnZpY2VzO1xuICB0aGlzLl9zdGFydEluZGV4ID0gb3B0aW9ucy5zdGFydEluZGV4O1xuICB0aGlzLl91cmwgPSBvcHRpb25zLnVybDtcbiAgdGhpcy5fY29sdW1ucyA9IG9wdGlvbnMuY29sdW1ucztcbiAgdGhpcy5fbWFwQ29sdW1uTmFtZVRvSW5kaWNlcyA9IG9wdGlvbnMubWFwQ29sdW1uTmFtZVRvSW5kaWNlcztcbiAgdGhpcy5fY2h1bmtIZWFkZXJzID0gb3B0aW9ucy5jaHVua0hlYWRlcnM7XG4gIHRoaXMuX3Jvd3NldCA9IG9wdGlvbnMucm93c2V0O1xuXG4gIC8vIHVzZSB0aGUgc3RhcnQgaW5kZXggYW5kIHJvdyBjb3VudCB0byBjb21wdXRlIHRoZSBlbmQgaW5kZXhcbiAgdGhpcy5fZW5kSW5kZXggPSB0aGlzLl9zdGFydEluZGV4ICsgb3B0aW9ucy5yb3dDb3VudCAtIDE7XG5cbiAgLy8gdXNlIHRoZSBzdGFydCBhbmQgZW5kIGluZGV4IHRvIGJ1aWxkIGFuIGlkIGZvciB0aGlzIGNodW5rXG4gIHRoaXMuX2lkID0gYnVpbGRJZCh0aGlzLl9zdGFydEluZGV4LCB0aGlzLl9lbmRJbmRleCk7XG59XG5cblV0aWwuaW5oZXJpdHMoQ2h1bmssIEV2ZW50RW1pdHRlcik7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29tcHJlc3NlZCBzaXplIG9mIHRoaXMgY2h1bmsncyBjb250ZW50cyBvbiBTMy9CbG9iLlxuICogQSB2YWx1ZSBvZiAtMSBtZWFucyB0aGUgY29udGVudHMgb2YgdGhpcyBjaHVuayBhcmUgbm90IHN0b3JlZCBvbiBTMy9CbG9iLlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbkNodW5rLnByb3RvdHlwZS5nZXRDb21wcmVzc2VkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2NvbXByZXNzZWRTaXplO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1bmNvbXByZXNzZWQgc2l6ZSBvZiB0aGlzIGNodW5rJ3MgY29udGVudHMgb24gUzMvQmxvYi5cbiAqIEEgdmFsdWUgb2YgLTEgbWVhbnMgdGhlIGNvbnRlbnRzIG9mIHRoaXMgY2h1bmsgYXJlIG5vdCBzdG9yZWQgb24gUzMvQmxvYi5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5DaHVuay5wcm90b3R5cGUuZ2V0VW5jb21wcmVzc2VkU2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3VuY29tcHJlc3NlZFNpemU7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHJvdyBpbmRleCBvZiB0aGUgZmlyc3Qgcm93IGluIHRoaXMgY2h1bmsuXG4gKlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuQ2h1bmsucHJvdG90eXBlLmdldFN0YXJ0SW5kZXggPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9zdGFydEluZGV4O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSByb3cgaW5kZXggb2YgdGhlIGxhc3Qgcm93IGluIHRoaXMgY2h1bmsuXG4gKlxuICogQHJldHVybnMge051bWJlcn1cbiAqL1xuQ2h1bmsucHJvdG90eXBlLmdldEVuZEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fZW5kSW5kZXg7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGlkIG9mIHRoaXMgY2h1bmsuXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuQ2h1bmsucHJvdG90eXBlLmdldElkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faWQ7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgdGhpcyBjaHVuayBvdmVybGFwcyB3aXRoIGEgZ2l2ZW4gd2luZG93LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCBUaGUgc3RhcnQgaW5kZXggb2YgdGhlIHdpbmRvdy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgVGhlIGVuZCBpbmRleCBvZiB0aGUgd2luZG93LlxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5DaHVuay5wcm90b3R5cGUub3ZlcmxhcHNXaXRoV2luZG93ID0gZnVuY3Rpb24gKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgY2h1bmtTdGFydCA9IHRoaXMuX3N0YXJ0SW5kZXgsIGNodW5rRW5kID0gdGhpcy5fZW5kSW5kZXg7XG5cbiAgLy8gY2hlY2sgaWYgdGhlIHdpbmRvdyBvdmVybGFwcyB3aXRoIHRoZSBjaHVuayBmcm9tIHRoZSBsZWZ0IG9yXG4gIC8vIGZyb20gdGhlIHJpZ2h0IG9yIGZyb20gYm90aCBzaWRlc1xuICByZXR1cm4gKChlbmQgPD0gY2h1bmtFbmQgJiYgZW5kID49IGNodW5rU3RhcnQpIHx8XG4gICAgKHN0YXJ0ID49IGNodW5rU3RhcnQgJiYgc3RhcnQgPD0gY2h1bmtFbmQpIHx8XG4gICAgKHN0YXJ0IDw9IGNodW5rU3RhcnQgJiYgZW5kID49IGNodW5rRW5kKSk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHJvd3MgaW4gdGhpcyBjaHVuay5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0W119XG4gKi9cbkNodW5rLnByb3RvdHlwZS5nZXRSb3dzID0gZnVuY3Rpb24gKCkge1xuICAvLyBpZiB3ZSBkb24ndCBhbHJlYWR5IGhhdmUgYSB2YWxpZCB2YWx1ZSBmb3IgdGhlIHJvd3NcbiAgaWYgKCFVdGlsLmlzQXJyYXkodGhpcy5fcm93cykpIHtcbiAgICAvLyBpZiB3ZSBoYXZlIGEgc3RyaW5nIHZlcnNpb24gb2YgdGhlIHJvd3NldFxuICAgIGlmIChVdGlsLnN0cmluZy5pc05vdE51bGxPckVtcHR5KHRoaXMuX3Jvd3NldEFzU3RyaW5nKSkge1xuICAgICAgLy8gYWRkIHNxdWFyZSBicmFja2V0cyBvbiBlaXRoZXIgc2lkZSBhbmQgZG8gYSBqc29uLXBhcnNlIHRvIGdldCB0aGVcbiAgICAgIC8vIHJvd3NldFxuICAgICAgdGhpcy5fcm93c2V0ID0gSlNPTi5wYXJzZSgnWycgKyB0aGlzLl9yb3dzZXRBc1N0cmluZyArICddJyk7XG5cbiAgICAgIC8vIHdlIGRvbid0IG5lZWQgdGhlIHN0cmluZyB2ZXJzaW9uIG9mIHRoZSByb3dzZXQgYW55bW9yZVxuICAgICAgdGhpcy5fcm93c2V0QXNTdHJpbmcgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBhIHZhbGlkIHZhbHVlIGZvciB0aGUgcm93c2V0XG4gICAgaWYgKFV0aWwuaXNBcnJheSh0aGlzLl9yb3dzZXQpKSB7XG4gICAgICAvLyBjb252ZXJ0IHRoZSByb3dzZXQgdG8gYW4gYXJyYXkgb2Ygcm93c1xuICAgICAgdGhpcy5fcm93cyA9IGNvbnZlcnRSb3dzZXRUb1Jvd3MoXG4gICAgICAgIHRoaXMuX3N0YXRlbWVudCxcbiAgICAgICAgdGhpcy5fc3RhcnRJbmRleCxcbiAgICAgICAgdGhpcy5fcm93c2V0LFxuICAgICAgICB0aGlzLl9jb2x1bW5zLFxuICAgICAgICB0aGlzLl9tYXBDb2x1bW5OYW1lVG9JbmRpY2VzKTtcblxuICAgICAgLy8gY2xlYXIgb3V0IHRoZSByb3dzZXQgYmVjYXVzZSB3ZSBkb24ndCBuZWVkIGl0IGFueW1vcmVcbiAgICAgIHRoaXMuX3Jvd3NldCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcy5fcm93cztcbn07XG5cbi8qKlxuICogQ2xlYXJzIG91dCB0aGUgcm93cyBpbiB0aGlzIGNodW5rIGlmIGl0IGhhcyBhIHZhbGlkIHVybCBvciBpZiB0aGUgZm9yY2UgZmxhZ1xuICogaXMgdHJ1ZS5cbiAqXG4gKiBAcGFyYW0gZm9yY2VcbiAqL1xuQ2h1bmsucHJvdG90eXBlLmNsZWFyUm93cyA9IGZ1bmN0aW9uIChmb3JjZSkge1xuICBpZiAoVXRpbC5zdHJpbmcuaXNOb3ROdWxsT3JFbXB0eSh0aGlzLl91cmwpIHx8IGZvcmNlKSB7XG4gICAgLy8gY2xlYXIgb3V0IGFsbCByb3cgYW5kIHJvd3NldCByZWxhdGVkIGZpZWxkc1xuICAgIHRoaXMuX3Jvd3NldEFzU3RyaW5nID0gdGhpcy5fcm93c2V0ID0gdGhpcy5fcm93cyA9IHVuZGVmaW5lZDtcbiAgfVxufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoaXMgY2h1bmsncyB1cmwuXG4gKlxuICogQHBhcmFtIHVybFxuICovXG5DaHVuay5wcm90b3R5cGUuc2V0VXJsID0gZnVuY3Rpb24gKHVybCkge1xuICB0aGlzLl91cmwgPSB1cmw7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiB0aGlzIGNodW5rJ3MgY29udGVudHMgYXJlIGxvYWRlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5DaHVuay5wcm90b3R5cGUuaXNMb2FkZWQgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHRoZSBjaHVuayBpcyBjb25zaWRlcmVkIGxvYWRlZCBpZiB3ZSBoYXZlIHZhbGlkIHZhbHVlcyBmb3JcbiAgLy8gX3Jvd3NldEFzU3RyaW5nLCBfcm93c2V0IG9yIF9yb3dzXG4gIHJldHVybiBVdGlsLnN0cmluZy5pc05vdE51bGxPckVtcHR5KHRoaXMuX3Jvd3NldEFzU3RyaW5nKSB8fFxuICAgIFV0aWwuaXNBcnJheSh0aGlzLl9yb3dzZXQpIHx8IFV0aWwuaXNBcnJheSh0aGlzLl9yb3dzKTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoaXMgY2h1bmsgaXMgY3VycmVudGx5IGluIHRoZSBwcm9jZXNzIG9mIGxvYWRpbmcgaXRzXG4gKiBjb250ZW50cywgZmFsc2Ugb3RoZXJ3aXNlLlxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5DaHVuay5wcm90b3R5cGUuaXNMb2FkaW5nID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faXNMb2FkaW5nO1xufTtcblxuLyoqXG4gKiBMb2FkcyB0aGUgY29udGVudHMgb2YgdGhpcyBjaHVuay5cbiAqXG4gKiBAcGFyYW0gY2FsbGJhY2tcbiAqL1xuQ2h1bmsucHJvdG90eXBlLmxvYWQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgLy8gd2UndmUgc3RhcnRlZCBsb2FkaW5nXG4gIHRoaXMuX2lzTG9hZGluZyA9IHRydWU7XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgLyoqXG4gICAqIENvbXBsZXRlcyB0aGUgY2h1bmsgbG9hZC5cbiAgICpcbiAgICogQHBhcmFtIGVyclxuICAgKi9cbiAgY29uc3QgY29tcGxldGVMb2FkID0gZnVuY3Rpb24gKGVycikge1xuICAgIC8vIHdlJ3JlIGRvbmUgbG9hZGluZ1xuICAgIHNlbGYuX2lzTG9hZGluZyA9IGZhbHNlO1xuXG4gICAgLy8gZW1pdCBhbiBldmVudCB0byBub3RpZnkgc3Vic2NyaWJlcnNcbiAgICBzZWxmLmVtaXQoJ2xvYWRjb21wbGV0ZScsIGVyciwgc2VsZik7XG5cbiAgICAvLyBpbnZva2UgdGhlIGNhbGxiYWNrIGlmIG9uZSB3YXMgc3BlY2lmaWVkXG4gICAgaWYgKFV0aWwuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgIGNhbGxiYWNrKGVyciwgc2VsZik7XG4gICAgfVxuICB9O1xuXG4gIC8vIElmIHRoZSBjaHVuayBpcyBhbHJlYWR5IGxvYWRlZCwgY29tcGxldGUgdGhlIGxvYWQgYXN5bmNocm9ub3VzbHkuXG4gIC8vIFRoaXMgZW5zdXJlIHRoYXQgd2UgYXJlIHN0cmVhbWluZyBjaHVua3MgdGhlIHJpZ2h0IG9yZGVyIGV2ZW4gaWYgdGhlIGRhdGEgd2FzIHJlY2VpdmVkIGJlZm9yZVxuICAvLyBhbm90aGVyIGNodW5rLlxuICBpZiAodGhpcy5pc0xvYWRlZCgpKSB7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjb21wbGV0ZUxvYWQpO1xuICB9IGVsc2Uge1xuICAgIC8vIGlzc3VlIGEgcmVxdWVzdCB0byBsb2FkIHRoZSBjaHVuaydzIGNvbnRlbnRzIGZyb20gUzMvQmxvYlxuICAgIHRoaXMuX3NlcnZpY2VzLmxhcmdlUmVzdWx0U2V0LmdldE9iamVjdChcbiAgICAgIHtcbiAgICAgICAgdXJsOiB0aGlzLl91cmwsXG4gICAgICAgIGhlYWRlcnM6IHRoaXMuX2NodW5rSGVhZGVycyxcbiAgICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChlcnIsIGJvZHkpIHtcbiAgICAgICAgICAvLyBpZiB0aGUgcmVxdWVzdCBzdWNjZWVkZWQsIHNhdmUgdGhlXG4gICAgICAgICAgLy8gYm9keSBhcyBhIHN0cmluZyB2ZXJzaW9uIG9mIHRoZSByb3dzZXRcbiAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgc2VsZi5fcm93c2V0QXNTdHJpbmcgPSBib2R5O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGNvbXBsZXRlIHRoZSBsb2FkXG4gICAgICAgICAgY29tcGxldGVMb2FkKGVycik7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEJ1aWxkcyBhbiBpZCBmb3IgYSBjaHVuayBmcm9tIGl0cyBzdGFydCBhbmQgZW5kIGluZGV4LlxuICpcbiAqIEBwYXJhbSBzdGFydEluZGV4IFRoZSByb3cgaW5kZXggb2YgdGhlIGZpcnN0IGNodW5rIHJvdy5cbiAqIEBwYXJhbSBlbmRJbmRleCBUaGUgcm93IGluZGV4IG9mIHRoZSBsYXN0IGNodW5rIHJvdy5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYnVpbGRJZChzdGFydEluZGV4LCBlbmRJbmRleCkge1xuICByZXR1cm4gVXRpbC5mb3JtYXQoJ3M9JWQsIGU9JWQnLCBzdGFydEluZGV4LCBlbmRJbmRleCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSByb3dzZXQgdG8gYW4gYXJyYXkgb2YgcmVjb3Jkcy5cbiAqXG4gKiBAcGFyYW0gc3RhdGVtZW50XG4gKiBAcGFyYW0gc3RhcnRJbmRleCB0aGUgY2h1bmsgc3RhcnQgaW5kZXguXG4gKiBAcGFyYW0gcm93c2V0XG4gKiBAcGFyYW0gY29sdW1uc1xuICogQHBhcmFtIG1hcENvbHVtbk5hbWVUb0luZGljZXNcbiAqXG4gKiBAcmV0dXJucyB7QXJyYXl9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjb252ZXJ0Um93c2V0VG9Sb3dzKFxuICBzdGF0ZW1lbnQsXG4gIHN0YXJ0SW5kZXgsXG4gIHJvd3NldCxcbiAgY29sdW1ucyxcbiAgbWFwQ29sdW1uTmFtZVRvSW5kaWNlcykge1xuICAvLyBhc3NlcnQgdGhhdCByb3dzZXQgYW5kIGNvbHVtbnMgYXJlIGFycmF5c1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0FycmF5KHJvd3NldCkpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0FycmF5KGNvbHVtbnMpKTtcblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vICAgICBDcmVhdGUgZnVuY3Rpb25zIHRoYXQgd2lsbCBiZSB1c2VkIGFzIHJvdyBtZXRob2RzICAgICAgICAgICAgIC8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoaXMgcm93IGluIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICBjb25zdCBnZXRSb3dJbmRleCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5yb3dJbmRleDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgc3RhdGVtZW50IHRoYXQgcHJvZHVjZWQgdGhpcyByb3cuXG4gICAqXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgY29uc3QgZ2V0U3RhdGVtZW50ID0gZnVuY3Rpb24gZ2V0U3RhdGVtZW50KCkge1xuICAgIHJldHVybiBzdGF0ZW1lbnQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIGEgY29sdW1uLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gY29sdW1uSWRlbnRpZmllciB0aGlzIGNhbiBiZSBlaXRoZXIgdGhlIGNvbHVtblxuICAgKiAgIG5hbWUgb3IgdGhlIGNvbHVtbiBpbmRleC5cbiAgICpcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBjb25zdCBnZXRDb2x1bW5WYWx1ZSA9IGZ1bmN0aW9uIGdldENvbHVtblZhbHVlKGNvbHVtbklkZW50aWZpZXIpIHtcbiAgICAvLyByZXNvbHZlIHRoZSBjb2x1bW4gaWRlbnRpZmllciB0byB0aGUgY29ycmVjdCBjb2x1bW4gaWYgcG9zc2libGVcbiAgICBjb25zdCBjb2x1bW4gPSByZXNvbHZlQ29sdW1uSWRlbnRpZmllclRvQ29sdW1uKFxuICAgICAgY29sdW1ucywgY29sdW1uSWRlbnRpZmllciwgbWFwQ29sdW1uTmFtZVRvSW5kaWNlcyk7XG5cbiAgICByZXR1cm4gY29sdW1uID8gY29sdW1uLmdldFJvd1ZhbHVlKHRoaXMpIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGNvbHVtbiBhcyBhIFN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGNvbHVtbklkZW50aWZpZXIgdGhpcyBjYW4gYmUgZWl0aGVyIHRoZSBjb2x1bW5cbiAgICogICBuYW1lIG9yIHRoZSBjb2x1bW4gaW5kZXguXG4gICAqXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgY29uc3QgZ2V0Q29sdW1uVmFsdWVBc1N0cmluZyA9IGZ1bmN0aW9uIGdldENvbHVtblZhbHVlQXNTdHJpbmcoY29sdW1uSWRlbnRpZmllcikge1xuICAgIC8vIHJlc29sdmUgdGhlIGNvbHVtbiBpZGVudGlmaWVyIHRvIHRoZSBjb3JyZWN0IGNvbHVtbiBpZiBwb3NzaWJsZVxuICAgIGNvbnN0IGNvbHVtbiA9IHJlc29sdmVDb2x1bW5JZGVudGlmaWVyVG9Db2x1bW4oXG4gICAgICBjb2x1bW5zLCBjb2x1bW5JZGVudGlmaWVyLCBtYXBDb2x1bW5OYW1lVG9JbmRpY2VzKTtcblxuICAgIHJldHVybiBjb2x1bW4gPyBjb2x1bW4uZ2V0Um93VmFsdWVBc1N0cmluZyh0aGlzKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vICAgICBDb252ZXJ0IHRoZSByb3dzZXQgdG8gYW4gYXJyYXkgb2Ygcm93IG9iamVjdHMgICAgICAgICAgICAgICAgIC8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLy8gY3JlYXRlIGEgbmV3IGFycmF5IHRvIHN0b3JlIHRoZSBwcm9jZXNzZWQgcm93c1xuICBjb25zdCBsZW5ndGggPSByb3dzZXQubGVuZ3RoO1xuICBjb25zdCByb3dzID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAvLyBhZGQgYSBuZXcgaXRlbSB0byB0aGUgcm93cyBhcnJheVxuICAgIHJvd3NbaW5kZXhdID1cbiAgICAgIHtcbiAgICAgICAgX2FycmF5UHJvY2Vzc2VkQ29sdW1uczogW10sXG5cbiAgICAgICAgdmFsdWVzOiByb3dzZXRbaW5kZXhdLFxuICAgICAgICByb3dJbmRleDogc3RhcnRJbmRleCArIGluZGV4LFxuICAgICAgICBnZXRSb3dJbmRleDogZ2V0Um93SW5kZXgsXG4gICAgICAgIGdldFN0YXRlbWVudDogZ2V0U3RhdGVtZW50LFxuICAgICAgICBnZXRDb2x1bW5WYWx1ZTogZ2V0Q29sdW1uVmFsdWUsXG4gICAgICAgIGdldENvbHVtblZhbHVlQXNTdHJpbmc6IGdldENvbHVtblZhbHVlQXNTdHJpbmdcbiAgICAgIH07XG4gIH1cblxuICByZXR1cm4gcm93cztcbn1cblxuLyoqXG4gKiBSZXNvbHZlcyBhIGNvbHVtbiBpZGVudGlmaWVyIHRvIHRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbiBpZiBwb3NzaWJsZS4gVGhlXG4gKiBjb2x1bW4gaWRlbnRpZmllciBjYW4gYmUgYSBjb2x1bW4gbmFtZSBvciBhIGNvbHVtbiBpbmRleC4gSWYgYW4gaW52YWxpZFxuICogY29sdW1uIGlkZW50aWZpZXIgaXMgc3BlY2lmaWVkLCB3ZSByZXR1cm4gdW5kZWZpbmVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IGNvbHVtbnNcbiAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSBjb2x1bW5JZGVudGlmaWVyXG4gKiBAcGFyYW0ge09iamVjdH0gbWFwQ29sdW1uTmFtZVRvSW5kaWNlc1xuICpcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiByZXNvbHZlQ29sdW1uSWRlbnRpZmllclRvQ29sdW1uKFxuICBjb2x1bW5zLCBjb2x1bW5JZGVudGlmaWVyLCBtYXBDb2x1bW5OYW1lVG9JbmRpY2VzKSB7XG4gIGxldCBjb2x1bW5JbmRleDtcblxuICAvLyBpZiB0aGUgY29sdW1uIGlkZW50aWZpZXIgaXMgYSBzdHJpbmcsIHRyZWF0IGl0IGFzIGEgY29sdW1uXG4gIC8vIG5hbWUgYW5kIHVzZSBpdCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBzcGVjaWZpZWQgY29sdW1uXG4gIGlmIChVdGlsLmlzU3RyaW5nKGNvbHVtbklkZW50aWZpZXIpKSB7XG4gICAgLy8gaWYgYSB2YWxpZCBjb2x1bW4gbmFtZSB3YXMgc3BlY2lmaWVkLCBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjb2x1bW5cbiAgICAvLyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwQ29sdW1uTmFtZVRvSW5kaWNlcywgY29sdW1uSWRlbnRpZmllcikpIHtcbiAgICAgIGNvbHVtbkluZGV4ID0gbWFwQ29sdW1uTmFtZVRvSW5kaWNlc1tjb2x1bW5JZGVudGlmaWVyXVswXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoVXRpbC5pc051bWJlcihjb2x1bW5JZGVudGlmaWVyKSkge1xuICAgIC8vIGlmIHRoZSBjb2x1bW4gaWRlbnRpZmllciBpcyBhIG51bWJlciwgdHJlYXQgaXQgYXMgYSBjb2x1bW4gaW5kZXhcbiAgICBjb2x1bW5JbmRleCA9IGNvbHVtbklkZW50aWZpZXI7XG4gIH1cblxuICByZXR1cm4gY29sdW1uc1tjb2x1bW5JbmRleF07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ2h1bms7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/result/chunk.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/result/chunk_cache.js":
/*!*************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/result/chunk_cache.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const DoublyLinkedList = __webpack_require__(/*! ./doubly_linked_list */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/doubly_linked_list.js\");\n\n/**\n * An LRU cache used to store chunks.\n * \n * !! This cache is not fully implemented and not used at this time !!\n *\n * @param capacity the cache size in terms of the number of chunks.\n * @constructor\n */\nfunction ChunkCache(capacity) {\n  this._capacity = capacity;\n\n  // create a map and a doubly linked list to track the cached chunks\n  this._map = {};\n  this._list = new DoublyLinkedList();\n}\n\n/**\n * Adds a chunk to the cache.\n *\n * @param chunk\n */\nChunkCache.prototype.put = function (chunk) {\n  let evictedNode;\n  let evictedChunk;\n\n  const map = this._map;\n  const list = this._list;\n  const chunkId = chunk.getId();\n\n  // if we already have the chunk in the cache, remove the corresponding node\n  // from the list\n  if (Object.prototype.hasOwnProperty.call(map, chunkId) && map[chunkId]) {\n    list.remove(map[chunkId]);\n  }\n\n  // append the chunk to the list and put the corresponding node in the map\n  map[chunkId] = list.insertEnd(chunk);\n\n  // if we've exceeded the cache capacity\n  if (list.getLength() > this._capacity) {\n    // remove the current head of the list\n    evictedNode = list.getHead();\n    list.remove(evictedNode);\n\n    // evict the chunk associated with the removed node\n    evictedChunk = evictedNode.getValue();\n    delete map[evictedChunk.getId()];\n\n    // clear the rows from the evicted chunk\n    // TODO: should the force flag be set to true here?\n    evictedChunk.clearRows();\n  }\n};\n\nmodule.exports = ChunkCache;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvY2h1bmtfY2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQUEseUJBQXlCLG1CQUFPLENBQUMsNEdBQXNCOztBQUV2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9jaHVua19jYWNoZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBEb3VibHlMaW5rZWRMaXN0ID0gcmVxdWlyZSgnLi9kb3VibHlfbGlua2VkX2xpc3QnKTtcblxuLyoqXG4gKiBBbiBMUlUgY2FjaGUgdXNlZCB0byBzdG9yZSBjaHVua3MuXG4gKiBcbiAqICEhIFRoaXMgY2FjaGUgaXMgbm90IGZ1bGx5IGltcGxlbWVudGVkIGFuZCBub3QgdXNlZCBhdCB0aGlzIHRpbWUgISFcbiAqXG4gKiBAcGFyYW0gY2FwYWNpdHkgdGhlIGNhY2hlIHNpemUgaW4gdGVybXMgb2YgdGhlIG51bWJlciBvZiBjaHVua3MuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ2h1bmtDYWNoZShjYXBhY2l0eSkge1xuICB0aGlzLl9jYXBhY2l0eSA9IGNhcGFjaXR5O1xuXG4gIC8vIGNyZWF0ZSBhIG1hcCBhbmQgYSBkb3VibHkgbGlua2VkIGxpc3QgdG8gdHJhY2sgdGhlIGNhY2hlZCBjaHVua3NcbiAgdGhpcy5fbWFwID0ge307XG4gIHRoaXMuX2xpc3QgPSBuZXcgRG91Ymx5TGlua2VkTGlzdCgpO1xufVxuXG4vKipcbiAqIEFkZHMgYSBjaHVuayB0byB0aGUgY2FjaGUuXG4gKlxuICogQHBhcmFtIGNodW5rXG4gKi9cbkNodW5rQ2FjaGUucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICBsZXQgZXZpY3RlZE5vZGU7XG4gIGxldCBldmljdGVkQ2h1bms7XG5cbiAgY29uc3QgbWFwID0gdGhpcy5fbWFwO1xuICBjb25zdCBsaXN0ID0gdGhpcy5fbGlzdDtcbiAgY29uc3QgY2h1bmtJZCA9IGNodW5rLmdldElkKCk7XG5cbiAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIHRoZSBjaHVuayBpbiB0aGUgY2FjaGUsIHJlbW92ZSB0aGUgY29ycmVzcG9uZGluZyBub2RlXG4gIC8vIGZyb20gdGhlIGxpc3RcbiAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtYXAsIGNodW5rSWQpICYmIG1hcFtjaHVua0lkXSkge1xuICAgIGxpc3QucmVtb3ZlKG1hcFtjaHVua0lkXSk7XG4gIH1cblxuICAvLyBhcHBlbmQgdGhlIGNodW5rIHRvIHRoZSBsaXN0IGFuZCBwdXQgdGhlIGNvcnJlc3BvbmRpbmcgbm9kZSBpbiB0aGUgbWFwXG4gIG1hcFtjaHVua0lkXSA9IGxpc3QuaW5zZXJ0RW5kKGNodW5rKTtcblxuICAvLyBpZiB3ZSd2ZSBleGNlZWRlZCB0aGUgY2FjaGUgY2FwYWNpdHlcbiAgaWYgKGxpc3QuZ2V0TGVuZ3RoKCkgPiB0aGlzLl9jYXBhY2l0eSkge1xuICAgIC8vIHJlbW92ZSB0aGUgY3VycmVudCBoZWFkIG9mIHRoZSBsaXN0XG4gICAgZXZpY3RlZE5vZGUgPSBsaXN0LmdldEhlYWQoKTtcbiAgICBsaXN0LnJlbW92ZShldmljdGVkTm9kZSk7XG5cbiAgICAvLyBldmljdCB0aGUgY2h1bmsgYXNzb2NpYXRlZCB3aXRoIHRoZSByZW1vdmVkIG5vZGVcbiAgICBldmljdGVkQ2h1bmsgPSBldmljdGVkTm9kZS5nZXRWYWx1ZSgpO1xuICAgIGRlbGV0ZSBtYXBbZXZpY3RlZENodW5rLmdldElkKCldO1xuXG4gICAgLy8gY2xlYXIgdGhlIHJvd3MgZnJvbSB0aGUgZXZpY3RlZCBjaHVua1xuICAgIC8vIFRPRE86IHNob3VsZCB0aGUgZm9yY2UgZmxhZyBiZSBzZXQgdG8gdHJ1ZSBoZXJlP1xuICAgIGV2aWN0ZWRDaHVuay5jbGVhclJvd3MoKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDaHVua0NhY2hlOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/result/chunk_cache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/result/column.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/result/column.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst BigNumber = __webpack_require__(/*! bignumber.js */ \"(rsc)/./node_modules/bignumber.js/bignumber.js\");\nconst GlobalConfig = __webpack_require__(/*! ../../global_config */ \"(rsc)/./node_modules/snowflake-sdk/lib/global_config.js\");\nconst Logger = __webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst SfTimestamp = __webpack_require__(/*! ./sf_timestamp */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/sf_timestamp.js\");\nconst DataTypes = __webpack_require__(/*! ./data_types */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/data_types.js\");\nconst SqlTypes = (__webpack_require__(/*! ./data_types */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/data_types.js\").SqlTypes);\nconst dateTimeFormatConverter = __webpack_require__(/*! ./datetime_format_converter */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/datetime_format_converter.js\");\nconst bigInt = __webpack_require__(/*! big-integer */ \"(rsc)/./node_modules/big-integer/BigInteger.js\");\nconst moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst momentTimezone = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\n\n/**\n * Creates a new Column.\n *\n * @param {Object} options\n * @param {Number} index\n * @param {Object} statementParameters\n * @param {String} resultVersion\n *\n * @constructor\n */\nfunction Column(options, index, statementParameters, resultVersion) {\n  const name = options.overriddenName || options.name;\n  const nullable = options.nullable;\n  const scale = options.scale;\n  const type = options.type;\n  const precision = options.precision;\n  const fieldsMetadata = options.fields;\n\n  /**\n   * Returns the name of this column.\n   *\n   * @return {String}\n   */\n  this.getName = function () {\n    return name;\n  };\n\n  /**\n   * Returns the index of this column.\n   *\n   * @return {Number}\n   */\n  this.getIndex = function () {\n    return index;\n  };\n\n  /**\n   * Returns the id of this column.\n   *\n   * @return {Number}\n   */\n  this.getId = function () {\n    // use the index as the id for now\n    return index;\n  };\n\n  /**\n   * Determines if this column is nullable.\n   *\n   * @returns {Boolean}\n   */\n  this.isNullable = function () {\n    return nullable;\n  };\n\n  /**\n   * Returns the scale associated with this column.\n   *\n   * @returns {Number}\n   */\n  this.getScale = function () {\n    return scale;\n  };\n\n  /**\n   * Returns the type associated with this column.\n   *\n   * @returns {String}\n   */\n  this.getType = function () {\n    return type;\n  };\n\n  /**\n   * Returns the precision associated with this column\n   *\n   * @returns {Number}\n   */\n  this.getPrecision = function () {\n    return precision;\n  };\n\n  // add methods that make it easy to check if the column is of a specific type\n  this.isString = createFnIsColumnOfType(type, SqlTypes.isString, SqlTypes);\n  this.isBinary = createFnIsColumnOfType(type, SqlTypes.isBinary, SqlTypes);\n  this.isNumber = createFnIsColumnOfType(type, SqlTypes.isNumber, SqlTypes);\n  this.isBoolean = createFnIsColumnOfType(type, SqlTypes.isBoolean, SqlTypes);\n  this.isDate = createFnIsColumnOfType(type, SqlTypes.isDate, SqlTypes);\n  this.isTime = createFnIsColumnOfType(type, SqlTypes.isTime, SqlTypes);\n  this.isTimestamp = createFnIsColumnOfType(type, SqlTypes.isTimestamp, SqlTypes);\n  this.isTimestampLtz = createFnIsColumnOfType(type, SqlTypes.isTimestampLtz, SqlTypes);\n  this.isTimestampNtz = createFnIsColumnOfType(type, SqlTypes.isTimestampNtz, SqlTypes);\n  this.isTimestampTz = createFnIsColumnOfType(type, SqlTypes.isTimestampTz, SqlTypes);\n  this.isVariant = createFnIsColumnOfType(type, (type) => SqlTypes.isVariant(type, fieldsMetadata), SqlTypes);\n  this.isObject = createFnIsColumnOfType(type, (type) => SqlTypes.isObject(type, fieldsMetadata), SqlTypes);\n  this.isArray = createFnIsColumnOfType(type, (type) => SqlTypes.isArray(type, fieldsMetadata), SqlTypes);\n  this.isMap = createFnIsColumnOfType(type, (type) => SqlTypes.isMap(type, fieldsMetadata), SqlTypes);\n\n  let convert;\n  let toString;\n  let toValue;\n  let format;\n\n  if (this.isNumber()) {\n    const integerAs = statementParameters['JS_TREAT_INTEGER_AS_BIGINT'];\n    if (!integerAs) {\n      convert = convertRawNumber;\n    } else {\n      if (this.getScale() > 0 || this.getType() === SqlTypes.values.REAL) {\n        convert = convertRawNumber;\n      } else {\n        // This is an integer so represent it as a big int\n        convert = convertRawBigInt;\n      }\n    }\n    toValue = toValueFromNumber;\n    toString = toStringFromNumber;\n  } else if (this.isTime()) {\n    convert = convertRawTime;\n    toValue = toValueFromTime;\n    toString = toStringFromTime;\n    format = statementParameters['TIME_OUTPUT_FORMAT'];\n  } else {\n    toValue = noop;\n\n    if (this.isBoolean()) {\n      convert = convertRawBoolean;\n      toString = toStringFromBoolean;\n    } else if (this.isDate()) {\n      convert = convertRawDate;\n      toString = toStringFromDate;\n      format = statementParameters['DATE_OUTPUT_FORMAT'];\n    } else if (this.isTimestamp()) {\n      if (this.isTimestampLtz()) {\n        convert = convertRawTimestampLtz;\n        toString = toStringFromTimestamp;\n        format = statementParameters['TIMESTAMP_LTZ_OUTPUT_FORMAT'];\n      } else if (this.isTimestampNtz()) {\n        convert = convertRawTimestampNtz;\n        toString = toStringFromTimestamp;\n        format = statementParameters['TIMESTAMP_NTZ_OUTPUT_FORMAT'];\n      } else if (this.isTimestampTz()) {\n        convert = convertRawTimestampTz;\n        toString = toStringFromTimestamp;\n        format = statementParameters['TIMESTAMP_TZ_OUTPUT_FORMAT'];\n      }\n\n      // if we don't have a type-specific timezone, use the default format\n      if (!format) {\n        format = statementParameters['TIMESTAMP_OUTPUT_FORMAT'];\n      }\n    } else if (this.isBinary()) {\n      convert = convertRawBinary;\n      toString = toStringFromBinary;\n      format = statementParameters['BINARY_OUTPUT_FORMAT'];\n    } else if (this.isVariant()) {\n      convert = convertRawVariant;\n      toString = toStringFromRawValue;\n    } else if (this.isObject()) {\n      convert = convertRawStructuredType(convertJsonObject);\n      toString = toStringFromRawValue;\n    } else if (this.isArray()) {\n      convert = convertRawStructuredType(convertJsonArray);\n      toString = toStringFromRawValue;\n    } else if (this.isMap()) {\n      convert = convertRawStructuredType(convertJsonMap);\n      toString = toStringFromRawValue;\n    } else {\n      // column is of type string, so leave value as is\n      convert = noop;\n      toString = toStringFromString;\n    }\n  }\n\n  // create a private context to pass to the extract function\n  const context =\n    {\n      convert: convert,\n      toValue: toValue,\n      toString: toString,\n      format: format,\n      resultVersion: resultVersion,\n      statementParameters: statementParameters,\n      fieldsMetadata: fieldsMetadata\n    };\n\n  /**\n   * Returns the value of this column in a row.\n   *\n   * @param {Object} row\n   *\n   * @returns {*}\n   */\n  this.getRowValue = function (row) {\n    return extractFromRow.call(this, row, context, false);\n  };\n\n  /**\n   * Returns the value of this in a row as a String.\n   *\n   * @param {Object} row\n   *\n   * @returns {String}\n   */\n  this.getRowValueAsString = function (row) {\n    return extractFromRow.call(this, row, context, true);\n  };\n}\n\n/**\n * Returns a function that can be used to determine if a column is of a given\n * type.\n *\n * @param {String} columnType the column type.\n * @param {Function} columnComparisonFn the column comparison function.\n * @param {Object} scope the scope in which to invoke the column comparison\n *   function.\n *\n * @returns {Function}\n */\nfunction createFnIsColumnOfType(columnType, columnComparisonFn, scope) {\n  return function () {\n    return columnComparisonFn.call(scope, columnType);\n  };\n}\n\n/**\n * Converts a raw column value of type Number. The returned value is an object\n * that contains the raw string version of the value as well as the\n * post-processed version of the value obtained after casting to Number.\n *\n * @param {String} rawColumnValue\n *\n * @returns {Object}\n */\nfunction convertRawNumber(rawColumnValue) {\n  return {\n    raw: rawColumnValue,\n    processed: Number(rawColumnValue)\n  };\n}\n\n/**\n * Converts a raw column value that is an integer. The returned value is an object\n * that contains the raw string version of the value as well as the post-processed\n * version of the value obtained after casting to bigInt\n *\n * @param rawColumnValue\n * @returns {{processed: bigInt.BigInteger, raw: *}}\n */\nfunction convertRawBigInt(rawColumnValue) {\n  return {\n    raw: rawColumnValue,\n    processed: bigInt(rawColumnValue)\n  };\n}\n\n/**\n * Converts a raw column value of type Boolean to a boolean (true, false,\n * or null).\n *\n * @param {String} rawColumnValue\n *\n * @returns {Boolean}\n */\nfunction convertRawBoolean(rawColumnValue) {\n  let ret;\n\n  if (rawColumnValue  === true || (rawColumnValue === '1') || (rawColumnValue.toUpperCase() === 'TRUE')) {\n    ret = true;\n  } else if (rawColumnValue === false || (rawColumnValue === '0') || (rawColumnValue.toUpperCase() === 'FALSE')) {\n    ret = false;\n  } else {\n    throw new Error(`Value could not be converted to boolean: ${rawColumnValue}`);\n  }\n  return ret;\n}\n\n/**\n * Converts a raw column value of structured type object to javascript Object\n *\n * @param {Object} json\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertJsonObject(json, context) {\n  if (context.fieldsMetadata){\n    context.fieldsMetadata = context.fieldsMetadata.reduce(function (map, obj) {\n      map[obj.name] = obj;\n      return map;\n    }, {});\n\n    const result = {};\n    Object.keys(json).forEach(function (key) {\n      const fieldMetadata = context.fieldsMetadata[key];\n      result[key] = mapStructuredTypeValue(json[key], context, fieldMetadata);\n    });\n    return result;\n  } else {\n    return json;\n  }\n}\n\n/**\n * Converts a raw column value of structured type array to javascript Object\n *\n * @param {Object} json\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertJsonArray(json, context) {\n  if (context.fieldsMetadata) {\n    const result = [];\n    json.forEach(function (value) {\n      result.push(mapStructuredTypeValue(value, context, context.fieldsMetadata[0]));\n    });\n    return result;\n  } else {\n    return json;\n  }\n}\n\n/**\n * Converts a raw column value of structured type map to javascript Object\n *\n * @param {Object} json\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertJsonMap(json, context) {\n  if (Array.isArray(context.fieldsMetadata) && context.fieldsMetadata.length === 2) {\n    const result = new Map;\n    const keyMetadata = context.fieldsMetadata[0];\n    const valueMetadata = context.fieldsMetadata[1];\n    Object.keys(json).forEach(function (key) {\n      const convertedKey = mapStructuredTypeValue(key, context, keyMetadata);\n      const convertedValue = mapStructuredTypeValue(json[key], context, valueMetadata);\n      result.set(convertedKey, convertedValue);\n    });\n    return result;\n  } else {\n    return json;\n  }\n}\n\n/**\n * Converts a raw column value of structured type OBJECT to javascript Object\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Object}\n */\nconst convertRawStructuredType = (convertJsonFn) => (rawColumnValue, column, context) => {\n  if (Util.string.isNotNullOrEmpty(rawColumnValue)) {\n    try {\n      const json = JSON.parse(rawColumnValue);\n      return convertJsonFn(json, context);\n    } catch (jsonParseError) {\n      Logger.getInstance().debug('Column %s raw value cannot be parsed as JSON: %s ', column.name, jsonParseError.message);\n      throw new Error(util.format('Column [%s] raw value cannot be parsed as JSON: %s ', column.name, jsonParseError.message));\n    }\n  } else {\n    throw new Error(util.format('Column %s raw value is null or empty ', column.name));\n  }\n};\n\nfunction mapStructuredTypeValue(columnValue, context, metadataField) {\n  const formatLtz = context.statementParameters['TIMESTAMP_LTZ_OUTPUT_FORMAT'] ?? context.statementParameters['TIMESTAMP_OUTPUT_FORMAT'];\n  const formatTz = context.statementParameters['TIMESTAMP_TZ_OUTPUT_FORMAT'] ?? context.statementParameters['TIMESTAMP_OUTPUT_FORMAT'];\n  const formatNtz = context.statementParameters['TIMESTAMP_NTZ_OUTPUT_FORMAT'];\n  let value;\n  switch (metadataField.type) {\n  case 'text':\n    value = columnValue;\n    break;\n  case 'real':\n    value = toValueFromNumber(convertRawNumber(columnValue));\n    break;\n  case 'fixed':\n    value = toValueFromNumber(convertRawNumber(columnValue));\n    break;\n  case 'boolean':\n    value = convertRawBoolean(columnValue);\n    break;\n  case 'timestamp_ltz':\n    value = convertTimestampTzString(columnValue, formatLtz, context.statementParameters['TIMEZONE'], metadataField.scale).toSfDate();\n    break;\n  case 'timestamp_ntz':\n    value = convertTimestampNtzString(columnValue, formatNtz, moment.tz.zone('UTC'), metadataField.scale).toSfDate();\n    break;\n  case 'timestamp_tz':\n    value = convertTimestampTzString(columnValue, formatTz, context.statementParameters['TIMEZONE'], metadataField.scale).toSfDate();\n    break;\n  case 'date': {\n    context.format = context.statementParameters['DATE_OUTPUT_FORMAT'];\n    value = convertDateString(columnValue, context.format );\n    break;\n  }\n  case 'time':\n    context.format = context.statementParameters['TIME_OUTPUT_FORMAT'];\n    value = convertTimeString(columnValue, context.format, moment.tz.zone('UTC'), metadataField.scale).toSfTime();\n    break;\n  case 'binary':\n    context.format = context.statementParameters['BINARY_OUTPUT_FORMAT'];\n    value = convertRawBinary(columnValue, this, context).toJSON().data;\n    break;\n  case 'object': {\n    const internalContext = {\n      convert: convertRawStructuredType(convertJsonObject),\n      toValue: noop,\n      toString: toString,\n      format: toStringFromRawValue,\n      resultVersion: context.resultVersion,\n      statementParameters: context.statementParameters,\n      fieldsMetadata: metadataField.fields\n    };\n    value = convertJsonObject(columnValue, internalContext);\n    break;\n  }\n  case 'array': {\n    const internalArrayContext = {\n      convert: convertRawStructuredType(convertJsonArray),\n      toValue: noop,\n      toString: toString,\n      format: toStringFromRawValue,\n      resultVersion: context.resultVersion,\n      statementParameters: context.statementParameters,\n      fieldsMetadata: metadataField.fields\n    };\n    value = convertJsonArray(columnValue, internalArrayContext);\n    break;\n  }\n  case 'map': {\n    const internalMapContext = {\n      convert: convertRawStructuredType(convertJsonMap),\n      toValue: noop,\n      toString: toString,\n      format: toStringFromRawValue,\n      resultVersion: context.resultVersion,\n      statementParameters: context.statementParameters,\n      fieldsMetadata: metadataField.fields\n    };\n    value = convertJsonMap(columnValue, internalMapContext);\n    break;\n  }\n  default:\n    Logger.getInstance().info(`Column type not supported: ${context.fieldsMetadata.type}`);\n    throw new Error(`Column type not supported: ${context.fieldsMetadata.type}`);\n  }\n  return value;\n}\n\nconst convertTimestampTzString = function (stringValue, formatSql, timezone, scale) {\n  const formatMoment = dateTimeFormatConverter.convertSnowflakeFormatToMomentFormat(formatSql, scale);\n  const epochSeconds = momentTimezone(stringValue, formatMoment).unix();\n  return new SfTimestamp(epochSeconds, 0, scale, timezone, formatSql);\n};\n\nconst convertTimestampNtzString = function (stringValue, formatSql, timezone, scale) {\n  const formatMoment = dateTimeFormatConverter.convertSnowflakeFormatToMomentFormat(formatSql, scale);\n  const epochSeconds = momentTimezone.utc(stringValue, formatMoment).unix();\n  return new SfTimestamp(epochSeconds, 0, scale, timezone, formatSql);\n};\n\nconst convertDateString = function (stringValue, formatSql) {\n  const formatMoment = dateTimeFormatConverter.convertSnowflakeFormatToMomentFormat(formatSql, 0);\n  const epochSeconds = momentTimezone.utc(stringValue, formatMoment).unix();\n  const date = new SfTimestamp(\n    epochSeconds, // convert to seconds\n    0,                              // no nano seconds\n    0,                              // no scale required\n    'UTC',                          // use utc as the timezone\n    context.format);\n  date._valueAsString = stringValue;\n  return date.toSfDate();\n};\n\n\nconst convertTimeString = function (stringValue, formatSql, timezone, scale) {\n  const formatMoment = dateTimeFormatConverter.convertSnowflakeFormatToMomentFormat(formatSql, scale);\n  const moment = momentTimezone(stringValue, formatMoment);\n  const epochSeconds = moment.hours() * 3600 + moment.minutes() * 60 + moment.seconds();\n  const time =  new SfTimestamp(epochSeconds, 0, scale, timezone, formatSql);\n  time._valueAsString = stringValue;\n  return time;\n};\n\n/**\n * Converts a raw column value of type Date to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawDate(rawColumnValue, column, context) {\n  return new SfTimestamp(\n    Number(rawColumnValue) * 86400, // convert to seconds\n    0,                              // no nano seconds\n    0,                              // no scale required\n    'UTC',                          // use utc as the timezone\n    context.format).toSfDate();\n}\n\n/**\n * Converts a raw column value of type Time to a Snowflake Time.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Object}\n */\nfunction convertRawTime(rawColumnValue, column, context) {\n  const columnScale = column.getScale();\n\n  // the values might be big so use BigNumber to do arithmetic\n  const valFracSecsBig =\n    new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n\n  return convertRawTimestampHelper(\n    valFracSecsBig,\n    columnScale,\n    'UTC',\n    context.format).toSfTime();\n}\n\n/**\n * Converts a raw column value of type TIMESTAMP_LTZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampLtz(rawColumnValue, column, context) {\n  const columnScale = column.getScale();\n\n  // the values might be big so use BigNumber to do arithmetic\n  const valFracSecsBig =\n    new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n\n  // create a new snowflake date\n  return convertRawTimestampHelper(\n    valFracSecsBig,\n    columnScale,\n    context.statementParameters['TIMEZONE'],\n    context.format).toSfDate();\n}\n\n/**\n * Converts a raw column value of type TIMESTAMP_NTZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampNtz(rawColumnValue, column, context) {\n  const columnScale = column.getScale();\n\n  // the values might be big so use BigNumber to do arithmetic\n  const valFracSecsBig =\n    new BigNumber(rawColumnValue).times(Math.pow(10, columnScale));\n\n  // create a new snowflake date\n  return convertRawTimestampHelper(\n    valFracSecsBig,\n    columnScale,\n    'UTC',     // it's _ntz, so use UTC for timezone\n    context.format).toSfDate();\n}\n\n/**\n * Converts a raw column value of type TIMESTAMP_TZ to a Snowflake Date.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Date}\n */\nfunction convertRawTimestampTz(rawColumnValue, column, context) {\n  let valFracSecsBig;\n  let valFracSecsWithTzBig;\n  let timezoneBig;\n  let timezone;\n  let timestampAndTZIndex;\n\n  // compute the scale factor\n  const columnScale = column.getScale();\n  const scaleFactor = Math.pow(10, columnScale);\n\n  const resultVersion = context.resultVersion;\n  if (resultVersion === '0' || resultVersion === undefined) {\n    // the values might be big so use BigNumber to do arithmetic\n    valFracSecsBig =\n      new BigNumber(rawColumnValue).times(scaleFactor);\n\n    // for _tz, the timezone is baked into the value\n    valFracSecsWithTzBig = valFracSecsBig;\n\n    // extract everything but the lowest 14 bits to get the fractional seconds\n    valFracSecsBig =\n      valFracSecsWithTzBig.dividedBy(16384).integerValue(BigNumber.ROUND_FLOOR);\n\n    // extract the lowest 14 bits to get the timezone\n    if (valFracSecsWithTzBig.isGreaterThanOrEqualTo(0)) {\n      timezoneBig = valFracSecsWithTzBig.modulo(16384);\n    } else {\n      timezoneBig =\n        valFracSecsWithTzBig.modulo(16384).plus(16384);\n    }\n  } else {\n    // split the value into number of seconds and timezone index\n    timestampAndTZIndex = rawColumnValue.split(' ');\n\n    // the values might be big so use BigNumber to do arithmetic\n    valFracSecsBig =\n      new BigNumber(timestampAndTZIndex[0]).times(scaleFactor);\n\n    timezoneBig = new BigNumber(timestampAndTZIndex[1]);\n  }\n\n  timezone = timezoneBig.toNumber();\n\n  // assert that timezone is valid\n  Errors.assertInternal(timezone >= 0 && timezone <= 2880);\n\n  // subtract 24 hours from the timezone to map [0, 48] to\n  // [-24, 24], and convert the result to a number\n  timezone = timezone - 1440;\n\n  // create a new snowflake date\n  return convertRawTimestampHelper(\n    valFracSecsBig,\n    columnScale,\n    timezone,\n    context.format).toSfDate();\n}\n\n/**\n * Helper function for the convertRawTimestamp*() functions.\n * Returns an instance of SfTimestamp.\n *\n * @param {Object} epochFracSecsBig\n * @param {Number} scale\n * @param {String | Number} timezone\n * @param {String} format\n *\n * @returns {Object}\n */\nfunction convertRawTimestampHelper(\n  epochFracSecsBig,\n  scale,\n  timezone,\n  format) {\n  // compute the scale factor\n  const scaleFactor = Math.pow(10, scale);\n\n  // split the value into epoch seconds + nanoseconds; for example,\n  // 1365148923.123456789 will be split into 1365148923 (epoch seconds)\n  // and 123456789 (nano seconds)\n  const valSecBig = epochFracSecsBig.dividedBy(scaleFactor).integerValue(BigNumber.ROUND_FLOOR);\n  const fractionsBig = epochFracSecsBig.minus(valSecBig.times(scaleFactor));\n  const valSecNanoBig = fractionsBig.times(Math.pow(10, 9 - scale));\n\n  // create a new snowflake date from the information\n  return new SfTimestamp(\n    valSecBig.toNumber(),\n    valSecNanoBig.toNumber(),\n    scale,\n    timezone,\n    format);\n}\n\n/**\n * Converts a raw column value of type Variant to a JavaScript value.\n *\n * @param {String} rawColumnValue\n *\n * @returns {Object | Array}\n */\nfunction convertRawVariant(rawColumnValue) {\n  // if the input is a non-empty string, convert it to a json object\n  if (Util.string.isNotNullOrEmpty(rawColumnValue)) {\n    try {\n      return GlobalConfig.jsonColumnVariantParser(rawColumnValue);\n    } catch (jsonParseError) {\n      try {\n        return GlobalConfig.xmlColumnVariantParser(rawColumnValue);\n      } catch (xmlParseError) {\n        Logger.getInstance().debug('Variant cannot be parsed neither as JSON: %s nor as XML: %s', jsonParseError.message, xmlParseError.message);\n        throw new Errors.VariantParseError(jsonParseError, xmlParseError);\n      }\n    }\n  }\n}\n\n/**\n * Converts a raw column value of type Binary to a Buffer.\n *\n * @param {String} rawColumnValue\n * @param {Object} column\n * @param {Object} context\n *\n * @returns {Buffer}\n */\nfunction convertRawBinary(rawColumnValue, column, context) {\n  // Ensure the format is valid.\n  const format = context.format.toUpperCase();\n  Errors.assertInternal(format === 'HEX' || format === 'BASE64');\n\n  // Decode hex string sent by GS.\n  const buffer = Buffer.from(rawColumnValue, 'HEX');\n\n  if (format === 'HEX') {\n    buffer.toStringSf = function () {\n      // The raw value is already an uppercase hex string, so just return it.\n      // Note that buffer.toString(\"HEX\") returns a lowercase hex string, but we\n      // want upper case.\n      return rawColumnValue;\n    };\n  } else {\n    buffer.toStringSf = function () {\n      return this.toString('BASE64');\n    };\n  }\n\n  buffer.getFormat = function () {\n    return format;\n  };\n\n  return buffer;\n}\n\n/**\n * Returns the input value as is.\n *\n * @param {*} value\n *\n * @returns {*}\n */\nfunction noop(value) {\n  return value;\n}\n\n/**\n * The toValue() function for a column of type Number.\n *\n * @param {*} columnValue\n *\n * @returns {Number}\n */\nfunction toValueFromNumber(columnValue) {\n  return columnValue ? columnValue.processed : columnValue;\n}\n\n/**\n * The toValue() function for a column of type Time.\n *\n * @param {*} columnValue\n *\n * @returns {String}\n */\nfunction toValueFromTime(columnValue) {\n  // there's no native javascript type that can be used to represent time, so\n  // just convert to string\n  return toStringFromTime(columnValue);\n}\n\n/**\n * The toString() function for a column of type Number.\n *\n * @param {Number} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromNumber(columnValue) {\n  return (columnValue !== null) ? columnValue.raw : DataTypes.getNullValue();\n}\n\n/**\n * The toString() function for a column of type Boolean.\n *\n * @param {Boolean} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromBoolean(columnValue) {\n  return (columnValue !== null) ? String(columnValue).toUpperCase() :\n    DataTypes.getNullValue();\n}\n\n/**\n * The toString() function for a column of type Date.\n *\n * @param {Date} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromDate(columnValue) {\n  return (columnValue !== null) ? columnValue.toJSON() : DataTypes.getNullValue();\n}\n\n/**\n * The toString() function for a column of type Time.\n *\n * @param {Object} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromTime(columnValue) {\n  return (columnValue !== null) ? columnValue.toJSON() : DataTypes.getNullValue();\n}\n\n/**\n * The toString() function for a column of type Timestamp.\n *\n * @param {Date} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromTimestamp(columnValue) {\n  return (columnValue !== null) ? columnValue.toJSON() : DataTypes.getNullValue();\n}\n\n/**\n * The toString() function for a column of type Variant.\n *\n * @param {Object} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromRawValue(columnValue) {\n  return (columnValue !== null) ? JSON.stringify(columnValue) : DataTypes.getNullValue();\n}\n\n/**\n * The toString() function for a column of type String.\n *\n * @param {String} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromString(columnValue) {\n  return (columnValue !== null) ? columnValue : DataTypes.getNullValue();\n}\n\n/**\n * The toString() function for a column of type Binary.\n *\n * @param {Buffer} columnValue\n *\n * @returns {String}\n */\nfunction toStringFromBinary(columnValue) {\n  return (columnValue !== null) ? columnValue.toStringSf() : DataTypes.getNullValue();\n}\n\n/**\n * Extracts the value of a column from a given row.\n *\n * @param {Object} row\n * @param {Object} context\n * @param {Boolean} asString\n *\n * @returns {*}\n */\nfunction extractFromRow(row, context, asString) {\n  const map = row._arrayProcessedColumns;\n  const values = row.values;\n\n  // get the value\n  const columnIndex = this.getIndex();\n  let ret = values[columnIndex];\n\n  // if we want the value as a string, and the column is of type variant, and we\n  // haven't already processed the value before, we don't need to process the\n  // value, so only process if none of the aforementioned conditions are true\n  if (!(asString && this.isVariant() && !map[columnIndex])) {\n    // if the column value has not been processed yet, process it, put it back\n    // in the values array, and remember that the value has been processed\n    if (!map[columnIndex]) {\n      if (ret !== null) {\n        ret = values[columnIndex] =\n          context.convert(values[columnIndex], this, context);\n      }\n      map[columnIndex] = true;\n    }\n\n    // use the appropriate extraction function depending on whether\n    // we want the value or a string representation of the value\n    const extractFn = !asString ? context.toValue : context.toString;\n    ret = extractFn(ret);\n  }\n\n  return ret;\n}\n\nmodule.exports = Column;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvY29sdW1uLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxrRUFBWTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsc0VBQWM7QUFDckMsa0JBQWtCLG1CQUFPLENBQUMsb0VBQWM7QUFDeEMscUJBQXFCLG1CQUFPLENBQUMsb0ZBQXFCO0FBQ2xELGVBQWUsbUJBQU8sQ0FBQyxzRUFBYztBQUNyQyxvQkFBb0IsbUJBQU8sQ0FBQyxnR0FBZ0I7QUFDNUMsa0JBQWtCLG1CQUFPLENBQUMsNEZBQWM7QUFDeEMsaUJBQWlCLDRIQUFnQztBQUNqRCxnQ0FBZ0MsbUJBQU8sQ0FBQywwSEFBNkI7QUFDckUsZUFBZSxtQkFBTyxDQUFDLG1FQUFhO0FBQ3BDLGVBQWUsbUJBQU8sQ0FBQyxxREFBUTtBQUMvQix1QkFBdUIsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDaEQsYUFBYSxtQkFBTyxDQUFDLGtFQUFZOztBQUVqQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSixnRUFBZ0UsZUFBZTtBQUMvRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLElBQUk7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDRCQUE0QjtBQUN4RixrREFBa0QsNEJBQTRCO0FBQzlFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLGlCQUFpQjtBQUM1QixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsR0FBRztBQUNkO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxNQUFNO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9jb2x1bW4uanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uLy4uL2Vycm9ycycpO1xuY29uc3QgQmlnTnVtYmVyID0gcmVxdWlyZSgnYmlnbnVtYmVyLmpzJyk7XG5jb25zdCBHbG9iYWxDb25maWcgPSByZXF1aXJlKCcuLi8uLi9nbG9iYWxfY29uZmlnJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi8uLi9sb2dnZXInKTtcbmNvbnN0IFNmVGltZXN0YW1wID0gcmVxdWlyZSgnLi9zZl90aW1lc3RhbXAnKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4vZGF0YV90eXBlcycpO1xuY29uc3QgU3FsVHlwZXMgPSByZXF1aXJlKCcuL2RhdGFfdHlwZXMnKS5TcWxUeXBlcztcbmNvbnN0IGRhdGVUaW1lRm9ybWF0Q29udmVydGVyID0gcmVxdWlyZSgnLi9kYXRldGltZV9mb3JtYXRfY29udmVydGVyJyk7XG5jb25zdCBiaWdJbnQgPSByZXF1aXJlKCdiaWctaW50ZWdlcicpO1xuY29uc3QgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5jb25zdCBtb21lbnRUaW1lem9uZSA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xuY29uc3QgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IENvbHVtbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHBhcmFtIHtOdW1iZXJ9IGluZGV4XG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50UGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJlc3VsdFZlcnNpb25cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ29sdW1uKG9wdGlvbnMsIGluZGV4LCBzdGF0ZW1lbnRQYXJhbWV0ZXJzLCByZXN1bHRWZXJzaW9uKSB7XG4gIGNvbnN0IG5hbWUgPSBvcHRpb25zLm92ZXJyaWRkZW5OYW1lIHx8IG9wdGlvbnMubmFtZTtcbiAgY29uc3QgbnVsbGFibGUgPSBvcHRpb25zLm51bGxhYmxlO1xuICBjb25zdCBzY2FsZSA9IG9wdGlvbnMuc2NhbGU7XG4gIGNvbnN0IHR5cGUgPSBvcHRpb25zLnR5cGU7XG4gIGNvbnN0IHByZWNpc2lvbiA9IG9wdGlvbnMucHJlY2lzaW9uO1xuICBjb25zdCBmaWVsZHNNZXRhZGF0YSA9IG9wdGlvbnMuZmllbGRzO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBuYW1lIG9mIHRoaXMgY29sdW1uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAqL1xuICB0aGlzLmdldE5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG5hbWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGluZGV4IG9mIHRoaXMgY29sdW1uLlxuICAgKlxuICAgKiBAcmV0dXJuIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLmdldEluZGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBpbmRleDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgaWQgb2YgdGhpcyBjb2x1bW4uXG4gICAqXG4gICAqIEByZXR1cm4ge051bWJlcn1cbiAgICovXG4gIHRoaXMuZ2V0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gdXNlIHRoZSBpbmRleCBhcyB0aGUgaWQgZm9yIG5vd1xuICAgIHJldHVybiBpbmRleDtcbiAgfTtcblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiB0aGlzIGNvbHVtbiBpcyBudWxsYWJsZS5cbiAgICpcbiAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAqL1xuICB0aGlzLmlzTnVsbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIG51bGxhYmxlO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzY2FsZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb2x1bW4uXG4gICAqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLmdldFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzY2FsZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdHlwZSBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb2x1bW4uXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICB0aGlzLmdldFR5cGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHByZWNpc2lvbiBhc3NvY2lhdGVkIHdpdGggdGhpcyBjb2x1bW5cbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIHRoaXMuZ2V0UHJlY2lzaW9uID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwcmVjaXNpb247XG4gIH07XG5cbiAgLy8gYWRkIG1ldGhvZHMgdGhhdCBtYWtlIGl0IGVhc3kgdG8gY2hlY2sgaWYgdGhlIGNvbHVtbiBpcyBvZiBhIHNwZWNpZmljIHR5cGVcbiAgdGhpcy5pc1N0cmluZyA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgU3FsVHlwZXMuaXNTdHJpbmcsIFNxbFR5cGVzKTtcbiAgdGhpcy5pc0JpbmFyeSA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgU3FsVHlwZXMuaXNCaW5hcnksIFNxbFR5cGVzKTtcbiAgdGhpcy5pc051bWJlciA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgU3FsVHlwZXMuaXNOdW1iZXIsIFNxbFR5cGVzKTtcbiAgdGhpcy5pc0Jvb2xlYW4gPSBjcmVhdGVGbklzQ29sdW1uT2ZUeXBlKHR5cGUsIFNxbFR5cGVzLmlzQm9vbGVhbiwgU3FsVHlwZXMpO1xuICB0aGlzLmlzRGF0ZSA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgU3FsVHlwZXMuaXNEYXRlLCBTcWxUeXBlcyk7XG4gIHRoaXMuaXNUaW1lID0gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZSh0eXBlLCBTcWxUeXBlcy5pc1RpbWUsIFNxbFR5cGVzKTtcbiAgdGhpcy5pc1RpbWVzdGFtcCA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgU3FsVHlwZXMuaXNUaW1lc3RhbXAsIFNxbFR5cGVzKTtcbiAgdGhpcy5pc1RpbWVzdGFtcEx0eiA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgU3FsVHlwZXMuaXNUaW1lc3RhbXBMdHosIFNxbFR5cGVzKTtcbiAgdGhpcy5pc1RpbWVzdGFtcE50eiA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgU3FsVHlwZXMuaXNUaW1lc3RhbXBOdHosIFNxbFR5cGVzKTtcbiAgdGhpcy5pc1RpbWVzdGFtcFR6ID0gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZSh0eXBlLCBTcWxUeXBlcy5pc1RpbWVzdGFtcFR6LCBTcWxUeXBlcyk7XG4gIHRoaXMuaXNWYXJpYW50ID0gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZSh0eXBlLCAodHlwZSkgPT4gU3FsVHlwZXMuaXNWYXJpYW50KHR5cGUsIGZpZWxkc01ldGFkYXRhKSwgU3FsVHlwZXMpO1xuICB0aGlzLmlzT2JqZWN0ID0gY3JlYXRlRm5Jc0NvbHVtbk9mVHlwZSh0eXBlLCAodHlwZSkgPT4gU3FsVHlwZXMuaXNPYmplY3QodHlwZSwgZmllbGRzTWV0YWRhdGEpLCBTcWxUeXBlcyk7XG4gIHRoaXMuaXNBcnJheSA9IGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUodHlwZSwgKHR5cGUpID0+IFNxbFR5cGVzLmlzQXJyYXkodHlwZSwgZmllbGRzTWV0YWRhdGEpLCBTcWxUeXBlcyk7XG4gIHRoaXMuaXNNYXAgPSBjcmVhdGVGbklzQ29sdW1uT2ZUeXBlKHR5cGUsICh0eXBlKSA9PiBTcWxUeXBlcy5pc01hcCh0eXBlLCBmaWVsZHNNZXRhZGF0YSksIFNxbFR5cGVzKTtcblxuICBsZXQgY29udmVydDtcbiAgbGV0IHRvU3RyaW5nO1xuICBsZXQgdG9WYWx1ZTtcbiAgbGV0IGZvcm1hdDtcblxuICBpZiAodGhpcy5pc051bWJlcigpKSB7XG4gICAgY29uc3QgaW50ZWdlckFzID0gc3RhdGVtZW50UGFyYW1ldGVyc1snSlNfVFJFQVRfSU5URUdFUl9BU19CSUdJTlQnXTtcbiAgICBpZiAoIWludGVnZXJBcykge1xuICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdOdW1iZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh0aGlzLmdldFNjYWxlKCkgPiAwIHx8IHRoaXMuZ2V0VHlwZSgpID09PSBTcWxUeXBlcy52YWx1ZXMuUkVBTCkge1xuICAgICAgICBjb252ZXJ0ID0gY29udmVydFJhd051bWJlcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYW4gaW50ZWdlciBzbyByZXByZXNlbnQgaXQgYXMgYSBiaWcgaW50XG4gICAgICAgIGNvbnZlcnQgPSBjb252ZXJ0UmF3QmlnSW50O1xuICAgICAgfVxuICAgIH1cbiAgICB0b1ZhbHVlID0gdG9WYWx1ZUZyb21OdW1iZXI7XG4gICAgdG9TdHJpbmcgPSB0b1N0cmluZ0Zyb21OdW1iZXI7XG4gIH0gZWxzZSBpZiAodGhpcy5pc1RpbWUoKSkge1xuICAgIGNvbnZlcnQgPSBjb252ZXJ0UmF3VGltZTtcbiAgICB0b1ZhbHVlID0gdG9WYWx1ZUZyb21UaW1lO1xuICAgIHRvU3RyaW5nID0gdG9TdHJpbmdGcm9tVGltZTtcbiAgICBmb3JtYXQgPSBzdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FX09VVFBVVF9GT1JNQVQnXTtcbiAgfSBlbHNlIHtcbiAgICB0b1ZhbHVlID0gbm9vcDtcblxuICAgIGlmICh0aGlzLmlzQm9vbGVhbigpKSB7XG4gICAgICBjb252ZXJ0ID0gY29udmVydFJhd0Jvb2xlYW47XG4gICAgICB0b1N0cmluZyA9IHRvU3RyaW5nRnJvbUJvb2xlYW47XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzRGF0ZSgpKSB7XG4gICAgICBjb252ZXJ0ID0gY29udmVydFJhd0RhdGU7XG4gICAgICB0b1N0cmluZyA9IHRvU3RyaW5nRnJvbURhdGU7XG4gICAgICBmb3JtYXQgPSBzdGF0ZW1lbnRQYXJhbWV0ZXJzWydEQVRFX09VVFBVVF9GT1JNQVQnXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNUaW1lc3RhbXAoKSkge1xuICAgICAgaWYgKHRoaXMuaXNUaW1lc3RhbXBMdHooKSkge1xuICAgICAgICBjb252ZXJ0ID0gY29udmVydFJhd1RpbWVzdGFtcEx0ejtcbiAgICAgICAgdG9TdHJpbmcgPSB0b1N0cmluZ0Zyb21UaW1lc3RhbXA7XG4gICAgICAgIGZvcm1hdCA9IHN0YXRlbWVudFBhcmFtZXRlcnNbJ1RJTUVTVEFNUF9MVFpfT1VUUFVUX0ZPUk1BVCddO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmlzVGltZXN0YW1wTnR6KCkpIHtcbiAgICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdUaW1lc3RhbXBOdHo7XG4gICAgICAgIHRvU3RyaW5nID0gdG9TdHJpbmdGcm9tVGltZXN0YW1wO1xuICAgICAgICBmb3JtYXQgPSBzdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FU1RBTVBfTlRaX09VVFBVVF9GT1JNQVQnXTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1RpbWVzdGFtcFR6KCkpIHtcbiAgICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdUaW1lc3RhbXBUejtcbiAgICAgICAgdG9TdHJpbmcgPSB0b1N0cmluZ0Zyb21UaW1lc3RhbXA7XG4gICAgICAgIGZvcm1hdCA9IHN0YXRlbWVudFBhcmFtZXRlcnNbJ1RJTUVTVEFNUF9UWl9PVVRQVVRfRk9STUFUJ107XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYSB0eXBlLXNwZWNpZmljIHRpbWV6b25lLCB1c2UgdGhlIGRlZmF1bHQgZm9ybWF0XG4gICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICBmb3JtYXQgPSBzdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FU1RBTVBfT1VUUFVUX0ZPUk1BVCddO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5pc0JpbmFyeSgpKSB7XG4gICAgICBjb252ZXJ0ID0gY29udmVydFJhd0JpbmFyeTtcbiAgICAgIHRvU3RyaW5nID0gdG9TdHJpbmdGcm9tQmluYXJ5O1xuICAgICAgZm9ybWF0ID0gc3RhdGVtZW50UGFyYW1ldGVyc1snQklOQVJZX09VVFBVVF9GT1JNQVQnXTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNWYXJpYW50KCkpIHtcbiAgICAgIGNvbnZlcnQgPSBjb252ZXJ0UmF3VmFyaWFudDtcbiAgICAgIHRvU3RyaW5nID0gdG9TdHJpbmdGcm9tUmF3VmFsdWU7XG4gICAgfSBlbHNlIGlmICh0aGlzLmlzT2JqZWN0KCkpIHtcbiAgICAgIGNvbnZlcnQgPSBjb252ZXJ0UmF3U3RydWN0dXJlZFR5cGUoY29udmVydEpzb25PYmplY3QpO1xuICAgICAgdG9TdHJpbmcgPSB0b1N0cmluZ0Zyb21SYXdWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNBcnJheSgpKSB7XG4gICAgICBjb252ZXJ0ID0gY29udmVydFJhd1N0cnVjdHVyZWRUeXBlKGNvbnZlcnRKc29uQXJyYXkpO1xuICAgICAgdG9TdHJpbmcgPSB0b1N0cmluZ0Zyb21SYXdWYWx1ZTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaXNNYXAoKSkge1xuICAgICAgY29udmVydCA9IGNvbnZlcnRSYXdTdHJ1Y3R1cmVkVHlwZShjb252ZXJ0SnNvbk1hcCk7XG4gICAgICB0b1N0cmluZyA9IHRvU3RyaW5nRnJvbVJhd1ZhbHVlO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb2x1bW4gaXMgb2YgdHlwZSBzdHJpbmcsIHNvIGxlYXZlIHZhbHVlIGFzIGlzXG4gICAgICBjb252ZXJ0ID0gbm9vcDtcbiAgICAgIHRvU3RyaW5nID0gdG9TdHJpbmdGcm9tU3RyaW5nO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNyZWF0ZSBhIHByaXZhdGUgY29udGV4dCB0byBwYXNzIHRvIHRoZSBleHRyYWN0IGZ1bmN0aW9uXG4gIGNvbnN0IGNvbnRleHQgPVxuICAgIHtcbiAgICAgIGNvbnZlcnQ6IGNvbnZlcnQsXG4gICAgICB0b1ZhbHVlOiB0b1ZhbHVlLFxuICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgICAgZm9ybWF0OiBmb3JtYXQsXG4gICAgICByZXN1bHRWZXJzaW9uOiByZXN1bHRWZXJzaW9uLFxuICAgICAgc3RhdGVtZW50UGFyYW1ldGVyczogc3RhdGVtZW50UGFyYW1ldGVycyxcbiAgICAgIGZpZWxkc01ldGFkYXRhOiBmaWVsZHNNZXRhZGF0YVxuICAgIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHZhbHVlIG9mIHRoaXMgY29sdW1uIGluIGEgcm93LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcm93XG4gICAqXG4gICAqIEByZXR1cm5zIHsqfVxuICAgKi9cbiAgdGhpcy5nZXRSb3dWYWx1ZSA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICByZXR1cm4gZXh0cmFjdEZyb21Sb3cuY2FsbCh0aGlzLCByb3csIGNvbnRleHQsIGZhbHNlKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhpcyBpbiBhIHJvdyBhcyBhIFN0cmluZy5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJvd1xuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy5nZXRSb3dWYWx1ZUFzU3RyaW5nID0gZnVuY3Rpb24gKHJvdykge1xuICAgIHJldHVybiBleHRyYWN0RnJvbVJvdy5jYWxsKHRoaXMsIHJvdywgY29udGV4dCwgdHJ1ZSk7XG4gIH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGV0ZXJtaW5lIGlmIGEgY29sdW1uIGlzIG9mIGEgZ2l2ZW5cbiAqIHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGNvbHVtblR5cGUgdGhlIGNvbHVtbiB0eXBlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gY29sdW1uQ29tcGFyaXNvbkZuIHRoZSBjb2x1bW4gY29tcGFyaXNvbiBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzY29wZSB0aGUgc2NvcGUgaW4gd2hpY2ggdG8gaW52b2tlIHRoZSBjb2x1bW4gY29tcGFyaXNvblxuICogICBmdW5jdGlvbi5cbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZuSXNDb2x1bW5PZlR5cGUoY29sdW1uVHlwZSwgY29sdW1uQ29tcGFyaXNvbkZuLCBzY29wZSkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb2x1bW5Db21wYXJpc29uRm4uY2FsbChzY29wZSwgY29sdW1uVHlwZSk7XG4gIH07XG59XG5cbi8qKlxuICogQ29udmVydHMgYSByYXcgY29sdW1uIHZhbHVlIG9mIHR5cGUgTnVtYmVyLiBUaGUgcmV0dXJuZWQgdmFsdWUgaXMgYW4gb2JqZWN0XG4gKiB0aGF0IGNvbnRhaW5zIHRoZSByYXcgc3RyaW5nIHZlcnNpb24gb2YgdGhlIHZhbHVlIGFzIHdlbGwgYXMgdGhlXG4gKiBwb3N0LXByb2Nlc3NlZCB2ZXJzaW9uIG9mIHRoZSB2YWx1ZSBvYnRhaW5lZCBhZnRlciBjYXN0aW5nIHRvIE51bWJlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmF3TnVtYmVyKHJhd0NvbHVtblZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgcmF3OiByYXdDb2x1bW5WYWx1ZSxcbiAgICBwcm9jZXNzZWQ6IE51bWJlcihyYXdDb2x1bW5WYWx1ZSlcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHJhdyBjb2x1bW4gdmFsdWUgdGhhdCBpcyBhbiBpbnRlZ2VyLiBUaGUgcmV0dXJuZWQgdmFsdWUgaXMgYW4gb2JqZWN0XG4gKiB0aGF0IGNvbnRhaW5zIHRoZSByYXcgc3RyaW5nIHZlcnNpb24gb2YgdGhlIHZhbHVlIGFzIHdlbGwgYXMgdGhlIHBvc3QtcHJvY2Vzc2VkXG4gKiB2ZXJzaW9uIG9mIHRoZSB2YWx1ZSBvYnRhaW5lZCBhZnRlciBjYXN0aW5nIHRvIGJpZ0ludFxuICpcbiAqIEBwYXJhbSByYXdDb2x1bW5WYWx1ZVxuICogQHJldHVybnMge3twcm9jZXNzZWQ6IGJpZ0ludC5CaWdJbnRlZ2VyLCByYXc6ICp9fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmF3QmlnSW50KHJhd0NvbHVtblZhbHVlKSB7XG4gIHJldHVybiB7XG4gICAgcmF3OiByYXdDb2x1bW5WYWx1ZSxcbiAgICBwcm9jZXNzZWQ6IGJpZ0ludChyYXdDb2x1bW5WYWx1ZSlcbiAgfTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHJhdyBjb2x1bW4gdmFsdWUgb2YgdHlwZSBCb29sZWFuIHRvIGEgYm9vbGVhbiAodHJ1ZSwgZmFsc2UsXG4gKiBvciBudWxsKS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhd0Jvb2xlYW4ocmF3Q29sdW1uVmFsdWUpIHtcbiAgbGV0IHJldDtcblxuICBpZiAocmF3Q29sdW1uVmFsdWUgID09PSB0cnVlIHx8IChyYXdDb2x1bW5WYWx1ZSA9PT0gJzEnKSB8fCAocmF3Q29sdW1uVmFsdWUudG9VcHBlckNhc2UoKSA9PT0gJ1RSVUUnKSkge1xuICAgIHJldCA9IHRydWU7XG4gIH0gZWxzZSBpZiAocmF3Q29sdW1uVmFsdWUgPT09IGZhbHNlIHx8IChyYXdDb2x1bW5WYWx1ZSA9PT0gJzAnKSB8fCAocmF3Q29sdW1uVmFsdWUudG9VcHBlckNhc2UoKSA9PT0gJ0ZBTFNFJykpIHtcbiAgICByZXQgPSBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFZhbHVlIGNvdWxkIG5vdCBiZSBjb252ZXJ0ZWQgdG8gYm9vbGVhbjogJHtyYXdDb2x1bW5WYWx1ZX1gKTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSBvZiBzdHJ1Y3R1cmVkIHR5cGUgb2JqZWN0IHRvIGphdmFzY3JpcHQgT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGpzb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY29udmVydEpzb25PYmplY3QoanNvbiwgY29udGV4dCkge1xuICBpZiAoY29udGV4dC5maWVsZHNNZXRhZGF0YSl7XG4gICAgY29udGV4dC5maWVsZHNNZXRhZGF0YSA9IGNvbnRleHQuZmllbGRzTWV0YWRhdGEucmVkdWNlKGZ1bmN0aW9uIChtYXAsIG9iaikge1xuICAgICAgbWFwW29iai5uYW1lXSA9IG9iajtcbiAgICAgIHJldHVybiBtYXA7XG4gICAgfSwge30pO1xuXG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgT2JqZWN0LmtleXMoanNvbikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICBjb25zdCBmaWVsZE1ldGFkYXRhID0gY29udGV4dC5maWVsZHNNZXRhZGF0YVtrZXldO1xuICAgICAgcmVzdWx0W2tleV0gPSBtYXBTdHJ1Y3R1cmVkVHlwZVZhbHVlKGpzb25ba2V5XSwgY29udGV4dCwgZmllbGRNZXRhZGF0YSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSBvZiBzdHJ1Y3R1cmVkIHR5cGUgYXJyYXkgdG8gamF2YXNjcmlwdCBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0ganNvblxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjb252ZXJ0SnNvbkFycmF5KGpzb24sIGNvbnRleHQpIHtcbiAgaWYgKGNvbnRleHQuZmllbGRzTWV0YWRhdGEpIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBqc29uLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXN1bHQucHVzaChtYXBTdHJ1Y3R1cmVkVHlwZVZhbHVlKHZhbHVlLCBjb250ZXh0LCBjb250ZXh0LmZpZWxkc01ldGFkYXRhWzBdKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4ganNvbjtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSBvZiBzdHJ1Y3R1cmVkIHR5cGUgbWFwIHRvIGphdmFzY3JpcHQgT2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGpzb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY29udmVydEpzb25NYXAoanNvbiwgY29udGV4dCkge1xuICBpZiAoQXJyYXkuaXNBcnJheShjb250ZXh0LmZpZWxkc01ldGFkYXRhKSAmJiBjb250ZXh0LmZpZWxkc01ldGFkYXRhLmxlbmd0aCA9PT0gMikge1xuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBNYXA7XG4gICAgY29uc3Qga2V5TWV0YWRhdGEgPSBjb250ZXh0LmZpZWxkc01ldGFkYXRhWzBdO1xuICAgIGNvbnN0IHZhbHVlTWV0YWRhdGEgPSBjb250ZXh0LmZpZWxkc01ldGFkYXRhWzFdO1xuICAgIE9iamVjdC5rZXlzKGpzb24pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgY29uc3QgY29udmVydGVkS2V5ID0gbWFwU3RydWN0dXJlZFR5cGVWYWx1ZShrZXksIGNvbnRleHQsIGtleU1ldGFkYXRhKTtcbiAgICAgIGNvbnN0IGNvbnZlcnRlZFZhbHVlID0gbWFwU3RydWN0dXJlZFR5cGVWYWx1ZShqc29uW2tleV0sIGNvbnRleHQsIHZhbHVlTWV0YWRhdGEpO1xuICAgICAgcmVzdWx0LnNldChjb252ZXJ0ZWRLZXksIGNvbnZlcnRlZFZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBqc29uO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSByYXcgY29sdW1uIHZhbHVlIG9mIHN0cnVjdHVyZWQgdHlwZSBPQkpFQ1QgdG8gamF2YXNjcmlwdCBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2x1bW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuY29uc3QgY29udmVydFJhd1N0cnVjdHVyZWRUeXBlID0gKGNvbnZlcnRKc29uRm4pID0+IChyYXdDb2x1bW5WYWx1ZSwgY29sdW1uLCBjb250ZXh0KSA9PiB7XG4gIGlmIChVdGlsLnN0cmluZy5pc05vdE51bGxPckVtcHR5KHJhd0NvbHVtblZhbHVlKSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShyYXdDb2x1bW5WYWx1ZSk7XG4gICAgICByZXR1cm4gY29udmVydEpzb25Gbihqc29uLCBjb250ZXh0KTtcbiAgICB9IGNhdGNoIChqc29uUGFyc2VFcnJvcikge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0NvbHVtbiAlcyByYXcgdmFsdWUgY2Fubm90IGJlIHBhcnNlZCBhcyBKU09OOiAlcyAnLCBjb2x1bW4ubmFtZSwganNvblBhcnNlRXJyb3IubWVzc2FnZSk7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IodXRpbC5mb3JtYXQoJ0NvbHVtbiBbJXNdIHJhdyB2YWx1ZSBjYW5ub3QgYmUgcGFyc2VkIGFzIEpTT046ICVzICcsIGNvbHVtbi5uYW1lLCBqc29uUGFyc2VFcnJvci5tZXNzYWdlKSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcih1dGlsLmZvcm1hdCgnQ29sdW1uICVzIHJhdyB2YWx1ZSBpcyBudWxsIG9yIGVtcHR5ICcsIGNvbHVtbi5uYW1lKSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIG1hcFN0cnVjdHVyZWRUeXBlVmFsdWUoY29sdW1uVmFsdWUsIGNvbnRleHQsIG1ldGFkYXRhRmllbGQpIHtcbiAgY29uc3QgZm9ybWF0THR6ID0gY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FU1RBTVBfTFRaX09VVFBVVF9GT1JNQVQnXSA/PyBjb250ZXh0LnN0YXRlbWVudFBhcmFtZXRlcnNbJ1RJTUVTVEFNUF9PVVRQVVRfRk9STUFUJ107XG4gIGNvbnN0IGZvcm1hdFR6ID0gY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FU1RBTVBfVFpfT1VUUFVUX0ZPUk1BVCddID8/IGNvbnRleHQuc3RhdGVtZW50UGFyYW1ldGVyc1snVElNRVNUQU1QX09VVFBVVF9GT1JNQVQnXTtcbiAgY29uc3QgZm9ybWF0TnR6ID0gY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FU1RBTVBfTlRaX09VVFBVVF9GT1JNQVQnXTtcbiAgbGV0IHZhbHVlO1xuICBzd2l0Y2ggKG1ldGFkYXRhRmllbGQudHlwZSkge1xuICBjYXNlICd0ZXh0JzpcbiAgICB2YWx1ZSA9IGNvbHVtblZhbHVlO1xuICAgIGJyZWFrO1xuICBjYXNlICdyZWFsJzpcbiAgICB2YWx1ZSA9IHRvVmFsdWVGcm9tTnVtYmVyKGNvbnZlcnRSYXdOdW1iZXIoY29sdW1uVmFsdWUpKTtcbiAgICBicmVhaztcbiAgY2FzZSAnZml4ZWQnOlxuICAgIHZhbHVlID0gdG9WYWx1ZUZyb21OdW1iZXIoY29udmVydFJhd051bWJlcihjb2x1bW5WYWx1ZSkpO1xuICAgIGJyZWFrO1xuICBjYXNlICdib29sZWFuJzpcbiAgICB2YWx1ZSA9IGNvbnZlcnRSYXdCb29sZWFuKGNvbHVtblZhbHVlKTtcbiAgICBicmVhaztcbiAgY2FzZSAndGltZXN0YW1wX2x0eic6XG4gICAgdmFsdWUgPSBjb252ZXJ0VGltZXN0YW1wVHpTdHJpbmcoY29sdW1uVmFsdWUsIGZvcm1hdEx0eiwgY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FWk9ORSddLCBtZXRhZGF0YUZpZWxkLnNjYWxlKS50b1NmRGF0ZSgpO1xuICAgIGJyZWFrO1xuICBjYXNlICd0aW1lc3RhbXBfbnR6JzpcbiAgICB2YWx1ZSA9IGNvbnZlcnRUaW1lc3RhbXBOdHpTdHJpbmcoY29sdW1uVmFsdWUsIGZvcm1hdE50eiwgbW9tZW50LnR6LnpvbmUoJ1VUQycpLCBtZXRhZGF0YUZpZWxkLnNjYWxlKS50b1NmRGF0ZSgpO1xuICAgIGJyZWFrO1xuICBjYXNlICd0aW1lc3RhbXBfdHonOlxuICAgIHZhbHVlID0gY29udmVydFRpbWVzdGFtcFR6U3RyaW5nKGNvbHVtblZhbHVlLCBmb3JtYXRUeiwgY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FWk9ORSddLCBtZXRhZGF0YUZpZWxkLnNjYWxlKS50b1NmRGF0ZSgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdkYXRlJzoge1xuICAgIGNvbnRleHQuZm9ybWF0ID0gY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydEQVRFX09VVFBVVF9GT1JNQVQnXTtcbiAgICB2YWx1ZSA9IGNvbnZlcnREYXRlU3RyaW5nKGNvbHVtblZhbHVlLCBjb250ZXh0LmZvcm1hdCApO1xuICAgIGJyZWFrO1xuICB9XG4gIGNhc2UgJ3RpbWUnOlxuICAgIGNvbnRleHQuZm9ybWF0ID0gY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydUSU1FX09VVFBVVF9GT1JNQVQnXTtcbiAgICB2YWx1ZSA9IGNvbnZlcnRUaW1lU3RyaW5nKGNvbHVtblZhbHVlLCBjb250ZXh0LmZvcm1hdCwgbW9tZW50LnR6LnpvbmUoJ1VUQycpLCBtZXRhZGF0YUZpZWxkLnNjYWxlKS50b1NmVGltZSgpO1xuICAgIGJyZWFrO1xuICBjYXNlICdiaW5hcnknOlxuICAgIGNvbnRleHQuZm9ybWF0ID0gY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzWydCSU5BUllfT1VUUFVUX0ZPUk1BVCddO1xuICAgIHZhbHVlID0gY29udmVydFJhd0JpbmFyeShjb2x1bW5WYWx1ZSwgdGhpcywgY29udGV4dCkudG9KU09OKCkuZGF0YTtcbiAgICBicmVhaztcbiAgY2FzZSAnb2JqZWN0Jzoge1xuICAgIGNvbnN0IGludGVybmFsQ29udGV4dCA9IHtcbiAgICAgIGNvbnZlcnQ6IGNvbnZlcnRSYXdTdHJ1Y3R1cmVkVHlwZShjb252ZXJ0SnNvbk9iamVjdCksXG4gICAgICB0b1ZhbHVlOiBub29wLFxuICAgICAgdG9TdHJpbmc6IHRvU3RyaW5nLFxuICAgICAgZm9ybWF0OiB0b1N0cmluZ0Zyb21SYXdWYWx1ZSxcbiAgICAgIHJlc3VsdFZlcnNpb246IGNvbnRleHQucmVzdWx0VmVyc2lvbixcbiAgICAgIHN0YXRlbWVudFBhcmFtZXRlcnM6IGNvbnRleHQuc3RhdGVtZW50UGFyYW1ldGVycyxcbiAgICAgIGZpZWxkc01ldGFkYXRhOiBtZXRhZGF0YUZpZWxkLmZpZWxkc1xuICAgIH07XG4gICAgdmFsdWUgPSBjb252ZXJ0SnNvbk9iamVjdChjb2x1bW5WYWx1ZSwgaW50ZXJuYWxDb250ZXh0KTtcbiAgICBicmVhaztcbiAgfVxuICBjYXNlICdhcnJheSc6IHtcbiAgICBjb25zdCBpbnRlcm5hbEFycmF5Q29udGV4dCA9IHtcbiAgICAgIGNvbnZlcnQ6IGNvbnZlcnRSYXdTdHJ1Y3R1cmVkVHlwZShjb252ZXJ0SnNvbkFycmF5KSxcbiAgICAgIHRvVmFsdWU6IG5vb3AsXG4gICAgICB0b1N0cmluZzogdG9TdHJpbmcsXG4gICAgICBmb3JtYXQ6IHRvU3RyaW5nRnJvbVJhd1ZhbHVlLFxuICAgICAgcmVzdWx0VmVyc2lvbjogY29udGV4dC5yZXN1bHRWZXJzaW9uLFxuICAgICAgc3RhdGVtZW50UGFyYW1ldGVyczogY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzLFxuICAgICAgZmllbGRzTWV0YWRhdGE6IG1ldGFkYXRhRmllbGQuZmllbGRzXG4gICAgfTtcbiAgICB2YWx1ZSA9IGNvbnZlcnRKc29uQXJyYXkoY29sdW1uVmFsdWUsIGludGVybmFsQXJyYXlDb250ZXh0KTtcbiAgICBicmVhaztcbiAgfVxuICBjYXNlICdtYXAnOiB7XG4gICAgY29uc3QgaW50ZXJuYWxNYXBDb250ZXh0ID0ge1xuICAgICAgY29udmVydDogY29udmVydFJhd1N0cnVjdHVyZWRUeXBlKGNvbnZlcnRKc29uTWFwKSxcbiAgICAgIHRvVmFsdWU6IG5vb3AsXG4gICAgICB0b1N0cmluZzogdG9TdHJpbmcsXG4gICAgICBmb3JtYXQ6IHRvU3RyaW5nRnJvbVJhd1ZhbHVlLFxuICAgICAgcmVzdWx0VmVyc2lvbjogY29udGV4dC5yZXN1bHRWZXJzaW9uLFxuICAgICAgc3RhdGVtZW50UGFyYW1ldGVyczogY29udGV4dC5zdGF0ZW1lbnRQYXJhbWV0ZXJzLFxuICAgICAgZmllbGRzTWV0YWRhdGE6IG1ldGFkYXRhRmllbGQuZmllbGRzXG4gICAgfTtcbiAgICB2YWx1ZSA9IGNvbnZlcnRKc29uTWFwKGNvbHVtblZhbHVlLCBpbnRlcm5hbE1hcENvbnRleHQpO1xuICAgIGJyZWFrO1xuICB9XG4gIGRlZmF1bHQ6XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbyhgQ29sdW1uIHR5cGUgbm90IHN1cHBvcnRlZDogJHtjb250ZXh0LmZpZWxkc01ldGFkYXRhLnR5cGV9YCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBDb2x1bW4gdHlwZSBub3Qgc3VwcG9ydGVkOiAke2NvbnRleHQuZmllbGRzTWV0YWRhdGEudHlwZX1gKTtcbiAgfVxuICByZXR1cm4gdmFsdWU7XG59XG5cbmNvbnN0IGNvbnZlcnRUaW1lc3RhbXBUelN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmdWYWx1ZSwgZm9ybWF0U3FsLCB0aW1lem9uZSwgc2NhbGUpIHtcbiAgY29uc3QgZm9ybWF0TW9tZW50ID0gZGF0ZVRpbWVGb3JtYXRDb252ZXJ0ZXIuY29udmVydFNub3dmbGFrZUZvcm1hdFRvTW9tZW50Rm9ybWF0KGZvcm1hdFNxbCwgc2NhbGUpO1xuICBjb25zdCBlcG9jaFNlY29uZHMgPSBtb21lbnRUaW1lem9uZShzdHJpbmdWYWx1ZSwgZm9ybWF0TW9tZW50KS51bml4KCk7XG4gIHJldHVybiBuZXcgU2ZUaW1lc3RhbXAoZXBvY2hTZWNvbmRzLCAwLCBzY2FsZSwgdGltZXpvbmUsIGZvcm1hdFNxbCk7XG59O1xuXG5jb25zdCBjb252ZXJ0VGltZXN0YW1wTnR6U3RyaW5nID0gZnVuY3Rpb24gKHN0cmluZ1ZhbHVlLCBmb3JtYXRTcWwsIHRpbWV6b25lLCBzY2FsZSkge1xuICBjb25zdCBmb3JtYXRNb21lbnQgPSBkYXRlVGltZUZvcm1hdENvbnZlcnRlci5jb252ZXJ0U25vd2ZsYWtlRm9ybWF0VG9Nb21lbnRGb3JtYXQoZm9ybWF0U3FsLCBzY2FsZSk7XG4gIGNvbnN0IGVwb2NoU2Vjb25kcyA9IG1vbWVudFRpbWV6b25lLnV0YyhzdHJpbmdWYWx1ZSwgZm9ybWF0TW9tZW50KS51bml4KCk7XG4gIHJldHVybiBuZXcgU2ZUaW1lc3RhbXAoZXBvY2hTZWNvbmRzLCAwLCBzY2FsZSwgdGltZXpvbmUsIGZvcm1hdFNxbCk7XG59O1xuXG5jb25zdCBjb252ZXJ0RGF0ZVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmdWYWx1ZSwgZm9ybWF0U3FsKSB7XG4gIGNvbnN0IGZvcm1hdE1vbWVudCA9IGRhdGVUaW1lRm9ybWF0Q29udmVydGVyLmNvbnZlcnRTbm93Zmxha2VGb3JtYXRUb01vbWVudEZvcm1hdChmb3JtYXRTcWwsIDApO1xuICBjb25zdCBlcG9jaFNlY29uZHMgPSBtb21lbnRUaW1lem9uZS51dGMoc3RyaW5nVmFsdWUsIGZvcm1hdE1vbWVudCkudW5peCgpO1xuICBjb25zdCBkYXRlID0gbmV3IFNmVGltZXN0YW1wKFxuICAgIGVwb2NoU2Vjb25kcywgLy8gY29udmVydCB0byBzZWNvbmRzXG4gICAgMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBuYW5vIHNlY29uZHNcbiAgICAwLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5vIHNjYWxlIHJlcXVpcmVkXG4gICAgJ1VUQycsICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB1c2UgdXRjIGFzIHRoZSB0aW1lem9uZVxuICAgIGNvbnRleHQuZm9ybWF0KTtcbiAgZGF0ZS5fdmFsdWVBc1N0cmluZyA9IHN0cmluZ1ZhbHVlO1xuICByZXR1cm4gZGF0ZS50b1NmRGF0ZSgpO1xufTtcblxuXG5jb25zdCBjb252ZXJ0VGltZVN0cmluZyA9IGZ1bmN0aW9uIChzdHJpbmdWYWx1ZSwgZm9ybWF0U3FsLCB0aW1lem9uZSwgc2NhbGUpIHtcbiAgY29uc3QgZm9ybWF0TW9tZW50ID0gZGF0ZVRpbWVGb3JtYXRDb252ZXJ0ZXIuY29udmVydFNub3dmbGFrZUZvcm1hdFRvTW9tZW50Rm9ybWF0KGZvcm1hdFNxbCwgc2NhbGUpO1xuICBjb25zdCBtb21lbnQgPSBtb21lbnRUaW1lem9uZShzdHJpbmdWYWx1ZSwgZm9ybWF0TW9tZW50KTtcbiAgY29uc3QgZXBvY2hTZWNvbmRzID0gbW9tZW50LmhvdXJzKCkgKiAzNjAwICsgbW9tZW50Lm1pbnV0ZXMoKSAqIDYwICsgbW9tZW50LnNlY29uZHMoKTtcbiAgY29uc3QgdGltZSA9ICBuZXcgU2ZUaW1lc3RhbXAoZXBvY2hTZWNvbmRzLCAwLCBzY2FsZSwgdGltZXpvbmUsIGZvcm1hdFNxbCk7XG4gIHRpbWUuX3ZhbHVlQXNTdHJpbmcgPSBzdHJpbmdWYWx1ZTtcbiAgcmV0dXJuIHRpbWU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSBvZiB0eXBlIERhdGUgdG8gYSBTbm93Zmxha2UgRGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2x1bW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge0RhdGV9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYXdEYXRlKHJhd0NvbHVtblZhbHVlLCBjb2x1bW4sIGNvbnRleHQpIHtcbiAgcmV0dXJuIG5ldyBTZlRpbWVzdGFtcChcbiAgICBOdW1iZXIocmF3Q29sdW1uVmFsdWUpICogODY0MDAsIC8vIGNvbnZlcnQgdG8gc2Vjb25kc1xuICAgIDAsICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbm8gbmFubyBzZWNvbmRzXG4gICAgMCwgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBubyBzY2FsZSByZXF1aXJlZFxuICAgICdVVEMnLCAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHV0YyBhcyB0aGUgdGltZXpvbmVcbiAgICBjb250ZXh0LmZvcm1hdCkudG9TZkRhdGUoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHJhdyBjb2x1bW4gdmFsdWUgb2YgdHlwZSBUaW1lIHRvIGEgU25vd2ZsYWtlIFRpbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbHVtblZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gY29sdW1uXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYXdUaW1lKHJhd0NvbHVtblZhbHVlLCBjb2x1bW4sIGNvbnRleHQpIHtcbiAgY29uc3QgY29sdW1uU2NhbGUgPSBjb2x1bW4uZ2V0U2NhbGUoKTtcblxuICAvLyB0aGUgdmFsdWVzIG1pZ2h0IGJlIGJpZyBzbyB1c2UgQmlnTnVtYmVyIHRvIGRvIGFyaXRobWV0aWNcbiAgY29uc3QgdmFsRnJhY1NlY3NCaWcgPVxuICAgIG5ldyBCaWdOdW1iZXIocmF3Q29sdW1uVmFsdWUpLnRpbWVzKE1hdGgucG93KDEwLCBjb2x1bW5TY2FsZSkpO1xuXG4gIHJldHVybiBjb252ZXJ0UmF3VGltZXN0YW1wSGVscGVyKFxuICAgIHZhbEZyYWNTZWNzQmlnLFxuICAgIGNvbHVtblNjYWxlLFxuICAgICdVVEMnLFxuICAgIGNvbnRleHQuZm9ybWF0KS50b1NmVGltZSgpO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSBvZiB0eXBlIFRJTUVTVEFNUF9MVFogdG8gYSBTbm93Zmxha2UgRGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2x1bW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge0RhdGV9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYXdUaW1lc3RhbXBMdHoocmF3Q29sdW1uVmFsdWUsIGNvbHVtbiwgY29udGV4dCkge1xuICBjb25zdCBjb2x1bW5TY2FsZSA9IGNvbHVtbi5nZXRTY2FsZSgpO1xuXG4gIC8vIHRoZSB2YWx1ZXMgbWlnaHQgYmUgYmlnIHNvIHVzZSBCaWdOdW1iZXIgdG8gZG8gYXJpdGhtZXRpY1xuICBjb25zdCB2YWxGcmFjU2Vjc0JpZyA9XG4gICAgbmV3IEJpZ051bWJlcihyYXdDb2x1bW5WYWx1ZSkudGltZXMoTWF0aC5wb3coMTAsIGNvbHVtblNjYWxlKSk7XG5cbiAgLy8gY3JlYXRlIGEgbmV3IHNub3dmbGFrZSBkYXRlXG4gIHJldHVybiBjb252ZXJ0UmF3VGltZXN0YW1wSGVscGVyKFxuICAgIHZhbEZyYWNTZWNzQmlnLFxuICAgIGNvbHVtblNjYWxlLFxuICAgIGNvbnRleHQuc3RhdGVtZW50UGFyYW1ldGVyc1snVElNRVpPTkUnXSxcbiAgICBjb250ZXh0LmZvcm1hdCkudG9TZkRhdGUoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHJhdyBjb2x1bW4gdmFsdWUgb2YgdHlwZSBUSU1FU1RBTVBfTlRaIHRvIGEgU25vd2ZsYWtlIERhdGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJhd0NvbHVtblZhbHVlXG4gKiBAcGFyYW0ge09iamVjdH0gY29sdW1uXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICpcbiAqIEByZXR1cm5zIHtEYXRlfVxuICovXG5mdW5jdGlvbiBjb252ZXJ0UmF3VGltZXN0YW1wTnR6KHJhd0NvbHVtblZhbHVlLCBjb2x1bW4sIGNvbnRleHQpIHtcbiAgY29uc3QgY29sdW1uU2NhbGUgPSBjb2x1bW4uZ2V0U2NhbGUoKTtcblxuICAvLyB0aGUgdmFsdWVzIG1pZ2h0IGJlIGJpZyBzbyB1c2UgQmlnTnVtYmVyIHRvIGRvIGFyaXRobWV0aWNcbiAgY29uc3QgdmFsRnJhY1NlY3NCaWcgPVxuICAgIG5ldyBCaWdOdW1iZXIocmF3Q29sdW1uVmFsdWUpLnRpbWVzKE1hdGgucG93KDEwLCBjb2x1bW5TY2FsZSkpO1xuXG4gIC8vIGNyZWF0ZSBhIG5ldyBzbm93Zmxha2UgZGF0ZVxuICByZXR1cm4gY29udmVydFJhd1RpbWVzdGFtcEhlbHBlcihcbiAgICB2YWxGcmFjU2Vjc0JpZyxcbiAgICBjb2x1bW5TY2FsZSxcbiAgICAnVVRDJywgICAgIC8vIGl0J3MgX250eiwgc28gdXNlIFVUQyBmb3IgdGltZXpvbmVcbiAgICBjb250ZXh0LmZvcm1hdCkudG9TZkRhdGUoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHJhdyBjb2x1bW4gdmFsdWUgb2YgdHlwZSBUSU1FU1RBTVBfVFogdG8gYSBTbm93Zmxha2UgRGF0ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2x1bW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge0RhdGV9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYXdUaW1lc3RhbXBUeihyYXdDb2x1bW5WYWx1ZSwgY29sdW1uLCBjb250ZXh0KSB7XG4gIGxldCB2YWxGcmFjU2Vjc0JpZztcbiAgbGV0IHZhbEZyYWNTZWNzV2l0aFR6QmlnO1xuICBsZXQgdGltZXpvbmVCaWc7XG4gIGxldCB0aW1lem9uZTtcbiAgbGV0IHRpbWVzdGFtcEFuZFRaSW5kZXg7XG5cbiAgLy8gY29tcHV0ZSB0aGUgc2NhbGUgZmFjdG9yXG4gIGNvbnN0IGNvbHVtblNjYWxlID0gY29sdW1uLmdldFNjYWxlKCk7XG4gIGNvbnN0IHNjYWxlRmFjdG9yID0gTWF0aC5wb3coMTAsIGNvbHVtblNjYWxlKTtcblxuICBjb25zdCByZXN1bHRWZXJzaW9uID0gY29udGV4dC5yZXN1bHRWZXJzaW9uO1xuICBpZiAocmVzdWx0VmVyc2lvbiA9PT0gJzAnIHx8IHJlc3VsdFZlcnNpb24gPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIHRoZSB2YWx1ZXMgbWlnaHQgYmUgYmlnIHNvIHVzZSBCaWdOdW1iZXIgdG8gZG8gYXJpdGhtZXRpY1xuICAgIHZhbEZyYWNTZWNzQmlnID1cbiAgICAgIG5ldyBCaWdOdW1iZXIocmF3Q29sdW1uVmFsdWUpLnRpbWVzKHNjYWxlRmFjdG9yKTtcblxuICAgIC8vIGZvciBfdHosIHRoZSB0aW1lem9uZSBpcyBiYWtlZCBpbnRvIHRoZSB2YWx1ZVxuICAgIHZhbEZyYWNTZWNzV2l0aFR6QmlnID0gdmFsRnJhY1NlY3NCaWc7XG5cbiAgICAvLyBleHRyYWN0IGV2ZXJ5dGhpbmcgYnV0IHRoZSBsb3dlc3QgMTQgYml0cyB0byBnZXQgdGhlIGZyYWN0aW9uYWwgc2Vjb25kc1xuICAgIHZhbEZyYWNTZWNzQmlnID1cbiAgICAgIHZhbEZyYWNTZWNzV2l0aFR6QmlnLmRpdmlkZWRCeSgxNjM4NCkuaW50ZWdlclZhbHVlKEJpZ051bWJlci5ST1VORF9GTE9PUik7XG5cbiAgICAvLyBleHRyYWN0IHRoZSBsb3dlc3QgMTQgYml0cyB0byBnZXQgdGhlIHRpbWV6b25lXG4gICAgaWYgKHZhbEZyYWNTZWNzV2l0aFR6QmlnLmlzR3JlYXRlclRoYW5PckVxdWFsVG8oMCkpIHtcbiAgICAgIHRpbWV6b25lQmlnID0gdmFsRnJhY1NlY3NXaXRoVHpCaWcubW9kdWxvKDE2Mzg0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGltZXpvbmVCaWcgPVxuICAgICAgICB2YWxGcmFjU2Vjc1dpdGhUekJpZy5tb2R1bG8oMTYzODQpLnBsdXMoMTYzODQpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBzcGxpdCB0aGUgdmFsdWUgaW50byBudW1iZXIgb2Ygc2Vjb25kcyBhbmQgdGltZXpvbmUgaW5kZXhcbiAgICB0aW1lc3RhbXBBbmRUWkluZGV4ID0gcmF3Q29sdW1uVmFsdWUuc3BsaXQoJyAnKTtcblxuICAgIC8vIHRoZSB2YWx1ZXMgbWlnaHQgYmUgYmlnIHNvIHVzZSBCaWdOdW1iZXIgdG8gZG8gYXJpdGhtZXRpY1xuICAgIHZhbEZyYWNTZWNzQmlnID1cbiAgICAgIG5ldyBCaWdOdW1iZXIodGltZXN0YW1wQW5kVFpJbmRleFswXSkudGltZXMoc2NhbGVGYWN0b3IpO1xuXG4gICAgdGltZXpvbmVCaWcgPSBuZXcgQmlnTnVtYmVyKHRpbWVzdGFtcEFuZFRaSW5kZXhbMV0pO1xuICB9XG5cbiAgdGltZXpvbmUgPSB0aW1lem9uZUJpZy50b051bWJlcigpO1xuXG4gIC8vIGFzc2VydCB0aGF0IHRpbWV6b25lIGlzIHZhbGlkXG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbCh0aW1lem9uZSA+PSAwICYmIHRpbWV6b25lIDw9IDI4ODApO1xuXG4gIC8vIHN1YnRyYWN0IDI0IGhvdXJzIGZyb20gdGhlIHRpbWV6b25lIHRvIG1hcCBbMCwgNDhdIHRvXG4gIC8vIFstMjQsIDI0XSwgYW5kIGNvbnZlcnQgdGhlIHJlc3VsdCB0byBhIG51bWJlclxuICB0aW1lem9uZSA9IHRpbWV6b25lIC0gMTQ0MDtcblxuICAvLyBjcmVhdGUgYSBuZXcgc25vd2ZsYWtlIGRhdGVcbiAgcmV0dXJuIGNvbnZlcnRSYXdUaW1lc3RhbXBIZWxwZXIoXG4gICAgdmFsRnJhY1NlY3NCaWcsXG4gICAgY29sdW1uU2NhbGUsXG4gICAgdGltZXpvbmUsXG4gICAgY29udGV4dC5mb3JtYXQpLnRvU2ZEYXRlKCk7XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIGZvciB0aGUgY29udmVydFJhd1RpbWVzdGFtcCooKSBmdW5jdGlvbnMuXG4gKiBSZXR1cm5zIGFuIGluc3RhbmNlIG9mIFNmVGltZXN0YW1wLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBlcG9jaEZyYWNTZWNzQmlnXG4gKiBAcGFyYW0ge051bWJlcn0gc2NhbGVcbiAqIEBwYXJhbSB7U3RyaW5nIHwgTnVtYmVyfSB0aW1lem9uZVxuICogQHBhcmFtIHtTdHJpbmd9IGZvcm1hdFxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYXdUaW1lc3RhbXBIZWxwZXIoXG4gIGVwb2NoRnJhY1NlY3NCaWcsXG4gIHNjYWxlLFxuICB0aW1lem9uZSxcbiAgZm9ybWF0KSB7XG4gIC8vIGNvbXB1dGUgdGhlIHNjYWxlIGZhY3RvclxuICBjb25zdCBzY2FsZUZhY3RvciA9IE1hdGgucG93KDEwLCBzY2FsZSk7XG5cbiAgLy8gc3BsaXQgdGhlIHZhbHVlIGludG8gZXBvY2ggc2Vjb25kcyArIG5hbm9zZWNvbmRzOyBmb3IgZXhhbXBsZSxcbiAgLy8gMTM2NTE0ODkyMy4xMjM0NTY3ODkgd2lsbCBiZSBzcGxpdCBpbnRvIDEzNjUxNDg5MjMgKGVwb2NoIHNlY29uZHMpXG4gIC8vIGFuZCAxMjM0NTY3ODkgKG5hbm8gc2Vjb25kcylcbiAgY29uc3QgdmFsU2VjQmlnID0gZXBvY2hGcmFjU2Vjc0JpZy5kaXZpZGVkQnkoc2NhbGVGYWN0b3IpLmludGVnZXJWYWx1ZShCaWdOdW1iZXIuUk9VTkRfRkxPT1IpO1xuICBjb25zdCBmcmFjdGlvbnNCaWcgPSBlcG9jaEZyYWNTZWNzQmlnLm1pbnVzKHZhbFNlY0JpZy50aW1lcyhzY2FsZUZhY3RvcikpO1xuICBjb25zdCB2YWxTZWNOYW5vQmlnID0gZnJhY3Rpb25zQmlnLnRpbWVzKE1hdGgucG93KDEwLCA5IC0gc2NhbGUpKTtcblxuICAvLyBjcmVhdGUgYSBuZXcgc25vd2ZsYWtlIGRhdGUgZnJvbSB0aGUgaW5mb3JtYXRpb25cbiAgcmV0dXJuIG5ldyBTZlRpbWVzdGFtcChcbiAgICB2YWxTZWNCaWcudG9OdW1iZXIoKSxcbiAgICB2YWxTZWNOYW5vQmlnLnRvTnVtYmVyKCksXG4gICAgc2NhbGUsXG4gICAgdGltZXpvbmUsXG4gICAgZm9ybWF0KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIHJhdyBjb2x1bW4gdmFsdWUgb2YgdHlwZSBWYXJpYW50IHRvIGEgSmF2YVNjcmlwdCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0IHwgQXJyYXl9XG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRSYXdWYXJpYW50KHJhd0NvbHVtblZhbHVlKSB7XG4gIC8vIGlmIHRoZSBpbnB1dCBpcyBhIG5vbi1lbXB0eSBzdHJpbmcsIGNvbnZlcnQgaXQgdG8gYSBqc29uIG9iamVjdFxuICBpZiAoVXRpbC5zdHJpbmcuaXNOb3ROdWxsT3JFbXB0eShyYXdDb2x1bW5WYWx1ZSkpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIEdsb2JhbENvbmZpZy5qc29uQ29sdW1uVmFyaWFudFBhcnNlcihyYXdDb2x1bW5WYWx1ZSk7XG4gICAgfSBjYXRjaCAoanNvblBhcnNlRXJyb3IpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBHbG9iYWxDb25maWcueG1sQ29sdW1uVmFyaWFudFBhcnNlcihyYXdDb2x1bW5WYWx1ZSk7XG4gICAgICB9IGNhdGNoICh4bWxQYXJzZUVycm9yKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdWYXJpYW50IGNhbm5vdCBiZSBwYXJzZWQgbmVpdGhlciBhcyBKU09OOiAlcyBub3IgYXMgWE1MOiAlcycsIGpzb25QYXJzZUVycm9yLm1lc3NhZ2UsIHhtbFBhcnNlRXJyb3IubWVzc2FnZSk7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcnMuVmFyaWFudFBhcnNlRXJyb3IoanNvblBhcnNlRXJyb3IsIHhtbFBhcnNlRXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgcmF3IGNvbHVtbiB2YWx1ZSBvZiB0eXBlIEJpbmFyeSB0byBhIEJ1ZmZlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcmF3Q29sdW1uVmFsdWVcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2x1bW5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge0J1ZmZlcn1cbiAqL1xuZnVuY3Rpb24gY29udmVydFJhd0JpbmFyeShyYXdDb2x1bW5WYWx1ZSwgY29sdW1uLCBjb250ZXh0KSB7XG4gIC8vIEVuc3VyZSB0aGUgZm9ybWF0IGlzIHZhbGlkLlxuICBjb25zdCBmb3JtYXQgPSBjb250ZXh0LmZvcm1hdC50b1VwcGVyQ2FzZSgpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoZm9ybWF0ID09PSAnSEVYJyB8fCBmb3JtYXQgPT09ICdCQVNFNjQnKTtcblxuICAvLyBEZWNvZGUgaGV4IHN0cmluZyBzZW50IGJ5IEdTLlxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuZnJvbShyYXdDb2x1bW5WYWx1ZSwgJ0hFWCcpO1xuXG4gIGlmIChmb3JtYXQgPT09ICdIRVgnKSB7XG4gICAgYnVmZmVyLnRvU3RyaW5nU2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBUaGUgcmF3IHZhbHVlIGlzIGFscmVhZHkgYW4gdXBwZXJjYXNlIGhleCBzdHJpbmcsIHNvIGp1c3QgcmV0dXJuIGl0LlxuICAgICAgLy8gTm90ZSB0aGF0IGJ1ZmZlci50b1N0cmluZyhcIkhFWFwiKSByZXR1cm5zIGEgbG93ZXJjYXNlIGhleCBzdHJpbmcsIGJ1dCB3ZVxuICAgICAgLy8gd2FudCB1cHBlciBjYXNlLlxuICAgICAgcmV0dXJuIHJhd0NvbHVtblZhbHVlO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgYnVmZmVyLnRvU3RyaW5nU2YgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50b1N0cmluZygnQkFTRTY0Jyk7XG4gICAgfTtcbiAgfVxuXG4gIGJ1ZmZlci5nZXRGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZvcm1hdDtcbiAgfTtcblxuICByZXR1cm4gYnVmZmVyO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIGlucHV0IHZhbHVlIGFzIGlzLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gbm9vcCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWU7XG59XG5cbi8qKlxuICogVGhlIHRvVmFsdWUoKSBmdW5jdGlvbiBmb3IgYSBjb2x1bW4gb2YgdHlwZSBOdW1iZXIuXG4gKlxuICogQHBhcmFtIHsqfSBjb2x1bW5WYWx1ZVxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cbmZ1bmN0aW9uIHRvVmFsdWVGcm9tTnVtYmVyKGNvbHVtblZhbHVlKSB7XG4gIHJldHVybiBjb2x1bW5WYWx1ZSA/IGNvbHVtblZhbHVlLnByb2Nlc3NlZCA6IGNvbHVtblZhbHVlO1xufVxuXG4vKipcbiAqIFRoZSB0b1ZhbHVlKCkgZnVuY3Rpb24gZm9yIGEgY29sdW1uIG9mIHR5cGUgVGltZS5cbiAqXG4gKiBAcGFyYW0geyp9IGNvbHVtblZhbHVlXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZUZyb21UaW1lKGNvbHVtblZhbHVlKSB7XG4gIC8vIHRoZXJlJ3Mgbm8gbmF0aXZlIGphdmFzY3JpcHQgdHlwZSB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlcHJlc2VudCB0aW1lLCBzb1xuICAvLyBqdXN0IGNvbnZlcnQgdG8gc3RyaW5nXG4gIHJldHVybiB0b1N0cmluZ0Zyb21UaW1lKGNvbHVtblZhbHVlKTtcbn1cblxuLyoqXG4gKiBUaGUgdG9TdHJpbmcoKSBmdW5jdGlvbiBmb3IgYSBjb2x1bW4gb2YgdHlwZSBOdW1iZXIuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvbHVtblZhbHVlXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmdGcm9tTnVtYmVyKGNvbHVtblZhbHVlKSB7XG4gIHJldHVybiAoY29sdW1uVmFsdWUgIT09IG51bGwpID8gY29sdW1uVmFsdWUucmF3IDogRGF0YVR5cGVzLmdldE51bGxWYWx1ZSgpO1xufVxuXG4vKipcbiAqIFRoZSB0b1N0cmluZygpIGZ1bmN0aW9uIGZvciBhIGNvbHVtbiBvZiB0eXBlIEJvb2xlYW4uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBjb2x1bW5WYWx1ZVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nRnJvbUJvb2xlYW4oY29sdW1uVmFsdWUpIHtcbiAgcmV0dXJuIChjb2x1bW5WYWx1ZSAhPT0gbnVsbCkgPyBTdHJpbmcoY29sdW1uVmFsdWUpLnRvVXBwZXJDYXNlKCkgOlxuICAgIERhdGFUeXBlcy5nZXROdWxsVmFsdWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgdG9TdHJpbmcoKSBmdW5jdGlvbiBmb3IgYSBjb2x1bW4gb2YgdHlwZSBEYXRlLlxuICpcbiAqIEBwYXJhbSB7RGF0ZX0gY29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b1N0cmluZ0Zyb21EYXRlKGNvbHVtblZhbHVlKSB7XG4gIHJldHVybiAoY29sdW1uVmFsdWUgIT09IG51bGwpID8gY29sdW1uVmFsdWUudG9KU09OKCkgOiBEYXRhVHlwZXMuZ2V0TnVsbFZhbHVlKCk7XG59XG5cbi8qKlxuICogVGhlIHRvU3RyaW5nKCkgZnVuY3Rpb24gZm9yIGEgY29sdW1uIG9mIHR5cGUgVGltZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b1N0cmluZ0Zyb21UaW1lKGNvbHVtblZhbHVlKSB7XG4gIHJldHVybiAoY29sdW1uVmFsdWUgIT09IG51bGwpID8gY29sdW1uVmFsdWUudG9KU09OKCkgOiBEYXRhVHlwZXMuZ2V0TnVsbFZhbHVlKCk7XG59XG5cbi8qKlxuICogVGhlIHRvU3RyaW5nKCkgZnVuY3Rpb24gZm9yIGEgY29sdW1uIG9mIHR5cGUgVGltZXN0YW1wLlxuICpcbiAqIEBwYXJhbSB7RGF0ZX0gY29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b1N0cmluZ0Zyb21UaW1lc3RhbXAoY29sdW1uVmFsdWUpIHtcbiAgcmV0dXJuIChjb2x1bW5WYWx1ZSAhPT0gbnVsbCkgPyBjb2x1bW5WYWx1ZS50b0pTT04oKSA6IERhdGFUeXBlcy5nZXROdWxsVmFsdWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgdG9TdHJpbmcoKSBmdW5jdGlvbiBmb3IgYSBjb2x1bW4gb2YgdHlwZSBWYXJpYW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb2x1bW5WYWx1ZVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nRnJvbVJhd1ZhbHVlKGNvbHVtblZhbHVlKSB7XG4gIHJldHVybiAoY29sdW1uVmFsdWUgIT09IG51bGwpID8gSlNPTi5zdHJpbmdpZnkoY29sdW1uVmFsdWUpIDogRGF0YVR5cGVzLmdldE51bGxWYWx1ZSgpO1xufVxuXG4vKipcbiAqIFRoZSB0b1N0cmluZygpIGZ1bmN0aW9uIGZvciBhIGNvbHVtbiBvZiB0eXBlIFN0cmluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gY29sdW1uVmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5mdW5jdGlvbiB0b1N0cmluZ0Zyb21TdHJpbmcoY29sdW1uVmFsdWUpIHtcbiAgcmV0dXJuIChjb2x1bW5WYWx1ZSAhPT0gbnVsbCkgPyBjb2x1bW5WYWx1ZSA6IERhdGFUeXBlcy5nZXROdWxsVmFsdWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgdG9TdHJpbmcoKSBmdW5jdGlvbiBmb3IgYSBjb2x1bW4gb2YgdHlwZSBCaW5hcnkuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNvbHVtblZhbHVlXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZnVuY3Rpb24gdG9TdHJpbmdGcm9tQmluYXJ5KGNvbHVtblZhbHVlKSB7XG4gIHJldHVybiAoY29sdW1uVmFsdWUgIT09IG51bGwpID8gY29sdW1uVmFsdWUudG9TdHJpbmdTZigpIDogRGF0YVR5cGVzLmdldE51bGxWYWx1ZSgpO1xufVxuXG4vKipcbiAqIEV4dHJhY3RzIHRoZSB2YWx1ZSBvZiBhIGNvbHVtbiBmcm9tIGEgZ2l2ZW4gcm93LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByb3dcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge0Jvb2xlYW59IGFzU3RyaW5nXG4gKlxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RGcm9tUm93KHJvdywgY29udGV4dCwgYXNTdHJpbmcpIHtcbiAgY29uc3QgbWFwID0gcm93Ll9hcnJheVByb2Nlc3NlZENvbHVtbnM7XG4gIGNvbnN0IHZhbHVlcyA9IHJvdy52YWx1ZXM7XG5cbiAgLy8gZ2V0IHRoZSB2YWx1ZVxuICBjb25zdCBjb2x1bW5JbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcbiAgbGV0IHJldCA9IHZhbHVlc1tjb2x1bW5JbmRleF07XG5cbiAgLy8gaWYgd2Ugd2FudCB0aGUgdmFsdWUgYXMgYSBzdHJpbmcsIGFuZCB0aGUgY29sdW1uIGlzIG9mIHR5cGUgdmFyaWFudCwgYW5kIHdlXG4gIC8vIGhhdmVuJ3QgYWxyZWFkeSBwcm9jZXNzZWQgdGhlIHZhbHVlIGJlZm9yZSwgd2UgZG9uJ3QgbmVlZCB0byBwcm9jZXNzIHRoZVxuICAvLyB2YWx1ZSwgc28gb25seSBwcm9jZXNzIGlmIG5vbmUgb2YgdGhlIGFmb3JlbWVudGlvbmVkIGNvbmRpdGlvbnMgYXJlIHRydWVcbiAgaWYgKCEoYXNTdHJpbmcgJiYgdGhpcy5pc1ZhcmlhbnQoKSAmJiAhbWFwW2NvbHVtbkluZGV4XSkpIHtcbiAgICAvLyBpZiB0aGUgY29sdW1uIHZhbHVlIGhhcyBub3QgYmVlbiBwcm9jZXNzZWQgeWV0LCBwcm9jZXNzIGl0LCBwdXQgaXQgYmFja1xuICAgIC8vIGluIHRoZSB2YWx1ZXMgYXJyYXksIGFuZCByZW1lbWJlciB0aGF0IHRoZSB2YWx1ZSBoYXMgYmVlbiBwcm9jZXNzZWRcbiAgICBpZiAoIW1hcFtjb2x1bW5JbmRleF0pIHtcbiAgICAgIGlmIChyZXQgIT09IG51bGwpIHtcbiAgICAgICAgcmV0ID0gdmFsdWVzW2NvbHVtbkluZGV4XSA9XG4gICAgICAgICAgY29udGV4dC5jb252ZXJ0KHZhbHVlc1tjb2x1bW5JbmRleF0sIHRoaXMsIGNvbnRleHQpO1xuICAgICAgfVxuICAgICAgbWFwW2NvbHVtbkluZGV4XSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gdXNlIHRoZSBhcHByb3ByaWF0ZSBleHRyYWN0aW9uIGZ1bmN0aW9uIGRlcGVuZGluZyBvbiB3aGV0aGVyXG4gICAgLy8gd2Ugd2FudCB0aGUgdmFsdWUgb3IgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgdGhlIHZhbHVlXG4gICAgY29uc3QgZXh0cmFjdEZuID0gIWFzU3RyaW5nID8gY29udGV4dC50b1ZhbHVlIDogY29udGV4dC50b1N0cmluZztcbiAgICByZXQgPSBleHRyYWN0Rm4ocmV0KTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gQ29sdW1uO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/result/column.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/result/data_types.js":
/*!************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/result/data_types.js ***!
  \************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\n\nconst sqlTypes =\n  {\n    values:\n      {\n        TEXT: 'text',\n        BINARY: 'binary',\n        BOOLEAN: 'boolean',\n        FIXED: 'fixed',\n        REAL: 'real',\n        DATE: 'date',\n        TIME: 'time',\n        TIMESTAMP_LTZ: 'timestamp_ltz',\n        TIMESTAMP_NTZ: 'timestamp_ntz',\n        TIMESTAMP_TZ: 'timestamp_tz',\n        VARIANT: 'variant',\n        OBJECT: 'object',\n        ARRAY: 'array',\n        MAP: 'map'\n      },\n\n    /**\n     * Determines if a column's SQL type is String.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isString: function (sqlType) {\n      return (sqlType === this.values.TEXT);\n    },\n\n    /**\n     * Determines if a column's SQL type is Binary.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isBinary: function (sqlType) {\n      return (sqlType === this.values.BINARY);\n    },\n\n    /**\n     * Determines if a column's SQL type is Boolean.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isBoolean: function (sqlType) {\n      return (sqlType === this.values.BOOLEAN);\n    },\n\n    /**\n     * Determines if a column's SQL type is Number.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isNumber: function (sqlType) {\n      return (sqlType === this.values.FIXED) || (sqlType === this.values.REAL);\n    },\n\n    /**\n     * Determines if a column's SQL type is Date.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isDate: function (sqlType) {\n      return (sqlType === this.values.DATE);\n    },\n\n    /**\n     * Determines if a column's SQL type is Time.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTime: function (sqlType) {\n      return (sqlType === this.values.TIME);\n    },\n\n    /**\n     * Determines if a column's SQL type is Timestamp.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTimestamp: function (sqlType) {\n      return (sqlType === this.values.TIMESTAMP_LTZ) ||\n        (sqlType === this.values.TIMESTAMP_NTZ) ||\n        (sqlType === this.values.TIMESTAMP_TZ);\n    },\n\n    /**\n     * Determines if a column's SQL type is TIMESTAMP_LTZ.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTimestampLtz: function (sqlType) {\n      return (sqlType === this.values.TIMESTAMP_LTZ);\n    },\n\n    /**\n     * Determines if a column's SQL type is TIMESTAMP_NTZ.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTimestampNtz: function (sqlType) {\n      return (sqlType === this.values.TIMESTAMP_NTZ);\n    },\n\n    /**\n     * Determines if a column's SQL type is TIMESTAMP_TZ.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isTimestampTz: function (sqlType) {\n      return (sqlType === this.values.TIMESTAMP_TZ);\n    },\n\n    /**\n     * Determines if a column's SQL type is Variant.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isVariant: function (sqlType, fieldsMetadata) {\n      return (sqlType === this.values.VARIANT) ||\n        (sqlType === this.values.OBJECT && fieldsMetadata == null) ||\n        (sqlType === this.values.ARRAY && fieldsMetadata == null) ||\n        (sqlType === this.values.MAP && fieldsMetadata == null);\n    },\n\n    /**\n     * Determines if a column's SQL type is Object.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isObject: function (sqlType, fieldsMetadata) {\n      return (sqlType === this.values.OBJECT && fieldsMetadata != null);\n    },\n\n    /**\n     * Determines if a column's SQL type is Array.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isArray: function (sqlType, fieldsMetadata) {\n      return (sqlType === this.values.ARRAY && fieldsMetadata != null);\n    },\n\n    /**\n     * Determines if a column's SQL type is Map.\n     *\n     * @param {Object} sqlType\n     *\n     * @returns {Boolean}\n     */\n    isMap: function (sqlType, fieldsMetadata) {\n      return (sqlType === this.values.MAP && fieldsMetadata != null);\n    }\n  };\n\nconst nativeTypes =\n  {\n    values:\n      {\n        STRING: 'STRING',\n        BOOLEAN: 'BOOLEAN',\n        NUMBER: 'NUMBER',\n        DATE: 'DATE',\n        JSON: 'JSON',\n        BUFFER: 'BUFFER',\n        OBJECT: 'OBJECT',\n        ARRAY: 'ARRAY',\n        MAP: 'MAP'\n      },\n\n    /**\n     * Determines if a given value is a valid native type.\n     *\n     * @param {*} value\n     *\n     * @returns {boolean}\n     */\n    isValidValue: function (value) {\n      return !!this.values[Util.isString(value) ? value.toUpperCase() : value];\n    },\n\n    /**\n     * Given an array of strings, returns the index of the first element that\n     * represents an invalid native type. If the values are all valid, a value of\n     * -1 is returned.\n     *\n     * @param {String[]} nativeTypes\n     *\n     * @returns {Number}\n     */\n    findInvalidValue: function (nativeTypes) {\n      // validate input\n      Errors.assertInternal(Util.isArray(nativeTypes));\n\n      // find the index of the first invalid value\n      let invalidValueIndex = -1;\n      for (let index = 0, length = nativeTypes.length; index < length; index++) {\n        if (!this.isValidValue(nativeTypes[index])) {\n          invalidValueIndex = index;\n          break;\n        }\n      }\n\n      return invalidValueIndex;\n    }\n  };\n\nlet isRepresentNullAsStringNull = true;\n\nexports.setIsRepresentNullAsStringNull = function (option) {\n  isRepresentNullAsStringNull = option;\n};\n\nexports.getNullValue = function () {\n  return isRepresentNullAsStringNull ? 'NULL' : null;\n};\n\nconst sqlTypeValues = sqlTypes.values;\nconst nativeTypeValues = nativeTypes.values;\n\nconst MAP_SQL_TO_NATIVE = {};\nMAP_SQL_TO_NATIVE[sqlTypeValues.TEXT] = nativeTypeValues.STRING;\nMAP_SQL_TO_NATIVE[sqlTypeValues.BINARY] = nativeTypeValues.BUFFER;\nMAP_SQL_TO_NATIVE[sqlTypeValues.BOOLEAN] = nativeTypeValues.BOOLEAN;\nMAP_SQL_TO_NATIVE[sqlTypeValues.FIXED] = nativeTypeValues.NUMBER;\nMAP_SQL_TO_NATIVE[sqlTypeValues.REAL] = nativeTypeValues.NUMBER;\nMAP_SQL_TO_NATIVE[sqlTypeValues.DATE] = nativeTypeValues.DATE;\nMAP_SQL_TO_NATIVE[sqlTypeValues.TIME] = nativeTypeValues.STRING;\nMAP_SQL_TO_NATIVE[sqlTypeValues.TIMESTAMP_LTZ] = nativeTypeValues.DATE;\nMAP_SQL_TO_NATIVE[sqlTypeValues.TIMESTAMP_NTZ] = nativeTypeValues.DATE;\nMAP_SQL_TO_NATIVE[sqlTypeValues.TIMESTAMP_TZ] = nativeTypeValues.DATE;\nMAP_SQL_TO_NATIVE[sqlTypeValues.VARIANT] = nativeTypeValues.JSON;\nMAP_SQL_TO_NATIVE[sqlTypeValues.OBJECT] = nativeTypeValues.OBJECT;\nMAP_SQL_TO_NATIVE[sqlTypeValues.ARRAY] = nativeTypeValues.ARRAY;\nMAP_SQL_TO_NATIVE[sqlTypeValues.MAP] = nativeTypeValues.MAP;\n\nexports.SqlTypes = sqlTypes;\nexports.NativeTypes = nativeTypes;\n\n/**\n * Given a SQL type, returns the corresponding native type.\n *\n * @param {String} sqlType\n *\n * @returns {String}\n */\nexports.toNativeType = function (sqlType) {\n  return MAP_SQL_TO_NATIVE[sqlType];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvZGF0YV90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsa0VBQVk7QUFDakMsZUFBZSxtQkFBTyxDQUFDLHNFQUFjOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsdURBQXVELGdCQUFnQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTs7QUFFQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEIsbUJBQW1COztBQUVuQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9jb25uZWN0aW9uL3Jlc3VsdC9kYXRhX3R5cGVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcblxuY29uc3Qgc3FsVHlwZXMgPVxuICB7XG4gICAgdmFsdWVzOlxuICAgICAge1xuICAgICAgICBURVhUOiAndGV4dCcsXG4gICAgICAgIEJJTkFSWTogJ2JpbmFyeScsXG4gICAgICAgIEJPT0xFQU46ICdib29sZWFuJyxcbiAgICAgICAgRklYRUQ6ICdmaXhlZCcsXG4gICAgICAgIFJFQUw6ICdyZWFsJyxcbiAgICAgICAgREFURTogJ2RhdGUnLFxuICAgICAgICBUSU1FOiAndGltZScsXG4gICAgICAgIFRJTUVTVEFNUF9MVFo6ICd0aW1lc3RhbXBfbHR6JyxcbiAgICAgICAgVElNRVNUQU1QX05UWjogJ3RpbWVzdGFtcF9udHonLFxuICAgICAgICBUSU1FU1RBTVBfVFo6ICd0aW1lc3RhbXBfdHonLFxuICAgICAgICBWQVJJQU5UOiAndmFyaWFudCcsXG4gICAgICAgIE9CSkVDVDogJ29iamVjdCcsXG4gICAgICAgIEFSUkFZOiAnYXJyYXknLFxuICAgICAgICBNQVA6ICdtYXAnXG4gICAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIFN0cmluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcWxUeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1N0cmluZzogZnVuY3Rpb24gKHNxbFR5cGUpIHtcbiAgICAgIHJldHVybiAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVEVYVCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBCaW5hcnkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNCaW5hcnk6IGZ1bmN0aW9uIChzcWxUeXBlKSB7XG4gICAgICByZXR1cm4gKHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLkJJTkFSWSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBCb29sZWFuLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNxbFR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzQm9vbGVhbjogZnVuY3Rpb24gKHNxbFR5cGUpIHtcbiAgICAgIHJldHVybiAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuQk9PTEVBTik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBOdW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNOdW1iZXI6IGZ1bmN0aW9uIChzcWxUeXBlKSB7XG4gICAgICByZXR1cm4gKHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLkZJWEVEKSB8fCAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuUkVBTCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBEYXRlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNxbFR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzRGF0ZTogZnVuY3Rpb24gKHNxbFR5cGUpIHtcbiAgICAgIHJldHVybiAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuREFURSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBUaW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNxbFR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzVGltZTogZnVuY3Rpb24gKHNxbFR5cGUpIHtcbiAgICAgIHJldHVybiAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVElNRSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBUaW1lc3RhbXAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUaW1lc3RhbXA6IGZ1bmN0aW9uIChzcWxUeXBlKSB7XG4gICAgICByZXR1cm4gKHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLlRJTUVTVEFNUF9MVFopIHx8XG4gICAgICAgIChzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5USU1FU1RBTVBfTlRaKSB8fFxuICAgICAgICAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVElNRVNUQU1QX1RaKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIFRJTUVTVEFNUF9MVFouXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUaW1lc3RhbXBMdHo6IGZ1bmN0aW9uIChzcWxUeXBlKSB7XG4gICAgICByZXR1cm4gKHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLlRJTUVTVEFNUF9MVFopO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgY29sdW1uJ3MgU1FMIHR5cGUgaXMgVElNRVNUQU1QX05UWi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcWxUeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc1RpbWVzdGFtcE50ejogZnVuY3Rpb24gKHNxbFR5cGUpIHtcbiAgICAgIHJldHVybiAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVElNRVNUQU1QX05UWik7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBjb2x1bW4ncyBTUUwgdHlwZSBpcyBUSU1FU1RBTVBfVFouXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNUaW1lc3RhbXBUejogZnVuY3Rpb24gKHNxbFR5cGUpIHtcbiAgICAgIHJldHVybiAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVElNRVNUQU1QX1RaKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIFZhcmlhbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc3FsVHlwZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNWYXJpYW50OiBmdW5jdGlvbiAoc3FsVHlwZSwgZmllbGRzTWV0YWRhdGEpIHtcbiAgICAgIHJldHVybiAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuVkFSSUFOVCkgfHxcbiAgICAgICAgKHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLk9CSkVDVCAmJiBmaWVsZHNNZXRhZGF0YSA9PSBudWxsKSB8fFxuICAgICAgICAoc3FsVHlwZSA9PT0gdGhpcy52YWx1ZXMuQVJSQVkgJiYgZmllbGRzTWV0YWRhdGEgPT0gbnVsbCkgfHxcbiAgICAgICAgKHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLk1BUCAmJiBmaWVsZHNNZXRhZGF0YSA9PSBudWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIE9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcWxUeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc09iamVjdDogZnVuY3Rpb24gKHNxbFR5cGUsIGZpZWxkc01ldGFkYXRhKSB7XG4gICAgICByZXR1cm4gKHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLk9CSkVDVCAmJiBmaWVsZHNNZXRhZGF0YSAhPSBudWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIEFycmF5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNxbFR5cGVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzQXJyYXk6IGZ1bmN0aW9uIChzcWxUeXBlLCBmaWVsZHNNZXRhZGF0YSkge1xuICAgICAgcmV0dXJuIChzcWxUeXBlID09PSB0aGlzLnZhbHVlcy5BUlJBWSAmJiBmaWVsZHNNZXRhZGF0YSAhPSBudWxsKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGNvbHVtbidzIFNRTCB0eXBlIGlzIE1hcC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzcWxUeXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc01hcDogZnVuY3Rpb24gKHNxbFR5cGUsIGZpZWxkc01ldGFkYXRhKSB7XG4gICAgICByZXR1cm4gKHNxbFR5cGUgPT09IHRoaXMudmFsdWVzLk1BUCAmJiBmaWVsZHNNZXRhZGF0YSAhPSBudWxsKTtcbiAgICB9XG4gIH07XG5cbmNvbnN0IG5hdGl2ZVR5cGVzID1cbiAge1xuICAgIHZhbHVlczpcbiAgICAgIHtcbiAgICAgICAgU1RSSU5HOiAnU1RSSU5HJyxcbiAgICAgICAgQk9PTEVBTjogJ0JPT0xFQU4nLFxuICAgICAgICBOVU1CRVI6ICdOVU1CRVInLFxuICAgICAgICBEQVRFOiAnREFURScsXG4gICAgICAgIEpTT046ICdKU09OJyxcbiAgICAgICAgQlVGRkVSOiAnQlVGRkVSJyxcbiAgICAgICAgT0JKRUNUOiAnT0JKRUNUJyxcbiAgICAgICAgQVJSQVk6ICdBUlJBWScsXG4gICAgICAgIE1BUDogJ01BUCdcbiAgICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYSB2YWxpZCBuYXRpdmUgdHlwZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgICAqL1xuICAgIGlzVmFsaWRWYWx1ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnZhbHVlc1tVdGlsLmlzU3RyaW5nKHZhbHVlKSA/IHZhbHVlLnRvVXBwZXJDYXNlKCkgOiB2YWx1ZV07XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdpdmVuIGFuIGFycmF5IG9mIHN0cmluZ3MsIHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBlbGVtZW50IHRoYXRcbiAgICAgKiByZXByZXNlbnRzIGFuIGludmFsaWQgbmF0aXZlIHR5cGUuIElmIHRoZSB2YWx1ZXMgYXJlIGFsbCB2YWxpZCwgYSB2YWx1ZSBvZlxuICAgICAqIC0xIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmdbXX0gbmF0aXZlVHlwZXNcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAgICovXG4gICAgZmluZEludmFsaWRWYWx1ZTogZnVuY3Rpb24gKG5hdGl2ZVR5cGVzKSB7XG4gICAgICAvLyB2YWxpZGF0ZSBpbnB1dFxuICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNBcnJheShuYXRpdmVUeXBlcykpO1xuXG4gICAgICAvLyBmaW5kIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgaW52YWxpZCB2YWx1ZVxuICAgICAgbGV0IGludmFsaWRWYWx1ZUluZGV4ID0gLTE7XG4gICAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IG5hdGl2ZVR5cGVzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzVmFsaWRWYWx1ZShuYXRpdmVUeXBlc1tpbmRleF0pKSB7XG4gICAgICAgICAgaW52YWxpZFZhbHVlSW5kZXggPSBpbmRleDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gaW52YWxpZFZhbHVlSW5kZXg7XG4gICAgfVxuICB9O1xuXG5sZXQgaXNSZXByZXNlbnROdWxsQXNTdHJpbmdOdWxsID0gdHJ1ZTtcblxuZXhwb3J0cy5zZXRJc1JlcHJlc2VudE51bGxBc1N0cmluZ051bGwgPSBmdW5jdGlvbiAob3B0aW9uKSB7XG4gIGlzUmVwcmVzZW50TnVsbEFzU3RyaW5nTnVsbCA9IG9wdGlvbjtcbn07XG5cbmV4cG9ydHMuZ2V0TnVsbFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gaXNSZXByZXNlbnROdWxsQXNTdHJpbmdOdWxsID8gJ05VTEwnIDogbnVsbDtcbn07XG5cbmNvbnN0IHNxbFR5cGVWYWx1ZXMgPSBzcWxUeXBlcy52YWx1ZXM7XG5jb25zdCBuYXRpdmVUeXBlVmFsdWVzID0gbmF0aXZlVHlwZXMudmFsdWVzO1xuXG5jb25zdCBNQVBfU1FMX1RPX05BVElWRSA9IHt9O1xuTUFQX1NRTF9UT19OQVRJVkVbc3FsVHlwZVZhbHVlcy5URVhUXSA9IG5hdGl2ZVR5cGVWYWx1ZXMuU1RSSU5HO1xuTUFQX1NRTF9UT19OQVRJVkVbc3FsVHlwZVZhbHVlcy5CSU5BUlldID0gbmF0aXZlVHlwZVZhbHVlcy5CVUZGRVI7XG5NQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlVmFsdWVzLkJPT0xFQU5dID0gbmF0aXZlVHlwZVZhbHVlcy5CT09MRUFOO1xuTUFQX1NRTF9UT19OQVRJVkVbc3FsVHlwZVZhbHVlcy5GSVhFRF0gPSBuYXRpdmVUeXBlVmFsdWVzLk5VTUJFUjtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuUkVBTF0gPSBuYXRpdmVUeXBlVmFsdWVzLk5VTUJFUjtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuREFURV0gPSBuYXRpdmVUeXBlVmFsdWVzLkRBVEU7XG5NQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlVmFsdWVzLlRJTUVdID0gbmF0aXZlVHlwZVZhbHVlcy5TVFJJTkc7XG5NQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlVmFsdWVzLlRJTUVTVEFNUF9MVFpdID0gbmF0aXZlVHlwZVZhbHVlcy5EQVRFO1xuTUFQX1NRTF9UT19OQVRJVkVbc3FsVHlwZVZhbHVlcy5USU1FU1RBTVBfTlRaXSA9IG5hdGl2ZVR5cGVWYWx1ZXMuREFURTtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuVElNRVNUQU1QX1RaXSA9IG5hdGl2ZVR5cGVWYWx1ZXMuREFURTtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuVkFSSUFOVF0gPSBuYXRpdmVUeXBlVmFsdWVzLkpTT047XG5NQVBfU1FMX1RPX05BVElWRVtzcWxUeXBlVmFsdWVzLk9CSkVDVF0gPSBuYXRpdmVUeXBlVmFsdWVzLk9CSkVDVDtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuQVJSQVldID0gbmF0aXZlVHlwZVZhbHVlcy5BUlJBWTtcbk1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVWYWx1ZXMuTUFQXSA9IG5hdGl2ZVR5cGVWYWx1ZXMuTUFQO1xuXG5leHBvcnRzLlNxbFR5cGVzID0gc3FsVHlwZXM7XG5leHBvcnRzLk5hdGl2ZVR5cGVzID0gbmF0aXZlVHlwZXM7XG5cbi8qKlxuICogR2l2ZW4gYSBTUUwgdHlwZSwgcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyBuYXRpdmUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3FsVHlwZVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cbmV4cG9ydHMudG9OYXRpdmVUeXBlID0gZnVuY3Rpb24gKHNxbFR5cGUpIHtcbiAgcmV0dXJuIE1BUF9TUUxfVE9fTkFUSVZFW3NxbFR5cGVdO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/result/data_types.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/result/datetime_format_converter.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/result/datetime_format_converter.js ***!
  \***************************************************************************************/
/***/ ((module) => {

eval("/**\n * The map of symbols for datatime representation in Snowflake and in Moment.js formatting.\n * The order of tags is important Please don't change it\n */\nfunction formatTagsMap() {\n  return [\n    // proper mappings\n    ['YYYY', 'YYYY'],\n    ['YY', 'YY'],\n    ['MM', 'MM'],\n    ['MON', 'MMM'],\n    ['DD', 'DD'],\n    ['DY', 'ddd'],\n    ['HH24', 'HH'],\n    ['HH12', 'hh'],\n    ['HH', 'HH'],\n    ['AM', 'A'],\n    ['PM', 'A'],\n    ['MI', 'mm'],\n    ['SS', 'ss'],\n    ['TZH:TZM', 'Z'],\n    ['TZHTZM', 'ZZ'],\n\n    // special code needed\n    ['TZH', ''],\n    ['TZM', ''],\n    ['FF', '']\n  ];\n}\n\nfunction convertSnowflakeFormatToMomentFormat(formatSql, scale) {\n  const tags = formatTagsMap();\n\n  // get an upper-case version of the input sql format\n  const formatSqlUpper = formatSql.toUpperCase();\n\n  // iterate over the format string\n  const length = formatSql.length;\n  let formatMoment = '';\n  for (let pos = 0; pos < length;) {\n    let tag = null;\n    let out = null;\n\n    // at each position, check if there's a tag at that position; if so, use\n    // 'out' as the replacement\n    for (let index = 0; index < tags.length; index++) {\n      if (formatSqlUpper.substr(pos).indexOf(tags[index][0]) === 0) {\n        tag = tags[index][0];\n        out = tags[index][1];\n        break;\n      }\n    }\n\n    // if we didn't find a match, just insert the character after escaping it\n    // (by wrapping it in square brackets)\n    if (out === null) {\n      formatMoment += formatSql[pos];\n      pos++;\n    } else {\n      // we found one of our special tags\n      if (out === '') {\n        if (tag === 'TZH') {\n          out = 'Z';\n        } else if (tag === 'FF') {\n          // if 'FF' is followed by a digit, use the digit as the scale\n          let digit = null;\n          if (pos + tag.length < length) {\n            const matches = formatSql[pos + tag.length].match(/[0-9]/);\n            if (matches) {\n              digit = matches[0];\n            }\n          }\n          if (digit !== null) {\n            pos++; // skip the digit as well\n          }\n\n          // if we need to include fractional seconds\n          if (scale > 0) {\n            // divide the nanoSeconds to get the requested number of\n            // meaningful digits\n            // pad with the appropriate number of leading zeros\n            out = (new Array(9).join('S')).substr(-scale);\n          }\n        }\n      }\n\n      // append the 'out' text to the moment format and update the position\n      formatMoment += out;\n      pos += tag.length;\n    }\n  }\n  return formatMoment;\n}\n\nmodule.exports.formatTagsMap = formatTagsMap;\nmodule.exports.convertSnowflakeFormatToMomentFormat = convertSnowflakeFormatToMomentFormat;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvZGF0ZXRpbWVfZm9ybWF0X2NvbnZlcnRlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7O0FBRUEsa0VBQWtFO0FBQ2xFO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QixtREFBbUQiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvZGF0ZXRpbWVfZm9ybWF0X2NvbnZlcnRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIFRoZSBtYXAgb2Ygc3ltYm9scyBmb3IgZGF0YXRpbWUgcmVwcmVzZW50YXRpb24gaW4gU25vd2ZsYWtlIGFuZCBpbiBNb21lbnQuanMgZm9ybWF0dGluZy5cbiAqIFRoZSBvcmRlciBvZiB0YWdzIGlzIGltcG9ydGFudCBQbGVhc2UgZG9uJ3QgY2hhbmdlIGl0XG4gKi9cbmZ1bmN0aW9uIGZvcm1hdFRhZ3NNYXAoKSB7XG4gIHJldHVybiBbXG4gICAgLy8gcHJvcGVyIG1hcHBpbmdzXG4gICAgWydZWVlZJywgJ1lZWVknXSxcbiAgICBbJ1lZJywgJ1lZJ10sXG4gICAgWydNTScsICdNTSddLFxuICAgIFsnTU9OJywgJ01NTSddLFxuICAgIFsnREQnLCAnREQnXSxcbiAgICBbJ0RZJywgJ2RkZCddLFxuICAgIFsnSEgyNCcsICdISCddLFxuICAgIFsnSEgxMicsICdoaCddLFxuICAgIFsnSEgnLCAnSEgnXSxcbiAgICBbJ0FNJywgJ0EnXSxcbiAgICBbJ1BNJywgJ0EnXSxcbiAgICBbJ01JJywgJ21tJ10sXG4gICAgWydTUycsICdzcyddLFxuICAgIFsnVFpIOlRaTScsICdaJ10sXG4gICAgWydUWkhUWk0nLCAnWlonXSxcblxuICAgIC8vIHNwZWNpYWwgY29kZSBuZWVkZWRcbiAgICBbJ1RaSCcsICcnXSxcbiAgICBbJ1RaTScsICcnXSxcbiAgICBbJ0ZGJywgJyddXG4gIF07XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRTbm93Zmxha2VGb3JtYXRUb01vbWVudEZvcm1hdChmb3JtYXRTcWwsIHNjYWxlKSB7XG4gIGNvbnN0IHRhZ3MgPSBmb3JtYXRUYWdzTWFwKCk7XG5cbiAgLy8gZ2V0IGFuIHVwcGVyLWNhc2UgdmVyc2lvbiBvZiB0aGUgaW5wdXQgc3FsIGZvcm1hdFxuICBjb25zdCBmb3JtYXRTcWxVcHBlciA9IGZvcm1hdFNxbC50b1VwcGVyQ2FzZSgpO1xuXG4gIC8vIGl0ZXJhdGUgb3ZlciB0aGUgZm9ybWF0IHN0cmluZ1xuICBjb25zdCBsZW5ndGggPSBmb3JtYXRTcWwubGVuZ3RoO1xuICBsZXQgZm9ybWF0TW9tZW50ID0gJyc7XG4gIGZvciAobGV0IHBvcyA9IDA7IHBvcyA8IGxlbmd0aDspIHtcbiAgICBsZXQgdGFnID0gbnVsbDtcbiAgICBsZXQgb3V0ID0gbnVsbDtcblxuICAgIC8vIGF0IGVhY2ggcG9zaXRpb24sIGNoZWNrIGlmIHRoZXJlJ3MgYSB0YWcgYXQgdGhhdCBwb3NpdGlvbjsgaWYgc28sIHVzZVxuICAgIC8vICdvdXQnIGFzIHRoZSByZXBsYWNlbWVudFxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCB0YWdzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgaWYgKGZvcm1hdFNxbFVwcGVyLnN1YnN0cihwb3MpLmluZGV4T2YodGFnc1tpbmRleF1bMF0pID09PSAwKSB7XG4gICAgICAgIHRhZyA9IHRhZ3NbaW5kZXhdWzBdO1xuICAgICAgICBvdXQgPSB0YWdzW2luZGV4XVsxXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgd2UgZGlkbid0IGZpbmQgYSBtYXRjaCwganVzdCBpbnNlcnQgdGhlIGNoYXJhY3RlciBhZnRlciBlc2NhcGluZyBpdFxuICAgIC8vIChieSB3cmFwcGluZyBpdCBpbiBzcXVhcmUgYnJhY2tldHMpXG4gICAgaWYgKG91dCA9PT0gbnVsbCkge1xuICAgICAgZm9ybWF0TW9tZW50ICs9IGZvcm1hdFNxbFtwb3NdO1xuICAgICAgcG9zKys7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHdlIGZvdW5kIG9uZSBvZiBvdXIgc3BlY2lhbCB0YWdzXG4gICAgICBpZiAob3V0ID09PSAnJykge1xuICAgICAgICBpZiAodGFnID09PSAnVFpIJykge1xuICAgICAgICAgIG91dCA9ICdaJztcbiAgICAgICAgfSBlbHNlIGlmICh0YWcgPT09ICdGRicpIHtcbiAgICAgICAgICAvLyBpZiAnRkYnIGlzIGZvbGxvd2VkIGJ5IGEgZGlnaXQsIHVzZSB0aGUgZGlnaXQgYXMgdGhlIHNjYWxlXG4gICAgICAgICAgbGV0IGRpZ2l0ID0gbnVsbDtcbiAgICAgICAgICBpZiAocG9zICsgdGFnLmxlbmd0aCA8IGxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hlcyA9IGZvcm1hdFNxbFtwb3MgKyB0YWcubGVuZ3RoXS5tYXRjaCgvWzAtOV0vKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgICAgICAgIGRpZ2l0ID0gbWF0Y2hlc1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRpZ2l0ICE9PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MrKzsgLy8gc2tpcCB0aGUgZGlnaXQgYXMgd2VsbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHdlIG5lZWQgdG8gaW5jbHVkZSBmcmFjdGlvbmFsIHNlY29uZHNcbiAgICAgICAgICBpZiAoc2NhbGUgPiAwKSB7XG4gICAgICAgICAgICAvLyBkaXZpZGUgdGhlIG5hbm9TZWNvbmRzIHRvIGdldCB0aGUgcmVxdWVzdGVkIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gbWVhbmluZ2Z1bCBkaWdpdHNcbiAgICAgICAgICAgIC8vIHBhZCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvc1xuICAgICAgICAgICAgb3V0ID0gKG5ldyBBcnJheSg5KS5qb2luKCdTJykpLnN1YnN0cigtc2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhcHBlbmQgdGhlICdvdXQnIHRleHQgdG8gdGhlIG1vbWVudCBmb3JtYXQgYW5kIHVwZGF0ZSB0aGUgcG9zaXRpb25cbiAgICAgIGZvcm1hdE1vbWVudCArPSBvdXQ7XG4gICAgICBwb3MgKz0gdGFnLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZvcm1hdE1vbWVudDtcbn1cblxubW9kdWxlLmV4cG9ydHMuZm9ybWF0VGFnc01hcCA9IGZvcm1hdFRhZ3NNYXA7XG5tb2R1bGUuZXhwb3J0cy5jb252ZXJ0U25vd2ZsYWtlRm9ybWF0VG9Nb21lbnRGb3JtYXQgPSBjb252ZXJ0U25vd2ZsYWtlRm9ybWF0VG9Nb21lbnRGb3JtYXQ7XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/result/datetime_format_converter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/result/doubly_linked_list.js":
/*!********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/result/doubly_linked_list.js ***!
  \********************************************************************************/
/***/ ((module) => {

eval("function DoublyLinkedList() {\n  this._length = 0;\n  this._head = null;\n  this._tail = null;\n}\n\n/**\n * Returns the length of the list.\n *\n * @returns {number}\n */\nDoublyLinkedList.prototype.getLength = function () {\n  return this._length;\n};\n\n/**\n * Returns the first element in the list.\n *\n * @returns {Object}\n */\nDoublyLinkedList.prototype.getHead = function () {\n  return this._head;\n};\n\n/**\n * Returns the last element in the list.\n *\n * @returns {Object}\n */\nDoublyLinkedList.prototype.getTail = function () {\n  return this._tail;\n};\n\n/**\n * Inserts a value at the end of the list.\n *\n * @param value\n *\n * @returns {Object} the node that was inserted into the list.\n */\nDoublyLinkedList.prototype.insertEnd = function (value) {\n  // create a node from the specified value\n  const node = new Node(value, null, null);\n\n  // if there are no element in the list yet\n  if (this._length === 0) {\n    this._head = node;\n    this._tail = node;\n  } else {\n    // add the node to the end\n    this._tail.setNext(node);\n    node.setPrev(this._tail);\n    this._tail = node;\n  }\n\n  // increment the length\n  this._length++;\n\n  // return the node that was created\n  return node;\n};\n\n/**\n * Removes a given node from the list.\n *\n * @param node\n */\nDoublyLinkedList.prototype.remove = function (node) {\n  // if no node was specified, we have nothing to do\n  if (!node) {\n    return;\n  }\n\n  // if we're removing the first element in the list, adjust the head,\n  // otherwise connect the node's previous to its next\n  if (node.getPrev() === null) {\n    this._head = node.getNext();\n  } else {\n    node.getPrev().setNext(node.getNext());\n  }\n\n  // if we're removing the last element in the list, adjust the tail,\n  // otherwise connect the node's next to its previous\n  if (node.getNext() === null) {\n    this._tail = node.getPrev();\n  } else {\n    node.getNext().setPrev(node.getPrev());\n  }\n\n  // decrement the length\n  this._length--;\n};\n\nfunction Node(value, prev, next) {\n  this._value = value;\n  this._prev = prev;\n  this._next = next;\n}\n\nNode.prototype.getValue = function () {\n  return this._value;\n};\n\nNode.prototype.getPrev = function () {\n  return this._prev;\n};\n\nNode.prototype.setPrev = function (prev) {\n  this._prev = prev;\n};\n\nNode.prototype.getNext = function () {\n  return this._next;\n};\n\nNode.prototype.setNext = function (next) {\n  this._next = next;\n};\n\nmodule.exports = DoublyLinkedList;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvZG91Ymx5X2xpbmtlZF9saXN0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2Nvbm5lY3Rpb24vcmVzdWx0L2RvdWJseV9saW5rZWRfbGlzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBEb3VibHlMaW5rZWRMaXN0KCkge1xuICB0aGlzLl9sZW5ndGggPSAwO1xuICB0aGlzLl9oZWFkID0gbnVsbDtcbiAgdGhpcy5fdGFpbCA9IG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGVuZ3RoIG9mIHRoZSBsaXN0LlxuICpcbiAqIEByZXR1cm5zIHtudW1iZXJ9XG4gKi9cbkRvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmdldExlbmd0aCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2xlbmd0aDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZmlyc3QgZWxlbWVudCBpbiB0aGUgbGlzdC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5Eb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5nZXRIZWFkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5faGVhZDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IGluIHRoZSBsaXN0LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbkRvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLmdldFRhaWwgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl90YWlsO1xufTtcblxuLyoqXG4gKiBJbnNlcnRzIGEgdmFsdWUgYXQgdGhlIGVuZCBvZiB0aGUgbGlzdC5cbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgbm9kZSB0aGF0IHdhcyBpbnNlcnRlZCBpbnRvIHRoZSBsaXN0LlxuICovXG5Eb3VibHlMaW5rZWRMaXN0LnByb3RvdHlwZS5pbnNlcnRFbmQgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgLy8gY3JlYXRlIGEgbm9kZSBmcm9tIHRoZSBzcGVjaWZpZWQgdmFsdWVcbiAgY29uc3Qgbm9kZSA9IG5ldyBOb2RlKHZhbHVlLCBudWxsLCBudWxsKTtcblxuICAvLyBpZiB0aGVyZSBhcmUgbm8gZWxlbWVudCBpbiB0aGUgbGlzdCB5ZXRcbiAgaWYgKHRoaXMuX2xlbmd0aCA9PT0gMCkge1xuICAgIHRoaXMuX2hlYWQgPSBub2RlO1xuICAgIHRoaXMuX3RhaWwgPSBub2RlO1xuICB9IGVsc2Uge1xuICAgIC8vIGFkZCB0aGUgbm9kZSB0byB0aGUgZW5kXG4gICAgdGhpcy5fdGFpbC5zZXROZXh0KG5vZGUpO1xuICAgIG5vZGUuc2V0UHJldih0aGlzLl90YWlsKTtcbiAgICB0aGlzLl90YWlsID0gbm9kZTtcbiAgfVxuXG4gIC8vIGluY3JlbWVudCB0aGUgbGVuZ3RoXG4gIHRoaXMuX2xlbmd0aCsrO1xuXG4gIC8vIHJldHVybiB0aGUgbm9kZSB0aGF0IHdhcyBjcmVhdGVkXG4gIHJldHVybiBub2RlO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgZ2l2ZW4gbm9kZSBmcm9tIHRoZSBsaXN0LlxuICpcbiAqIEBwYXJhbSBub2RlXG4gKi9cbkRvdWJseUxpbmtlZExpc3QucHJvdG90eXBlLnJlbW92ZSA9IGZ1bmN0aW9uIChub2RlKSB7XG4gIC8vIGlmIG5vIG5vZGUgd2FzIHNwZWNpZmllZCwgd2UgaGF2ZSBub3RoaW5nIHRvIGRvXG4gIGlmICghbm9kZSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIGlmIHdlJ3JlIHJlbW92aW5nIHRoZSBmaXJzdCBlbGVtZW50IGluIHRoZSBsaXN0LCBhZGp1c3QgdGhlIGhlYWQsXG4gIC8vIG90aGVyd2lzZSBjb25uZWN0IHRoZSBub2RlJ3MgcHJldmlvdXMgdG8gaXRzIG5leHRcbiAgaWYgKG5vZGUuZ2V0UHJldigpID09PSBudWxsKSB7XG4gICAgdGhpcy5faGVhZCA9IG5vZGUuZ2V0TmV4dCgpO1xuICB9IGVsc2Uge1xuICAgIG5vZGUuZ2V0UHJldigpLnNldE5leHQobm9kZS5nZXROZXh0KCkpO1xuICB9XG5cbiAgLy8gaWYgd2UncmUgcmVtb3ZpbmcgdGhlIGxhc3QgZWxlbWVudCBpbiB0aGUgbGlzdCwgYWRqdXN0IHRoZSB0YWlsLFxuICAvLyBvdGhlcndpc2UgY29ubmVjdCB0aGUgbm9kZSdzIG5leHQgdG8gaXRzIHByZXZpb3VzXG4gIGlmIChub2RlLmdldE5leHQoKSA9PT0gbnVsbCkge1xuICAgIHRoaXMuX3RhaWwgPSBub2RlLmdldFByZXYoKTtcbiAgfSBlbHNlIHtcbiAgICBub2RlLmdldE5leHQoKS5zZXRQcmV2KG5vZGUuZ2V0UHJldigpKTtcbiAgfVxuXG4gIC8vIGRlY3JlbWVudCB0aGUgbGVuZ3RoXG4gIHRoaXMuX2xlbmd0aC0tO1xufTtcblxuZnVuY3Rpb24gTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCkge1xuICB0aGlzLl92YWx1ZSA9IHZhbHVlO1xuICB0aGlzLl9wcmV2ID0gcHJldjtcbiAgdGhpcy5fbmV4dCA9IG5leHQ7XG59XG5cbk5vZGUucHJvdG90eXBlLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fdmFsdWU7XG59O1xuXG5Ob2RlLnByb3RvdHlwZS5nZXRQcmV2ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcHJldjtcbn07XG5cbk5vZGUucHJvdG90eXBlLnNldFByZXYgPSBmdW5jdGlvbiAocHJldikge1xuICB0aGlzLl9wcmV2ID0gcHJldjtcbn07XG5cbk5vZGUucHJvdG90eXBlLmdldE5leHQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9uZXh0O1xufTtcblxuTm9kZS5wcm90b3R5cGUuc2V0TmV4dCA9IGZ1bmN0aW9uIChuZXh0KSB7XG4gIHRoaXMuX25leHQgPSBuZXh0O1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBEb3VibHlMaW5rZWRMaXN0OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/result/doubly_linked_list.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/result/result.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/result/result.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst Chunk = __webpack_require__(/*! ./chunk */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/chunk.js\");\nconst ResultStream = __webpack_require__(/*! ./result_stream */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/result_stream.js\");\nconst ChunkCache = __webpack_require__(/*! ./chunk_cache */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/chunk_cache.js\");\nconst Column = __webpack_require__(/*! ./column */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/column.js\");\nconst StatementType = __webpack_require__(/*! ./statement_type */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/statement_type.js\");\nconst ColumnNamesCreator = __webpack_require__(/*! ./unique_column_name_creator */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/unique_column_name_creator.js\");\nconst RowMode = __webpack_require__(/*! ../../constants/row_mode */ \"(rsc)/./node_modules/snowflake-sdk/lib/constants/row_mode.js\");\nconst Logger = __webpack_require__(/*! ../../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\n\n/**\n * Creates a new Result.\n *\n * @param {Object} options\n * @constructor\n */\nfunction Result(options) {\n  let chunkHeaders;\n  let length;\n  let index;\n  let parameter;\n  let mapColumnNameToIndices;\n  let columns;\n  let column;\n  let version;\n\n  // assert that options is a valid object that contains a response, statement,\n  // services and connection config\n  Errors.assertInternal(Util.isObject(options));\n  Errors.assertInternal(Util.isObject(options.response));\n  Errors.assertInternal(Util.isObject(options.statement));\n  Errors.assertInternal(Util.isObject(options.services));\n  Errors.assertInternal(Util.isObject(options.connectionConfig));\n\n  // save the statement, services and connection config\n  this._statement = options.statement;\n  this._services = options.services;\n  this._connectionConfig = options.connectionConfig;\n\n  const data = options.response.data;\n\n  this._queryId = data.queryId;\n  this._version = version = String(data.version); // don't rely on the version being a number\n  this._returnedRows = data.returned;\n  this._totalRows = data.total;\n  this._statementTypeId = data.statementTypeId;\n  this._queryContext = data.queryContext;\n\n  // if no chunk headers were specified, but a query-result-master-key (qrmk)\n  // was specified, build the chunk headers from the qrmk\n  chunkHeaders = data.chunkHeaders;\n  if (!Util.isObject(chunkHeaders) && Util.isString(data.qrmk)) {\n    chunkHeaders =\n      {\n        'x-amz-server-side-encryption-customer-algorithm': 'AES256',\n        'x-amz-server-side-encryption-customer-key': data.qrmk\n      };\n  }\n  this._chunkHeaders = chunkHeaders;\n\n  // build a session state object from the response data; this can be used to\n  // get the values of the current role, current warehouse, current database,\n  // etc.\n  this._sessionState = createSessionState(data);\n\n  // convert the parameters array to a map\n  const parametersMap = {};\n  const parametersArray = data.parameters || [];\n  for (index = 0, length = parametersArray.length; index < length; index++) {\n    parameter = parametersArray[index];\n    parametersMap[parameter.name] = parameter.value;\n  }\n\n  // save the parameters array\n  this._parametersArray = parametersArray;\n\n  // TODO: add timezone related information to columns\n\n  // create columns from the rowtype array returned in the result\n  const rowtype = data.rowtype;\n  const numColumns = rowtype.length;\n\n  this._columns = columns = new Array(numColumns);\n\n  // convert the rowtype array to an array of columns and build an inverted\n  // index map in which the keys are the column names and the values are the\n  // indices of the columns with the corresponding names\n  this._mapColumnNameToIndices = mapColumnNameToIndices = {};\n\n  const rowMode = options.rowMode;\n  if (rowMode === RowMode.OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS) {\n    ColumnNamesCreator.addOverridenNamesForDuplicatedColumns(rowtype);\n  }\n\n  Logger.getInstance().trace(`Mapping columns in resultset (total: ${numColumns})`);\n  for (let index = 0; index < numColumns; index++) {\n\n    // create a new column and add it to the columns array\n    columns[index] = column =\n      new Column(rowtype[index], index, parametersMap, version);\n\n    // if we don't already have an index array for a column with this name,\n    // create a new one, otherwise just append to the existing array of indices\n    mapColumnNameToIndices[column.getName()] =\n      mapColumnNameToIndices[column.getName()] || [];\n    mapColumnNameToIndices[column.getName()].push(index);\n  }\n  Logger.getInstance().trace('Finished mapping columns.');\n\n  // create chunks\n  this._chunks = createChunks(\n    data.chunks,\n    data.rowset,\n    this._columns,\n    this._mapColumnNameToIndices,\n    this._chunkHeaders,\n    parametersMap,\n    this._version,\n    this._statement,\n    this._services);\n\n  this.getQueryContext = function () {\n    return this._queryContext;\n  };\n\n  /* Disable the ChunkCache until the implementation is complete.\n   * \n   *   // create a chunk cache and save a reference to it in case we need to\n   *   // TODO: should we be clearing the cache at some point, e.g. when the result\n   *   // is destroyed?\n   *   this._chunkCache = createChunkCache(\n   *   this._chunks,\n   *   this._connectionConfig.getResultChunkCacheSize());\n    */\n}\n\nUtil.inherits(Result, EventEmitter);\n\n/**\n * Refreshes the result by updating the chunk urls.\n *\n * @param response\n */\nResult.prototype.refresh = function (response) {\n  const chunks = this._chunks;\n  const chunkCfgs = response.data.chunks;\n  for (let index = 0, length = chunks.length; index < length; index++) {\n    chunks[index].setUrl(chunkCfgs[index].url);\n  }\n};\n\n/**\n * TODO\n *\n * @param chunks\n * @param capacity\n *\n * @returns {ChunkCache}\n */\n// eslint-disable-next-line no-unused-vars\nfunction createChunkCache(chunks, capacity) {\n  let index;\n  let length;\n\n  // create a chunk cache\n  const chunkCache = new ChunkCache(capacity);\n\n  // every time a chunk is loaded, add it to the cache\n  // TODO: should the caching be based on most recently 'used' or most recently\n  // 'loaded'?\n  const onLoadComplete = function (err, chunk) {\n    if (!err) {\n      chunkCache.put(chunk);\n    }\n  };\n\n  // subscribe to the 'loadcomplete' event on all the chunks\n  for (index = 0, length = chunks.length; index < length; index++) {\n    chunks[index].on('loadcomplete', onLoadComplete);\n  }\n\n  // TODO: do we need to unsubscribe from the loadcomplete event at some point?\n\n  return chunkCache;\n}\n\n/**\n * Creates a session state object from the values of the current role, current\n * warehouse, etc., returned in the result response.\n *\n * @param responseData\n *\n * @returns {Object}\n */\nfunction createSessionState(responseData) {\n  const currentRole = responseData.finalRoleName;\n  const currentWarehouse = responseData.finalWarehouseName;\n  const currentDatabaseProvider = responseData.databaseProvider;\n  const currentDatabase = responseData.finalDatabaseName;\n  const currentSchema = responseData.finalSchemaName;\n\n  return {\n    getCurrentRole: function () {\n      return currentRole;\n    },\n    getCurrentWarehouse: function () {\n      return currentWarehouse;\n    },\n    getCurrentDatabaseProvider: function () {\n      return currentDatabaseProvider;\n    },\n    getCurrentDatabase: function () {\n      return currentDatabase;\n    },\n    getCurrentSchema: function () {\n      return currentSchema;\n    }\n  };\n}\n\n/**\n * Creates an array of Chunk instances from the chunk-related information in the\n * result response.\n *\n * @param chunkCfgs\n * @param rowset\n * @param columns\n * @param mapColumnNameToIndices\n * @param chunkHeaders\n * @param statementParameters\n * @param resultVersion\n * @param statement\n * @param services\n *\n * @returns {Chunk}\n */\nfunction createChunks(chunkCfgs,\n  rowset,\n  columns,\n  mapColumnNameToIndices,\n  chunkHeaders,\n  statementParameters,\n  resultVersion,\n  statement,\n  services) {\n  let startIndex;\n  let index;\n  let chunkCfg;\n\n  // if we don't have any chunks, or if some records were returned inline,\n  // fabricate a config object for the first chunk\n  chunkCfgs = chunkCfgs || [];\n  if (!chunkCfgs || rowset.length > 0) {\n    chunkCfgs.unshift(\n      {\n        rowCount: rowset.length,\n        url: null,\n        rowset: rowset\n      });\n  }\n\n  const chunks = new Array(chunkCfgs.length);\n  Logger.getInstance().trace(`Downloading ${chunkCfgs.length} chunks`);\n\n  // loop over the chunk config objects and build Chunk instances out of them\n  startIndex = 0;\n  const length = chunkCfgs.length;\n  for (index = 0; index < length; index++) {\n    chunkCfg = chunkCfgs[index];\n\n    // augment the chunk config object with additional information\n    chunkCfg.statement = statement;\n    chunkCfg.services = services;\n    chunkCfg.startIndex = startIndex;\n    chunkCfg.columns = columns;\n    chunkCfg.mapColumnNameToIndices = mapColumnNameToIndices;\n    chunkCfg.chunkHeaders = chunkHeaders;\n    chunkCfg.statementParameters = statementParameters;\n    chunkCfg.resultVersion = resultVersion;\n\n    // increment the start index for the next chunk\n    startIndex += chunkCfg.rowCount;\n\n    // create a new Chunk from the config object, and add it to the chunks array\n    chunks[index] = new Chunk(chunkCfg);\n  }\n\n  return chunks;\n}\n\n/**\n * Returns the chunks in this result that overlap with a specified window.\n *\n * @param {Number} start the start index of the window.\n * @param {Number} end the end index of the window.\n *\n * @returns {Chunk[]}\n */\nResult.prototype.findOverlappingChunks = function (start, end) {\n  return findOverlappingChunks(this._chunks, start, end);\n};\n\n/**\n * Fetches the rows from the result.\n *\n * @param {Object} options\n *\n * @returns {EventEmitter}\n */\nResult.prototype.fetchRows = function (options) {\n  // validate options\n  Errors.assertInternal(Util.isObject(options));\n  Errors.assertInternal(Util.isFunction(options.each));\n\n  // if no value was specified for the start index or if the specified start\n  // index is negative, default to 0, otherwise truncate the fractional part\n  let start = options.startIndex;\n  start = (!Util.isNumber(start) || (start < 0)) ? 0 : Math.floor(start);\n\n  // if no value was specified for the end index or if the end index is larger\n  // than the row index of the last row, default to the index of the last row,\n  // otherwise truncate the fractional part\n  const returnedRows = this.getReturnedRows();\n  let end = options.endIndex;\n  end = (!Util.isNumber(end) || (end >= returnedRows)) ? returnedRows - 1 :\n    Math.floor(end);\n\n  // create an EventEmitter that will be returned to the\n  // caller to track progress of the fetch-rows operation\n  const operation = new EventEmitter();\n\n  // define a function to asynchronously complete the operation\n  const asyncComplete = function (err, continueCallback) {\n    process.nextTick(function () {\n      operation.emit('complete', err, continueCallback);\n    });\n  };\n\n  // if the start index is greater than the end index, asynchronously\n  // complete the operation and return the operation\n  if (start > end) {\n    // the operation is now complete\n    asyncComplete();\n    return operation;\n  }\n\n  const connectionConfig = this._connectionConfig;\n\n  // create a context object to store the state of the operation; we could store\n  // the state in the operation itself, but it would be good to keep this state\n  // private\n  const context =\n    {\n      maxNumRowsToProcess: end - start + 1,\n      numRowsProcessed: 0,\n      rowBatchSize: connectionConfig.getResultProcessingBatchSize(),\n      rowBatchDuration: connectionConfig.getResultProcessingBatchDuration()\n    };\n\n  // identify the chunks needed to get the requested rows, and create a stream\n  // to read their contents\n  const resultStream = new ResultStream(\n    {\n      chunks: findOverlappingChunks(this._chunks, start, end),\n      prefetchSize: connectionConfig.getResultPrefetch()\n    });\n\n  // subscribe to the stream's 'close' event\n  resultStream.on('close', function (err, continueCallback) {\n    // the operation is now complete\n    asyncComplete(err, continueCallback);\n  });\n\n  // subscribe to the stream's 'data' event\n  resultStream.on('data', function (chunk) {\n    // start processing the chunk rows\n    processChunk(chunk);\n  });\n\n  /**\n   * Processes the rows in a given chunk.\n   *\n   * @param {Object} chunk\n   */\n  const processChunk = function (chunk) {\n    // get all the rows in the current chunk that overlap with the requested\n    // window\n    const chunkStart = chunk.getStartIndex();\n    const chunkEnd = chunk.getEndIndex();\n    const rows = chunk.getRows().slice(\n      Math.max(chunkStart, start) - chunkStart,\n      Math.min(chunkEnd, end) + 1 - chunkStart);\n\n    let rowIndex = 0;\n    const rowsLength = rows.length;\n\n    // create a function that can be called to batch-process rows\n    const processRows = function () {\n      // get the start position and start time\n      const startIndex = rowIndex;\n      const startTime = Date.now();\n      const each = options.each;\n\n      let stoppedProcessingRows;\n\n      while (rowIndex < rowsLength) {\n        // invoke the each() callback on the current row\n        const ret = each(rows[rowIndex++]);\n\n        context.numRowsProcessed++;\n\n        // if the callback returned false, stop processing rows\n        if (ret === false) {\n          stoppedProcessingRows = true;\n          break;\n        }\n\n        // use the current position and current time to check if we've been\n        // processing rows for too long; if so, leave the rest for the next\n        // tick of the event loop\n        if ((rowIndex - startIndex) >= context.rowBatchSize &&\n          (Date.now() - startTime) > context.rowBatchDuration) {\n          process.nextTick(processRows);\n          break;\n        }\n      }\n\n      // if there are no more rows for us to process in this chunk\n      if (!(rowIndex < rowsLength) || stoppedProcessingRows) {\n        // if we exhausted all the rows in this chunk and we haven't yet\n        // processed all the rows we want to process, ask the result stream to\n        // do another read\n        if (!(rowIndex < rowsLength) &&\n          context.numRowsProcessed !== context.maxNumRowsToProcess) {\n          resultStream.read();\n        } else {\n          // we've either processed all the rows we wanted to process or we\n          // were told to stop processing rows by the each() callback; either\n          // way, close the result stream to complete the operation\n          resultStream.asyncClose();\n        }\n      }\n    };\n\n    // start processing rows\n    processRows();\n  };\n\n  // start reading from the stream in the next tick of the event loop\n  process.nextTick(function () {\n    resultStream.read();\n  });\n\n  return operation;\n};\n\n/**\n * Given a sorted array of chunks, returns a sub-array that overlaps with a\n * specified window.\n *\n * @param chunks\n * @param windowStart\n * @param windowEnd\n *\n * @returns {Array}\n */\nfunction findOverlappingChunks(chunks, windowStart, windowEnd) {\n  const overlappingChunks = [];\n\n  if (chunks.length !== 0) {\n    // get the index of the first chunk that overlaps with the specified window\n    let index = findFirstOverlappingChunk(chunks, windowStart, windowEnd);\n\n    // iterate over the chunks starting with the first overlapping chunk and\n    // keep going until there's no overlap\n    for (let length = chunks.length; index < length; index++) {\n      const chunk = chunks[index];\n      if (chunk.overlapsWithWindow(windowStart, windowEnd)) {\n        overlappingChunks.push(chunk);\n      } else {\n        // no future chunks will overlap because the chunks array is sorted\n        break;\n      }\n    }\n  }\n\n  return overlappingChunks;\n}\n\n/**\n * Given a sorted array of chunks, returns the index of the first chunk in the\n * array that overlaps with a specified window.\n *\n * @param chunks\n * @param windowStartIndex\n * @param windowEndIndex\n *\n * @returns {number}\n */\nfunction findFirstOverlappingChunk(chunks, windowStartIndex, windowEndIndex) {\n  const helper = function (chunks,\n    chunkIndexLeft,\n    chunkIndexRight,\n    windowStartIndex,\n    windowEndIndex) {\n    let result;\n    let middleChunkEndIndex;\n\n    // initialize the return value to -1\n    result = -1;\n\n    // compute the index of the middle chunk and get the middle chunk\n    const chunkIndexMiddle = Math.floor((chunkIndexLeft + chunkIndexRight) / 2);\n    const middleChunk = chunks[chunkIndexMiddle];\n\n    // if we have two or fewer chunks\n    if ((chunkIndexMiddle === chunkIndexLeft) ||\n      (chunkIndexMiddle === chunkIndexRight)) {\n      // if we have just one chunk, and it overlaps with the specified window,\n      // we've found the chunk we were looking for\n      if (chunkIndexLeft === chunkIndexRight) {\n        if (middleChunk.overlapsWithWindow(windowStartIndex, windowEndIndex)) {\n          result = chunkIndexLeft;\n        }\n      } else { // we just have two chunks left to check\n        // if the first chunk overlaps with the specified window, that's the\n        // chunk we were looking for\n        if (chunks[chunkIndexLeft].overlapsWithWindow(\n          windowStartIndex, windowEndIndex)) {\n          result = chunkIndexLeft;\n        } else if (chunks[chunkIndexRight].overlapsWithWindow(\n          windowStartIndex, windowEndIndex)) {\n          // otherwise, if the second chunk overlaps with the specified window,\n          // that's the chunk we were looking for\n          result = chunkIndexRight;\n        }\n      }\n\n      return result;\n    }\n\n    // if the middle chunk does not overlap with the specified window\n    if (!middleChunk.overlapsWithWindow(windowStartIndex, windowEndIndex)) {\n      middleChunkEndIndex = middleChunk.getEndIndex();\n\n      // if the window is to the right of the middle chunk,\n      // recurse on the right half\n      if (windowStartIndex > middleChunkEndIndex) {\n        return helper(\n          chunks,\n          chunkIndexMiddle,\n          chunkIndexRight,\n          windowStartIndex,\n          windowEndIndex);\n      } else {\n        // recurse on the left half\n        return helper(\n          chunks,\n          chunkIndexLeft,\n          chunkIndexMiddle,\n          windowStartIndex,\n          windowEndIndex);\n      }\n    } else {\n      // if the middle chunk overlaps but the chunk before it does not, the\n      // middle chunk is the one we were looking\n      if ((chunkIndexMiddle === 0) ||\n        !chunks[chunkIndexMiddle - 1].overlapsWithWindow(\n          windowStartIndex, windowEndIndex)) {\n        return chunkIndexMiddle;\n      } else {\n        // recurse on the left half\n        return helper(\n          chunks,\n          chunkIndexLeft,\n          chunkIndexMiddle,\n          windowStartIndex,\n          windowEndIndex);\n      }\n    }\n  };\n\n  return helper(chunks, 0, chunks.length - 1, windowStartIndex, windowEndIndex);\n}\n\n/**\n * Returns the columns in this result.\n *\n * @returns {Object[]}\n */\nResult.prototype.getColumns = function () {\n  return this._columns;\n};\n\n/**\n * Given a column identifier, returns the corresponding column. The column\n * identifier can be either the column name (String) or the column index\n * (Number). If a column name is specified and there is more than one column\n * with that name, the first column with the specified name will be returned.\n *\n * @param {String | Number} columnIdentifier\n *\n * @returns {Object}\n */\nResult.prototype.getColumn = function (columnIdentifier) {\n  let columnIndex;\n\n  // if the column identifier is a string, treat it as a column\n  // name and use it to get the index of the specified column\n  if (Util.isString(columnIdentifier)) {\n    // if a valid column name was specified, get the index of the first column\n    // with the specified name\n    if (Object.prototype.hasOwnProperty.call(this._mapColumnNameToIndices, columnIdentifier)) {\n      columnIndex = this._mapColumnNameToIndices[columnIdentifier][0];\n    }\n  } else if (Util.isNumber(columnIdentifier)) {\n    // if the column identifier is a number, treat it as a column index\n    columnIndex = columnIdentifier;\n  }\n\n  return this._columns[columnIndex];\n};\n\n/**\n * Returns the statement id generated by the server for the statement that\n * produced this result.\n *\n * Should use getQueryId instead.\n * @deprecated\n * @returns {string}\n */\nResult.prototype.getStatementId = function () {\n  return this._queryId;\n};\n\n/**\n * Returns the query id generated by the server for the statement that\n * produced this result.\n *\n * @returns {string}\n */\nResult.prototype.getQueryId = function () {\n  return this._queryId;\n};\n\n/**\n * Returns the number of rows in this result.\n *\n * @returns {number}\n */\nResult.prototype.getReturnedRows = function () {\n  return this._returnedRows;\n};\n\n/**\n * Returns the number of rows updated by the statement that produced this\n * result. If the statement isn't a DML, we return -1.\n *\n * @returns {Number}\n */\nResult.prototype.getNumUpdatedRows = function () {\n  // initialize if necessary\n  if (!this._numUpdatedRows) {\n    let numUpdatedRows = -1;\n\n    // the updated-rows metric only applies to dml's\n    const statementTypeId = this._statementTypeId;\n    if (StatementType.isDml(statementTypeId)) {\n      if (StatementType.isInsert(statementTypeId) ||\n        StatementType.isUpdate(statementTypeId) ||\n        StatementType.isDelete(statementTypeId) ||\n        StatementType.isMerge(statementTypeId) ||\n        StatementType.isMultiTableInsert(statementTypeId)) {\n        const chunks = this._chunks;\n        const columns = this._columns;\n\n        // if the statement is a dml, the result should be small,\n        // meaning we only have one chunk\n        Errors.assertInternal(Util.isArray(chunks) && (chunks.length === 1));\n\n        // add up the values in all the columns\n        numUpdatedRows = 0;\n        const rows = chunks[0].getRows();\n        for (let rowIndex = 0, rowsLength = rows.length;\n          rowIndex < rowsLength; rowIndex++) {\n          const row = rows[rowIndex];\n          for (let colIndex = 0, colsLength = columns.length;\n            colIndex < colsLength; colIndex++) {\n            numUpdatedRows += Number(\n              row.getColumnValue(columns[colIndex].getId()));\n          }\n        }\n      }\n      // TODO: handle 'copy' and 'unload'\n    }\n\n    this._numUpdatedRows = numUpdatedRows;\n  }\n\n  return this._numUpdatedRows;\n};\n\n/**\n * Returns the number of rows we would have had in this result if the value of\n * the ROWS_PER_RESULTSET parameter was 0 at the time this statement was\n * executed.\n *\n * @returns {number}\n */\nResult.prototype.getTotalRows = function () {\n  return this._totalRows;\n};\n\n/**\n * Returns the parameters associated with this result. These parameters contain\n * directives about how to consume and present the result.\n *\n * @returns {Object[]}\n */\nResult.prototype.getParametersArray = function () {\n  return this._parametersArray;\n};\n\n/**\n * Returns an object that contains information about the values of the current\n * warehouse, current database, and any other session-related state when the\n * statement that produced this result finished executing.\n *\n * @returns {Object}\n */\nResult.prototype.getSessionState = function () {\n  return this._sessionState;\n};\n\n/**\n * Returns the version associated with this result.\n *\n * @returns {string}\n */\nResult.prototype.getVersion = function () {\n  return this._version;\n};\n\nmodule.exports = Result;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvcmVzdWx0LmpzIiwibWFwcGluZ3MiOiJBQUFBLHFCQUFxQiwwREFBOEI7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLGtFQUFZO0FBQ2pDLGVBQWUsbUJBQU8sQ0FBQyxzRUFBYztBQUNyQyxjQUFjLG1CQUFPLENBQUMsa0ZBQVM7QUFDL0IscUJBQXFCLG1CQUFPLENBQUMsa0dBQWlCO0FBQzlDLG1CQUFtQixtQkFBTyxDQUFDLDhGQUFlO0FBQzFDLGVBQWUsbUJBQU8sQ0FBQyxvRkFBVTtBQUNqQyxzQkFBc0IsbUJBQU8sQ0FBQyxvR0FBa0I7QUFDaEQsMkJBQTJCLG1CQUFPLENBQUMsNEhBQThCO0FBQ2pFLGdCQUFnQixtQkFBTyxDQUFDLDhGQUEwQjtBQUNsRCxlQUFlLG1CQUFPLENBQUMsc0VBQWM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0Esa0RBQWtEO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMERBQTBEO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsZ0JBQWdCO0FBQ25FO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxRUFBcUUsV0FBVztBQUNoRixzQkFBc0Isb0JBQW9COztBQUUxQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyxnQkFBZ0I7QUFDMUQ7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBLDRDQUE0QyxrQkFBa0I7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixnQkFBZ0I7QUFDbEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsdUVBQXVFO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFDQUFxQyxnQkFBZ0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxpQkFBaUI7QUFDNUI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2Nvbm5lY3Rpb24vcmVzdWx0L3Jlc3VsdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5jb25zdCBDaHVuayA9IHJlcXVpcmUoJy4vY2h1bmsnKTtcbmNvbnN0IFJlc3VsdFN0cmVhbSA9IHJlcXVpcmUoJy4vcmVzdWx0X3N0cmVhbScpO1xuY29uc3QgQ2h1bmtDYWNoZSA9IHJlcXVpcmUoJy4vY2h1bmtfY2FjaGUnKTtcbmNvbnN0IENvbHVtbiA9IHJlcXVpcmUoJy4vY29sdW1uJyk7XG5jb25zdCBTdGF0ZW1lbnRUeXBlID0gcmVxdWlyZSgnLi9zdGF0ZW1lbnRfdHlwZScpO1xuY29uc3QgQ29sdW1uTmFtZXNDcmVhdG9yID0gcmVxdWlyZSgnLi91bmlxdWVfY29sdW1uX25hbWVfY3JlYXRvcicpO1xuY29uc3QgUm93TW9kZSA9IHJlcXVpcmUoJy4uLy4uL2NvbnN0YW50cy9yb3dfbW9kZScpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vLi4vbG9nZ2VyJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBSZXN1bHQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSZXN1bHQob3B0aW9ucykge1xuICBsZXQgY2h1bmtIZWFkZXJzO1xuICBsZXQgbGVuZ3RoO1xuICBsZXQgaW5kZXg7XG4gIGxldCBwYXJhbWV0ZXI7XG4gIGxldCBtYXBDb2x1bW5OYW1lVG9JbmRpY2VzO1xuICBsZXQgY29sdW1ucztcbiAgbGV0IGNvbHVtbjtcbiAgbGV0IHZlcnNpb247XG5cbiAgLy8gYXNzZXJ0IHRoYXQgb3B0aW9ucyBpcyBhIHZhbGlkIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgcmVzcG9uc2UsIHN0YXRlbWVudCxcbiAgLy8gc2VydmljZXMgYW5kIGNvbm5lY3Rpb24gY29uZmlnXG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpKTtcbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucy5yZXNwb25zZSkpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zLnN0YXRlbWVudCkpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zLnNlcnZpY2VzKSk7XG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMuY29ubmVjdGlvbkNvbmZpZykpO1xuXG4gIC8vIHNhdmUgdGhlIHN0YXRlbWVudCwgc2VydmljZXMgYW5kIGNvbm5lY3Rpb24gY29uZmlnXG4gIHRoaXMuX3N0YXRlbWVudCA9IG9wdGlvbnMuc3RhdGVtZW50O1xuICB0aGlzLl9zZXJ2aWNlcyA9IG9wdGlvbnMuc2VydmljZXM7XG4gIHRoaXMuX2Nvbm5lY3Rpb25Db25maWcgPSBvcHRpb25zLmNvbm5lY3Rpb25Db25maWc7XG5cbiAgY29uc3QgZGF0YSA9IG9wdGlvbnMucmVzcG9uc2UuZGF0YTtcblxuICB0aGlzLl9xdWVyeUlkID0gZGF0YS5xdWVyeUlkO1xuICB0aGlzLl92ZXJzaW9uID0gdmVyc2lvbiA9IFN0cmluZyhkYXRhLnZlcnNpb24pOyAvLyBkb24ndCByZWx5IG9uIHRoZSB2ZXJzaW9uIGJlaW5nIGEgbnVtYmVyXG4gIHRoaXMuX3JldHVybmVkUm93cyA9IGRhdGEucmV0dXJuZWQ7XG4gIHRoaXMuX3RvdGFsUm93cyA9IGRhdGEudG90YWw7XG4gIHRoaXMuX3N0YXRlbWVudFR5cGVJZCA9IGRhdGEuc3RhdGVtZW50VHlwZUlkO1xuICB0aGlzLl9xdWVyeUNvbnRleHQgPSBkYXRhLnF1ZXJ5Q29udGV4dDtcblxuICAvLyBpZiBubyBjaHVuayBoZWFkZXJzIHdlcmUgc3BlY2lmaWVkLCBidXQgYSBxdWVyeS1yZXN1bHQtbWFzdGVyLWtleSAocXJtaylcbiAgLy8gd2FzIHNwZWNpZmllZCwgYnVpbGQgdGhlIGNodW5rIGhlYWRlcnMgZnJvbSB0aGUgcXJta1xuICBjaHVua0hlYWRlcnMgPSBkYXRhLmNodW5rSGVhZGVycztcbiAgaWYgKCFVdGlsLmlzT2JqZWN0KGNodW5rSGVhZGVycykgJiYgVXRpbC5pc1N0cmluZyhkYXRhLnFybWspKSB7XG4gICAgY2h1bmtIZWFkZXJzID1cbiAgICAgIHtcbiAgICAgICAgJ3gtYW16LXNlcnZlci1zaWRlLWVuY3J5cHRpb24tY3VzdG9tZXItYWxnb3JpdGhtJzogJ0FFUzI1NicsXG4gICAgICAgICd4LWFtei1zZXJ2ZXItc2lkZS1lbmNyeXB0aW9uLWN1c3RvbWVyLWtleSc6IGRhdGEucXJta1xuICAgICAgfTtcbiAgfVxuICB0aGlzLl9jaHVua0hlYWRlcnMgPSBjaHVua0hlYWRlcnM7XG5cbiAgLy8gYnVpbGQgYSBzZXNzaW9uIHN0YXRlIG9iamVjdCBmcm9tIHRoZSByZXNwb25zZSBkYXRhOyB0aGlzIGNhbiBiZSB1c2VkIHRvXG4gIC8vIGdldCB0aGUgdmFsdWVzIG9mIHRoZSBjdXJyZW50IHJvbGUsIGN1cnJlbnQgd2FyZWhvdXNlLCBjdXJyZW50IGRhdGFiYXNlLFxuICAvLyBldGMuXG4gIHRoaXMuX3Nlc3Npb25TdGF0ZSA9IGNyZWF0ZVNlc3Npb25TdGF0ZShkYXRhKTtcblxuICAvLyBjb252ZXJ0IHRoZSBwYXJhbWV0ZXJzIGFycmF5IHRvIGEgbWFwXG4gIGNvbnN0IHBhcmFtZXRlcnNNYXAgPSB7fTtcbiAgY29uc3QgcGFyYW1ldGVyc0FycmF5ID0gZGF0YS5wYXJhbWV0ZXJzIHx8IFtdO1xuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gcGFyYW1ldGVyc0FycmF5Lmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJzQXJyYXlbaW5kZXhdO1xuICAgIHBhcmFtZXRlcnNNYXBbcGFyYW1ldGVyLm5hbWVdID0gcGFyYW1ldGVyLnZhbHVlO1xuICB9XG5cbiAgLy8gc2F2ZSB0aGUgcGFyYW1ldGVycyBhcnJheVxuICB0aGlzLl9wYXJhbWV0ZXJzQXJyYXkgPSBwYXJhbWV0ZXJzQXJyYXk7XG5cbiAgLy8gVE9ETzogYWRkIHRpbWV6b25lIHJlbGF0ZWQgaW5mb3JtYXRpb24gdG8gY29sdW1uc1xuXG4gIC8vIGNyZWF0ZSBjb2x1bW5zIGZyb20gdGhlIHJvd3R5cGUgYXJyYXkgcmV0dXJuZWQgaW4gdGhlIHJlc3VsdFxuICBjb25zdCByb3d0eXBlID0gZGF0YS5yb3d0eXBlO1xuICBjb25zdCBudW1Db2x1bW5zID0gcm93dHlwZS5sZW5ndGg7XG5cbiAgdGhpcy5fY29sdW1ucyA9IGNvbHVtbnMgPSBuZXcgQXJyYXkobnVtQ29sdW1ucyk7XG5cbiAgLy8gY29udmVydCB0aGUgcm93dHlwZSBhcnJheSB0byBhbiBhcnJheSBvZiBjb2x1bW5zIGFuZCBidWlsZCBhbiBpbnZlcnRlZFxuICAvLyBpbmRleCBtYXAgaW4gd2hpY2ggdGhlIGtleXMgYXJlIHRoZSBjb2x1bW4gbmFtZXMgYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZVxuICAvLyBpbmRpY2VzIG9mIHRoZSBjb2x1bW5zIHdpdGggdGhlIGNvcnJlc3BvbmRpbmcgbmFtZXNcbiAgdGhpcy5fbWFwQ29sdW1uTmFtZVRvSW5kaWNlcyA9IG1hcENvbHVtbk5hbWVUb0luZGljZXMgPSB7fTtcblxuICBjb25zdCByb3dNb2RlID0gb3B0aW9ucy5yb3dNb2RlO1xuICBpZiAocm93TW9kZSA9PT0gUm93TW9kZS5PQkpFQ1RfV0lUSF9SRU5BTUVEX0RVUExJQ0FURURfQ09MVU1OUykge1xuICAgIENvbHVtbk5hbWVzQ3JlYXRvci5hZGRPdmVycmlkZW5OYW1lc0ZvckR1cGxpY2F0ZWRDb2x1bW5zKHJvd3R5cGUpO1xuICB9XG5cbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYE1hcHBpbmcgY29sdW1ucyBpbiByZXN1bHRzZXQgKHRvdGFsOiAke251bUNvbHVtbnN9KWApO1xuICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgbnVtQ29sdW1uczsgaW5kZXgrKykge1xuXG4gICAgLy8gY3JlYXRlIGEgbmV3IGNvbHVtbiBhbmQgYWRkIGl0IHRvIHRoZSBjb2x1bW5zIGFycmF5XG4gICAgY29sdW1uc1tpbmRleF0gPSBjb2x1bW4gPVxuICAgICAgbmV3IENvbHVtbihyb3d0eXBlW2luZGV4XSwgaW5kZXgsIHBhcmFtZXRlcnNNYXAsIHZlcnNpb24pO1xuXG4gICAgLy8gaWYgd2UgZG9uJ3QgYWxyZWFkeSBoYXZlIGFuIGluZGV4IGFycmF5IGZvciBhIGNvbHVtbiB3aXRoIHRoaXMgbmFtZSxcbiAgICAvLyBjcmVhdGUgYSBuZXcgb25lLCBvdGhlcndpc2UganVzdCBhcHBlbmQgdG8gdGhlIGV4aXN0aW5nIGFycmF5IG9mIGluZGljZXNcbiAgICBtYXBDb2x1bW5OYW1lVG9JbmRpY2VzW2NvbHVtbi5nZXROYW1lKCldID1cbiAgICAgIG1hcENvbHVtbk5hbWVUb0luZGljZXNbY29sdW1uLmdldE5hbWUoKV0gfHwgW107XG4gICAgbWFwQ29sdW1uTmFtZVRvSW5kaWNlc1tjb2x1bW4uZ2V0TmFtZSgpXS5wdXNoKGluZGV4KTtcbiAgfVxuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnRmluaXNoZWQgbWFwcGluZyBjb2x1bW5zLicpO1xuXG4gIC8vIGNyZWF0ZSBjaHVua3NcbiAgdGhpcy5fY2h1bmtzID0gY3JlYXRlQ2h1bmtzKFxuICAgIGRhdGEuY2h1bmtzLFxuICAgIGRhdGEucm93c2V0LFxuICAgIHRoaXMuX2NvbHVtbnMsXG4gICAgdGhpcy5fbWFwQ29sdW1uTmFtZVRvSW5kaWNlcyxcbiAgICB0aGlzLl9jaHVua0hlYWRlcnMsXG4gICAgcGFyYW1ldGVyc01hcCxcbiAgICB0aGlzLl92ZXJzaW9uLFxuICAgIHRoaXMuX3N0YXRlbWVudCxcbiAgICB0aGlzLl9zZXJ2aWNlcyk7XG5cbiAgdGhpcy5nZXRRdWVyeUNvbnRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3F1ZXJ5Q29udGV4dDtcbiAgfTtcblxuICAvKiBEaXNhYmxlIHRoZSBDaHVua0NhY2hlIHVudGlsIHRoZSBpbXBsZW1lbnRhdGlvbiBpcyBjb21wbGV0ZS5cbiAgICogXG4gICAqICAgLy8gY3JlYXRlIGEgY2h1bmsgY2FjaGUgYW5kIHNhdmUgYSByZWZlcmVuY2UgdG8gaXQgaW4gY2FzZSB3ZSBuZWVkIHRvXG4gICAqICAgLy8gVE9ETzogc2hvdWxkIHdlIGJlIGNsZWFyaW5nIHRoZSBjYWNoZSBhdCBzb21lIHBvaW50LCBlLmcuIHdoZW4gdGhlIHJlc3VsdFxuICAgKiAgIC8vIGlzIGRlc3Ryb3llZD9cbiAgICogICB0aGlzLl9jaHVua0NhY2hlID0gY3JlYXRlQ2h1bmtDYWNoZShcbiAgICogICB0aGlzLl9jaHVua3MsXG4gICAqICAgdGhpcy5fY29ubmVjdGlvbkNvbmZpZy5nZXRSZXN1bHRDaHVua0NhY2hlU2l6ZSgpKTtcbiAgICAqL1xufVxuXG5VdGlsLmluaGVyaXRzKFJlc3VsdCwgRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBSZWZyZXNoZXMgdGhlIHJlc3VsdCBieSB1cGRhdGluZyB0aGUgY2h1bmsgdXJscy5cbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2VcbiAqL1xuUmVzdWx0LnByb3RvdHlwZS5yZWZyZXNoID0gZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gIGNvbnN0IGNodW5rcyA9IHRoaXMuX2NodW5rcztcbiAgY29uc3QgY2h1bmtDZmdzID0gcmVzcG9uc2UuZGF0YS5jaHVua3M7XG4gIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gY2h1bmtzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjaHVua3NbaW5kZXhdLnNldFVybChjaHVua0NmZ3NbaW5kZXhdLnVybCk7XG4gIH1cbn07XG5cbi8qKlxuICogVE9ET1xuICpcbiAqIEBwYXJhbSBjaHVua3NcbiAqIEBwYXJhbSBjYXBhY2l0eVxuICpcbiAqIEByZXR1cm5zIHtDaHVua0NhY2hlfVxuICovXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rQ2FjaGUoY2h1bmtzLCBjYXBhY2l0eSkge1xuICBsZXQgaW5kZXg7XG4gIGxldCBsZW5ndGg7XG5cbiAgLy8gY3JlYXRlIGEgY2h1bmsgY2FjaGVcbiAgY29uc3QgY2h1bmtDYWNoZSA9IG5ldyBDaHVua0NhY2hlKGNhcGFjaXR5KTtcblxuICAvLyBldmVyeSB0aW1lIGEgY2h1bmsgaXMgbG9hZGVkLCBhZGQgaXQgdG8gdGhlIGNhY2hlXG4gIC8vIFRPRE86IHNob3VsZCB0aGUgY2FjaGluZyBiZSBiYXNlZCBvbiBtb3N0IHJlY2VudGx5ICd1c2VkJyBvciBtb3N0IHJlY2VudGx5XG4gIC8vICdsb2FkZWQnP1xuICBjb25zdCBvbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIChlcnIsIGNodW5rKSB7XG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIGNodW5rQ2FjaGUucHV0KGNodW5rKTtcbiAgICB9XG4gIH07XG5cbiAgLy8gc3Vic2NyaWJlIHRvIHRoZSAnbG9hZGNvbXBsZXRlJyBldmVudCBvbiBhbGwgdGhlIGNodW5rc1xuICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gY2h1bmtzLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjaHVua3NbaW5kZXhdLm9uKCdsb2FkY29tcGxldGUnLCBvbkxvYWRDb21wbGV0ZSk7XG4gIH1cblxuICAvLyBUT0RPOiBkbyB3ZSBuZWVkIHRvIHVuc3Vic2NyaWJlIGZyb20gdGhlIGxvYWRjb21wbGV0ZSBldmVudCBhdCBzb21lIHBvaW50P1xuXG4gIHJldHVybiBjaHVua0NhY2hlO1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBzZXNzaW9uIHN0YXRlIG9iamVjdCBmcm9tIHRoZSB2YWx1ZXMgb2YgdGhlIGN1cnJlbnQgcm9sZSwgY3VycmVudFxuICogd2FyZWhvdXNlLCBldGMuLCByZXR1cm5lZCBpbiB0aGUgcmVzdWx0IHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSByZXNwb25zZURhdGFcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVTZXNzaW9uU3RhdGUocmVzcG9uc2VEYXRhKSB7XG4gIGNvbnN0IGN1cnJlbnRSb2xlID0gcmVzcG9uc2VEYXRhLmZpbmFsUm9sZU5hbWU7XG4gIGNvbnN0IGN1cnJlbnRXYXJlaG91c2UgPSByZXNwb25zZURhdGEuZmluYWxXYXJlaG91c2VOYW1lO1xuICBjb25zdCBjdXJyZW50RGF0YWJhc2VQcm92aWRlciA9IHJlc3BvbnNlRGF0YS5kYXRhYmFzZVByb3ZpZGVyO1xuICBjb25zdCBjdXJyZW50RGF0YWJhc2UgPSByZXNwb25zZURhdGEuZmluYWxEYXRhYmFzZU5hbWU7XG4gIGNvbnN0IGN1cnJlbnRTY2hlbWEgPSByZXNwb25zZURhdGEuZmluYWxTY2hlbWFOYW1lO1xuXG4gIHJldHVybiB7XG4gICAgZ2V0Q3VycmVudFJvbGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50Um9sZTtcbiAgICB9LFxuICAgIGdldEN1cnJlbnRXYXJlaG91c2U6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50V2FyZWhvdXNlO1xuICAgIH0sXG4gICAgZ2V0Q3VycmVudERhdGFiYXNlUHJvdmlkZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50RGF0YWJhc2VQcm92aWRlcjtcbiAgICB9LFxuICAgIGdldEN1cnJlbnREYXRhYmFzZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIGN1cnJlbnREYXRhYmFzZTtcbiAgICB9LFxuICAgIGdldEN1cnJlbnRTY2hlbWE6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJyZW50U2NoZW1hO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGFycmF5IG9mIENodW5rIGluc3RhbmNlcyBmcm9tIHRoZSBjaHVuay1yZWxhdGVkIGluZm9ybWF0aW9uIGluIHRoZVxuICogcmVzdWx0IHJlc3BvbnNlLlxuICpcbiAqIEBwYXJhbSBjaHVua0NmZ3NcbiAqIEBwYXJhbSByb3dzZXRcbiAqIEBwYXJhbSBjb2x1bW5zXG4gKiBAcGFyYW0gbWFwQ29sdW1uTmFtZVRvSW5kaWNlc1xuICogQHBhcmFtIGNodW5rSGVhZGVyc1xuICogQHBhcmFtIHN0YXRlbWVudFBhcmFtZXRlcnNcbiAqIEBwYXJhbSByZXN1bHRWZXJzaW9uXG4gKiBAcGFyYW0gc3RhdGVtZW50XG4gKiBAcGFyYW0gc2VydmljZXNcbiAqXG4gKiBAcmV0dXJucyB7Q2h1bmt9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNodW5rcyhjaHVua0NmZ3MsXG4gIHJvd3NldCxcbiAgY29sdW1ucyxcbiAgbWFwQ29sdW1uTmFtZVRvSW5kaWNlcyxcbiAgY2h1bmtIZWFkZXJzLFxuICBzdGF0ZW1lbnRQYXJhbWV0ZXJzLFxuICByZXN1bHRWZXJzaW9uLFxuICBzdGF0ZW1lbnQsXG4gIHNlcnZpY2VzKSB7XG4gIGxldCBzdGFydEluZGV4O1xuICBsZXQgaW5kZXg7XG4gIGxldCBjaHVua0NmZztcblxuICAvLyBpZiB3ZSBkb24ndCBoYXZlIGFueSBjaHVua3MsIG9yIGlmIHNvbWUgcmVjb3JkcyB3ZXJlIHJldHVybmVkIGlubGluZSxcbiAgLy8gZmFicmljYXRlIGEgY29uZmlnIG9iamVjdCBmb3IgdGhlIGZpcnN0IGNodW5rXG4gIGNodW5rQ2ZncyA9IGNodW5rQ2ZncyB8fCBbXTtcbiAgaWYgKCFjaHVua0NmZ3MgfHwgcm93c2V0Lmxlbmd0aCA+IDApIHtcbiAgICBjaHVua0NmZ3MudW5zaGlmdChcbiAgICAgIHtcbiAgICAgICAgcm93Q291bnQ6IHJvd3NldC5sZW5ndGgsXG4gICAgICAgIHVybDogbnVsbCxcbiAgICAgICAgcm93c2V0OiByb3dzZXRcbiAgICAgIH0pO1xuICB9XG5cbiAgY29uc3QgY2h1bmtzID0gbmV3IEFycmF5KGNodW5rQ2Zncy5sZW5ndGgpO1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgRG93bmxvYWRpbmcgJHtjaHVua0NmZ3MubGVuZ3RofSBjaHVua3NgKTtcblxuICAvLyBsb29wIG92ZXIgdGhlIGNodW5rIGNvbmZpZyBvYmplY3RzIGFuZCBidWlsZCBDaHVuayBpbnN0YW5jZXMgb3V0IG9mIHRoZW1cbiAgc3RhcnRJbmRleCA9IDA7XG4gIGNvbnN0IGxlbmd0aCA9IGNodW5rQ2Zncy5sZW5ndGg7XG4gIGZvciAoaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGNodW5rQ2ZnID0gY2h1bmtDZmdzW2luZGV4XTtcblxuICAgIC8vIGF1Z21lbnQgdGhlIGNodW5rIGNvbmZpZyBvYmplY3Qgd2l0aCBhZGRpdGlvbmFsIGluZm9ybWF0aW9uXG4gICAgY2h1bmtDZmcuc3RhdGVtZW50ID0gc3RhdGVtZW50O1xuICAgIGNodW5rQ2ZnLnNlcnZpY2VzID0gc2VydmljZXM7XG4gICAgY2h1bmtDZmcuc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXg7XG4gICAgY2h1bmtDZmcuY29sdW1ucyA9IGNvbHVtbnM7XG4gICAgY2h1bmtDZmcubWFwQ29sdW1uTmFtZVRvSW5kaWNlcyA9IG1hcENvbHVtbk5hbWVUb0luZGljZXM7XG4gICAgY2h1bmtDZmcuY2h1bmtIZWFkZXJzID0gY2h1bmtIZWFkZXJzO1xuICAgIGNodW5rQ2ZnLnN0YXRlbWVudFBhcmFtZXRlcnMgPSBzdGF0ZW1lbnRQYXJhbWV0ZXJzO1xuICAgIGNodW5rQ2ZnLnJlc3VsdFZlcnNpb24gPSByZXN1bHRWZXJzaW9uO1xuXG4gICAgLy8gaW5jcmVtZW50IHRoZSBzdGFydCBpbmRleCBmb3IgdGhlIG5leHQgY2h1bmtcbiAgICBzdGFydEluZGV4ICs9IGNodW5rQ2ZnLnJvd0NvdW50O1xuXG4gICAgLy8gY3JlYXRlIGEgbmV3IENodW5rIGZyb20gdGhlIGNvbmZpZyBvYmplY3QsIGFuZCBhZGQgaXQgdG8gdGhlIGNodW5rcyBhcnJheVxuICAgIGNodW5rc1tpbmRleF0gPSBuZXcgQ2h1bmsoY2h1bmtDZmcpO1xuICB9XG5cbiAgcmV0dXJuIGNodW5rcztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBjaHVua3MgaW4gdGhpcyByZXN1bHQgdGhhdCBvdmVybGFwIHdpdGggYSBzcGVjaWZpZWQgd2luZG93LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGFydCB0aGUgc3RhcnQgaW5kZXggb2YgdGhlIHdpbmRvdy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgdGhlIGVuZCBpbmRleCBvZiB0aGUgd2luZG93LlxuICpcbiAqIEByZXR1cm5zIHtDaHVua1tdfVxuICovXG5SZXN1bHQucHJvdG90eXBlLmZpbmRPdmVybGFwcGluZ0NodW5rcyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gIHJldHVybiBmaW5kT3ZlcmxhcHBpbmdDaHVua3ModGhpcy5fY2h1bmtzLCBzdGFydCwgZW5kKTtcbn07XG5cbi8qKlxuICogRmV0Y2hlcyB0aGUgcm93cyBmcm9tIHRoZSByZXN1bHQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfVxuICovXG5SZXN1bHQucHJvdG90eXBlLmZldGNoUm93cyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIC8vIHZhbGlkYXRlIG9wdGlvbnNcbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucykpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0Z1bmN0aW9uKG9wdGlvbnMuZWFjaCkpO1xuXG4gIC8vIGlmIG5vIHZhbHVlIHdhcyBzcGVjaWZpZWQgZm9yIHRoZSBzdGFydCBpbmRleCBvciBpZiB0aGUgc3BlY2lmaWVkIHN0YXJ0XG4gIC8vIGluZGV4IGlzIG5lZ2F0aXZlLCBkZWZhdWx0IHRvIDAsIG90aGVyd2lzZSB0cnVuY2F0ZSB0aGUgZnJhY3Rpb25hbCBwYXJ0XG4gIGxldCBzdGFydCA9IG9wdGlvbnMuc3RhcnRJbmRleDtcbiAgc3RhcnQgPSAoIVV0aWwuaXNOdW1iZXIoc3RhcnQpIHx8IChzdGFydCA8IDApKSA/IDAgOiBNYXRoLmZsb29yKHN0YXJ0KTtcblxuICAvLyBpZiBubyB2YWx1ZSB3YXMgc3BlY2lmaWVkIGZvciB0aGUgZW5kIGluZGV4IG9yIGlmIHRoZSBlbmQgaW5kZXggaXMgbGFyZ2VyXG4gIC8vIHRoYW4gdGhlIHJvdyBpbmRleCBvZiB0aGUgbGFzdCByb3csIGRlZmF1bHQgdG8gdGhlIGluZGV4IG9mIHRoZSBsYXN0IHJvdyxcbiAgLy8gb3RoZXJ3aXNlIHRydW5jYXRlIHRoZSBmcmFjdGlvbmFsIHBhcnRcbiAgY29uc3QgcmV0dXJuZWRSb3dzID0gdGhpcy5nZXRSZXR1cm5lZFJvd3MoKTtcbiAgbGV0IGVuZCA9IG9wdGlvbnMuZW5kSW5kZXg7XG4gIGVuZCA9ICghVXRpbC5pc051bWJlcihlbmQpIHx8IChlbmQgPj0gcmV0dXJuZWRSb3dzKSkgPyByZXR1cm5lZFJvd3MgLSAxIDpcbiAgICBNYXRoLmZsb29yKGVuZCk7XG5cbiAgLy8gY3JlYXRlIGFuIEV2ZW50RW1pdHRlciB0aGF0IHdpbGwgYmUgcmV0dXJuZWQgdG8gdGhlXG4gIC8vIGNhbGxlciB0byB0cmFjayBwcm9ncmVzcyBvZiB0aGUgZmV0Y2gtcm93cyBvcGVyYXRpb25cbiAgY29uc3Qgb3BlcmF0aW9uID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuXG4gIC8vIGRlZmluZSBhIGZ1bmN0aW9uIHRvIGFzeW5jaHJvbm91c2x5IGNvbXBsZXRlIHRoZSBvcGVyYXRpb25cbiAgY29uc3QgYXN5bmNDb21wbGV0ZSA9IGZ1bmN0aW9uIChlcnIsIGNvbnRpbnVlQ2FsbGJhY2spIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIG9wZXJhdGlvbi5lbWl0KCdjb21wbGV0ZScsIGVyciwgY29udGludWVDYWxsYmFjayk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gaWYgdGhlIHN0YXJ0IGluZGV4IGlzIGdyZWF0ZXIgdGhhbiB0aGUgZW5kIGluZGV4LCBhc3luY2hyb25vdXNseVxuICAvLyBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uIGFuZCByZXR1cm4gdGhlIG9wZXJhdGlvblxuICBpZiAoc3RhcnQgPiBlbmQpIHtcbiAgICAvLyB0aGUgb3BlcmF0aW9uIGlzIG5vdyBjb21wbGV0ZVxuICAgIGFzeW5jQ29tcGxldGUoKTtcbiAgICByZXR1cm4gb3BlcmF0aW9uO1xuICB9XG5cbiAgY29uc3QgY29ubmVjdGlvbkNvbmZpZyA9IHRoaXMuX2Nvbm5lY3Rpb25Db25maWc7XG5cbiAgLy8gY3JlYXRlIGEgY29udGV4dCBvYmplY3QgdG8gc3RvcmUgdGhlIHN0YXRlIG9mIHRoZSBvcGVyYXRpb247IHdlIGNvdWxkIHN0b3JlXG4gIC8vIHRoZSBzdGF0ZSBpbiB0aGUgb3BlcmF0aW9uIGl0c2VsZiwgYnV0IGl0IHdvdWxkIGJlIGdvb2QgdG8ga2VlcCB0aGlzIHN0YXRlXG4gIC8vIHByaXZhdGVcbiAgY29uc3QgY29udGV4dCA9XG4gICAge1xuICAgICAgbWF4TnVtUm93c1RvUHJvY2VzczogZW5kIC0gc3RhcnQgKyAxLFxuICAgICAgbnVtUm93c1Byb2Nlc3NlZDogMCxcbiAgICAgIHJvd0JhdGNoU2l6ZTogY29ubmVjdGlvbkNvbmZpZy5nZXRSZXN1bHRQcm9jZXNzaW5nQmF0Y2hTaXplKCksXG4gICAgICByb3dCYXRjaER1cmF0aW9uOiBjb25uZWN0aW9uQ29uZmlnLmdldFJlc3VsdFByb2Nlc3NpbmdCYXRjaER1cmF0aW9uKClcbiAgICB9O1xuXG4gIC8vIGlkZW50aWZ5IHRoZSBjaHVua3MgbmVlZGVkIHRvIGdldCB0aGUgcmVxdWVzdGVkIHJvd3MsIGFuZCBjcmVhdGUgYSBzdHJlYW1cbiAgLy8gdG8gcmVhZCB0aGVpciBjb250ZW50c1xuICBjb25zdCByZXN1bHRTdHJlYW0gPSBuZXcgUmVzdWx0U3RyZWFtKFxuICAgIHtcbiAgICAgIGNodW5rczogZmluZE92ZXJsYXBwaW5nQ2h1bmtzKHRoaXMuX2NodW5rcywgc3RhcnQsIGVuZCksXG4gICAgICBwcmVmZXRjaFNpemU6IGNvbm5lY3Rpb25Db25maWcuZ2V0UmVzdWx0UHJlZmV0Y2goKVxuICAgIH0pO1xuXG4gIC8vIHN1YnNjcmliZSB0byB0aGUgc3RyZWFtJ3MgJ2Nsb3NlJyBldmVudFxuICByZXN1bHRTdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKGVyciwgY29udGludWVDYWxsYmFjaykge1xuICAgIC8vIHRoZSBvcGVyYXRpb24gaXMgbm93IGNvbXBsZXRlXG4gICAgYXN5bmNDb21wbGV0ZShlcnIsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICB9KTtcblxuICAvLyBzdWJzY3JpYmUgdG8gdGhlIHN0cmVhbSdzICdkYXRhJyBldmVudFxuICByZXN1bHRTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAvLyBzdGFydCBwcm9jZXNzaW5nIHRoZSBjaHVuayByb3dzXG4gICAgcHJvY2Vzc0NodW5rKGNodW5rKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIFByb2Nlc3NlcyB0aGUgcm93cyBpbiBhIGdpdmVuIGNodW5rLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY2h1bmtcbiAgICovXG4gIGNvbnN0IHByb2Nlc3NDaHVuayA9IGZ1bmN0aW9uIChjaHVuaykge1xuICAgIC8vIGdldCBhbGwgdGhlIHJvd3MgaW4gdGhlIGN1cnJlbnQgY2h1bmsgdGhhdCBvdmVybGFwIHdpdGggdGhlIHJlcXVlc3RlZFxuICAgIC8vIHdpbmRvd1xuICAgIGNvbnN0IGNodW5rU3RhcnQgPSBjaHVuay5nZXRTdGFydEluZGV4KCk7XG4gICAgY29uc3QgY2h1bmtFbmQgPSBjaHVuay5nZXRFbmRJbmRleCgpO1xuICAgIGNvbnN0IHJvd3MgPSBjaHVuay5nZXRSb3dzKCkuc2xpY2UoXG4gICAgICBNYXRoLm1heChjaHVua1N0YXJ0LCBzdGFydCkgLSBjaHVua1N0YXJ0LFxuICAgICAgTWF0aC5taW4oY2h1bmtFbmQsIGVuZCkgKyAxIC0gY2h1bmtTdGFydCk7XG5cbiAgICBsZXQgcm93SW5kZXggPSAwO1xuICAgIGNvbnN0IHJvd3NMZW5ndGggPSByb3dzLmxlbmd0aDtcblxuICAgIC8vIGNyZWF0ZSBhIGZ1bmN0aW9uIHRoYXQgY2FuIGJlIGNhbGxlZCB0byBiYXRjaC1wcm9jZXNzIHJvd3NcbiAgICBjb25zdCBwcm9jZXNzUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGdldCB0aGUgc3RhcnQgcG9zaXRpb24gYW5kIHN0YXJ0IHRpbWVcbiAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSByb3dJbmRleDtcbiAgICAgIGNvbnN0IHN0YXJ0VGltZSA9IERhdGUubm93KCk7XG4gICAgICBjb25zdCBlYWNoID0gb3B0aW9ucy5lYWNoO1xuXG4gICAgICBsZXQgc3RvcHBlZFByb2Nlc3NpbmdSb3dzO1xuXG4gICAgICB3aGlsZSAocm93SW5kZXggPCByb3dzTGVuZ3RoKSB7XG4gICAgICAgIC8vIGludm9rZSB0aGUgZWFjaCgpIGNhbGxiYWNrIG9uIHRoZSBjdXJyZW50IHJvd1xuICAgICAgICBjb25zdCByZXQgPSBlYWNoKHJvd3Nbcm93SW5kZXgrK10pO1xuXG4gICAgICAgIGNvbnRleHQubnVtUm93c1Byb2Nlc3NlZCsrO1xuXG4gICAgICAgIC8vIGlmIHRoZSBjYWxsYmFjayByZXR1cm5lZCBmYWxzZSwgc3RvcCBwcm9jZXNzaW5nIHJvd3NcbiAgICAgICAgaWYgKHJldCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBzdG9wcGVkUHJvY2Vzc2luZ1Jvd3MgPSB0cnVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdXNlIHRoZSBjdXJyZW50IHBvc2l0aW9uIGFuZCBjdXJyZW50IHRpbWUgdG8gY2hlY2sgaWYgd2UndmUgYmVlblxuICAgICAgICAvLyBwcm9jZXNzaW5nIHJvd3MgZm9yIHRvbyBsb25nOyBpZiBzbywgbGVhdmUgdGhlIHJlc3QgZm9yIHRoZSBuZXh0XG4gICAgICAgIC8vIHRpY2sgb2YgdGhlIGV2ZW50IGxvb3BcbiAgICAgICAgaWYgKChyb3dJbmRleCAtIHN0YXJ0SW5kZXgpID49IGNvbnRleHQucm93QmF0Y2hTaXplICYmXG4gICAgICAgICAgKERhdGUubm93KCkgLSBzdGFydFRpbWUpID4gY29udGV4dC5yb3dCYXRjaER1cmF0aW9uKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhwcm9jZXNzUm93cyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gaWYgdGhlcmUgYXJlIG5vIG1vcmUgcm93cyBmb3IgdXMgdG8gcHJvY2VzcyBpbiB0aGlzIGNodW5rXG4gICAgICBpZiAoIShyb3dJbmRleCA8IHJvd3NMZW5ndGgpIHx8IHN0b3BwZWRQcm9jZXNzaW5nUm93cykge1xuICAgICAgICAvLyBpZiB3ZSBleGhhdXN0ZWQgYWxsIHRoZSByb3dzIGluIHRoaXMgY2h1bmsgYW5kIHdlIGhhdmVuJ3QgeWV0XG4gICAgICAgIC8vIHByb2Nlc3NlZCBhbGwgdGhlIHJvd3Mgd2Ugd2FudCB0byBwcm9jZXNzLCBhc2sgdGhlIHJlc3VsdCBzdHJlYW0gdG9cbiAgICAgICAgLy8gZG8gYW5vdGhlciByZWFkXG4gICAgICAgIGlmICghKHJvd0luZGV4IDwgcm93c0xlbmd0aCkgJiZcbiAgICAgICAgICBjb250ZXh0Lm51bVJvd3NQcm9jZXNzZWQgIT09IGNvbnRleHQubWF4TnVtUm93c1RvUHJvY2Vzcykge1xuICAgICAgICAgIHJlc3VsdFN0cmVhbS5yZWFkKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gd2UndmUgZWl0aGVyIHByb2Nlc3NlZCBhbGwgdGhlIHJvd3Mgd2Ugd2FudGVkIHRvIHByb2Nlc3Mgb3Igd2VcbiAgICAgICAgICAvLyB3ZXJlIHRvbGQgdG8gc3RvcCBwcm9jZXNzaW5nIHJvd3MgYnkgdGhlIGVhY2goKSBjYWxsYmFjazsgZWl0aGVyXG4gICAgICAgICAgLy8gd2F5LCBjbG9zZSB0aGUgcmVzdWx0IHN0cmVhbSB0byBjb21wbGV0ZSB0aGUgb3BlcmF0aW9uXG4gICAgICAgICAgcmVzdWx0U3RyZWFtLmFzeW5jQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBzdGFydCBwcm9jZXNzaW5nIHJvd3NcbiAgICBwcm9jZXNzUm93cygpO1xuICB9O1xuXG4gIC8vIHN0YXJ0IHJlYWRpbmcgZnJvbSB0aGUgc3RyZWFtIGluIHRoZSBuZXh0IHRpY2sgb2YgdGhlIGV2ZW50IGxvb3BcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgcmVzdWx0U3RyZWFtLnJlYWQoKTtcbiAgfSk7XG5cbiAgcmV0dXJuIG9wZXJhdGlvbjtcbn07XG5cbi8qKlxuICogR2l2ZW4gYSBzb3J0ZWQgYXJyYXkgb2YgY2h1bmtzLCByZXR1cm5zIGEgc3ViLWFycmF5IHRoYXQgb3ZlcmxhcHMgd2l0aCBhXG4gKiBzcGVjaWZpZWQgd2luZG93LlxuICpcbiAqIEBwYXJhbSBjaHVua3NcbiAqIEBwYXJhbSB3aW5kb3dTdGFydFxuICogQHBhcmFtIHdpbmRvd0VuZFxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqL1xuZnVuY3Rpb24gZmluZE92ZXJsYXBwaW5nQ2h1bmtzKGNodW5rcywgd2luZG93U3RhcnQsIHdpbmRvd0VuZCkge1xuICBjb25zdCBvdmVybGFwcGluZ0NodW5rcyA9IFtdO1xuXG4gIGlmIChjaHVua3MubGVuZ3RoICE9PSAwKSB7XG4gICAgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgY2h1bmsgdGhhdCBvdmVybGFwcyB3aXRoIHRoZSBzcGVjaWZpZWQgd2luZG93XG4gICAgbGV0IGluZGV4ID0gZmluZEZpcnN0T3ZlcmxhcHBpbmdDaHVuayhjaHVua3MsIHdpbmRvd1N0YXJ0LCB3aW5kb3dFbmQpO1xuXG4gICAgLy8gaXRlcmF0ZSBvdmVyIHRoZSBjaHVua3Mgc3RhcnRpbmcgd2l0aCB0aGUgZmlyc3Qgb3ZlcmxhcHBpbmcgY2h1bmsgYW5kXG4gICAgLy8ga2VlcCBnb2luZyB1bnRpbCB0aGVyZSdzIG5vIG92ZXJsYXBcbiAgICBmb3IgKGxldCBsZW5ndGggPSBjaHVua3MubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgY2h1bmsgPSBjaHVua3NbaW5kZXhdO1xuICAgICAgaWYgKGNodW5rLm92ZXJsYXBzV2l0aFdpbmRvdyh3aW5kb3dTdGFydCwgd2luZG93RW5kKSkge1xuICAgICAgICBvdmVybGFwcGluZ0NodW5rcy5wdXNoKGNodW5rKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIG5vIGZ1dHVyZSBjaHVua3Mgd2lsbCBvdmVybGFwIGJlY2F1c2UgdGhlIGNodW5rcyBhcnJheSBpcyBzb3J0ZWRcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG92ZXJsYXBwaW5nQ2h1bmtzO1xufVxuXG4vKipcbiAqIEdpdmVuIGEgc29ydGVkIGFycmF5IG9mIGNodW5rcywgcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGNodW5rIGluIHRoZVxuICogYXJyYXkgdGhhdCBvdmVybGFwcyB3aXRoIGEgc3BlY2lmaWVkIHdpbmRvdy5cbiAqXG4gKiBAcGFyYW0gY2h1bmtzXG4gKiBAcGFyYW0gd2luZG93U3RhcnRJbmRleFxuICogQHBhcmFtIHdpbmRvd0VuZEluZGV4XG4gKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZnVuY3Rpb24gZmluZEZpcnN0T3ZlcmxhcHBpbmdDaHVuayhjaHVua3MsIHdpbmRvd1N0YXJ0SW5kZXgsIHdpbmRvd0VuZEluZGV4KSB7XG4gIGNvbnN0IGhlbHBlciA9IGZ1bmN0aW9uIChjaHVua3MsXG4gICAgY2h1bmtJbmRleExlZnQsXG4gICAgY2h1bmtJbmRleFJpZ2h0LFxuICAgIHdpbmRvd1N0YXJ0SW5kZXgsXG4gICAgd2luZG93RW5kSW5kZXgpIHtcbiAgICBsZXQgcmVzdWx0O1xuICAgIGxldCBtaWRkbGVDaHVua0VuZEluZGV4O1xuXG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgcmV0dXJuIHZhbHVlIHRvIC0xXG4gICAgcmVzdWx0ID0gLTE7XG5cbiAgICAvLyBjb21wdXRlIHRoZSBpbmRleCBvZiB0aGUgbWlkZGxlIGNodW5rIGFuZCBnZXQgdGhlIG1pZGRsZSBjaHVua1xuICAgIGNvbnN0IGNodW5rSW5kZXhNaWRkbGUgPSBNYXRoLmZsb29yKChjaHVua0luZGV4TGVmdCArIGNodW5rSW5kZXhSaWdodCkgLyAyKTtcbiAgICBjb25zdCBtaWRkbGVDaHVuayA9IGNodW5rc1tjaHVua0luZGV4TWlkZGxlXTtcblxuICAgIC8vIGlmIHdlIGhhdmUgdHdvIG9yIGZld2VyIGNodW5rc1xuICAgIGlmICgoY2h1bmtJbmRleE1pZGRsZSA9PT0gY2h1bmtJbmRleExlZnQpIHx8XG4gICAgICAoY2h1bmtJbmRleE1pZGRsZSA9PT0gY2h1bmtJbmRleFJpZ2h0KSkge1xuICAgICAgLy8gaWYgd2UgaGF2ZSBqdXN0IG9uZSBjaHVuaywgYW5kIGl0IG92ZXJsYXBzIHdpdGggdGhlIHNwZWNpZmllZCB3aW5kb3csXG4gICAgICAvLyB3ZSd2ZSBmb3VuZCB0aGUgY2h1bmsgd2Ugd2VyZSBsb29raW5nIGZvclxuICAgICAgaWYgKGNodW5rSW5kZXhMZWZ0ID09PSBjaHVua0luZGV4UmlnaHQpIHtcbiAgICAgICAgaWYgKG1pZGRsZUNodW5rLm92ZXJsYXBzV2l0aFdpbmRvdyh3aW5kb3dTdGFydEluZGV4LCB3aW5kb3dFbmRJbmRleCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBjaHVua0luZGV4TGVmdDtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHsgLy8gd2UganVzdCBoYXZlIHR3byBjaHVua3MgbGVmdCB0byBjaGVja1xuICAgICAgICAvLyBpZiB0aGUgZmlyc3QgY2h1bmsgb3ZlcmxhcHMgd2l0aCB0aGUgc3BlY2lmaWVkIHdpbmRvdywgdGhhdCdzIHRoZVxuICAgICAgICAvLyBjaHVuayB3ZSB3ZXJlIGxvb2tpbmcgZm9yXG4gICAgICAgIGlmIChjaHVua3NbY2h1bmtJbmRleExlZnRdLm92ZXJsYXBzV2l0aFdpbmRvdyhcbiAgICAgICAgICB3aW5kb3dTdGFydEluZGV4LCB3aW5kb3dFbmRJbmRleCkpIHtcbiAgICAgICAgICByZXN1bHQgPSBjaHVua0luZGV4TGVmdDtcbiAgICAgICAgfSBlbHNlIGlmIChjaHVua3NbY2h1bmtJbmRleFJpZ2h0XS5vdmVybGFwc1dpdGhXaW5kb3coXG4gICAgICAgICAgd2luZG93U3RhcnRJbmRleCwgd2luZG93RW5kSW5kZXgpKSB7XG4gICAgICAgICAgLy8gb3RoZXJ3aXNlLCBpZiB0aGUgc2Vjb25kIGNodW5rIG92ZXJsYXBzIHdpdGggdGhlIHNwZWNpZmllZCB3aW5kb3csXG4gICAgICAgICAgLy8gdGhhdCdzIHRoZSBjaHVuayB3ZSB3ZXJlIGxvb2tpbmcgZm9yXG4gICAgICAgICAgcmVzdWx0ID0gY2h1bmtJbmRleFJpZ2h0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIG1pZGRsZSBjaHVuayBkb2VzIG5vdCBvdmVybGFwIHdpdGggdGhlIHNwZWNpZmllZCB3aW5kb3dcbiAgICBpZiAoIW1pZGRsZUNodW5rLm92ZXJsYXBzV2l0aFdpbmRvdyh3aW5kb3dTdGFydEluZGV4LCB3aW5kb3dFbmRJbmRleCkpIHtcbiAgICAgIG1pZGRsZUNodW5rRW5kSW5kZXggPSBtaWRkbGVDaHVuay5nZXRFbmRJbmRleCgpO1xuXG4gICAgICAvLyBpZiB0aGUgd2luZG93IGlzIHRvIHRoZSByaWdodCBvZiB0aGUgbWlkZGxlIGNodW5rLFxuICAgICAgLy8gcmVjdXJzZSBvbiB0aGUgcmlnaHQgaGFsZlxuICAgICAgaWYgKHdpbmRvd1N0YXJ0SW5kZXggPiBtaWRkbGVDaHVua0VuZEluZGV4KSB7XG4gICAgICAgIHJldHVybiBoZWxwZXIoXG4gICAgICAgICAgY2h1bmtzLFxuICAgICAgICAgIGNodW5rSW5kZXhNaWRkbGUsXG4gICAgICAgICAgY2h1bmtJbmRleFJpZ2h0LFxuICAgICAgICAgIHdpbmRvd1N0YXJ0SW5kZXgsXG4gICAgICAgICAgd2luZG93RW5kSW5kZXgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gcmVjdXJzZSBvbiB0aGUgbGVmdCBoYWxmXG4gICAgICAgIHJldHVybiBoZWxwZXIoXG4gICAgICAgICAgY2h1bmtzLFxuICAgICAgICAgIGNodW5rSW5kZXhMZWZ0LFxuICAgICAgICAgIGNodW5rSW5kZXhNaWRkbGUsXG4gICAgICAgICAgd2luZG93U3RhcnRJbmRleCxcbiAgICAgICAgICB3aW5kb3dFbmRJbmRleCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIHRoZSBtaWRkbGUgY2h1bmsgb3ZlcmxhcHMgYnV0IHRoZSBjaHVuayBiZWZvcmUgaXQgZG9lcyBub3QsIHRoZVxuICAgICAgLy8gbWlkZGxlIGNodW5rIGlzIHRoZSBvbmUgd2Ugd2VyZSBsb29raW5nXG4gICAgICBpZiAoKGNodW5rSW5kZXhNaWRkbGUgPT09IDApIHx8XG4gICAgICAgICFjaHVua3NbY2h1bmtJbmRleE1pZGRsZSAtIDFdLm92ZXJsYXBzV2l0aFdpbmRvdyhcbiAgICAgICAgICB3aW5kb3dTdGFydEluZGV4LCB3aW5kb3dFbmRJbmRleCkpIHtcbiAgICAgICAgcmV0dXJuIGNodW5rSW5kZXhNaWRkbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyByZWN1cnNlIG9uIHRoZSBsZWZ0IGhhbGZcbiAgICAgICAgcmV0dXJuIGhlbHBlcihcbiAgICAgICAgICBjaHVua3MsXG4gICAgICAgICAgY2h1bmtJbmRleExlZnQsXG4gICAgICAgICAgY2h1bmtJbmRleE1pZGRsZSxcbiAgICAgICAgICB3aW5kb3dTdGFydEluZGV4LFxuICAgICAgICAgIHdpbmRvd0VuZEluZGV4KTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGhlbHBlcihjaHVua3MsIDAsIGNodW5rcy5sZW5ndGggLSAxLCB3aW5kb3dTdGFydEluZGV4LCB3aW5kb3dFbmRJbmRleCk7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY29sdW1ucyBpbiB0aGlzIHJlc3VsdC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0W119XG4gKi9cblJlc3VsdC5wcm90b3R5cGUuZ2V0Q29sdW1ucyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX2NvbHVtbnM7XG59O1xuXG4vKipcbiAqIEdpdmVuIGEgY29sdW1uIGlkZW50aWZpZXIsIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgY29sdW1uLiBUaGUgY29sdW1uXG4gKiBpZGVudGlmaWVyIGNhbiBiZSBlaXRoZXIgdGhlIGNvbHVtbiBuYW1lIChTdHJpbmcpIG9yIHRoZSBjb2x1bW4gaW5kZXhcbiAqIChOdW1iZXIpLiBJZiBhIGNvbHVtbiBuYW1lIGlzIHNwZWNpZmllZCBhbmQgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBjb2x1bW5cbiAqIHdpdGggdGhhdCBuYW1lLCB0aGUgZmlyc3QgY29sdW1uIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lIHdpbGwgYmUgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGNvbHVtbklkZW50aWZpZXJcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5SZXN1bHQucHJvdG90eXBlLmdldENvbHVtbiA9IGZ1bmN0aW9uIChjb2x1bW5JZGVudGlmaWVyKSB7XG4gIGxldCBjb2x1bW5JbmRleDtcblxuICAvLyBpZiB0aGUgY29sdW1uIGlkZW50aWZpZXIgaXMgYSBzdHJpbmcsIHRyZWF0IGl0IGFzIGEgY29sdW1uXG4gIC8vIG5hbWUgYW5kIHVzZSBpdCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBzcGVjaWZpZWQgY29sdW1uXG4gIGlmIChVdGlsLmlzU3RyaW5nKGNvbHVtbklkZW50aWZpZXIpKSB7XG4gICAgLy8gaWYgYSB2YWxpZCBjb2x1bW4gbmFtZSB3YXMgc3BlY2lmaWVkLCBnZXQgdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBjb2x1bW5cbiAgICAvLyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZVxuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy5fbWFwQ29sdW1uTmFtZVRvSW5kaWNlcywgY29sdW1uSWRlbnRpZmllcikpIHtcbiAgICAgIGNvbHVtbkluZGV4ID0gdGhpcy5fbWFwQ29sdW1uTmFtZVRvSW5kaWNlc1tjb2x1bW5JZGVudGlmaWVyXVswXTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoVXRpbC5pc051bWJlcihjb2x1bW5JZGVudGlmaWVyKSkge1xuICAgIC8vIGlmIHRoZSBjb2x1bW4gaWRlbnRpZmllciBpcyBhIG51bWJlciwgdHJlYXQgaXQgYXMgYSBjb2x1bW4gaW5kZXhcbiAgICBjb2x1bW5JbmRleCA9IGNvbHVtbklkZW50aWZpZXI7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fY29sdW1uc1tjb2x1bW5JbmRleF07XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIHN0YXRlbWVudCBpZCBnZW5lcmF0ZWQgYnkgdGhlIHNlcnZlciBmb3IgdGhlIHN0YXRlbWVudCB0aGF0XG4gKiBwcm9kdWNlZCB0aGlzIHJlc3VsdC5cbiAqXG4gKiBTaG91bGQgdXNlIGdldFF1ZXJ5SWQgaW5zdGVhZC5cbiAqIEBkZXByZWNhdGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5SZXN1bHQucHJvdG90eXBlLmdldFN0YXRlbWVudElkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcXVlcnlJZDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcXVlcnkgaWQgZ2VuZXJhdGVkIGJ5IHRoZSBzZXJ2ZXIgZm9yIHRoZSBzdGF0ZW1lbnQgdGhhdFxuICogcHJvZHVjZWQgdGhpcyByZXN1bHQuXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUmVzdWx0LnByb3RvdHlwZS5nZXRRdWVyeUlkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcXVlcnlJZDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3MgaW4gdGhpcyByZXN1bHQuXG4gKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuUmVzdWx0LnByb3RvdHlwZS5nZXRSZXR1cm5lZFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZXR1cm5lZFJvd3M7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIHVwZGF0ZWQgYnkgdGhlIHN0YXRlbWVudCB0aGF0IHByb2R1Y2VkIHRoaXNcbiAqIHJlc3VsdC4gSWYgdGhlIHN0YXRlbWVudCBpc24ndCBhIERNTCwgd2UgcmV0dXJuIC0xLlxuICpcbiAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gKi9cblJlc3VsdC5wcm90b3R5cGUuZ2V0TnVtVXBkYXRlZFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGluaXRpYWxpemUgaWYgbmVjZXNzYXJ5XG4gIGlmICghdGhpcy5fbnVtVXBkYXRlZFJvd3MpIHtcbiAgICBsZXQgbnVtVXBkYXRlZFJvd3MgPSAtMTtcblxuICAgIC8vIHRoZSB1cGRhdGVkLXJvd3MgbWV0cmljIG9ubHkgYXBwbGllcyB0byBkbWwnc1xuICAgIGNvbnN0IHN0YXRlbWVudFR5cGVJZCA9IHRoaXMuX3N0YXRlbWVudFR5cGVJZDtcbiAgICBpZiAoU3RhdGVtZW50VHlwZS5pc0RtbChzdGF0ZW1lbnRUeXBlSWQpKSB7XG4gICAgICBpZiAoU3RhdGVtZW50VHlwZS5pc0luc2VydChzdGF0ZW1lbnRUeXBlSWQpIHx8XG4gICAgICAgIFN0YXRlbWVudFR5cGUuaXNVcGRhdGUoc3RhdGVtZW50VHlwZUlkKSB8fFxuICAgICAgICBTdGF0ZW1lbnRUeXBlLmlzRGVsZXRlKHN0YXRlbWVudFR5cGVJZCkgfHxcbiAgICAgICAgU3RhdGVtZW50VHlwZS5pc01lcmdlKHN0YXRlbWVudFR5cGVJZCkgfHxcbiAgICAgICAgU3RhdGVtZW50VHlwZS5pc011bHRpVGFibGVJbnNlcnQoc3RhdGVtZW50VHlwZUlkKSkge1xuICAgICAgICBjb25zdCBjaHVua3MgPSB0aGlzLl9jaHVua3M7XG4gICAgICAgIGNvbnN0IGNvbHVtbnMgPSB0aGlzLl9jb2x1bW5zO1xuXG4gICAgICAgIC8vIGlmIHRoZSBzdGF0ZW1lbnQgaXMgYSBkbWwsIHRoZSByZXN1bHQgc2hvdWxkIGJlIHNtYWxsLFxuICAgICAgICAvLyBtZWFuaW5nIHdlIG9ubHkgaGF2ZSBvbmUgY2h1bmtcbiAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNBcnJheShjaHVua3MpICYmIChjaHVua3MubGVuZ3RoID09PSAxKSk7XG5cbiAgICAgICAgLy8gYWRkIHVwIHRoZSB2YWx1ZXMgaW4gYWxsIHRoZSBjb2x1bW5zXG4gICAgICAgIG51bVVwZGF0ZWRSb3dzID0gMDtcbiAgICAgICAgY29uc3Qgcm93cyA9IGNodW5rc1swXS5nZXRSb3dzKCk7XG4gICAgICAgIGZvciAobGV0IHJvd0luZGV4ID0gMCwgcm93c0xlbmd0aCA9IHJvd3MubGVuZ3RoO1xuICAgICAgICAgIHJvd0luZGV4IDwgcm93c0xlbmd0aDsgcm93SW5kZXgrKykge1xuICAgICAgICAgIGNvbnN0IHJvdyA9IHJvd3Nbcm93SW5kZXhdO1xuICAgICAgICAgIGZvciAobGV0IGNvbEluZGV4ID0gMCwgY29sc0xlbmd0aCA9IGNvbHVtbnMubGVuZ3RoO1xuICAgICAgICAgICAgY29sSW5kZXggPCBjb2xzTGVuZ3RoOyBjb2xJbmRleCsrKSB7XG4gICAgICAgICAgICBudW1VcGRhdGVkUm93cyArPSBOdW1iZXIoXG4gICAgICAgICAgICAgIHJvdy5nZXRDb2x1bW5WYWx1ZShjb2x1bW5zW2NvbEluZGV4XS5nZXRJZCgpKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBUT0RPOiBoYW5kbGUgJ2NvcHknIGFuZCAndW5sb2FkJ1xuICAgIH1cblxuICAgIHRoaXMuX251bVVwZGF0ZWRSb3dzID0gbnVtVXBkYXRlZFJvd3M7XG4gIH1cblxuICByZXR1cm4gdGhpcy5fbnVtVXBkYXRlZFJvd3M7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG51bWJlciBvZiByb3dzIHdlIHdvdWxkIGhhdmUgaGFkIGluIHRoaXMgcmVzdWx0IGlmIHRoZSB2YWx1ZSBvZlxuICogdGhlIFJPV1NfUEVSX1JFU1VMVFNFVCBwYXJhbWV0ZXIgd2FzIDAgYXQgdGhlIHRpbWUgdGhpcyBzdGF0ZW1lbnQgd2FzXG4gKiBleGVjdXRlZC5cbiAqXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxuICovXG5SZXN1bHQucHJvdG90eXBlLmdldFRvdGFsUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMuX3RvdGFsUm93cztcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgcGFyYW1ldGVycyBhc3NvY2lhdGVkIHdpdGggdGhpcyByZXN1bHQuIFRoZXNlIHBhcmFtZXRlcnMgY29udGFpblxuICogZGlyZWN0aXZlcyBhYm91dCBob3cgdG8gY29uc3VtZSBhbmQgcHJlc2VudCB0aGUgcmVzdWx0LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3RbXX1cbiAqL1xuUmVzdWx0LnByb3RvdHlwZS5nZXRQYXJhbWV0ZXJzQXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9wYXJhbWV0ZXJzQXJyYXk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgaW5mb3JtYXRpb24gYWJvdXQgdGhlIHZhbHVlcyBvZiB0aGUgY3VycmVudFxuICogd2FyZWhvdXNlLCBjdXJyZW50IGRhdGFiYXNlLCBhbmQgYW55IG90aGVyIHNlc3Npb24tcmVsYXRlZCBzdGF0ZSB3aGVuIHRoZVxuICogc3RhdGVtZW50IHRoYXQgcHJvZHVjZWQgdGhpcyByZXN1bHQgZmluaXNoZWQgZXhlY3V0aW5nLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblJlc3VsdC5wcm90b3R5cGUuZ2V0U2Vzc2lvblN0YXRlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fc2Vzc2lvblN0YXRlO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2ZXJzaW9uIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHJlc3VsdC5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5SZXN1bHQucHJvdG90eXBlLmdldFZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl92ZXJzaW9uO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBSZXN1bHQ7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/result/result.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/result/result_stream.js":
/*!***************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/result/result_stream.js ***!
  \***************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\n\n/**\n * Creates a stream-like object that can be used to read the contents of an\n * array of chunks with the ability to prefetch chunks as we go. Every time the\n * contents of a new chunk become available, a 'data' event is fired. When there\n * are no more chunks to read, a 'close' event is fired to indicate that the\n * read operation is complete. If no chunks are specified in the options, the\n * stream asynchronously fires a 'close' event after it is returned.\n *\n * @param {Object} [options] An options object with the following properties:\n *   {Object[]} chunks       - The chunks to read.\n *   {Number}   prefetchSize - The number of chunks to prefetch every time a new\n *     chunk is read.\n *\n * @constructor\n */\nfunction ResultStream(options) {\n  // options should be an object\n  Errors.assertInternal(Util.isObject(options));\n\n  const chunks = options.chunks;\n  const prefetchSize = options.prefetchSize;\n\n  // chunks should be an array\n  Errors.assertInternal(Util.isArray(chunks));\n\n  // prefetch size should be non-negative\n  Errors.assertInternal(Util.isNumber(prefetchSize) && (prefetchSize >= 0));\n\n  // Current chunk being streamed. Start with the first chunk.\n  let currChunk = 0;\n\n  const self = this;\n\n  /**\n   * Called when a chunk fires a 'loadcomplete' event.\n   *\n   * @param {Error} err\n   * @param {Chunk} chunk\n   */\n  const onLoadComplete = function (err, chunk) {\n    // unsubscribe from the 'loadcomplete' event\n    chunk.removeListener('loadcomplete', onLoadComplete);\n\n    // if the chunk load succeeded\n    if (!err) {\n      // Move on to the next chunk\n      currChunk++;\n\n      // emit an event to signal that new data is available\n      self.emit('data', chunk);\n    } else {\n      // close the stream with an error; also, include a callback when emitting\n      // the event in case someone wants to fix the problem and ask us to\n      // continue from where we got interrupted\n      close(self, err, doLoad);\n    }\n  };\n\n  /**\n   * Identifies the next chunk to load and issues requests to fetch both its\n   * contents plus the contents of the next few chunks. If there are no more\n   * chunks to load, a 'close' event is fired on the stream to notify\n   * subscribers that all the chunks have been successfully read.\n   */\n  const doLoad = function () {\n    // All chunks were loaded, we're done\n    if (currChunk >= chunks.length) {\n      self.asyncClose();\n    } else {\n      // Subscribe to the loadcomplete event on the current chunk being streamed to ensure the\n      // rows are returned in the correct order and not in the order chunk data are received\n      chunks[currChunk].on('loadcomplete', onLoadComplete);\n\n      // Fire off requests to load all the chunks in the buffer that aren't already loading\n      let chunk, index;\n      for (index = currChunk; index < chunks.length && index <= (currChunk + prefetchSize); index++) {\n        chunk = chunks[index];\n        if (!chunk.isLoading()) {\n          chunk.load();\n        }\n      }\n    }\n  };\n\n  /**\n   * Reads the next chunk of data in the result stream.\n   */\n  this.read = function () {\n    // TODO: if there are no more chunks to read, should we raise an error?\n    // TODO: what if we're already in the middle of a read?\n\n    // read the next chunk\n    doLoad();\n  };\n}\n\nUtil.inherits(ResultStream, EventEmitter);\n\n/**\n * Asynchronously closes this stream.\n *\n * @returns {ResultStream}\n */\nResultStream.prototype.asyncClose = function () {\n  // schedule an operation to close the stream in\n  // the next tick of the event loop\n  const self = this;\n  process.nextTick(function () {\n    close(self);\n  });\n\n  return this;\n};\n\n/**\n * Closes a given result stream.\n *\n * @param {ResultStream} stream The stream to close.\n * @param {Error} [err] The error, if any, to fire with the close event.\n * @param {Function} [callback] The callback, if any, to fire with the close\n *   event. This is in case someone wants to fix the problem and ask the stream\n *   to resume from the point of interruption.\n */\nfunction close(stream, err, callback) {\n  stream.emit('close', err, callback);\n}\n\nmodule.exports = ResultStream;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvcmVzdWx0X3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxQkFBcUIsMERBQThCO0FBQ25ELGFBQWEsbUJBQU8sQ0FBQyxrRUFBWTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsc0VBQWM7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsTUFBTSxVQUFVO0FBQ2hCLE1BQU0sVUFBVTtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTix5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhCQUE4Qiw4REFBOEQ7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVyxPQUFPO0FBQ2xCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvcmVzdWx0X3N0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vLi4vdXRpbCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vLi4vZXJyb3JzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0cmVhbS1saWtlIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIHJlYWQgdGhlIGNvbnRlbnRzIG9mIGFuXG4gKiBhcnJheSBvZiBjaHVua3Mgd2l0aCB0aGUgYWJpbGl0eSB0byBwcmVmZXRjaCBjaHVua3MgYXMgd2UgZ28uIEV2ZXJ5IHRpbWUgdGhlXG4gKiBjb250ZW50cyBvZiBhIG5ldyBjaHVuayBiZWNvbWUgYXZhaWxhYmxlLCBhICdkYXRhJyBldmVudCBpcyBmaXJlZC4gV2hlbiB0aGVyZVxuICogYXJlIG5vIG1vcmUgY2h1bmtzIHRvIHJlYWQsIGEgJ2Nsb3NlJyBldmVudCBpcyBmaXJlZCB0byBpbmRpY2F0ZSB0aGF0IHRoZVxuICogcmVhZCBvcGVyYXRpb24gaXMgY29tcGxldGUuIElmIG5vIGNodW5rcyBhcmUgc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zLCB0aGVcbiAqIHN0cmVhbSBhc3luY2hyb25vdXNseSBmaXJlcyBhICdjbG9zZScgZXZlbnQgYWZ0ZXIgaXQgaXMgcmV0dXJuZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCB3aXRoIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllczpcbiAqICAge09iamVjdFtdfSBjaHVua3MgICAgICAgLSBUaGUgY2h1bmtzIHRvIHJlYWQuXG4gKiAgIHtOdW1iZXJ9ICAgcHJlZmV0Y2hTaXplIC0gVGhlIG51bWJlciBvZiBjaHVua3MgdG8gcHJlZmV0Y2ggZXZlcnkgdGltZSBhIG5ld1xuICogICAgIGNodW5rIGlzIHJlYWQuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIFJlc3VsdFN0cmVhbShvcHRpb25zKSB7XG4gIC8vIG9wdGlvbnMgc2hvdWxkIGJlIGFuIG9iamVjdFxuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zKSk7XG5cbiAgY29uc3QgY2h1bmtzID0gb3B0aW9ucy5jaHVua3M7XG4gIGNvbnN0IHByZWZldGNoU2l6ZSA9IG9wdGlvbnMucHJlZmV0Y2hTaXplO1xuXG4gIC8vIGNodW5rcyBzaG91bGQgYmUgYW4gYXJyYXlcbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNBcnJheShjaHVua3MpKTtcblxuICAvLyBwcmVmZXRjaCBzaXplIHNob3VsZCBiZSBub24tbmVnYXRpdmVcbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNOdW1iZXIocHJlZmV0Y2hTaXplKSAmJiAocHJlZmV0Y2hTaXplID49IDApKTtcblxuICAvLyBDdXJyZW50IGNodW5rIGJlaW5nIHN0cmVhbWVkLiBTdGFydCB3aXRoIHRoZSBmaXJzdCBjaHVuay5cbiAgbGV0IGN1cnJDaHVuayA9IDA7XG5cbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIGEgY2h1bmsgZmlyZXMgYSAnbG9hZGNvbXBsZXRlJyBldmVudC5cbiAgICpcbiAgICogQHBhcmFtIHtFcnJvcn0gZXJyXG4gICAqIEBwYXJhbSB7Q2h1bmt9IGNodW5rXG4gICAqL1xuICBjb25zdCBvbkxvYWRDb21wbGV0ZSA9IGZ1bmN0aW9uIChlcnIsIGNodW5rKSB7XG4gICAgLy8gdW5zdWJzY3JpYmUgZnJvbSB0aGUgJ2xvYWRjb21wbGV0ZScgZXZlbnRcbiAgICBjaHVuay5yZW1vdmVMaXN0ZW5lcignbG9hZGNvbXBsZXRlJywgb25Mb2FkQ29tcGxldGUpO1xuXG4gICAgLy8gaWYgdGhlIGNodW5rIGxvYWQgc3VjY2VlZGVkXG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIC8vIE1vdmUgb24gdG8gdGhlIG5leHQgY2h1bmtcbiAgICAgIGN1cnJDaHVuaysrO1xuXG4gICAgICAvLyBlbWl0IGFuIGV2ZW50IHRvIHNpZ25hbCB0aGF0IG5ldyBkYXRhIGlzIGF2YWlsYWJsZVxuICAgICAgc2VsZi5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjbG9zZSB0aGUgc3RyZWFtIHdpdGggYW4gZXJyb3I7IGFsc28sIGluY2x1ZGUgYSBjYWxsYmFjayB3aGVuIGVtaXR0aW5nXG4gICAgICAvLyB0aGUgZXZlbnQgaW4gY2FzZSBzb21lb25lIHdhbnRzIHRvIGZpeCB0aGUgcHJvYmxlbSBhbmQgYXNrIHVzIHRvXG4gICAgICAvLyBjb250aW51ZSBmcm9tIHdoZXJlIHdlIGdvdCBpbnRlcnJ1cHRlZFxuICAgICAgY2xvc2Uoc2VsZiwgZXJyLCBkb0xvYWQpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSWRlbnRpZmllcyB0aGUgbmV4dCBjaHVuayB0byBsb2FkIGFuZCBpc3N1ZXMgcmVxdWVzdHMgdG8gZmV0Y2ggYm90aCBpdHNcbiAgICogY29udGVudHMgcGx1cyB0aGUgY29udGVudHMgb2YgdGhlIG5leHQgZmV3IGNodW5rcy4gSWYgdGhlcmUgYXJlIG5vIG1vcmVcbiAgICogY2h1bmtzIHRvIGxvYWQsIGEgJ2Nsb3NlJyBldmVudCBpcyBmaXJlZCBvbiB0aGUgc3RyZWFtIHRvIG5vdGlmeVxuICAgKiBzdWJzY3JpYmVycyB0aGF0IGFsbCB0aGUgY2h1bmtzIGhhdmUgYmVlbiBzdWNjZXNzZnVsbHkgcmVhZC5cbiAgICovXG4gIGNvbnN0IGRvTG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBBbGwgY2h1bmtzIHdlcmUgbG9hZGVkLCB3ZSdyZSBkb25lXG4gICAgaWYgKGN1cnJDaHVuayA+PSBjaHVua3MubGVuZ3RoKSB7XG4gICAgICBzZWxmLmFzeW5jQ2xvc2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3Vic2NyaWJlIHRvIHRoZSBsb2FkY29tcGxldGUgZXZlbnQgb24gdGhlIGN1cnJlbnQgY2h1bmsgYmVpbmcgc3RyZWFtZWQgdG8gZW5zdXJlIHRoZVxuICAgICAgLy8gcm93cyBhcmUgcmV0dXJuZWQgaW4gdGhlIGNvcnJlY3Qgb3JkZXIgYW5kIG5vdCBpbiB0aGUgb3JkZXIgY2h1bmsgZGF0YSBhcmUgcmVjZWl2ZWRcbiAgICAgIGNodW5rc1tjdXJyQ2h1bmtdLm9uKCdsb2FkY29tcGxldGUnLCBvbkxvYWRDb21wbGV0ZSk7XG5cbiAgICAgIC8vIEZpcmUgb2ZmIHJlcXVlc3RzIHRvIGxvYWQgYWxsIHRoZSBjaHVua3MgaW4gdGhlIGJ1ZmZlciB0aGF0IGFyZW4ndCBhbHJlYWR5IGxvYWRpbmdcbiAgICAgIGxldCBjaHVuaywgaW5kZXg7XG4gICAgICBmb3IgKGluZGV4ID0gY3VyckNodW5rOyBpbmRleCA8IGNodW5rcy5sZW5ndGggJiYgaW5kZXggPD0gKGN1cnJDaHVuayArIHByZWZldGNoU2l6ZSk7IGluZGV4KyspIHtcbiAgICAgICAgY2h1bmsgPSBjaHVua3NbaW5kZXhdO1xuICAgICAgICBpZiAoIWNodW5rLmlzTG9hZGluZygpKSB7XG4gICAgICAgICAgY2h1bmsubG9hZCgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBSZWFkcyB0aGUgbmV4dCBjaHVuayBvZiBkYXRhIGluIHRoZSByZXN1bHQgc3RyZWFtLlxuICAgKi9cbiAgdGhpcy5yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFRPRE86IGlmIHRoZXJlIGFyZSBubyBtb3JlIGNodW5rcyB0byByZWFkLCBzaG91bGQgd2UgcmFpc2UgYW4gZXJyb3I/XG4gICAgLy8gVE9ETzogd2hhdCBpZiB3ZSdyZSBhbHJlYWR5IGluIHRoZSBtaWRkbGUgb2YgYSByZWFkP1xuXG4gICAgLy8gcmVhZCB0aGUgbmV4dCBjaHVua1xuICAgIGRvTG9hZCgpO1xuICB9O1xufVxuXG5VdGlsLmluaGVyaXRzKFJlc3VsdFN0cmVhbSwgRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBBc3luY2hyb25vdXNseSBjbG9zZXMgdGhpcyBzdHJlYW0uXG4gKlxuICogQHJldHVybnMge1Jlc3VsdFN0cmVhbX1cbiAqL1xuUmVzdWx0U3RyZWFtLnByb3RvdHlwZS5hc3luY0Nsb3NlID0gZnVuY3Rpb24gKCkge1xuICAvLyBzY2hlZHVsZSBhbiBvcGVyYXRpb24gdG8gY2xvc2UgdGhlIHN0cmVhbSBpblxuICAvLyB0aGUgbmV4dCB0aWNrIG9mIHRoZSBldmVudCBsb29wXG4gIGNvbnN0IHNlbGYgPSB0aGlzO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBjbG9zZShzZWxmKTtcbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIENsb3NlcyBhIGdpdmVuIHJlc3VsdCBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtSZXN1bHRTdHJlYW19IHN0cmVhbSBUaGUgc3RyZWFtIHRvIGNsb3NlLlxuICogQHBhcmFtIHtFcnJvcn0gW2Vycl0gVGhlIGVycm9yLCBpZiBhbnksIHRvIGZpcmUgd2l0aCB0aGUgY2xvc2UgZXZlbnQuXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBjYWxsYmFjaywgaWYgYW55LCB0byBmaXJlIHdpdGggdGhlIGNsb3NlXG4gKiAgIGV2ZW50LiBUaGlzIGlzIGluIGNhc2Ugc29tZW9uZSB3YW50cyB0byBmaXggdGhlIHByb2JsZW0gYW5kIGFzayB0aGUgc3RyZWFtXG4gKiAgIHRvIHJlc3VtZSBmcm9tIHRoZSBwb2ludCBvZiBpbnRlcnJ1cHRpb24uXG4gKi9cbmZ1bmN0aW9uIGNsb3NlKHN0cmVhbSwgZXJyLCBjYWxsYmFjaykge1xuICBzdHJlYW0uZW1pdCgnY2xvc2UnLCBlcnIsIGNhbGxiYWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZXN1bHRTdHJlYW07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/result/result_stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/result/row_stream.js":
/*!************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/result/row_stream.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Readable = (__webpack_require__(/*! stream */ \"stream\").Readable);\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst ResultStream = __webpack_require__(/*! ./result_stream */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/result_stream.js\");\nconst DataTypes = __webpack_require__(/*! ./data_types */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/data_types.js\");\nconst RowMode = __webpack_require__(/*! ./../../constants/row_mode */ \"(rsc)/./node_modules/snowflake-sdk/lib/constants/row_mode.js\");\n\n/**\n * Creates a stream that can be used to read a statement result row by row.\n *\n * @param {Object} statement\n * @param {Object} context\n * @param {Object} options\n * @constructor\n */\nfunction RowStream(statement, context, options) {\n  // validate non-user-specified arguments\n  Errors.assertInternal(Util.exists(statement));\n  Errors.assertInternal(Util.exists(context));\n\n  // call Readable constructor\n  Readable.call(this,\n    {\n      objectMode: true,\n      highWaterMark: context.connectionConfig.getRowStreamHighWaterMark()\n    });\n\n  // extract streaming options\n  let start, end, fetchAsString, rowMode;\n  if (Util.isObject(options)) {\n    start = options.start;\n    end = options.end;\n    fetchAsString = options.fetchAsString;\n  }\n\n  // if a fetchAsString value is not specified in the stream options, try the\n  // statement and connection options (in that order)\n  if (!Util.exists(fetchAsString)) {\n    fetchAsString = context.fetchAsString;\n  }\n  if (!Util.exists(fetchAsString)) {\n    fetchAsString = context.connectionConfig.getFetchAsString();\n  }\n  if (!Util.exists(rowMode)) {\n    rowMode = context.rowMode || context.connectionConfig.getRowMode();\n  }\n\n  let resultStream = null, numResultStreamInterrupts = 0;\n  let rowBuffer = null, rowIndex = 0;\n  let columns, mapColumnIdToExtractFnName;\n  let initialized = false;\n  let previousChunk = null;\n\n  const self = this;\n\n  /**\n   * Reads the next row in the result.\n   *\n   * @private\n   */\n  this._read = function () {\n    // if the stream has been initialized, just read the next row\n    if (initialized) {\n      readNextRow();\n    } else if (context.isFetchingResult) {\n      // if we're still fetching the result, wait for the operation to complete\n      context.on('statement-complete', init);\n    } else if (context.result || isStatementErrorFatal(context)) {\n      // if we have a result or a fatal error, call init() in the next tick of\n      // the event loop\n      process.nextTick(init);\n    } else {\n      if (typeof context.multiResultIds === 'undefined') {\n        // fetch the result again and call init() upon completion of the operation\n        context.refresh(init);\n      } else {\n        //do nothing\n      }\n    }\n  };\n\n  /**\n   * Initializes this stream.\n   */\n  const init = function init() {\n    // the stream has now been initialized\n    initialized = true;\n\n    // if we have a result\n    if (context.result) {\n      // if no value was specified for the start index or if the specified start\n      // index is negative, default to 0, otherwise truncate the fractional part\n      start = (!Util.isNumber(start) || (start < 0)) ? 0 : Math.floor(start);\n\n      // if no value was specified for the end index or if the end index is\n      // larger than the row index of the last row, default to the index of the\n      // last row, otherwise truncate the fractional part\n      const returnedRows = context.result.getReturnedRows();\n      end = (!Util.isNumber(end) || (end >= returnedRows)) ? returnedRows - 1 :\n        Math.floor(end);\n\n      // find all the chunks that overlap with the specified range\n      const overlappingChunks = context.result.findOverlappingChunks(start, end);\n\n      // if no chunks overlap or start is greater than end, we're done\n      if ((overlappingChunks.length === 0) || (start > end)) {\n        process.nextTick(close);\n      } else {\n        // create a result stream from the overlapping chunks\n        resultStream = new ResultStream(\n          {\n            chunks: overlappingChunks,\n            prefetchSize: context.connectionConfig.getResultPrefetch()\n          });\n\n        readNextRow();\n      }\n    } else {\n      close(context.resultError);\n    }\n  };\n\n  /**\n   * Processes the row buffer.\n   */\n  const processRowBuffer = function processRowBuffer() {\n    // get the row to add to the read queue\n    let row = rowBuffer[rowIndex++];\n\n    // if we just read the last row in the row buffer, clear the row buffer and\n    // reset the row index so that we load the next chunk in the result stream\n    // when _read() is called\n    if (rowIndex === rowBuffer.length) {\n      rowBuffer = null;\n      rowIndex = 0;\n    }\n\n    // initialize the columns and column-related maps if necessary\n    if (!columns) {\n      columns = statement.getColumns();\n    }\n    if (!mapColumnIdToExtractFnName) {\n      mapColumnIdToExtractFnName =\n        buildMapColumnExtractFnNames(columns, fetchAsString);\n    }\n\n    // add the next row to the read queue\n    process.nextTick(function () {\n      // check if there are still rows available in the rowBuffer\n      if (rowBuffer && rowIndex > 0) {\n        rowIndex--; // decrement the index to include the previous row in the while loop\n\n        // push() data to readable stream until highWaterMark threshold is reached or all rows are pushed\n        while (rowIndex < rowBuffer.length) {\n          row = rowBuffer[rowIndex++];\n\n          // if buffer has reached the threshold based on the highWaterMark value then\n          // push() will return false and pause sending data to the buffer until the data is read from the buffer\n          if (!self.push(externalizeRow(row, columns, mapColumnIdToExtractFnName, rowMode))) {\n            break;\n          }\n        }\n\n        // check if all rows in rowBuffer has been pushed to the readable stream\n        if (rowIndex === rowBuffer.length) {\n          // reset the buffer and index\n          rowBuffer = null;\n          rowIndex = 0;\n        }\n      } else {\n        // No more rows left in the buffer\n        // Push the last row in the buffer\n        self.push(externalizeRow(row, columns, mapColumnIdToExtractFnName, rowMode));\n      }\n    });\n  };\n\n  /**\n   * Called when the result stream reads a new chunk.\n   *\n   * @param {Chunk} chunk\n   */\n  const onResultStreamData = function onResultStreamData(chunk) {\n    // unsubscribe from the result stream's 'data' and 'close' events\n    resultStream.removeListener('data', onResultStreamData);\n    resultStream.removeListener('close', onResultStreamClose);\n\n    // get all the rows in the chunk that overlap with the requested window,\n    // and use the resulting array as the new row buffer\n    const chunkStart = chunk.getStartIndex();\n    const chunkEnd = chunk.getEndIndex();\n    rowBuffer = chunk.getRows().slice(\n      Math.max(chunkStart, start) - chunkStart,\n      Math.min(chunkEnd, end) + 1 - chunkStart);\n\n    // reset the row index\n    rowIndex = 0;\n\n    // process the row buffer\n    processRowBuffer();\n\n    if (previousChunk && (previousChunk !== chunk)) {\n      previousChunk.clearRows();\n    }\n\n    previousChunk = chunk;\n  };\n\n  /**\n   * Called when there are no more chunks to read in the result stream or an\n   * error is encountered while trying to read the next chunk.\n   *\n   * @param err\n   * @param continueCallback\n   */\n  const onResultStreamClose = function onResultStreamClose(err, continueCallback) {\n    // if the error is retryable and\n    // the result stream hasn't been closed too many times\n    if (isResultStreamErrorRetryable(err) &&\n      (numResultStreamInterrupts <\n        context.connectionConfig.getResultStreamInterrupts())) {\n      numResultStreamInterrupts++;\n\n      // fetch the statement result again\n      context.refresh(function () {\n        if (context.resultError) {\n          close(context.resultError);\n        } else {\n          continueCallback();\n        }\n      });\n    } else {\n      close(err);\n    }\n  };\n\n  /**\n   * Closes the row stream.\n   *\n   * @param {Error} [err]\n   */\n  const close = function (err) {\n    // if we have a result stream, stop listening to events on it\n    if (resultStream) {\n      resultStream.removeListener('data', onResultStreamData);\n      resultStream.removeListener('close', onResultStreamClose);\n    }\n\n    // we're done, so time to clean up\n    rowBuffer = null;\n    rowIndex = 0;\n    resultStream = null;\n    numResultStreamInterrupts = 0;\n    if (previousChunk) {\n      previousChunk.clearRows();\n      previousChunk = null;\n    }\n\n    if (err) {\n      emitError(err);\n    } else {\n      self.push(null);\n    }\n  };\n\n  /**\n   * Called when we're ready to read the next row in the result.\n   */\n  const readNextRow = function readNextRow() {\n    // if we have a row buffer, process it\n    if (rowBuffer) {\n      processRowBuffer();\n    } else {\n      // subscribe to the result stream's 'data' and 'close' events\n      resultStream.on('data', onResultStreamData);\n      resultStream.on('close', onResultStreamClose);\n\n      // issue a request to fetch the next chunk in the result stream\n      resultStream.read();\n    }\n  };\n\n  /**\n   * Externalizes an error and emits it.\n   *\n   * @param {Error} err\n   */\n  const emitError = function emitError(err) {\n    self.emit('error', Errors.externalize(err));\n  };\n}\n\nUtil.inherits(RowStream, Readable);\n\n/**\n * Determines if a statement error is fatal.\n *\n * @returns {Boolean}\n * @param context\n */\nfunction isStatementErrorFatal(context) {\n  const error = context.resultError;\n  return (Errors.isOperationFailedError(error) && error.sqlState) || isFileUploadError(error, context.type);\n}\n\nfunction isFileUploadError(error, contextType) {\n  return error && contextType === 'FILE_PRE_EXEC';\n}\n\n/**\n * Determines if a result stream error is a retryable error.\n *\n * @param {Error} error\n * @returns {Boolean}\n */\nfunction isResultStreamErrorRetryable(error) {\n  return (Errors.isLargeResultSetError(error) && error.response &&\n    (error.response.statusCode === 403)) || (error && (error.code === 'ECONNRESET' || error.code === 'ETIMEDOUT'));\n}\n\n/**\n * Builds a map in which the keys are column ids and the values are the names of\n * the extract functions to use when retrieving row values for the corresponding\n * columns.\n *\n * @param {Object[]} columns\n * @param {String[]} fetchAsString the native types that should be retrieved as\n *   strings.\n *\n * @returns {Object}\n */\nfunction buildMapColumnExtractFnNames(columns, fetchAsString) {\n  const fnNameGetColumnValue = 'getColumnValue';\n  const fnNameGetColumnValueAsString = 'getColumnValueAsString';\n\n  let index, length, column;\n  const mapColumnIdToExtractFnName = {};\n\n  // if no native types need to be retrieved as strings, extract values normally\n  if (!Util.exists(fetchAsString)) {\n    for (index = 0, length = columns.length; index < length; index++) {\n      column = columns[index];\n      mapColumnIdToExtractFnName[column.getId()] = fnNameGetColumnValue;\n    }\n  } else {\n    // build a map that contains all the native types that need to be\n    // retrieved as strings when extracting column values from rows\n    const nativeTypesMap = {};\n    for (index = 0, length = fetchAsString.length; index < length; index++) {\n      nativeTypesMap[fetchAsString[index].toUpperCase()] = true;\n    }\n\n    // for each column, pick the appropriate extract function\n    // based on whether the value needs to be retrieved as a string\n    for (index = 0, length = columns.length; index < length; index++) {\n      column = columns[index];\n      mapColumnIdToExtractFnName[column.getId()] =\n        nativeTypesMap[DataTypes.toNativeType(column.getType())] ?\n          fnNameGetColumnValueAsString : fnNameGetColumnValue;\n    }\n  }\n\n  return mapColumnIdToExtractFnName;\n}\n\n/**\n * Converts an internal representation of a result row to a format appropriate\n * for consumption by the outside world.\n *\n * @param {Object} row\n * @param {Object[]} columns\n * @param {Object} [mapColumnIdToExtractFnName]\n * @param {String?} rowMode - string value ('array', 'object' or 'object_with_renamed_duplicated_columns'). Default is 'object' when parameter isn't set.\n *\n * @returns {Object}\n */\nfunction externalizeRow(row, columns, mapColumnIdToExtractFnName, rowMode) {\n  const isArrayRowMode = rowMode === RowMode.ARRAY;\n\n  const externalizedRow = isArrayRowMode ? [] : {};\n\n  for (let index = 0, length = columns.length; index < length; index++) {\n    const column = columns[index];\n    const extractFnName = mapColumnIdToExtractFnName[column.getId()];\n    externalizedRow[isArrayRowMode ? index : column.getName()] = row[extractFnName](column.getId());\n  }\n\n  return externalizedRow;\n}\n\nmodule.exports = RowStream;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvcm93X3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsc0RBQTBCO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyxrRUFBWTtBQUNqQyxlQUFlLG1CQUFPLENBQUMsc0VBQWM7QUFDckMscUJBQXFCLG1CQUFPLENBQUMsa0dBQWlCO0FBQzlDLGtCQUFrQixtQkFBTyxDQUFDLDRGQUFjO0FBQ3hDLGdCQUFnQixtQkFBTyxDQUFDLGdHQUE0Qjs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDZDQUE2QyxnQkFBZ0I7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsK0NBQStDLGdCQUFnQjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2Nvbm5lY3Rpb24vcmVzdWx0L3Jvd19zdHJlYW0uanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgUmVhZGFibGUgPSByZXF1aXJlKCdzdHJlYW0nKS5SZWFkYWJsZTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi8uLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi8uLi9lcnJvcnMnKTtcbmNvbnN0IFJlc3VsdFN0cmVhbSA9IHJlcXVpcmUoJy4vcmVzdWx0X3N0cmVhbScpO1xuY29uc3QgRGF0YVR5cGVzID0gcmVxdWlyZSgnLi9kYXRhX3R5cGVzJyk7XG5jb25zdCBSb3dNb2RlID0gcmVxdWlyZSgnLi8uLi8uLi9jb25zdGFudHMvcm93X21vZGUnKTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyZWFtIHRoYXQgY2FuIGJlIHVzZWQgdG8gcmVhZCBhIHN0YXRlbWVudCByZXN1bHQgcm93IGJ5IHJvdy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSb3dTdHJlYW0oc3RhdGVtZW50LCBjb250ZXh0LCBvcHRpb25zKSB7XG4gIC8vIHZhbGlkYXRlIG5vbi11c2VyLXNwZWNpZmllZCBhcmd1bWVudHNcbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuZXhpc3RzKHN0YXRlbWVudCkpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5leGlzdHMoY29udGV4dCkpO1xuXG4gIC8vIGNhbGwgUmVhZGFibGUgY29uc3RydWN0b3JcbiAgUmVhZGFibGUuY2FsbCh0aGlzLFxuICAgIHtcbiAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICBoaWdoV2F0ZXJNYXJrOiBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcuZ2V0Um93U3RyZWFtSGlnaFdhdGVyTWFyaygpXG4gICAgfSk7XG5cbiAgLy8gZXh0cmFjdCBzdHJlYW1pbmcgb3B0aW9uc1xuICBsZXQgc3RhcnQsIGVuZCwgZmV0Y2hBc1N0cmluZywgcm93TW9kZTtcbiAgaWYgKFV0aWwuaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICBzdGFydCA9IG9wdGlvbnMuc3RhcnQ7XG4gICAgZW5kID0gb3B0aW9ucy5lbmQ7XG4gICAgZmV0Y2hBc1N0cmluZyA9IG9wdGlvbnMuZmV0Y2hBc1N0cmluZztcbiAgfVxuXG4gIC8vIGlmIGEgZmV0Y2hBc1N0cmluZyB2YWx1ZSBpcyBub3Qgc3BlY2lmaWVkIGluIHRoZSBzdHJlYW0gb3B0aW9ucywgdHJ5IHRoZVxuICAvLyBzdGF0ZW1lbnQgYW5kIGNvbm5lY3Rpb24gb3B0aW9ucyAoaW4gdGhhdCBvcmRlcilcbiAgaWYgKCFVdGlsLmV4aXN0cyhmZXRjaEFzU3RyaW5nKSkge1xuICAgIGZldGNoQXNTdHJpbmcgPSBjb250ZXh0LmZldGNoQXNTdHJpbmc7XG4gIH1cbiAgaWYgKCFVdGlsLmV4aXN0cyhmZXRjaEFzU3RyaW5nKSkge1xuICAgIGZldGNoQXNTdHJpbmcgPSBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcuZ2V0RmV0Y2hBc1N0cmluZygpO1xuICB9XG4gIGlmICghVXRpbC5leGlzdHMocm93TW9kZSkpIHtcbiAgICByb3dNb2RlID0gY29udGV4dC5yb3dNb2RlIHx8IGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZy5nZXRSb3dNb2RlKCk7XG4gIH1cblxuICBsZXQgcmVzdWx0U3RyZWFtID0gbnVsbCwgbnVtUmVzdWx0U3RyZWFtSW50ZXJydXB0cyA9IDA7XG4gIGxldCByb3dCdWZmZXIgPSBudWxsLCByb3dJbmRleCA9IDA7XG4gIGxldCBjb2x1bW5zLCBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZTtcbiAgbGV0IGluaXRpYWxpemVkID0gZmFsc2U7XG4gIGxldCBwcmV2aW91c0NodW5rID0gbnVsbDtcblxuICBjb25zdCBzZWxmID0gdGhpcztcblxuICAvKipcbiAgICogUmVhZHMgdGhlIG5leHQgcm93IGluIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICB0aGlzLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIGlmIHRoZSBzdHJlYW0gaGFzIGJlZW4gaW5pdGlhbGl6ZWQsIGp1c3QgcmVhZCB0aGUgbmV4dCByb3dcbiAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJlYWROZXh0Um93KCk7XG4gICAgfSBlbHNlIGlmIChjb250ZXh0LmlzRmV0Y2hpbmdSZXN1bHQpIHtcbiAgICAgIC8vIGlmIHdlJ3JlIHN0aWxsIGZldGNoaW5nIHRoZSByZXN1bHQsIHdhaXQgZm9yIHRoZSBvcGVyYXRpb24gdG8gY29tcGxldGVcbiAgICAgIGNvbnRleHQub24oJ3N0YXRlbWVudC1jb21wbGV0ZScsIGluaXQpO1xuICAgIH0gZWxzZSBpZiAoY29udGV4dC5yZXN1bHQgfHwgaXNTdGF0ZW1lbnRFcnJvckZhdGFsKGNvbnRleHQpKSB7XG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgcmVzdWx0IG9yIGEgZmF0YWwgZXJyb3IsIGNhbGwgaW5pdCgpIGluIHRoZSBuZXh0IHRpY2sgb2ZcbiAgICAgIC8vIHRoZSBldmVudCBsb29wXG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGluaXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodHlwZW9mIGNvbnRleHQubXVsdGlSZXN1bHRJZHMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIC8vIGZldGNoIHRoZSByZXN1bHQgYWdhaW4gYW5kIGNhbGwgaW5pdCgpIHVwb24gY29tcGxldGlvbiBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICAgIGNvbnRleHQucmVmcmVzaChpbml0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vZG8gbm90aGluZ1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXMgdGhpcyBzdHJlYW0uXG4gICAqL1xuICBjb25zdCBpbml0ID0gZnVuY3Rpb24gaW5pdCgpIHtcbiAgICAvLyB0aGUgc3RyZWFtIGhhcyBub3cgYmVlbiBpbml0aWFsaXplZFxuICAgIGluaXRpYWxpemVkID0gdHJ1ZTtcblxuICAgIC8vIGlmIHdlIGhhdmUgYSByZXN1bHRcbiAgICBpZiAoY29udGV4dC5yZXN1bHQpIHtcbiAgICAgIC8vIGlmIG5vIHZhbHVlIHdhcyBzcGVjaWZpZWQgZm9yIHRoZSBzdGFydCBpbmRleCBvciBpZiB0aGUgc3BlY2lmaWVkIHN0YXJ0XG4gICAgICAvLyBpbmRleCBpcyBuZWdhdGl2ZSwgZGVmYXVsdCB0byAwLCBvdGhlcndpc2UgdHJ1bmNhdGUgdGhlIGZyYWN0aW9uYWwgcGFydFxuICAgICAgc3RhcnQgPSAoIVV0aWwuaXNOdW1iZXIoc3RhcnQpIHx8IChzdGFydCA8IDApKSA/IDAgOiBNYXRoLmZsb29yKHN0YXJ0KTtcblxuICAgICAgLy8gaWYgbm8gdmFsdWUgd2FzIHNwZWNpZmllZCBmb3IgdGhlIGVuZCBpbmRleCBvciBpZiB0aGUgZW5kIGluZGV4IGlzXG4gICAgICAvLyBsYXJnZXIgdGhhbiB0aGUgcm93IGluZGV4IG9mIHRoZSBsYXN0IHJvdywgZGVmYXVsdCB0byB0aGUgaW5kZXggb2YgdGhlXG4gICAgICAvLyBsYXN0IHJvdywgb3RoZXJ3aXNlIHRydW5jYXRlIHRoZSBmcmFjdGlvbmFsIHBhcnRcbiAgICAgIGNvbnN0IHJldHVybmVkUm93cyA9IGNvbnRleHQucmVzdWx0LmdldFJldHVybmVkUm93cygpO1xuICAgICAgZW5kID0gKCFVdGlsLmlzTnVtYmVyKGVuZCkgfHwgKGVuZCA+PSByZXR1cm5lZFJvd3MpKSA/IHJldHVybmVkUm93cyAtIDEgOlxuICAgICAgICBNYXRoLmZsb29yKGVuZCk7XG5cbiAgICAgIC8vIGZpbmQgYWxsIHRoZSBjaHVua3MgdGhhdCBvdmVybGFwIHdpdGggdGhlIHNwZWNpZmllZCByYW5nZVxuICAgICAgY29uc3Qgb3ZlcmxhcHBpbmdDaHVua3MgPSBjb250ZXh0LnJlc3VsdC5maW5kT3ZlcmxhcHBpbmdDaHVua3Moc3RhcnQsIGVuZCk7XG5cbiAgICAgIC8vIGlmIG5vIGNodW5rcyBvdmVybGFwIG9yIHN0YXJ0IGlzIGdyZWF0ZXIgdGhhbiBlbmQsIHdlJ3JlIGRvbmVcbiAgICAgIGlmICgob3ZlcmxhcHBpbmdDaHVua3MubGVuZ3RoID09PSAwKSB8fCAoc3RhcnQgPiBlbmQpKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soY2xvc2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gY3JlYXRlIGEgcmVzdWx0IHN0cmVhbSBmcm9tIHRoZSBvdmVybGFwcGluZyBjaHVua3NcbiAgICAgICAgcmVzdWx0U3RyZWFtID0gbmV3IFJlc3VsdFN0cmVhbShcbiAgICAgICAgICB7XG4gICAgICAgICAgICBjaHVua3M6IG92ZXJsYXBwaW5nQ2h1bmtzLFxuICAgICAgICAgICAgcHJlZmV0Y2hTaXplOiBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcuZ2V0UmVzdWx0UHJlZmV0Y2goKVxuICAgICAgICAgIH0pO1xuXG4gICAgICAgIHJlYWROZXh0Um93KCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNsb3NlKGNvbnRleHQucmVzdWx0RXJyb3IpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogUHJvY2Vzc2VzIHRoZSByb3cgYnVmZmVyLlxuICAgKi9cbiAgY29uc3QgcHJvY2Vzc1Jvd0J1ZmZlciA9IGZ1bmN0aW9uIHByb2Nlc3NSb3dCdWZmZXIoKSB7XG4gICAgLy8gZ2V0IHRoZSByb3cgdG8gYWRkIHRvIHRoZSByZWFkIHF1ZXVlXG4gICAgbGV0IHJvdyA9IHJvd0J1ZmZlcltyb3dJbmRleCsrXTtcblxuICAgIC8vIGlmIHdlIGp1c3QgcmVhZCB0aGUgbGFzdCByb3cgaW4gdGhlIHJvdyBidWZmZXIsIGNsZWFyIHRoZSByb3cgYnVmZmVyIGFuZFxuICAgIC8vIHJlc2V0IHRoZSByb3cgaW5kZXggc28gdGhhdCB3ZSBsb2FkIHRoZSBuZXh0IGNodW5rIGluIHRoZSByZXN1bHQgc3RyZWFtXG4gICAgLy8gd2hlbiBfcmVhZCgpIGlzIGNhbGxlZFxuICAgIGlmIChyb3dJbmRleCA9PT0gcm93QnVmZmVyLmxlbmd0aCkge1xuICAgICAgcm93QnVmZmVyID0gbnVsbDtcbiAgICAgIHJvd0luZGV4ID0gMDtcbiAgICB9XG5cbiAgICAvLyBpbml0aWFsaXplIHRoZSBjb2x1bW5zIGFuZCBjb2x1bW4tcmVsYXRlZCBtYXBzIGlmIG5lY2Vzc2FyeVxuICAgIGlmICghY29sdW1ucykge1xuICAgICAgY29sdW1ucyA9IHN0YXRlbWVudC5nZXRDb2x1bW5zKCk7XG4gICAgfVxuICAgIGlmICghbWFwQ29sdW1uSWRUb0V4dHJhY3RGbk5hbWUpIHtcbiAgICAgIG1hcENvbHVtbklkVG9FeHRyYWN0Rm5OYW1lID1cbiAgICAgICAgYnVpbGRNYXBDb2x1bW5FeHRyYWN0Rm5OYW1lcyhjb2x1bW5zLCBmZXRjaEFzU3RyaW5nKTtcbiAgICB9XG5cbiAgICAvLyBhZGQgdGhlIG5leHQgcm93IHRvIHRoZSByZWFkIHF1ZXVlXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAvLyBjaGVjayBpZiB0aGVyZSBhcmUgc3RpbGwgcm93cyBhdmFpbGFibGUgaW4gdGhlIHJvd0J1ZmZlclxuICAgICAgaWYgKHJvd0J1ZmZlciAmJiByb3dJbmRleCA+IDApIHtcbiAgICAgICAgcm93SW5kZXgtLTsgLy8gZGVjcmVtZW50IHRoZSBpbmRleCB0byBpbmNsdWRlIHRoZSBwcmV2aW91cyByb3cgaW4gdGhlIHdoaWxlIGxvb3BcblxuICAgICAgICAvLyBwdXNoKCkgZGF0YSB0byByZWFkYWJsZSBzdHJlYW0gdW50aWwgaGlnaFdhdGVyTWFyayB0aHJlc2hvbGQgaXMgcmVhY2hlZCBvciBhbGwgcm93cyBhcmUgcHVzaGVkXG4gICAgICAgIHdoaWxlIChyb3dJbmRleCA8IHJvd0J1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICByb3cgPSByb3dCdWZmZXJbcm93SW5kZXgrK107XG5cbiAgICAgICAgICAvLyBpZiBidWZmZXIgaGFzIHJlYWNoZWQgdGhlIHRocmVzaG9sZCBiYXNlZCBvbiB0aGUgaGlnaFdhdGVyTWFyayB2YWx1ZSB0aGVuXG4gICAgICAgICAgLy8gcHVzaCgpIHdpbGwgcmV0dXJuIGZhbHNlIGFuZCBwYXVzZSBzZW5kaW5nIGRhdGEgdG8gdGhlIGJ1ZmZlciB1bnRpbCB0aGUgZGF0YSBpcyByZWFkIGZyb20gdGhlIGJ1ZmZlclxuICAgICAgICAgIGlmICghc2VsZi5wdXNoKGV4dGVybmFsaXplUm93KHJvdywgY29sdW1ucywgbWFwQ29sdW1uSWRUb0V4dHJhY3RGbk5hbWUsIHJvd01vZGUpKSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hlY2sgaWYgYWxsIHJvd3MgaW4gcm93QnVmZmVyIGhhcyBiZWVuIHB1c2hlZCB0byB0aGUgcmVhZGFibGUgc3RyZWFtXG4gICAgICAgIGlmIChyb3dJbmRleCA9PT0gcm93QnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgIC8vIHJlc2V0IHRoZSBidWZmZXIgYW5kIGluZGV4XG4gICAgICAgICAgcm93QnVmZmVyID0gbnVsbDtcbiAgICAgICAgICByb3dJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIE5vIG1vcmUgcm93cyBsZWZ0IGluIHRoZSBidWZmZXJcbiAgICAgICAgLy8gUHVzaCB0aGUgbGFzdCByb3cgaW4gdGhlIGJ1ZmZlclxuICAgICAgICBzZWxmLnB1c2goZXh0ZXJuYWxpemVSb3cocm93LCBjb2x1bW5zLCBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZSwgcm93TW9kZSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgcmVzdWx0IHN0cmVhbSByZWFkcyBhIG5ldyBjaHVuay5cbiAgICpcbiAgICogQHBhcmFtIHtDaHVua30gY2h1bmtcbiAgICovXG4gIGNvbnN0IG9uUmVzdWx0U3RyZWFtRGF0YSA9IGZ1bmN0aW9uIG9uUmVzdWx0U3RyZWFtRGF0YShjaHVuaykge1xuICAgIC8vIHVuc3Vic2NyaWJlIGZyb20gdGhlIHJlc3VsdCBzdHJlYW0ncyAnZGF0YScgYW5kICdjbG9zZScgZXZlbnRzXG4gICAgcmVzdWx0U3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25SZXN1bHRTdHJlYW1EYXRhKTtcbiAgICByZXN1bHRTdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25SZXN1bHRTdHJlYW1DbG9zZSk7XG5cbiAgICAvLyBnZXQgYWxsIHRoZSByb3dzIGluIHRoZSBjaHVuayB0aGF0IG92ZXJsYXAgd2l0aCB0aGUgcmVxdWVzdGVkIHdpbmRvdyxcbiAgICAvLyBhbmQgdXNlIHRoZSByZXN1bHRpbmcgYXJyYXkgYXMgdGhlIG5ldyByb3cgYnVmZmVyXG4gICAgY29uc3QgY2h1bmtTdGFydCA9IGNodW5rLmdldFN0YXJ0SW5kZXgoKTtcbiAgICBjb25zdCBjaHVua0VuZCA9IGNodW5rLmdldEVuZEluZGV4KCk7XG4gICAgcm93QnVmZmVyID0gY2h1bmsuZ2V0Um93cygpLnNsaWNlKFxuICAgICAgTWF0aC5tYXgoY2h1bmtTdGFydCwgc3RhcnQpIC0gY2h1bmtTdGFydCxcbiAgICAgIE1hdGgubWluKGNodW5rRW5kLCBlbmQpICsgMSAtIGNodW5rU3RhcnQpO1xuXG4gICAgLy8gcmVzZXQgdGhlIHJvdyBpbmRleFxuICAgIHJvd0luZGV4ID0gMDtcblxuICAgIC8vIHByb2Nlc3MgdGhlIHJvdyBidWZmZXJcbiAgICBwcm9jZXNzUm93QnVmZmVyKCk7XG5cbiAgICBpZiAocHJldmlvdXNDaHVuayAmJiAocHJldmlvdXNDaHVuayAhPT0gY2h1bmspKSB7XG4gICAgICBwcmV2aW91c0NodW5rLmNsZWFyUm93cygpO1xuICAgIH1cblxuICAgIHByZXZpb3VzQ2h1bmsgPSBjaHVuaztcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgY2h1bmtzIHRvIHJlYWQgaW4gdGhlIHJlc3VsdCBzdHJlYW0gb3IgYW5cbiAgICogZXJyb3IgaXMgZW5jb3VudGVyZWQgd2hpbGUgdHJ5aW5nIHRvIHJlYWQgdGhlIG5leHQgY2h1bmsuXG4gICAqXG4gICAqIEBwYXJhbSBlcnJcbiAgICogQHBhcmFtIGNvbnRpbnVlQ2FsbGJhY2tcbiAgICovXG4gIGNvbnN0IG9uUmVzdWx0U3RyZWFtQ2xvc2UgPSBmdW5jdGlvbiBvblJlc3VsdFN0cmVhbUNsb3NlKGVyciwgY29udGludWVDYWxsYmFjaykge1xuICAgIC8vIGlmIHRoZSBlcnJvciBpcyByZXRyeWFibGUgYW5kXG4gICAgLy8gdGhlIHJlc3VsdCBzdHJlYW0gaGFzbid0IGJlZW4gY2xvc2VkIHRvbyBtYW55IHRpbWVzXG4gICAgaWYgKGlzUmVzdWx0U3RyZWFtRXJyb3JSZXRyeWFibGUoZXJyKSAmJlxuICAgICAgKG51bVJlc3VsdFN0cmVhbUludGVycnVwdHMgPFxuICAgICAgICBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcuZ2V0UmVzdWx0U3RyZWFtSW50ZXJydXB0cygpKSkge1xuICAgICAgbnVtUmVzdWx0U3RyZWFtSW50ZXJydXB0cysrO1xuXG4gICAgICAvLyBmZXRjaCB0aGUgc3RhdGVtZW50IHJlc3VsdCBhZ2FpblxuICAgICAgY29udGV4dC5yZWZyZXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKGNvbnRleHQucmVzdWx0RXJyb3IpIHtcbiAgICAgICAgICBjbG9zZShjb250ZXh0LnJlc3VsdEVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250aW51ZUNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbG9zZShlcnIpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2xvc2VzIHRoZSByb3cgc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0ge0Vycm9yfSBbZXJyXVxuICAgKi9cbiAgY29uc3QgY2xvc2UgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBhIHJlc3VsdCBzdHJlYW0sIHN0b3AgbGlzdGVuaW5nIHRvIGV2ZW50cyBvbiBpdFxuICAgIGlmIChyZXN1bHRTdHJlYW0pIHtcbiAgICAgIHJlc3VsdFN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uUmVzdWx0U3RyZWFtRGF0YSk7XG4gICAgICByZXN1bHRTdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25SZXN1bHRTdHJlYW1DbG9zZSk7XG4gICAgfVxuXG4gICAgLy8gd2UncmUgZG9uZSwgc28gdGltZSB0byBjbGVhbiB1cFxuICAgIHJvd0J1ZmZlciA9IG51bGw7XG4gICAgcm93SW5kZXggPSAwO1xuICAgIHJlc3VsdFN0cmVhbSA9IG51bGw7XG4gICAgbnVtUmVzdWx0U3RyZWFtSW50ZXJydXB0cyA9IDA7XG4gICAgaWYgKHByZXZpb3VzQ2h1bmspIHtcbiAgICAgIHByZXZpb3VzQ2h1bmsuY2xlYXJSb3dzKCk7XG4gICAgICBwcmV2aW91c0NodW5rID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBlbWl0RXJyb3IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2VsZi5wdXNoKG51bGwpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gd2UncmUgcmVhZHkgdG8gcmVhZCB0aGUgbmV4dCByb3cgaW4gdGhlIHJlc3VsdC5cbiAgICovXG4gIGNvbnN0IHJlYWROZXh0Um93ID0gZnVuY3Rpb24gcmVhZE5leHRSb3coKSB7XG4gICAgLy8gaWYgd2UgaGF2ZSBhIHJvdyBidWZmZXIsIHByb2Nlc3MgaXRcbiAgICBpZiAocm93QnVmZmVyKSB7XG4gICAgICBwcm9jZXNzUm93QnVmZmVyKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHN1YnNjcmliZSB0byB0aGUgcmVzdWx0IHN0cmVhbSdzICdkYXRhJyBhbmQgJ2Nsb3NlJyBldmVudHNcbiAgICAgIHJlc3VsdFN0cmVhbS5vbignZGF0YScsIG9uUmVzdWx0U3RyZWFtRGF0YSk7XG4gICAgICByZXN1bHRTdHJlYW0ub24oJ2Nsb3NlJywgb25SZXN1bHRTdHJlYW1DbG9zZSk7XG5cbiAgICAgIC8vIGlzc3VlIGEgcmVxdWVzdCB0byBmZXRjaCB0aGUgbmV4dCBjaHVuayBpbiB0aGUgcmVzdWx0IHN0cmVhbVxuICAgICAgcmVzdWx0U3RyZWFtLnJlYWQoKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIEV4dGVybmFsaXplcyBhbiBlcnJvciBhbmQgZW1pdHMgaXQuXG4gICAqXG4gICAqIEBwYXJhbSB7RXJyb3J9IGVyclxuICAgKi9cbiAgY29uc3QgZW1pdEVycm9yID0gZnVuY3Rpb24gZW1pdEVycm9yKGVycikge1xuICAgIHNlbGYuZW1pdCgnZXJyb3InLCBFcnJvcnMuZXh0ZXJuYWxpemUoZXJyKSk7XG4gIH07XG59XG5cblV0aWwuaW5oZXJpdHMoUm93U3RyZWFtLCBSZWFkYWJsZSk7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIHN0YXRlbWVudCBlcnJvciBpcyBmYXRhbC5cbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBwYXJhbSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGlzU3RhdGVtZW50RXJyb3JGYXRhbChjb250ZXh0KSB7XG4gIGNvbnN0IGVycm9yID0gY29udGV4dC5yZXN1bHRFcnJvcjtcbiAgcmV0dXJuIChFcnJvcnMuaXNPcGVyYXRpb25GYWlsZWRFcnJvcihlcnJvcikgJiYgZXJyb3Iuc3FsU3RhdGUpIHx8IGlzRmlsZVVwbG9hZEVycm9yKGVycm9yLCBjb250ZXh0LnR5cGUpO1xufVxuXG5mdW5jdGlvbiBpc0ZpbGVVcGxvYWRFcnJvcihlcnJvciwgY29udGV4dFR5cGUpIHtcbiAgcmV0dXJuIGVycm9yICYmIGNvbnRleHRUeXBlID09PSAnRklMRV9QUkVfRVhFQyc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIHJlc3VsdCBzdHJlYW0gZXJyb3IgaXMgYSByZXRyeWFibGUgZXJyb3IuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5mdW5jdGlvbiBpc1Jlc3VsdFN0cmVhbUVycm9yUmV0cnlhYmxlKGVycm9yKSB7XG4gIHJldHVybiAoRXJyb3JzLmlzTGFyZ2VSZXN1bHRTZXRFcnJvcihlcnJvcikgJiYgZXJyb3IucmVzcG9uc2UgJiZcbiAgICAoZXJyb3IucmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDAzKSkgfHwgKGVycm9yICYmIChlcnJvci5jb2RlID09PSAnRUNPTk5SRVNFVCcgfHwgZXJyb3IuY29kZSA9PT0gJ0VUSU1FRE9VVCcpKTtcbn1cblxuLyoqXG4gKiBCdWlsZHMgYSBtYXAgaW4gd2hpY2ggdGhlIGtleXMgYXJlIGNvbHVtbiBpZHMgYW5kIHRoZSB2YWx1ZXMgYXJlIHRoZSBuYW1lcyBvZlxuICogdGhlIGV4dHJhY3QgZnVuY3Rpb25zIHRvIHVzZSB3aGVuIHJldHJpZXZpbmcgcm93IHZhbHVlcyBmb3IgdGhlIGNvcnJlc3BvbmRpbmdcbiAqIGNvbHVtbnMuXG4gKlxuICogQHBhcmFtIHtPYmplY3RbXX0gY29sdW1uc1xuICogQHBhcmFtIHtTdHJpbmdbXX0gZmV0Y2hBc1N0cmluZyB0aGUgbmF0aXZlIHR5cGVzIHRoYXQgc2hvdWxkIGJlIHJldHJpZXZlZCBhc1xuICogICBzdHJpbmdzLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkTWFwQ29sdW1uRXh0cmFjdEZuTmFtZXMoY29sdW1ucywgZmV0Y2hBc1N0cmluZykge1xuICBjb25zdCBmbk5hbWVHZXRDb2x1bW5WYWx1ZSA9ICdnZXRDb2x1bW5WYWx1ZSc7XG4gIGNvbnN0IGZuTmFtZUdldENvbHVtblZhbHVlQXNTdHJpbmcgPSAnZ2V0Q29sdW1uVmFsdWVBc1N0cmluZyc7XG5cbiAgbGV0IGluZGV4LCBsZW5ndGgsIGNvbHVtbjtcbiAgY29uc3QgbWFwQ29sdW1uSWRUb0V4dHJhY3RGbk5hbWUgPSB7fTtcblxuICAvLyBpZiBubyBuYXRpdmUgdHlwZXMgbmVlZCB0byBiZSByZXRyaWV2ZWQgYXMgc3RyaW5ncywgZXh0cmFjdCB2YWx1ZXMgbm9ybWFsbHlcbiAgaWYgKCFVdGlsLmV4aXN0cyhmZXRjaEFzU3RyaW5nKSkge1xuICAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBjb2x1bW5zLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIGNvbHVtbiA9IGNvbHVtbnNbaW5kZXhdO1xuICAgICAgbWFwQ29sdW1uSWRUb0V4dHJhY3RGbk5hbWVbY29sdW1uLmdldElkKCldID0gZm5OYW1lR2V0Q29sdW1uVmFsdWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIGJ1aWxkIGEgbWFwIHRoYXQgY29udGFpbnMgYWxsIHRoZSBuYXRpdmUgdHlwZXMgdGhhdCBuZWVkIHRvIGJlXG4gICAgLy8gcmV0cmlldmVkIGFzIHN0cmluZ3Mgd2hlbiBleHRyYWN0aW5nIGNvbHVtbiB2YWx1ZXMgZnJvbSByb3dzXG4gICAgY29uc3QgbmF0aXZlVHlwZXNNYXAgPSB7fTtcbiAgICBmb3IgKGluZGV4ID0gMCwgbGVuZ3RoID0gZmV0Y2hBc1N0cmluZy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBuYXRpdmVUeXBlc01hcFtmZXRjaEFzU3RyaW5nW2luZGV4XS50b1VwcGVyQ2FzZSgpXSA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gZm9yIGVhY2ggY29sdW1uLCBwaWNrIHRoZSBhcHByb3ByaWF0ZSBleHRyYWN0IGZ1bmN0aW9uXG4gICAgLy8gYmFzZWQgb24gd2hldGhlciB0aGUgdmFsdWUgbmVlZHMgdG8gYmUgcmV0cmlldmVkIGFzIGEgc3RyaW5nXG4gICAgZm9yIChpbmRleCA9IDAsIGxlbmd0aCA9IGNvbHVtbnMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29sdW1uID0gY29sdW1uc1tpbmRleF07XG4gICAgICBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZVtjb2x1bW4uZ2V0SWQoKV0gPVxuICAgICAgICBuYXRpdmVUeXBlc01hcFtEYXRhVHlwZXMudG9OYXRpdmVUeXBlKGNvbHVtbi5nZXRUeXBlKCkpXSA/XG4gICAgICAgICAgZm5OYW1lR2V0Q29sdW1uVmFsdWVBc1N0cmluZyA6IGZuTmFtZUdldENvbHVtblZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiBvZiBhIHJlc3VsdCByb3cgdG8gYSBmb3JtYXQgYXBwcm9wcmlhdGVcbiAqIGZvciBjb25zdW1wdGlvbiBieSB0aGUgb3V0c2lkZSB3b3JsZC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcm93XG4gKiBAcGFyYW0ge09iamVjdFtdfSBjb2x1bW5zXG4gKiBAcGFyYW0ge09iamVjdH0gW21hcENvbHVtbklkVG9FeHRyYWN0Rm5OYW1lXVxuICogQHBhcmFtIHtTdHJpbmc/fSByb3dNb2RlIC0gc3RyaW5nIHZhbHVlICgnYXJyYXknLCAnb2JqZWN0JyBvciAnb2JqZWN0X3dpdGhfcmVuYW1lZF9kdXBsaWNhdGVkX2NvbHVtbnMnKS4gRGVmYXVsdCBpcyAnb2JqZWN0JyB3aGVuIHBhcmFtZXRlciBpc24ndCBzZXQuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gZXh0ZXJuYWxpemVSb3cocm93LCBjb2x1bW5zLCBtYXBDb2x1bW5JZFRvRXh0cmFjdEZuTmFtZSwgcm93TW9kZSkge1xuICBjb25zdCBpc0FycmF5Um93TW9kZSA9IHJvd01vZGUgPT09IFJvd01vZGUuQVJSQVk7XG5cbiAgY29uc3QgZXh0ZXJuYWxpemVkUm93ID0gaXNBcnJheVJvd01vZGUgPyBbXSA6IHt9O1xuXG4gIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gY29sdW1ucy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgY29uc3QgY29sdW1uID0gY29sdW1uc1tpbmRleF07XG4gICAgY29uc3QgZXh0cmFjdEZuTmFtZSA9IG1hcENvbHVtbklkVG9FeHRyYWN0Rm5OYW1lW2NvbHVtbi5nZXRJZCgpXTtcbiAgICBleHRlcm5hbGl6ZWRSb3dbaXNBcnJheVJvd01vZGUgPyBpbmRleCA6IGNvbHVtbi5nZXROYW1lKCldID0gcm93W2V4dHJhY3RGbk5hbWVdKGNvbHVtbi5nZXRJZCgpKTtcbiAgfVxuXG4gIHJldHVybiBleHRlcm5hbGl6ZWRSb3c7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUm93U3RyZWFtOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/result/row_stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/result/sf_timestamp.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/result/sf_timestamp.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Moment = __webpack_require__(/*! moment-timezone */ \"(rsc)/./node_modules/moment-timezone/index.js\");\nconst Util = __webpack_require__(/*! ../../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst datetimeFormatConverter = __webpack_require__(/*! ./datetime_format_converter */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/datetime_format_converter.js\");\n/**\n * Creates a new SfTimestamp instance.\n *\n * @param {Number} epochSeconds the epoch time in seconds.\n * @param {Number} nanoSeconds the number of nano seconds (incremental, not\n *   epoch).\n * @param {Number} scale the precision for the fractional part of the timestamp.\n * @param {String | Number} [timezone] the timezone name as a string\n *   (e.g. 'America/New_York') or the timezone offset in minutes (e.g. -240).\n * @param {String} [format] the SQL format to use to format the timestamp.\n * @constructor\n */\nfunction SfTimestamp(epochSeconds, nanoSeconds, scale, timezone, format) {\n  // pick reasonable defaults for the inputs if needed\n  epochSeconds = Util.isNumber(epochSeconds) ? epochSeconds : 0;\n  nanoSeconds = Util.isNumber(nanoSeconds) ? nanoSeconds : 0;\n  scale = Util.isNumber(scale) ? scale : 0;\n  format = Util.isString(format) ? format : '';\n\n  // save any information we'll need later\n  this.epochSeconds = epochSeconds;\n  this.nanoSeconds = nanoSeconds;\n  this.scale = scale;\n  this.timezone = timezone;\n  this.format = format;\n\n  // Milliseconds are truncated to avoid rounding issues, and the decimal part is not useful since Moment only supports milliseconds precision\n  const milliseconds = Math.trunc(nanoSeconds / 1000000);\n  let moment = Moment((epochSeconds * 1000) + milliseconds);\n\n  // set the moment's timezone\n  if (Util.isString(timezone)) {\n    moment = moment.tz(timezone);\n  } else if (Util.isNumber(timezone)) {\n    moment = moment.utcOffset(timezone);\n  }\n\n  // save the moment\n  this.moment = moment;\n}\n\n/**\n * Returns a string representing the specified SfTimestamp instance.\n *\n * @returns {String}\n */\nSfTimestamp.prototype.toString = function () {\n  // use cached value if possible\n  if (this._valueAsString) {\n    return this._valueAsString;\n  }\n\n  const moment = this.moment;\n  const nanoSeconds = this.nanoSeconds;\n  let scale = this.scale;\n  const formatSql = this.format;\n\n  // get an upper-case version of the input sql format\n  const formatSqlUpper = formatSql.toUpperCase();\n\n  const tags = datetimeFormatConverter.formatTagsMap();\n\n  // iterate over the format string\n  const length = formatSql.length;\n  let formatMoment = '';\n  for (let pos = 0; pos < length;) {\n    let tag = null;\n    let out = null;\n\n    // at each position, check if there's a tag at that position; if so, use\n    // 'out' as the replacement\n    for (let index = 0; index < tags.length; index++) {\n      if (formatSqlUpper.substr(pos).indexOf(tags[index][0]) === 0) {\n        tag = tags[index][0];\n        out = tags[index][1];\n        break;\n      }\n    }\n\n    // if we didn't find a match, just insert the character after escaping it\n    // (by wrapping it in square brackets)\n    if (out === null) {\n      formatMoment += '[' + formatSql[pos] + ']';\n      pos++;\n    } else {\n      // we found one of our special tags\n      if (out === '') {\n        if (tag === 'TZH') {\n          // format the moment to get the timezone string and extract the\n          // hours; for example, '-0700' will be converted to '-07'\n          out = moment.format('ZZ').substr(0, 3);\n        } else if (tag === 'TZM') {\n          // format the moment to get the timezone string and extract the\n          // minutes; for example, '-0700' will be converted to '00\n          out = moment.format('ZZ').substr(3);\n        } else if (tag === 'FF') {\n          // if 'FF' is followed by a digit, use the digit as the scale\n          let digit = null;\n          if (pos + tag.length < length) {\n            const matches = formatSql[pos + tag.length].match(/[0-9]/);\n            if (matches) {\n              digit = matches[0];\n            }\n          }\n          if (digit !== null) {\n            scale = digit;\n            pos++; // skip the digit as well\n          }\n\n          // if we need to include fractional seconds\n          if (scale > 0) {\n            // divide the nanoSeconds to get the requested number of\n            // meaningful digits\n            const scaled = Math.floor(nanoSeconds / Math.pow(10, 9 - scale));\n\n            // pad with the appropriate number of leading zeros\n            out = (new Array(9).join('0') + scaled).substr(-scale);\n          }\n        }\n      }\n\n      // append the 'out' text to the moment format and update the position\n      formatMoment += out;\n      pos += tag.length;\n    }\n  }\n  // format the moment and cache the result\n  const timezone = this.timezone.name || this.timezone;\n  if (timezone) {\n    if (typeof timezone === 'number') {\n      this._valueAsString = moment.utcOffset(timezone).format(formatMoment);\n    } else {\n      this._valueAsString = moment.tz(timezone).format(formatMoment);\n    }\n  } else {\n    this._valueAsString = moment.format(formatMoment);\n  }\n  return this._valueAsString;\n};\n\n/**\n * Converts this SfTimestamp to an SfDate that's just a normal JavaScript Date\n * with some additional methods like getEpochSeconds(), getNanoSeconds(),\n * getTimezone(), etc.\n *\n * @returns {Date}\n */\nSfTimestamp.prototype.toSfDate = function () {\n  // create a Date from the moment\n  const date = this.moment.toDate();\n\n  const self = this;\n\n  date.getEpochSeconds = function () {\n    return self.epochSeconds;\n  };\n\n  date.getNanoSeconds = function () {\n    return self.nanoSeconds;\n  };\n\n  date.getScale = function () {\n    return self.scale;\n  };\n\n  date.getTimezone = function () {\n    return self.timezone;\n  };\n\n  date.getFormat = function () {\n    return self.format;\n  };\n\n  date.toJSON = function () {\n    return self.toString();\n  };\n\n  return date;\n};\n\n/**\n * Converts this SfTimestamp to an SfTime, which is just a JavaScript Object\n * with some methods: getMidnightSeconds(), getNanoSeconds(), etc.\n *\n * @returns {Object}\n */\nSfTimestamp.prototype.toSfTime = function () {\n  const self = this;\n  return {\n    getMidnightSeconds: function () {\n      return self.epochSeconds;\n    },\n    getNanoSeconds: function () {\n      return self.nanoSeconds;\n    },\n    getScale: function () {\n      return self.scale;\n    },\n    getFormat: function () {\n      return self.format;\n    },\n    toJSON: function () {\n      return self.toString();\n    }\n  };\n};\n\nmodule.exports = SfTimestamp;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvc2ZfdGltZXN0YW1wLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxzRUFBaUI7QUFDeEMsYUFBYSxtQkFBTyxDQUFDLGtFQUFZO0FBQ2pDLGdDQUFnQyxtQkFBTyxDQUFDLDBIQUE2QjtBQUNyRTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsaUJBQWlCO0FBQzVCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7O0FBRUEsa0VBQWtFO0FBQ2xFO0FBQ0Esd0JBQXdCLHFCQUFxQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBLFVBQVU7QUFDVjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvc2ZfdGltZXN0YW1wLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IE1vbWVudCA9IHJlcXVpcmUoJ21vbWVudC10aW1lem9uZScpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcbmNvbnN0IGRhdGV0aW1lRm9ybWF0Q29udmVydGVyID0gcmVxdWlyZSgnLi9kYXRldGltZV9mb3JtYXRfY29udmVydGVyJyk7XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU2ZUaW1lc3RhbXAgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGVwb2NoU2Vjb25kcyB0aGUgZXBvY2ggdGltZSBpbiBzZWNvbmRzLlxuICogQHBhcmFtIHtOdW1iZXJ9IG5hbm9TZWNvbmRzIHRoZSBudW1iZXIgb2YgbmFubyBzZWNvbmRzIChpbmNyZW1lbnRhbCwgbm90XG4gKiAgIGVwb2NoKS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBzY2FsZSB0aGUgcHJlY2lzaW9uIGZvciB0aGUgZnJhY3Rpb25hbCBwYXJ0IG9mIHRoZSB0aW1lc3RhbXAuXG4gKiBAcGFyYW0ge1N0cmluZyB8IE51bWJlcn0gW3RpbWV6b25lXSB0aGUgdGltZXpvbmUgbmFtZSBhcyBhIHN0cmluZ1xuICogICAoZS5nLiAnQW1lcmljYS9OZXdfWW9yaycpIG9yIHRoZSB0aW1lem9uZSBvZmZzZXQgaW4gbWludXRlcyAoZS5nLiAtMjQwKS5cbiAqIEBwYXJhbSB7U3RyaW5nfSBbZm9ybWF0XSB0aGUgU1FMIGZvcm1hdCB0byB1c2UgdG8gZm9ybWF0IHRoZSB0aW1lc3RhbXAuXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU2ZUaW1lc3RhbXAoZXBvY2hTZWNvbmRzLCBuYW5vU2Vjb25kcywgc2NhbGUsIHRpbWV6b25lLCBmb3JtYXQpIHtcbiAgLy8gcGljayByZWFzb25hYmxlIGRlZmF1bHRzIGZvciB0aGUgaW5wdXRzIGlmIG5lZWRlZFxuICBlcG9jaFNlY29uZHMgPSBVdGlsLmlzTnVtYmVyKGVwb2NoU2Vjb25kcykgPyBlcG9jaFNlY29uZHMgOiAwO1xuICBuYW5vU2Vjb25kcyA9IFV0aWwuaXNOdW1iZXIobmFub1NlY29uZHMpID8gbmFub1NlY29uZHMgOiAwO1xuICBzY2FsZSA9IFV0aWwuaXNOdW1iZXIoc2NhbGUpID8gc2NhbGUgOiAwO1xuICBmb3JtYXQgPSBVdGlsLmlzU3RyaW5nKGZvcm1hdCkgPyBmb3JtYXQgOiAnJztcblxuICAvLyBzYXZlIGFueSBpbmZvcm1hdGlvbiB3ZSdsbCBuZWVkIGxhdGVyXG4gIHRoaXMuZXBvY2hTZWNvbmRzID0gZXBvY2hTZWNvbmRzO1xuICB0aGlzLm5hbm9TZWNvbmRzID0gbmFub1NlY29uZHM7XG4gIHRoaXMuc2NhbGUgPSBzY2FsZTtcbiAgdGhpcy50aW1lem9uZSA9IHRpbWV6b25lO1xuICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcblxuICAvLyBNaWxsaXNlY29uZHMgYXJlIHRydW5jYXRlZCB0byBhdm9pZCByb3VuZGluZyBpc3N1ZXMsIGFuZCB0aGUgZGVjaW1hbCBwYXJ0IGlzIG5vdCB1c2VmdWwgc2luY2UgTW9tZW50IG9ubHkgc3VwcG9ydHMgbWlsbGlzZWNvbmRzIHByZWNpc2lvblxuICBjb25zdCBtaWxsaXNlY29uZHMgPSBNYXRoLnRydW5jKG5hbm9TZWNvbmRzIC8gMTAwMDAwMCk7XG4gIGxldCBtb21lbnQgPSBNb21lbnQoKGVwb2NoU2Vjb25kcyAqIDEwMDApICsgbWlsbGlzZWNvbmRzKTtcblxuICAvLyBzZXQgdGhlIG1vbWVudCdzIHRpbWV6b25lXG4gIGlmIChVdGlsLmlzU3RyaW5nKHRpbWV6b25lKSkge1xuICAgIG1vbWVudCA9IG1vbWVudC50eih0aW1lem9uZSk7XG4gIH0gZWxzZSBpZiAoVXRpbC5pc051bWJlcih0aW1lem9uZSkpIHtcbiAgICBtb21lbnQgPSBtb21lbnQudXRjT2Zmc2V0KHRpbWV6b25lKTtcbiAgfVxuXG4gIC8vIHNhdmUgdGhlIG1vbWVudFxuICB0aGlzLm1vbWVudCA9IG1vbWVudDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgc3BlY2lmaWVkIFNmVGltZXN0YW1wIGluc3RhbmNlLlxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9XG4gKi9cblNmVGltZXN0YW1wLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gdXNlIGNhY2hlZCB2YWx1ZSBpZiBwb3NzaWJsZVxuICBpZiAodGhpcy5fdmFsdWVBc1N0cmluZykge1xuICAgIHJldHVybiB0aGlzLl92YWx1ZUFzU3RyaW5nO1xuICB9XG5cbiAgY29uc3QgbW9tZW50ID0gdGhpcy5tb21lbnQ7XG4gIGNvbnN0IG5hbm9TZWNvbmRzID0gdGhpcy5uYW5vU2Vjb25kcztcbiAgbGV0IHNjYWxlID0gdGhpcy5zY2FsZTtcbiAgY29uc3QgZm9ybWF0U3FsID0gdGhpcy5mb3JtYXQ7XG5cbiAgLy8gZ2V0IGFuIHVwcGVyLWNhc2UgdmVyc2lvbiBvZiB0aGUgaW5wdXQgc3FsIGZvcm1hdFxuICBjb25zdCBmb3JtYXRTcWxVcHBlciA9IGZvcm1hdFNxbC50b1VwcGVyQ2FzZSgpO1xuXG4gIGNvbnN0IHRhZ3MgPSBkYXRldGltZUZvcm1hdENvbnZlcnRlci5mb3JtYXRUYWdzTWFwKCk7XG5cbiAgLy8gaXRlcmF0ZSBvdmVyIHRoZSBmb3JtYXQgc3RyaW5nXG4gIGNvbnN0IGxlbmd0aCA9IGZvcm1hdFNxbC5sZW5ndGg7XG4gIGxldCBmb3JtYXRNb21lbnQgPSAnJztcbiAgZm9yIChsZXQgcG9zID0gMDsgcG9zIDwgbGVuZ3RoOykge1xuICAgIGxldCB0YWcgPSBudWxsO1xuICAgIGxldCBvdXQgPSBudWxsO1xuXG4gICAgLy8gYXQgZWFjaCBwb3NpdGlvbiwgY2hlY2sgaWYgdGhlcmUncyBhIHRhZyBhdCB0aGF0IHBvc2l0aW9uOyBpZiBzbywgdXNlXG4gICAgLy8gJ291dCcgYXMgdGhlIHJlcGxhY2VtZW50XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRhZ3MubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBpZiAoZm9ybWF0U3FsVXBwZXIuc3Vic3RyKHBvcykuaW5kZXhPZih0YWdzW2luZGV4XVswXSkgPT09IDApIHtcbiAgICAgICAgdGFnID0gdGFnc1tpbmRleF1bMF07XG4gICAgICAgIG91dCA9IHRhZ3NbaW5kZXhdWzFdO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBkaWRuJ3QgZmluZCBhIG1hdGNoLCBqdXN0IGluc2VydCB0aGUgY2hhcmFjdGVyIGFmdGVyIGVzY2FwaW5nIGl0XG4gICAgLy8gKGJ5IHdyYXBwaW5nIGl0IGluIHNxdWFyZSBicmFja2V0cylcbiAgICBpZiAob3V0ID09PSBudWxsKSB7XG4gICAgICBmb3JtYXRNb21lbnQgKz0gJ1snICsgZm9ybWF0U3FsW3Bvc10gKyAnXSc7XG4gICAgICBwb3MrKztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gd2UgZm91bmQgb25lIG9mIG91ciBzcGVjaWFsIHRhZ3NcbiAgICAgIGlmIChvdXQgPT09ICcnKSB7XG4gICAgICAgIGlmICh0YWcgPT09ICdUWkgnKSB7XG4gICAgICAgICAgLy8gZm9ybWF0IHRoZSBtb21lbnQgdG8gZ2V0IHRoZSB0aW1lem9uZSBzdHJpbmcgYW5kIGV4dHJhY3QgdGhlXG4gICAgICAgICAgLy8gaG91cnM7IGZvciBleGFtcGxlLCAnLTA3MDAnIHdpbGwgYmUgY29udmVydGVkIHRvICctMDcnXG4gICAgICAgICAgb3V0ID0gbW9tZW50LmZvcm1hdCgnWlonKS5zdWJzdHIoMCwgMyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGFnID09PSAnVFpNJykge1xuICAgICAgICAgIC8vIGZvcm1hdCB0aGUgbW9tZW50IHRvIGdldCB0aGUgdGltZXpvbmUgc3RyaW5nIGFuZCBleHRyYWN0IHRoZVxuICAgICAgICAgIC8vIG1pbnV0ZXM7IGZvciBleGFtcGxlLCAnLTA3MDAnIHdpbGwgYmUgY29udmVydGVkIHRvICcwMFxuICAgICAgICAgIG91dCA9IG1vbWVudC5mb3JtYXQoJ1paJykuc3Vic3RyKDMpO1xuICAgICAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ0ZGJykge1xuICAgICAgICAgIC8vIGlmICdGRicgaXMgZm9sbG93ZWQgYnkgYSBkaWdpdCwgdXNlIHRoZSBkaWdpdCBhcyB0aGUgc2NhbGVcbiAgICAgICAgICBsZXQgZGlnaXQgPSBudWxsO1xuICAgICAgICAgIGlmIChwb3MgKyB0YWcubGVuZ3RoIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGVzID0gZm9ybWF0U3FsW3BvcyArIHRhZy5sZW5ndGhdLm1hdGNoKC9bMC05XS8pO1xuICAgICAgICAgICAgaWYgKG1hdGNoZXMpIHtcbiAgICAgICAgICAgICAgZGlnaXQgPSBtYXRjaGVzWzBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoZGlnaXQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHNjYWxlID0gZGlnaXQ7XG4gICAgICAgICAgICBwb3MrKzsgLy8gc2tpcCB0aGUgZGlnaXQgYXMgd2VsbFxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIHdlIG5lZWQgdG8gaW5jbHVkZSBmcmFjdGlvbmFsIHNlY29uZHNcbiAgICAgICAgICBpZiAoc2NhbGUgPiAwKSB7XG4gICAgICAgICAgICAvLyBkaXZpZGUgdGhlIG5hbm9TZWNvbmRzIHRvIGdldCB0aGUgcmVxdWVzdGVkIG51bWJlciBvZlxuICAgICAgICAgICAgLy8gbWVhbmluZ2Z1bCBkaWdpdHNcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZCA9IE1hdGguZmxvb3IobmFub1NlY29uZHMgLyBNYXRoLnBvdygxMCwgOSAtIHNjYWxlKSk7XG5cbiAgICAgICAgICAgIC8vIHBhZCB3aXRoIHRoZSBhcHByb3ByaWF0ZSBudW1iZXIgb2YgbGVhZGluZyB6ZXJvc1xuICAgICAgICAgICAgb3V0ID0gKG5ldyBBcnJheSg5KS5qb2luKCcwJykgKyBzY2FsZWQpLnN1YnN0cigtc2NhbGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBhcHBlbmQgdGhlICdvdXQnIHRleHQgdG8gdGhlIG1vbWVudCBmb3JtYXQgYW5kIHVwZGF0ZSB0aGUgcG9zaXRpb25cbiAgICAgIGZvcm1hdE1vbWVudCArPSBvdXQ7XG4gICAgICBwb3MgKz0gdGFnLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgLy8gZm9ybWF0IHRoZSBtb21lbnQgYW5kIGNhY2hlIHRoZSByZXN1bHRcbiAgY29uc3QgdGltZXpvbmUgPSB0aGlzLnRpbWV6b25lLm5hbWUgfHwgdGhpcy50aW1lem9uZTtcbiAgaWYgKHRpbWV6b25lKSB7XG4gICAgaWYgKHR5cGVvZiB0aW1lem9uZSA9PT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMuX3ZhbHVlQXNTdHJpbmcgPSBtb21lbnQudXRjT2Zmc2V0KHRpbWV6b25lKS5mb3JtYXQoZm9ybWF0TW9tZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdmFsdWVBc1N0cmluZyA9IG1vbWVudC50eih0aW1lem9uZSkuZm9ybWF0KGZvcm1hdE1vbWVudCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRoaXMuX3ZhbHVlQXNTdHJpbmcgPSBtb21lbnQuZm9ybWF0KGZvcm1hdE1vbWVudCk7XG4gIH1cbiAgcmV0dXJuIHRoaXMuX3ZhbHVlQXNTdHJpbmc7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgU2ZUaW1lc3RhbXAgdG8gYW4gU2ZEYXRlIHRoYXQncyBqdXN0IGEgbm9ybWFsIEphdmFTY3JpcHQgRGF0ZVxuICogd2l0aCBzb21lIGFkZGl0aW9uYWwgbWV0aG9kcyBsaWtlIGdldEVwb2NoU2Vjb25kcygpLCBnZXROYW5vU2Vjb25kcygpLFxuICogZ2V0VGltZXpvbmUoKSwgZXRjLlxuICpcbiAqIEByZXR1cm5zIHtEYXRlfVxuICovXG5TZlRpbWVzdGFtcC5wcm90b3R5cGUudG9TZkRhdGUgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIGNyZWF0ZSBhIERhdGUgZnJvbSB0aGUgbW9tZW50XG4gIGNvbnN0IGRhdGUgPSB0aGlzLm1vbWVudC50b0RhdGUoKTtcblxuICBjb25zdCBzZWxmID0gdGhpcztcblxuICBkYXRlLmdldEVwb2NoU2Vjb25kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2VsZi5lcG9jaFNlY29uZHM7XG4gIH07XG5cbiAgZGF0ZS5nZXROYW5vU2Vjb25kcyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2VsZi5uYW5vU2Vjb25kcztcbiAgfTtcblxuICBkYXRlLmdldFNjYWxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZWxmLnNjYWxlO1xuICB9O1xuXG4gIGRhdGUuZ2V0VGltZXpvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNlbGYudGltZXpvbmU7XG4gIH07XG5cbiAgZGF0ZS5nZXRGb3JtYXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNlbGYuZm9ybWF0O1xuICB9O1xuXG4gIGRhdGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZWxmLnRvU3RyaW5nKCk7XG4gIH07XG5cbiAgcmV0dXJuIGRhdGU7XG59O1xuXG4vKipcbiAqIENvbnZlcnRzIHRoaXMgU2ZUaW1lc3RhbXAgdG8gYW4gU2ZUaW1lLCB3aGljaCBpcyBqdXN0IGEgSmF2YVNjcmlwdCBPYmplY3RcbiAqIHdpdGggc29tZSBtZXRob2RzOiBnZXRNaWRuaWdodFNlY29uZHMoKSwgZ2V0TmFub1NlY29uZHMoKSwgZXRjLlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cblNmVGltZXN0YW1wLnByb3RvdHlwZS50b1NmVGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gIHJldHVybiB7XG4gICAgZ2V0TWlkbmlnaHRTZWNvbmRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gc2VsZi5lcG9jaFNlY29uZHM7XG4gICAgfSxcbiAgICBnZXROYW5vU2Vjb25kczogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNlbGYubmFub1NlY29uZHM7XG4gICAgfSxcbiAgICBnZXRTY2FsZTogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNlbGYuc2NhbGU7XG4gICAgfSxcbiAgICBnZXRGb3JtYXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBzZWxmLmZvcm1hdDtcbiAgICB9LFxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkge1xuICAgICAgcmV0dXJuIHNlbGYudG9TdHJpbmcoKTtcbiAgICB9XG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNmVGltZXN0YW1wO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/result/sf_timestamp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/result/statement_type.js":
/*!****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/result/statement_type.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("exports.isDml = function (statementTypeId) {\n  return (statementTypeId >= 0x3000 && statementTypeId < 0x4000);\n};\n\nexports.isInsert = function (statementTypeId) {\n  return (statementTypeId === 0x3100);\n};\n\nexports.isUpdate = function (statementTypeId) {\n  return (statementTypeId === 0x3200);\n};\n\nexports.isDelete = function (statementTypeId) {\n  return (statementTypeId === 0x3300);\n};\n\nexports.isMerge = function (statementTypeId) {\n  return (statementTypeId === 0x3400);\n};\n\nexports.isMultiTableInsert = function (statementTypeId) {\n  return (statementTypeId === 0x3500);\n};\n\nexports.isDdl = function (statementTypeId) {\n  return (statementTypeId >= 0x6000);\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvc3RhdGVtZW50X3R5cGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYTtBQUNiO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUEsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvc3RhdGVtZW50X3R5cGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5pc0RtbCA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRUeXBlSWQpIHtcbiAgcmV0dXJuIChzdGF0ZW1lbnRUeXBlSWQgPj0gMHgzMDAwICYmIHN0YXRlbWVudFR5cGVJZCA8IDB4NDAwMCk7XG59O1xuXG5leHBvcnRzLmlzSW5zZXJ0ID0gZnVuY3Rpb24gKHN0YXRlbWVudFR5cGVJZCkge1xuICByZXR1cm4gKHN0YXRlbWVudFR5cGVJZCA9PT0gMHgzMTAwKTtcbn07XG5cbmV4cG9ydHMuaXNVcGRhdGUgPSBmdW5jdGlvbiAoc3RhdGVtZW50VHlwZUlkKSB7XG4gIHJldHVybiAoc3RhdGVtZW50VHlwZUlkID09PSAweDMyMDApO1xufTtcblxuZXhwb3J0cy5pc0RlbGV0ZSA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRUeXBlSWQpIHtcbiAgcmV0dXJuIChzdGF0ZW1lbnRUeXBlSWQgPT09IDB4MzMwMCk7XG59O1xuXG5leHBvcnRzLmlzTWVyZ2UgPSBmdW5jdGlvbiAoc3RhdGVtZW50VHlwZUlkKSB7XG4gIHJldHVybiAoc3RhdGVtZW50VHlwZUlkID09PSAweDM0MDApO1xufTtcblxuZXhwb3J0cy5pc011bHRpVGFibGVJbnNlcnQgPSBmdW5jdGlvbiAoc3RhdGVtZW50VHlwZUlkKSB7XG4gIHJldHVybiAoc3RhdGVtZW50VHlwZUlkID09PSAweDM1MDApO1xufTtcblxuZXhwb3J0cy5pc0RkbCA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRUeXBlSWQpIHtcbiAgcmV0dXJuIChzdGF0ZW1lbnRUeXBlSWQgPj0gMHg2MDAwKTtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/result/statement_type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/result/unique_column_name_creator.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/result/unique_column_name_creator.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("const resultContainsDuplicatedColumns = (rowtype) => {\n  const columnNames = rowtype.map(rt => rt.name);\n  return columnNames.length !== new Set(columnNames).size;\n};\n\nfunction addOverriddenNamesForDuplicatedColumns(rowtype) {\n\n  //Prepare renamed columns for duplicates if row mode was set to 'object_with_renamed_duplicated_columns'\n  if (resultContainsDuplicatedColumns(rowtype)) {\n\n    const columnNames = new Set(rowtype.map(el => el.name));\n    const quntityOfColumnNames = new Map();\n\n    for (let index = 0; index < rowtype.length; index++) {\n      const columnName = rowtype[index].name;\n      if (columnName) {\n        if (quntityOfColumnNames.has(columnName)) {\n          let times = quntityOfColumnNames.get(columnName) + 1;\n          let newColumnName = columnName + '_' + times;\n          while (columnNames.has(newColumnName)) {\n            times += 1;\n            newColumnName = columnName + '_' + times;\n          }\n          quntityOfColumnNames.set(columnName, times);\n          rowtype[index].overriddenName = newColumnName;\n          columnNames.add(newColumnName);\n        } else {\n          quntityOfColumnNames.set(columnName, 1);\n        }\n      }\n    }\n  }\n}\nexports.addOverridenNamesForDuplicatedColumns = addOverriddenNamesForDuplicatedColumns;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9yZXN1bHQvdW5pcXVlX2NvbHVtbl9uYW1lX2NyZWF0b3IuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdCQUF3Qix3QkFBd0I7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9jb25uZWN0aW9uL3Jlc3VsdC91bmlxdWVfY29sdW1uX25hbWVfY3JlYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCByZXN1bHRDb250YWluc0R1cGxpY2F0ZWRDb2x1bW5zID0gKHJvd3R5cGUpID0+IHtcbiAgY29uc3QgY29sdW1uTmFtZXMgPSByb3d0eXBlLm1hcChydCA9PiBydC5uYW1lKTtcbiAgcmV0dXJuIGNvbHVtbk5hbWVzLmxlbmd0aCAhPT0gbmV3IFNldChjb2x1bW5OYW1lcykuc2l6ZTtcbn07XG5cbmZ1bmN0aW9uIGFkZE92ZXJyaWRkZW5OYW1lc0ZvckR1cGxpY2F0ZWRDb2x1bW5zKHJvd3R5cGUpIHtcblxuICAvL1ByZXBhcmUgcmVuYW1lZCBjb2x1bW5zIGZvciBkdXBsaWNhdGVzIGlmIHJvdyBtb2RlIHdhcyBzZXQgdG8gJ29iamVjdF93aXRoX3JlbmFtZWRfZHVwbGljYXRlZF9jb2x1bW5zJ1xuICBpZiAocmVzdWx0Q29udGFpbnNEdXBsaWNhdGVkQ29sdW1ucyhyb3d0eXBlKSkge1xuXG4gICAgY29uc3QgY29sdW1uTmFtZXMgPSBuZXcgU2V0KHJvd3R5cGUubWFwKGVsID0+IGVsLm5hbWUpKTtcbiAgICBjb25zdCBxdW50aXR5T2ZDb2x1bW5OYW1lcyA9IG5ldyBNYXAoKTtcblxuICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCByb3d0eXBlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgY29uc3QgY29sdW1uTmFtZSA9IHJvd3R5cGVbaW5kZXhdLm5hbWU7XG4gICAgICBpZiAoY29sdW1uTmFtZSkge1xuICAgICAgICBpZiAocXVudGl0eU9mQ29sdW1uTmFtZXMuaGFzKGNvbHVtbk5hbWUpKSB7XG4gICAgICAgICAgbGV0IHRpbWVzID0gcXVudGl0eU9mQ29sdW1uTmFtZXMuZ2V0KGNvbHVtbk5hbWUpICsgMTtcbiAgICAgICAgICBsZXQgbmV3Q29sdW1uTmFtZSA9IGNvbHVtbk5hbWUgKyAnXycgKyB0aW1lcztcbiAgICAgICAgICB3aGlsZSAoY29sdW1uTmFtZXMuaGFzKG5ld0NvbHVtbk5hbWUpKSB7XG4gICAgICAgICAgICB0aW1lcyArPSAxO1xuICAgICAgICAgICAgbmV3Q29sdW1uTmFtZSA9IGNvbHVtbk5hbWUgKyAnXycgKyB0aW1lcztcbiAgICAgICAgICB9XG4gICAgICAgICAgcXVudGl0eU9mQ29sdW1uTmFtZXMuc2V0KGNvbHVtbk5hbWUsIHRpbWVzKTtcbiAgICAgICAgICByb3d0eXBlW2luZGV4XS5vdmVycmlkZGVuTmFtZSA9IG5ld0NvbHVtbk5hbWU7XG4gICAgICAgICAgY29sdW1uTmFtZXMuYWRkKG5ld0NvbHVtbk5hbWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHF1bnRpdHlPZkNvbHVtbk5hbWVzLnNldChjb2x1bW5OYW1lLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuZXhwb3J0cy5hZGRPdmVycmlkZW5OYW1lc0ZvckR1cGxpY2F0ZWRDb2x1bW5zID0gYWRkT3ZlcnJpZGRlbk5hbWVzRm9yRHVwbGljYXRlZENvbHVtbnM7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/result/unique_column_name_creator.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/connection/statement.js":
/*!****************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/connection/statement.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("const { v4: uuidv4 } = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\");\n\nconst Url = __webpack_require__(/*! url */ \"url\");\nconst QueryString = __webpack_require__(/*! querystring */ \"querystring\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Result = __webpack_require__(/*! ./result/result */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/result.js\");\nconst Parameters = __webpack_require__(/*! ../parameters */ \"(rsc)/./node_modules/snowflake-sdk/lib/parameters.js\");\nconst RowStream = __webpack_require__(/*! ./result/row_stream */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/row_stream.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst NativeTypes = (__webpack_require__(/*! ./result/data_types */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/data_types.js\").NativeTypes);\nconst FileTransferAgent = __webpack_require__(/*! ../file_transfer_agent/file_transfer_agent */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/file_transfer_agent.js\");\nconst Bind = __webpack_require__(/*! ./bind_uploader */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/bind_uploader.js\");\nconst RowMode = __webpack_require__(/*! ./../constants/row_mode */ \"(rsc)/./node_modules/snowflake-sdk/lib/constants/row_mode.js\");\n\nconst states =\n  {\n    FETCHING: 'fetching',\n    COMPLETE: 'complete'\n  };\n\nconst statementTypes =\n  {\n    ROW_PRE_EXEC: 'ROW_PRE_EXEC',\n    ROW_POST_EXEC: 'ROW_POST_EXEC',\n    FILE_PRE_EXEC: 'FILE_PRE_EXEC',\n    FILE_POST_EXEC: 'FILE_POST_EXEC'\n  };\n\nconst queryCodes = {\n  QUERY_IN_PROGRESS: '333333',       // GS code: the query is in progress\n  QUERY_IN_PROGRESS_ASYNC: '333334'  // GS code: the query is detached\n};\n\nexports.createContext = function (\n  options, services, connectionConfig) {\n  // create a statement context for a pre-exec statement\n  const context = createContextPreExec(\n    options, services, connectionConfig);\n\n  context.type = statementTypes.FILE_PRE_EXEC;\n\n  createStatement(options, context, services, connectionConfig);\n\n  // add the result request headers to the context\n  context.resultRequestHeaders = buildResultRequestHeadersFile();\n\n  return context;\n\n};\n\nfunction createStatement(\n  statementOptions, context, services, connectionConfig) {\n  // call super\n  BaseStatement.apply(this, [statementOptions, context, services, connectionConfig]);\n}\n\n/**\n * Check the type of command to execute.\n *\n * @param {Object} options\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nexports.createStatementPreExec = function (\n  options, services, connectionConfig) {\n  Logger.getInstance().debug('--createStatementPreExec');\n  // create a statement context for a pre-exec statement\n  const context = createContextPreExec(\n    options, services, connectionConfig);\n\n  if (options.sqlText && (Util.isPutCommand(options.sqlText) || Util.isGetCommand(options.sqlText))) {\n    if (options.fileStream) {\n      context.fileStream = options.fileStream;\n      options.fileStream = null;\n    }\n    return createFileStatementPreExec(\n      options, context, services, connectionConfig);\n  }\n\n  const numBinds = countBinding(context.binds);\n  Logger.getInstance().debug('numBinds = %d', numBinds);\n  let threshold = Parameters.getValue(Parameters.names.CLIENT_STAGE_ARRAY_BINDING_THRESHOLD);\n  if (connectionConfig.getbindThreshold()) {\n    threshold = connectionConfig.getbindThreshold();\n  }\n  Logger.getInstance().debug('threshold = %d', threshold);\n\n  // check array binding,\n  if (numBinds > threshold) {\n    return createStageStatementpreExec(options, context, services, connectionConfig);\n  } else {\n    return createRowStatementPreExec(\n      options, context, services, connectionConfig);\n  }\n};\n\n/**\n * Executes a statement and returns a statement object that can be used to fetch\n * its result.\n *\n * @param {Object} statementOptions\n * @param {Object} statementContext\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nfunction createRowStatementPreExec(\n  statementOptions, statementContext, services, connectionConfig) {\n  // set the statement type\n  statementContext.type = statementTypes.ROW_PRE_EXEC;\n\n  return new RowStatementPreExec(\n    statementOptions, statementContext, services, connectionConfig);\n}\n\n/**\n * Creates a statement object that can be used to fetch the result of a\n * previously executed statement.\n *\n * @param {Object} statementOptions\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nexports.createStatementPostExec = function (\n  statementOptions, services, connectionConfig) {\n  // check for missing options\n  Errors.checkArgumentExists(Util.exists(statementOptions),\n    ErrorCodes.ERR_CONN_FETCH_RESULT_MISSING_OPTIONS);\n\n  // check for invalid options\n  Errors.checkArgumentValid(Util.isObject(statementOptions),\n    ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_OPTIONS);\n\n  // check for missing query id\n  Errors.checkArgumentExists(Util.exists(statementOptions.queryId),\n    ErrorCodes.ERR_CONN_FETCH_RESULT_MISSING_QUERY_ID);\n\n  // check for invalid query id\n  Errors.checkArgumentValid(Util.isString(statementOptions.queryId),\n    ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_QUERY_ID);\n\n  // check for invalid complete callback\n  const complete = statementOptions.complete;\n  if (Util.exists(complete)) {\n    Errors.checkArgumentValid(Util.isFunction(complete),\n      ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_COMPLETE);\n  }\n\n  // check for invalid streamResult\n  if (Util.exists(statementOptions.streamResult)) {\n    Errors.checkArgumentValid(Util.isBoolean(statementOptions.streamResult),\n      ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_STREAM_RESULT);\n  }\n\n  // check for invalid fetchAsString\n  const fetchAsString = statementOptions.fetchAsString;\n  if (Util.exists(fetchAsString)) {\n    // check that the value is an array\n    Errors.checkArgumentValid(Util.isArray(fetchAsString),\n      ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING);\n\n    // check that all the array elements are valid\n    const invalidValueIndex = NativeTypes.findInvalidValue(fetchAsString);\n    Errors.checkArgumentValid(invalidValueIndex === -1,\n      ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING_VALUES,\n      JSON.stringify(fetchAsString[invalidValueIndex]));\n  }\n\n  const rowMode = statementOptions.rowMode;\n  if (Util.exists(rowMode)) {\n    RowMode.checkRowModeValid(rowMode);\n  }\n  const cwd = statementOptions.cwd;\n  if (Util.exists(cwd)) {\n    Errors.checkArgumentValid(Util.isString(cwd), ErrorCodes.ERR_CONN_FETCH_RESULT_INVALID_CWD);\n  }\n\n  // validate non-user-specified arguments\n  Errors.assertInternal(Util.isObject(services));\n  Errors.assertInternal(Util.isObject(connectionConfig));\n\n  // create a statement context\n  const statementContext = createStatementContext();\n\n  statementContext.queryId = statementOptions.queryId;\n  statementContext.complete = complete;\n  statementContext.streamResult = statementOptions.streamResult;\n  statementContext.fetchAsString = statementOptions.fetchAsString;\n  statementContext.multiResultIds = statementOptions.multiResultIds;\n  statementContext.multiCurId = statementOptions.multiCurId;\n  statementContext.rowMode = statementOptions.rowMode;\n  statementContext.cwd = statementOptions.cwd;\n\n  // set the statement type\n  statementContext.type = (statementContext.type === statementTypes.ROW_PRE_EXEC) ? statementTypes.ROW_POST_EXEC : statementTypes.FILE_POST_EXEC;\n\n  return new StatementPostExec(\n    statementOptions, statementContext, services, connectionConfig);\n};\n\n/**\n * Creates a new statement context object.\n *\n * @returns {Object}\n */\nfunction createStatementContext() {\n  return new EventEmitter();\n}\n\n/**\n * Creates a statement object that can be used to execute a PUT or GET file\n * operation.\n *\n * @param {Object} statementOptions\n * @param {Object} statementContext\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nfunction createFileStatementPreExec(\n  statementOptions, statementContext, services, connectionConfig) {\n  // set the statement type\n  statementContext.type = statementTypes.FILE_PRE_EXEC;\n\n  return new FileStatementPreExec(\n    statementOptions, statementContext, services, connectionConfig);\n}\n\n/**\n * Creates a statement object that can be used to execute stage binding\n * operation.\n *\n * @param {Object} statementOptions\n * @param {Object} statementContext\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nfunction createStageStatementpreExec(\n  statementOptions, statementContext, services, connectionConfig) {\n  return new StageBindingStatementPreExec(statementOptions, statementContext, services, connectionConfig);\n}\n\n/**\n * Creates a statement context object for pre-exec statement.\n *\n * @param {Object} statementOptions\n * @param {Object} services\n * @param {Object} connectionConfig\n *\n * @returns {Object}\n */\nfunction createContextPreExec(\n  statementOptions, services, connectionConfig) {\n  // check for missing options\n  Errors.checkArgumentExists(Util.exists(statementOptions),\n    ErrorCodes.ERR_CONN_EXEC_STMT_MISSING_OPTIONS);\n\n  // check for invalid options\n  Errors.checkArgumentValid(Util.isObject(statementOptions),\n    ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_OPTIONS);\n\n  if (!Util.exists(statementOptions.requestId)) {\n    // check for missing sql text\n    Errors.checkArgumentExists(Util.exists(statementOptions.sqlText),\n      ErrorCodes.ERR_CONN_EXEC_STMT_MISSING_SQL_TEXT);\n\n    // check for invalid sql text\n    Errors.checkArgumentValid(Util.isString(statementOptions.sqlText),\n      ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_SQL_TEXT);\n  }\n\n  // check for invalid complete callback\n  const complete = statementOptions.complete;\n  if (Util.exists(complete)) {\n    Errors.checkArgumentValid(Util.isFunction(complete),\n      ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_COMPLETE);\n  }\n\n  // check for invalid streamResult\n  if (Util.exists(statementOptions.streamResult)) {\n    Errors.checkArgumentValid(Util.isBoolean(statementOptions.streamResult),\n      ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_STREAM_RESULT);\n  }\n\n  // check for invalid fetchAsString\n  const fetchAsString = statementOptions.fetchAsString;\n  if (Util.exists(fetchAsString)) {\n    // check that the value is an array\n    Errors.checkArgumentValid(Util.isArray(fetchAsString),\n      ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING);\n\n    // check that all the array elements are valid\n    const invalidValueIndex = NativeTypes.findInvalidValue(fetchAsString);\n    Errors.checkArgumentValid(invalidValueIndex === -1,\n      ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING_VALUES,\n      JSON.stringify(fetchAsString[invalidValueIndex]));\n  }\n\n  // check for invalid requestId\n  if (Util.exists(statementOptions.requestId)) {\n    Errors.checkArgumentValid(Util.isString(statementOptions.requestId),\n      ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_REQUEST_ID);\n  }\n\n  // if parameters are specified, make sure the specified value is an object\n  if (Util.exists(statementOptions.parameters)) {\n    Errors.checkArgumentValid(Util.isObject(statementOptions.parameters),\n      ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_PARAMETERS);\n  }\n\n  // if binds are specified\n  const binds = statementOptions.binds;\n  if (Util.exists(binds)) {\n    // make sure the specified value is an array\n    Errors.checkArgumentValid(Util.isArray(binds),\n      ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_BINDS);\n\n    // make sure everything in the binds array is stringifiable\n    for (let index = 0, length = binds.length; index < length; index++) {\n      Errors.checkArgumentValid(JSON.stringify(binds[index]) !== undefined,\n        ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_BIND_VALUES, binds[index]);\n    }\n  }\n\n  // if an internal option is specified, make sure it's boolean\n  if (Util.exists(statementOptions.internal)) {\n    Errors.checkArgumentValid(Util.isBoolean(statementOptions.internal),\n      ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_INTERNAL);\n  }\n  const rowMode = statementOptions.rowMode;\n  if (Util.exists(rowMode)) {\n    RowMode.checkRowModeValid(rowMode);\n  }\n\n  // if an asyncExec flag is specified, make sure it's boolean\n  if (Util.exists(statementOptions.asyncExec)) {\n    Errors.checkArgumentValid(Util.isBoolean(statementOptions.asyncExec),\n      ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_ASYNC_EXEC);\n  }\n\n  // if a describeOnly flag is specified, make sure it's boolean\n  if (Util.exists(statementOptions.describeOnly)) {\n    Errors.checkArgumentValid(Util.isBoolean(statementOptions.describeOnly),\n      ErrorCodes.ERR_CONN_EXEC_STMT_INVALID_DESCRIBE_ONLY);\n  }\n\n  // create a statement context\n  const statementContext = createStatementContext();\n\n  statementContext.sqlText = statementOptions.sqlText;\n  statementContext.complete = complete;\n  statementContext.streamResult = statementOptions.streamResult;\n  statementContext.fetchAsString = statementOptions.fetchAsString;\n  statementContext.multiResultIds = statementOptions.multiResultIds;\n  statementContext.multiCurId = statementOptions.multiCurId;\n  statementContext.rowMode = statementOptions.rowMode;\n  statementContext.asyncExec = statementOptions.asyncExec;\n\n  // if a binds array is specified, add it to the statement context\n  if (Util.exists(statementOptions.binds)) {\n    statementContext.binds = statementOptions.binds;\n  }\n\n  // if parameters are specified, add them to the statement context\n  if (Util.exists(statementOptions.parameters)) {\n    statementContext.parameters = statementOptions.parameters;\n  }\n\n  // if the internal flag is specified, add it to the statement context\n  if (Util.exists(statementOptions.internal)) {\n    statementContext.internal = statementOptions.internal;\n  }\n\n  if (Util.exists(statementOptions.cwd)) {\n    statementContext.cwd = statementOptions.cwd;\n  }\n\n  // if the describeOnly flag is specified, add it to the statement context\n  if (Util.exists(statementOptions.describeOnly)) {\n    statementContext.describeOnly = statementOptions.describeOnly;\n  }\n\n  // validate non-user-specified arguments\n  Errors.assertInternal(Util.isObject(services));\n  Errors.assertInternal(Util.isObject(connectionConfig));\n\n  // use request id passed by user\n  if (statementOptions.requestId) {\n    statementContext.requestId = statementOptions.requestId;\n    statementContext.resubmitRequest = true;\n  } else {\n    // use a random uuid for the statement request id\n    statementContext.requestId = uuidv4();\n  }\n\n  return statementContext;\n}\n\n/**\n * Creates a new BaseStatement.\n *\n * @param statementOptions\n * @param context\n * @param services\n * @param connectionConfig\n * @constructor\n */\nfunction BaseStatement(\n  statementOptions, context, services, connectionConfig) {\n  // call super\n  EventEmitter.call(this);\n\n  // validate input\n  Errors.assertInternal(Util.isObject(statementOptions));\n  Errors.assertInternal(Util.isObject(context));\n\n  context.services = services;\n  context.connectionConfig = connectionConfig;\n  context.isFetchingResult = true;\n  context.rowMode = statementOptions.rowMode || connectionConfig.getRowMode();\n\n  // TODO: add the parameters map to the statement context\n\n  const statement = this;\n\n  /**\n   * Returns this statement's SQL text.\n   *\n   * @returns {String}\n   */\n  this.getSqlText = function () {\n    return context.sqlText;\n  };\n\n  /**\n   * Returns the current status of this statement.\n   *\n   * @returns {String}\n   */\n  this.getStatus = function () {\n    return context.isFetchingResult ? states.FETCHING : states.COMPLETE;\n  };\n\n  /**\n   * Returns the columns produced by this statement.\n   *\n   * @returns {Object[]}\n   */\n  this.getColumns = function () {\n    return context.result ? context.result.getColumns() : undefined;\n  };\n\n  /**\n   * Given a column identifier, returns the corresponding column. The column\n   * identifier can be either the column name (String) or the column index\n   * (Number). If a column is specified and there is more than one column with\n   * that name, the first column with the specified name will be returned.\n   *\n   * @param {String | Number} columnIdentifier\n   *\n   * @returns {Object}\n   */\n  this.getColumn = function (columnIdentifier) {\n    return context.result ? context.result.getColumn(columnIdentifier) :\n      undefined;\n  };\n\n  /**\n   * Returns the number of rows returned by this statement.\n   *\n   * @returns {Number}\n   */\n  this.getNumRows = function () {\n    return context.result ? context.result.getReturnedRows() : undefined;\n  };\n\n  /**\n   * Returns the number of rows updated by this statement.\n   *\n   * @returns {Number}\n   */\n  this.getNumUpdatedRows = function () {\n    return context.result ? context.result.getNumUpdatedRows() : undefined;\n  };\n\n  /**\n   * Returns an object that contains information about the values of the\n   * current warehouse, current database, etc., when this statement finished\n   * executing.\n   *\n   * @returns {Object}\n   */\n  this.getSessionState = function () {\n    return context.result ? context.result.getSessionState() : undefined;\n  };\n\n  /**\n   * Returns the request id that was used when the statement was issued.\n   *\n   * @returns {String}\n   */\n  this.getRequestId = function () {\n    return context.requestId;\n  };\n\n  /**\n   * Returns the query id generated by the server for this statement.\n   * If the statement is still executing and we don't know the query id\n   * yet, this method will return undefined.\n   *\n   * Should use getQueryId instead.\n   * @deprecated \n   * @returns {String}\n   */\n  this.getStatementId = function () {\n    return context.queryId;\n  };\n\n  /**\n   * Returns the query id generated by the server for this statement.\n   * If the statement is still executing and we don't know the query id\n   * yet, this method will return undefined.\n   *\n   * @returns {String}\n   */\n  this.getQueryId = function () {\n    return context.queryId;\n  };\n\n  /**\n   * Cancels this statement if possible.\n   *\n   * @param {Function} [callback]\n   */\n  this.cancel = function (callback) {\n    sendCancelStatement(context, statement, callback);\n  };\n\n  //Integration Testing purpose.\n  this.getQueryContextCacheSize = function () {\n    return services.sf.getQueryContextCacheSize();\n  };\n\n  this.getQueryContextDTOSize = function () {\n    return services.sf.getQueryContextDTO().entries.length;\n  };\n\n  /**\n   * Issues a request to get the statement result again.\n   *\n   * @param {Function} callback\n   */\n  context.refresh = function (callback) {\n    // pick the appropriate function to get the result based on whether we\n    // have the query id or request id (we should have at least one)\n    const sendRequestFn = context.queryId ?\n      sendRequestPostExec : sendRequestPreExec;\n\n    // the current result error might be transient,\n    // so issue a request to get the result again\n    sendRequestFn(context, function (err, body) {\n      // refresh the result\n      context.onStatementRequestComp(err, body);\n\n      // if a callback was specified, invoke it\n      if (Util.isFunction(callback)) {\n        callback(context);\n      }\n    });\n  };\n\n  /**\n   * Called when the statement request is complete.\n   *\n   * @param err\n   * @param body\n   */\n  context.onStatementRequestComp = async function (err, body) {\n    // if we already have a result or a result error, we invoked the complete\n    // callback once, so don't invoke it again\n    const suppressComplete = context.result || context.resultError;\n\n    // clear the previous result error\n    context.resultError = null;\n\n    // if there was no error, call the success function\n    if (!err) {\n      await context.onStatementRequestSucc(body);\n    } else {\n      // save the error\n      context.resultError = err;\n\n      // if we don't have a query id and we got a response from GS, extract\n      // the query id from the data\n      if (!context.queryId &&\n        Errors.isOperationFailedError(err) && err.data) {\n        context.queryId = err.data.queryId;\n      }\n    }\n\n    // we're no longer fetching the result\n    context.isFetchingResult = false;\n\n    if (!suppressComplete) {\n      // emit a complete event\n      context.emit('statement-complete', Errors.externalize(err), statement);\n\n      // if a complete function was specified, invoke it\n      if (Util.exists(context.complete)) {\n        invokeStatementComplete(statement, context);\n      }\n    } else {\n      Logger.getInstance().debug('refreshed result of statement with %s',\n        context.requestId ?\n          Util.format('request id = %s', context.requestId) :\n          Util.format('query id = %s', context.queryId));\n    }\n  };\n\n  /**\n   * Called when the statement request is successful. Subclasses must provide\n   * their own implementation.\n   */\n  context.onStatementRequestSucc = function () {\n  };\n}\n\nUtil.inherits(BaseStatement, EventEmitter);\n\n/**\n * Invokes the statement complete callback.\n *\n * @param {Object} statement\n * @param {Object} context\n */\nfunction invokeStatementComplete(statement, context) {\n  // find out if the result will be streamed;\n  // if a value is not specified, get it from the connection\n  let streamResult = context.streamResult;\n  if (!Util.exists(streamResult)) {\n    streamResult = context.connectionConfig.getStreamResult();\n  }\n\n  // if the result will be streamed later or in asyncExec mode,\n  // invoke the complete callback right away\n  if (streamResult) {\n    context.complete(Errors.externalize(context.resultError), statement);\n  } else if (context.asyncExec) {\n    // return the result object with the query ID inside.\n    context.complete(null, statement, context.result);\n  } else {\n    process.nextTick(function () {\n      // aggregate all the rows into an array and pass this\n      // array to the complete callback as the last argument\n      const rows = [];\n      statement.streamRows()\n        .on('readable', function () {\n          // read only when data is available\n          let row;\n\n          // while there are rows available to read, push row to results array\n          while ((row = this.read()) !== null) {\n            rows.push(row);\n          }\n        })\n        .on('end', function () {\n          context.complete(null, statement, rows);\n        })\n        .on('error', function (err) {\n          context.complete(Errors.externalize(err), statement);\n        });\n    });\n  }\n}\n\n/**\n * Creates a new RowStatementPreExec instance.\n *\n * @param {Object} statementOptions\n * @param {Object} context\n * @param {Object} services\n * @param {Object} connectionConfig\n * @constructor\n */\nfunction RowStatementPreExec(\n  statementOptions,\n  context,\n  services,\n  connectionConfig) {\n  Logger.getInstance().debug('RowStatementPreExec');\n  // call super\n  BaseStatement.apply(this, [statementOptions, context, services, connectionConfig]);\n\n  // add the result request headers to the context\n  context.resultRequestHeaders = buildResultRequestHeadersRow();\n\n  /**\n   * Called when the request to get the statement result is successful.\n   *\n   * @param {Object} body\n   */\n  context.onStatementRequestSucc =\n    createOnStatementRequestSuccRow(this, context);\n\n  /**\n   * Fetches the rows in this statement's result and invokes the each()\n   * callback on each row. If start and end values are specified, the each()\n   * callback will only be invoked on rows in the specified range.\n   *\n   * @param {Object} options\n   */\n  this.fetchRows = createFnFetchRows(this, context);\n\n  /**\n   * Streams the rows in this statement's result. If start and end values are\n   * specified, only rows in the specified range are streamed.\n   *\n   * @param {Object} options\n   */\n  this.streamRows = createFnStreamRows(this, context);\n\n  // send a request to execute the statement\n  sendRequestPreExec(context, context.onStatementRequestComp);\n}\n\nUtil.inherits(RowStatementPreExec, BaseStatement);\n\n/**\n * Creates a function that can be used by row statements to process the response\n * when the request is successful.\n *\n * @param statement\n * @param context\n * @returns {Function}\n */\nfunction createOnStatementRequestSuccRow(statement, context) {\n  return function (body) {\n    // if we don't already have a result\n    if (!context.result) {\n      if (body.code === queryCodes.QUERY_IN_PROGRESS_ASYNC) {\n        context.result = {\n          queryId: body.data.queryId\n        };\n        return;\n      }\n      if (body.data.resultIds != null && body.data.resultIds.length > 0) {\n        //multi statements\n        this._resultIds = body.data.resultIds.split(',');\n        context.isMulti = true;\n        context.multiResultIds = this._resultIds;\n        context.multiCurId = 0;\n        context.queryId = this._resultIds[context.multiCurId];\n        exports.createStatementPostExec(context, context.services, context.connectionConfig);\n      } else {\n        // build a result from the response\n        context.result = new Result(\n          {\n            response: body,\n            statement: statement,\n            services: context.services,\n            connectionConfig: context.connectionConfig,\n            rowMode: context.rowMode\n          });\n\n        context.queryId = context.result.getQueryId();\n        this.services.sf.deserializeQueryContext(context.result.getQueryContext());\n      }\n    } else {\n      // refresh the existing result\n      context.result.refresh(body);\n    }\n\n    if (context.isMulti == null || context.isMulti === false) {\n      // only update the parameters if the statement isn't a post-exec statement\n      if (context.type !== statementTypes.ROW_POST_EXEC || context.type !== statementTypes.FILE_POST_EXEC) {\n        Parameters.update(context.result.getParametersArray());\n      }\n    }\n  };\n}\n\n/**\n * Creates a new FileStatementPreExec instance.\n *\n * @param {Object} statementOptions\n * @param {Object} context\n * @param {Object} services\n * @param {Object} connectionConfig\n * @constructor\n */\nfunction FileStatementPreExec(\n  statementOptions, context, services, connectionConfig) {\n  // call super\n  BaseStatement.apply(this, [statementOptions, context, services, connectionConfig]);\n\n  // add the result request headers to the context\n  context.resultRequestHeaders = buildResultRequestHeadersFile();\n\n  /**\n   * Called when the statement request is successful.\n   *\n   * @param {Object} body\n   */\n  context.onStatementRequestSucc = async function (body) {\n    await executeFileTransferRequest(context, body, this);\n  };\n\n  /**\n   * Streams the rows in this statement's result. If start and end values are\n   * specified, only rows in the specified range are streamed.\n   *\n   * @param {Object} options\n   */\n  this.streamRows = createFnStreamRows(this, context);\n  this.hasNext = hasNextResult(this, context);\n  this.NextResult = createNextReuslt(this, context);\n\n  /**\n   * Returns the file metadata generated by the statement.\n   *\n   * @returns {Object}\n   */\n  this.getFileMetadata = function () {\n    return context.fileMetadata;\n  };\n\n  // send a request to execute the file statement\n  sendRequestPreExec(context, context.onStatementRequestComp);\n}\n\nasync function executeFileTransferRequest(context, body, statement, fileTransferAgent) {\n  context.fileMetadata = body;\n\n  const fta = fileTransferAgent ?? new FileTransferAgent(context);\n  await fta.execute();\n\n  try {\n    // build a result from the response\n    const result = fta.result();\n\n    // init result and meta\n    body.data = {\n      rowset: result.rowset,\n      returned: result.rowset.length,\n      rowtype: result.rowtype,\n      parameters: [],\n    };\n\n    context.result = new Result({\n      response: body,\n      statement: statement,\n      services: context.services,\n      connectionConfig: context.connectionConfig\n    });\n  } catch (error) {\n    context.resultError = error;\n  }\n}\n\nexports.executeFileTransferRequest = executeFileTransferRequest;\n\nUtil.inherits(FileStatementPreExec, BaseStatement);\n\n/**\n * Creates a new StageBindingStatementPreExec instance.\n *\n * @param {Object} statementOptions\n * @param {Object} context\n * @param {Object} services\n * @param {Object} connectionConfig\n * @constructor\n */\nfunction StageBindingStatementPreExec(\n  statementOptions, context, services, connectionConfig) {\n  // call super\n  BaseStatement.apply(this, arguments);\n\n  // add the result request headers to the context\n  context.resultRequestHeaders = buildResultRequestHeadersFile();\n\n  /**\n   * Called when the statement request is successful. Subclasses must provide\n   * their own implementation.\n   */\n  context.onStatementRequestSucc = function () {\n    //do nothing\n  };\n\n  /**\n   * Called the stage binding request\n   *\n   * @param {Object} options\n   * @param {Object} context\n   * @param {Object} services\n   * @param {Object} connectionConfig\n   */\n  this.StageBindingRequest = async function (options, context, services, connectionConfig) {\n    try {\n      const bindUploaderRequestId = uuidv4();\n      const bind = new Bind.BindUploader(options, services, connectionConfig, bindUploaderRequestId);\n      context.bindStage = Bind.GetStageName(bindUploaderRequestId);\n      await bind.Upload(context.binds);\n      return createRowStatementPreExec(\n        options, context, services, connectionConfig);\n    } catch (error) {\n      context.bindStage = null;\n      return createRowStatementPreExec(\n        options, context, services, connectionConfig);\n    }\n  };\n   \n  /**\n   * Fetches the rows in this statement's result and invokes the each()\n   * callback on each row. If start and end values are specified, the each()\n   * callback will only be invoked on rows in the specified range.\n   *\n   * @param {Object} options\n   */\n  this.fetchRows = createFnFetchRows(this, context);\n\n  /**\n   * Streams the rows in this statement's result. If start and end values are\n   * specified, only rows in the specified range are streamed.\n   *\n   * @param {Object} options\n   */\n  this.streamRows = createFnStreamRows(this, context);\n  this.hasNext = hasNextResult(this, context);\n  this.NextResult = createNextReuslt(this, context);\n\n  this.StageBindingRequest(statementOptions, context, services, connectionConfig);\n  \n}\n\nUtil.inherits(StageBindingStatementPreExec, BaseStatement);\n\n/**\n * Creates a new StatementPostExec instance.\n *\n * @param {Object} statementOptions\n * @param {Object} context\n * @param {Object} services\n * @param {Object} connectionConfig\n * @constructor\n */\nfunction StatementPostExec(\n  statementOptions, context, services, connectionConfig) {\n  // call super\n  BaseStatement.apply(this, [statementOptions, context, services, connectionConfig]);\n\n  // add the result request headers to the context\n  context.resultRequestHeaders = buildResultRequestHeadersRow();\n\n  /**\n   * Called when the statement request is successful.\n   *\n   * @param {Object} body\n   */\n  context.onStatementRequestSucc =\n    createOnStatementRequestSuccRow(this, context);\n\n  /**\n   * Fetches the rows in this statement's result and invokes the each()\n   * callback on each row. If startIndex and endIndex values are specified, the\n   * each() callback will only be invoked on rows in the requested range. The\n   * end() callback will be invoked when either all the requested rows have been\n   * successfully processed, or if an error was encountered while trying to\n   * fetch the requested rows.\n   *\n   * @param {Object} options\n   */\n  this.fetchRows = createFnFetchRows(this, context);\n\n  /**\n   * Streams the rows in this statement's result. If start and end values are\n   * specified, only rows in the specified range are streamed.\n   *\n   * @param {Object} options\n   */\n  this.streamRows = createFnStreamRows(this, context);\n  this.hasNext = hasNextResult(this, context);\n  this.NextResult = createNextReuslt(this, context);\n  \n  // send a request to fetch the result\n  sendRequestPostExec(context, context.onStatementRequestComp);\n}\n\nUtil.inherits(StatementPostExec, BaseStatement);\n\n/**\n * Creates a function that fetches the rows in a statement's result and\n * invokes the each() callback on each row. If start and end values are\n * specified, the each() callback will only be invoked on rows in the\n * specified range.\n *\n * @param statement\n * @param context\n */\nfunction createFnFetchRows(statement, context) {\n  return function (options) {\n    // check for missing options\n    Errors.checkArgumentExists(Util.exists(options),\n      ErrorCodes.ERR_STMT_FETCH_ROWS_MISSING_OPTIONS);\n\n    // check for invalid options\n    Errors.checkArgumentValid(Util.isObject(options),\n      ErrorCodes.ERR_STMT_FETCH_ROWS_INVALID_OPTIONS);\n\n    // check for missing each()\n    Errors.checkArgumentExists(Util.exists(options.each),\n      ErrorCodes.ERR_STMT_FETCH_ROWS_MISSING_EACH);\n\n    // check for invalid each()\n    Errors.checkArgumentValid(Util.isFunction(options.each),\n      ErrorCodes.ERR_STMT_FETCH_ROWS_INVALID_EACH);\n\n    // check for missing end()\n    Errors.checkArgumentExists(Util.exists(options.end),\n      ErrorCodes.ERR_STMT_FETCH_ROWS_MISSING_END);\n\n    // check for invalid end()\n    Errors.checkArgumentValid(Util.isFunction(options.end),\n      ErrorCodes.ERR_STMT_FETCH_ROWS_INVALID_END);\n\n    const rowMode = options.rowMode;\n    if (Util.exists(rowMode)) {\n      RowMode.checkRowModeValid(rowMode);\n    }\n\n    // if we're still trying to fetch the result, create an error of our own\n    // and invoke the end() callback\n    if (context.isFetchingResult) {\n      process.nextTick(function () {\n        options.end(Errors.createClientError(\n          ErrorCodes.ERR_STMT_FETCH_ROWS_FETCHING_RESULT).externalize(),\n        statement);\n      });\n    } else if (context.resultError) {\n      // if there was an error the last time we tried to get the result\n      // if we have a fatal error, end the fetch rows operation since we're not\n      // going to be able to get any rows, either because the statement failed\n      // or because the result's been purged\n      if (Errors.isOperationFailedError(context.resultError) &&\n        context.resultError.sqlState) {\n        process.nextTick(function () {\n          endFetchRows(options, statement, context);\n        });\n      } else {\n        context.refresh(function () {\n          // if there was no error, fetch rows from the result\n          if (!context.resultError) {\n            fetchRowsFromResult(options, statement, context);\n          } else {\n            // give up because it's unlikely we'll succeed if we retry again\n            endFetchRows(options, statement, context);\n          }\n        });\n      }\n    } else {\n      fetchRowsFromResult(options, statement, context);\n    }\n  };\n}\n\n/**\n * Creates a function that streams the rows in a statement's result. If start\n * and end values are specified, only rows in the specified range are streamed.\n *\n * @param statement\n * @param context\n */\nfunction createFnStreamRows(statement, context) {\n  return function (options) {\n    // if some options are specified\n    if (Util.exists(options)) {\n      // check for invalid options\n      Errors.checkArgumentValid(Util.isObject(options),\n        ErrorCodes.ERR_STMT_FETCH_ROWS_INVALID_OPTIONS);\n\n      // check for invalid start\n      if (Util.exists(options.start)) {\n        Errors.checkArgumentValid(Util.isNumber(options.start),\n          ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_START);\n      }\n\n      // check for invalid end\n      if (Util.exists(options.end)) {\n        Errors.checkArgumentValid(Util.isNumber(options.end),\n          ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_END);\n      }\n\n      // check for invalid fetchAsString\n      const fetchAsString = options.fetchAsString;\n      if (Util.exists(fetchAsString)) {\n        // check that the value is an array\n        Errors.checkArgumentValid(Util.isArray(fetchAsString),\n          ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING);\n\n        // check that all the array elements are valid\n        const invalidValueIndex = NativeTypes.findInvalidValue(fetchAsString);\n        Errors.checkArgumentValid(invalidValueIndex === -1,\n          ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING_VALUES,\n          JSON.stringify(fetchAsString[invalidValueIndex]));\n      }\n\n      const rowMode = context.rowMode;\n      if (Util.exists(rowMode)) {\n        RowMode.checkRowModeValid(rowMode);\n      }\n    }\n\n    return new RowStream(statement, context, options);\n  };\n}\n\n/**\n * Ends the fetchRows() operation.\n *\n * @param {Object} options the options passed to fetchRows().\n * @param {Object} statement\n * @param {Object} context\n */\nfunction endFetchRows(options, statement, context) {\n  options.end(Errors.externalize(context.resultError), statement);\n}\n\n/**\n * Fetches rows from the statement's result.\n *\n * @param {Object} options the options passed to fetchRows().\n * @param {Object} statement\n * @param {Object} context\n */\nfunction fetchRowsFromResult(options, statement, context) {\n  let numInterrupts = 0;\n\n  // forward to the result to get a FetchRowsOperation object\n  const operation = context.result.fetchRows(options);\n\n  // subscribe to the operation's 'complete' event\n  operation.on('complete', function (err, continueCallback) {\n    // we want to retry if the error is retryable and the\n    // result stream hasn't been closed too many times\n    if (Errors.isLargeResultSetError(err) && err.response &&\n      (err.response.statusCode === 403) &&\n      (numInterrupts <\n        context.connectionConfig.getResultStreamInterrupts())) {\n      // increment the interrupt counter\n      numInterrupts++;\n\n      // issue a request to fetch the result again\n      sendRequestPostExec(context, function (err, body) {\n        // refresh the result\n        context.onStatementRequestComp(err, body);\n\n        // if there was no error, continue from where we got interrupted\n        if (!err) {\n          continueCallback();\n        }\n      });\n    } else {\n      endFetchRows(options, statement, context);\n    }\n  });\n}\n\n/**\n * Issues a request to cancel a statement.\n *\n * @param {Object} statementContext\n * @param {Object} statement\n * @param {Function} callback\n */\nfunction sendCancelStatement(statementContext, statement, callback) {\n  let url;\n  let json;\n\n  // use different rest endpoints based on whether the query id is available\n  if (statementContext.queryId) {\n    url = '/queries/' + statementContext.queryId + '/abort-request';\n  } else {\n    url = '/queries/v1/abort-request';\n    json =\n      {\n        requestId: statementContext.requestId\n      };\n  }\n\n  // issue a request to cancel the statement\n  statementContext.services.sf.request(\n    {\n      method: 'POST',\n      url: url,\n      json: json,\n      callback: function (err) {\n        // if a callback was specified, invoke it\n        if (Util.isFunction(callback)) {\n          callback(Errors.externalize(err), statement);\n        }\n      }\n    });\n}\n\n/**\n * Issues a request to get the result of a statement that hasn't been previously\n * executed.\n *\n * @param statementContext\n * @param onResultAvailable\n */\nfunction sendRequestPreExec(statementContext, onResultAvailable) {\n  // get the request headers\n  const headers = statementContext.resultRequestHeaders;\n\n  // build the basic json for the request\n  const json =\n  {\n    disableOfflineChunks: false,\n  };\n  json.sqlText = statementContext.sqlText;\n\n  if (statementContext.resubmitRequest && !json.sqlText) {\n    json.sqlText = `SELECT 'Error retrieving query results for request id: ${statementContext.requestId}, `\n       + 'please use RESULT_SCAN instead\\' AS ErrorMessage;';\n  }\n\n  Logger.getInstance().debug('context.bindStage=' + statementContext.bindStage);\n  if (Util.exists(statementContext.bindStage)) {\n    json.bindStage = statementContext.bindStage;\n  } else if (Util.exists(statementContext.binds)) {\n    // if binds are specified, build a binds map and include it in the request\n    json.bindings = buildBindsMap(statementContext.binds);\n  }\n\n  // include statement parameters if a value was specified\n  if (Util.exists(statementContext.parameters)) {\n    json.parameters = statementContext.parameters;\n    Logger.getInstance().debug('context.parameters=' + statementContext.parameters);\n  }\n\n  // include the internal flag if a value was specified\n  if (Util.exists(statementContext.internal)) {\n    json.isInternal = statementContext.internal;\n  }\n\n  if (!statementContext.disableQueryContextCache){\n    json.queryContextDTO = statementContext.services.sf.getQueryContextDTO();\n  }\n\n  // include the asyncExec flag if a value was specified\n  if (Util.exists(statementContext.asyncExec)) {\n    json.asyncExec = statementContext.asyncExec;\n  }\n\n  // include describeOnly flag if a value was specified\n  if (Util.exists(statementContext.describeOnly)) {\n    json.describeOnly = statementContext.describeOnly;\n  }\n\n  // use the snowflake service to issue the request\n  sendSfRequest(statementContext,\n    {\n      method: 'POST',\n      headers: headers,\n      url: Url.format(\n        {\n          pathname: '/queries/v1/query-request',\n          search: QueryString.stringify(\n            {\n              requestId: statementContext.requestId\n            })\n        }),\n      json: json,\n      callback: buildResultRequestCallback(\n        statementContext, headers, onResultAvailable)\n    },\n    true);\n}\n\nthis.sendRequest = function (statementContext, onResultAvailable) {\n  // get the request headers\n  const headers = statementContext.resultRequestHeaders;\n\n  // build the basic json for the request\n  const json =\n  {\n    disableOfflineChunks: false,\n    sqlText: statementContext.sqlText\n  };\n\n  Logger.getInstance().debug('context.bindStage=' + statementContext.bindStage);\n  if (Util.exists(statementContext.bindStage)) {\n    json.bindStage = statementContext.bindStage;\n  } else if (Util.exists(statementContext.binds)) {\n    // if binds are specified, build a binds map and include it in the request\n    json.bindings = buildBindsMap(statementContext.binds);\n  }\n\n  // include statement parameters if a value was specified\n  if (Util.exists(statementContext.parameters)) {\n    json.parameters = statementContext.parameters;\n  }\n\n  // include the internal flag if a value was specified\n  if (Util.exists(statementContext.internal)) {\n    json.isInternal = statementContext.internal;\n  }\n\n  if (!statementContext.disableQueryContextCache){\n    json.queryContextDTO = statementContext.services.sf.getQueryContextDTO();\n  }\n\n  let options =\n  {\n    method: 'POST',\n    headers: headers,\n    url: Url.format(\n      {\n        pathname: '/queries/v1/query-request',\n        search: QueryString.stringify(\n          {\n            requestId: statementContext.requestId\n          })\n      }),\n    json: json,\n    callback: buildResultRequestCallback(\n      statementContext, headers, onResultAvailable)\n  };\n\n  const sf = statementContext.services.sf;\n\n  // clone the options\n  options = Util.apply({}, options);\n\n  return new Promise((resolve) => {\n    resolve(sf.postAsync(options));\n  });\n};\n\n/**\n * Converts a bind variables array to a map that can be included in the\n * POST-body when issuing a pre-exec statement request.\n *\n * @param bindsArray\n *\n * @returns {Object}\n */\nfunction buildBindsMap(bindsArray) {\n  const bindsMap = {};\n  const isArrayBinding = bindsArray.length > 0 && Util.isArray(bindsArray[0]);\n  const singleArray = isArrayBinding ? bindsArray[0] : bindsArray;\n\n  for (let index = 0, length = singleArray.length; index < length; index++) {\n    let value = singleArray[index];\n\n    // pick the appropriate logical data type based on the bind value\n    let type;\n    if (Util.isBoolean(value)) {\n      type = 'BOOLEAN';\n    } else if (Util.isObject(value) || Util.isArray(value)) {\n      type = 'VARIANT';\n    } else if (Util.isNumber(value)) {\n      if (Number(value) === value && value % 1 === 0) {\n        // if value is integer\n        type = 'FIXED';\n      } else {\n        type = 'REAL';\n      }\n    } else {\n      type = 'TEXT';\n    }\n\n    // convert non-null values to a string if necessary; we don't convert null\n    // because the client might want to run something like\n    //   sql text = update t set name = :1 where id = 1;, binds = [null]\n    // and converting null to a string would result in us executing\n    //   sql text = update t set name = 'null' where id = 1;\n    // instead of\n    //   sql text = update t set name = null where id = 1;\n    if (!isArrayBinding) {\n      if (value !== null && !Util.isString(value)) {\n        if (value instanceof Date) {\n          value = value.toJSON();\n        } else {\n          value = JSON.stringify(value);\n        }\n      }\n    } else {\n      value = [];\n      for (let rowIndex = 0; rowIndex < bindsArray.length; rowIndex++) {\n        let value0 = bindsArray[rowIndex][index];\n        if (value0 !== null && !Util.isString(value0)) {\n          if (value0 instanceof Date) {\n            value0 = value0.toJSON();\n          } else {\n            value0 = JSON.stringify(value0);\n          }\n        }\n        value.push(value0);\n      }\n    }\n\n    // add an entry for the bind variable to the map\n    bindsMap[index + 1] =\n      {\n        type: type,\n        value: value\n      };\n  }\n\n  return bindsMap;\n}\n\n/**\n * Issues a request to get the result of a statement that has been previously\n * executed.\n *\n * @param statementContext\n * @param onResultAvailable\n */\nfunction sendRequestPostExec(statementContext, onResultAvailable) {\n  // get the request headers\n  const headers = statementContext.resultRequestHeaders;\n\n  // use the snowflake service to issue the request\n  sendSfRequest(statementContext,\n    {\n      method: 'GET',\n      headers: headers,\n      url: Url.format(\n        {\n          pathname: '/queries/' + statementContext.queryId + '/result',\n          search: QueryString.stringify(\n            {\n              disableOfflineChunks: false\n            })\n        }),\n      callback: buildResultRequestCallback(\n        statementContext, headers, onResultAvailable)\n    });\n}\n\n/**\n * Issues a statement-related request using the Snowflake service.\n *\n * @param {Object} statementContext the statement context.\n * @param {Object} options the request options.\n * @param {Boolean} [appendQueryParamOnRetry] whether retry=true should be\n *   appended to the url if the request is retried.\n */\nfunction sendSfRequest(statementContext, options, appendQueryParamOnRetry) {\n  const sf = statementContext.services.sf;\n  const connectionConfig = statementContext.connectionConfig;\n\n  // clone the options\n  options = Util.apply({}, options);\n\n  // get the original url and callback\n  const urlOrig = options.url;\n  const callbackOrig = options.callback;\n\n  let numRetries = 0;\n  const maxNumRetries = connectionConfig.getRetrySfMaxNumRetries();\n  let sleep = connectionConfig.getRetrySfStartingSleepTime();\n  let lastStatusCodeForRetry;\n\n  // create a function to send the request\n  const sendRequest = function () {\n    // if this is a retry and a query parameter should be appended to the url on\n    // retry, update the url\n    if ((numRetries > 0) && appendQueryParamOnRetry) {\n      const retryOption = {\n        url: urlOrig,\n        retryCount: numRetries,\n        retryReason: lastStatusCodeForRetry,\n        includeRetryReason: connectionConfig.getIncludeRetryReason(),\n      };\n      \n      options.url = Util.url.appendRetryParam(retryOption);\n    }\n\n    sf.request(options);\n  };\n\n  // replace the specified callback with a new one that retries\n  options.callback = async function (err) {\n    // if we haven't exceeded the maximum number of retries yet and the server\n    // came back with a retryable error code\n    if (numRetries < maxNumRetries &&\n      err && Util.isRetryableHttpError(\n      err.response, false // no retry for HTTP 403\n    )) {\n      // increment the retry count\n      numRetries++;\n      lastStatusCodeForRetry = err.response ? err.response.statusCode : 0;\n\n      // use exponential backoff with decorrelated jitter to compute the\n      // next sleep time.\n      const cap = connectionConfig.getRetrySfMaxSleepTime();\n      sleep = Util.nextSleepTime(1, cap, sleep);\n\n      Logger.getInstance().debug(\n        'Retrying statement with request id %s, retry count = %s',\n        statementContext.requestId, numRetries);\n\n      // wait the appropriate amount of time before retrying the request\n      setTimeout(sendRequest, sleep * 1000);\n    } else {\n      // invoke the original callback\n      await callbackOrig.apply(this, arguments);\n    }\n  };\n\n  // issue the request\n  sendRequest();\n}\n\n/**\n * Builds a callback for use in an exec-statement or fetch-result request.\n *\n * @param statementContext\n * @param headers\n * @param onResultAvailable\n *\n * @returns {Function}\n */\nfunction buildResultRequestCallback(\n  statementContext, headers, onResultAvailable) {\n  const callback = async function (err, body) {\n    if (err) {\n      await onResultAvailable.call(null, err, null);\n    } else {\n      // extract the query id from the response and save it\n      statementContext.queryId = body.data.queryId;\n\n      // if the result is not ready yet, extract the result url from the response\n      // and issue a GET request to try to fetch the result again unless asyncExec is enabled.\n      if (body && (body.code === queryCodes.QUERY_IN_PROGRESS\n        || body.code === queryCodes.QUERY_IN_PROGRESS_ASYNC)) {\n\n        if (statementContext.asyncExec) {\n          await onResultAvailable.call(null, err, body);\n          return;\n        }\n\n        // extract the result url from the response and try to get the result\n        // again\n        sendSfRequest(statementContext,\n          {\n            method: 'GET',\n            headers: headers,\n            url: body.data.getResultUrl,\n            callback: callback\n          });\n      } else {\n        await onResultAvailable.call(null, err, body);\n      }\n    }\n  };\n\n  return callback;\n}\n\n/**\n * Builds the request headers for a row statement request.\n *\n * @returns {Object}\n */\nfunction buildResultRequestHeadersRow() {\n  return {\n    'Accept': 'application/snowflake'\n  };\n}\n\n/**\n * Builds the request headers for a file statement request.\n *\n * @returns {Object}\n */\nfunction buildResultRequestHeadersFile() {\n  return {\n    'Accept': 'application/json'\n  };\n}\n\n/**\n * Count number of bindings\n * \n * @returns {int}\n */\nfunction countBinding(binds) {\n  if (!Util.isArray(binds)) {\n    return 0;\n  }\n  Logger.getInstance().debug('-- binds.length= %d', binds.length);\n  let count = 0;\n  for (let index = 0; index < binds.length; index++) {\n    if (binds[index] != null && Util.isArray(binds[index])) {\n      count += binds[index].length;\n    }\n  }\n  return count;\n}\n\nfunction hasNextResult(statement, context) {\n  return function () {\n    return (context.multiResultIds != null && context.multiCurId + 1 < context.multiResultIds.length);\n  };\n}\n\nfunction createNextReuslt(statement, context) {\n  return function () {\n    if (hasNextResult(statement, context)) {\n      context.multiCurId++;\n      context.queryId = context.multiResultIds[context.multiCurId];\n      exports.createStatementPostExec(context, context.services, context.connectionConfig);\n    }\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29ubmVjdGlvbi9zdGF0ZW1lbnQuanMiLCJtYXBwaW5ncyI6IkFBQUEsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyw4REFBTTs7QUFFckMsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLG9CQUFvQixtQkFBTyxDQUFDLGdDQUFhO0FBQ3pDLHFCQUFxQiwwREFBOEI7QUFDbkQsYUFBYSxtQkFBTyxDQUFDLCtEQUFTO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQywyRkFBaUI7QUFDeEMsbUJBQW1CLG1CQUFPLENBQUMsMkVBQWU7QUFDMUMsa0JBQWtCLG1CQUFPLENBQUMsbUdBQXFCO0FBQy9DLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVztBQUNsQztBQUNBLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVztBQUNsQyxvQkFBb0Isc0lBQTBDO0FBQzlELDBCQUEwQixtQkFBTyxDQUFDLHFJQUE0QztBQUM5RSxhQUFhLG1CQUFPLENBQUMsMkZBQWlCO0FBQ3RDLGdCQUFnQixtQkFBTyxDQUFDLDZGQUF5Qjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtDQUErQyxnQkFBZ0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDOztBQUVsQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkVBQTZFLDJCQUEyQjtBQUN4RywyREFBMkQ7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRCxnQkFBZ0I7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSx5REFBeUQ7QUFDekQ7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSw2QkFBNkIsOEJBQThCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isc0JBQXNCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9jb25uZWN0aW9uL3N0YXRlbWVudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IHY0OiB1dWlkdjQgfSA9IHJlcXVpcmUoJ3V1aWQnKTtcblxuY29uc3QgVXJsID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCBRdWVyeVN0cmluZyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgUmVzdWx0ID0gcmVxdWlyZSgnLi9yZXN1bHQvcmVzdWx0Jyk7XG5jb25zdCBQYXJhbWV0ZXJzID0gcmVxdWlyZSgnLi4vcGFyYW1ldGVycycpO1xuY29uc3QgUm93U3RyZWFtID0gcmVxdWlyZSgnLi9yZXN1bHQvcm93X3N0cmVhbScpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBFcnJvckNvZGVzID0gRXJyb3JzLmNvZGVzO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBOYXRpdmVUeXBlcyA9IHJlcXVpcmUoJy4vcmVzdWx0L2RhdGFfdHlwZXMnKS5OYXRpdmVUeXBlcztcbmNvbnN0IEZpbGVUcmFuc2ZlckFnZW50ID0gcmVxdWlyZSgnLi4vZmlsZV90cmFuc2Zlcl9hZ2VudC9maWxlX3RyYW5zZmVyX2FnZW50Jyk7XG5jb25zdCBCaW5kID0gcmVxdWlyZSgnLi9iaW5kX3VwbG9hZGVyJyk7XG5jb25zdCBSb3dNb2RlID0gcmVxdWlyZSgnLi8uLi9jb25zdGFudHMvcm93X21vZGUnKTtcblxuY29uc3Qgc3RhdGVzID1cbiAge1xuICAgIEZFVENISU5HOiAnZmV0Y2hpbmcnLFxuICAgIENPTVBMRVRFOiAnY29tcGxldGUnXG4gIH07XG5cbmNvbnN0IHN0YXRlbWVudFR5cGVzID1cbiAge1xuICAgIFJPV19QUkVfRVhFQzogJ1JPV19QUkVfRVhFQycsXG4gICAgUk9XX1BPU1RfRVhFQzogJ1JPV19QT1NUX0VYRUMnLFxuICAgIEZJTEVfUFJFX0VYRUM6ICdGSUxFX1BSRV9FWEVDJyxcbiAgICBGSUxFX1BPU1RfRVhFQzogJ0ZJTEVfUE9TVF9FWEVDJ1xuICB9O1xuXG5jb25zdCBxdWVyeUNvZGVzID0ge1xuICBRVUVSWV9JTl9QUk9HUkVTUzogJzMzMzMzMycsICAgICAgIC8vIEdTIGNvZGU6IHRoZSBxdWVyeSBpcyBpbiBwcm9ncmVzc1xuICBRVUVSWV9JTl9QUk9HUkVTU19BU1lOQzogJzMzMzMzNCcgIC8vIEdTIGNvZGU6IHRoZSBxdWVyeSBpcyBkZXRhY2hlZFxufTtcblxuZXhwb3J0cy5jcmVhdGVDb250ZXh0ID0gZnVuY3Rpb24gKFxuICBvcHRpb25zLCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZykge1xuICAvLyBjcmVhdGUgYSBzdGF0ZW1lbnQgY29udGV4dCBmb3IgYSBwcmUtZXhlYyBzdGF0ZW1lbnRcbiAgY29uc3QgY29udGV4dCA9IGNyZWF0ZUNvbnRleHRQcmVFeGVjKFxuICAgIG9wdGlvbnMsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcblxuICBjb250ZXh0LnR5cGUgPSBzdGF0ZW1lbnRUeXBlcy5GSUxFX1BSRV9FWEVDO1xuXG4gIGNyZWF0ZVN0YXRlbWVudChvcHRpb25zLCBjb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG5cbiAgLy8gYWRkIHRoZSByZXN1bHQgcmVxdWVzdCBoZWFkZXJzIHRvIHRoZSBjb250ZXh0XG4gIGNvbnRleHQucmVzdWx0UmVxdWVzdEhlYWRlcnMgPSBidWlsZFJlc3VsdFJlcXVlc3RIZWFkZXJzRmlsZSgpO1xuXG4gIHJldHVybiBjb250ZXh0O1xuXG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTdGF0ZW1lbnQoXG4gIHN0YXRlbWVudE9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gIC8vIGNhbGwgc3VwZXJcbiAgQmFzZVN0YXRlbWVudC5hcHBseSh0aGlzLCBbc3RhdGVtZW50T3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWddKTtcbn1cblxuLyoqXG4gKiBDaGVjayB0aGUgdHlwZSBvZiBjb21tYW5kIHRvIGV4ZWN1dGUuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXJ2aWNlc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5leHBvcnRzLmNyZWF0ZVN0YXRlbWVudFByZUV4ZWMgPSBmdW5jdGlvbiAoXG4gIG9wdGlvbnMsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCctLWNyZWF0ZVN0YXRlbWVudFByZUV4ZWMnKTtcbiAgLy8gY3JlYXRlIGEgc3RhdGVtZW50IGNvbnRleHQgZm9yIGEgcHJlLWV4ZWMgc3RhdGVtZW50XG4gIGNvbnN0IGNvbnRleHQgPSBjcmVhdGVDb250ZXh0UHJlRXhlYyhcbiAgICBvcHRpb25zLCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG5cbiAgaWYgKG9wdGlvbnMuc3FsVGV4dCAmJiAoVXRpbC5pc1B1dENvbW1hbmQob3B0aW9ucy5zcWxUZXh0KSB8fCBVdGlsLmlzR2V0Q29tbWFuZChvcHRpb25zLnNxbFRleHQpKSkge1xuICAgIGlmIChvcHRpb25zLmZpbGVTdHJlYW0pIHtcbiAgICAgIGNvbnRleHQuZmlsZVN0cmVhbSA9IG9wdGlvbnMuZmlsZVN0cmVhbTtcbiAgICAgIG9wdGlvbnMuZmlsZVN0cmVhbSA9IG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVGaWxlU3RhdGVtZW50UHJlRXhlYyhcbiAgICAgIG9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcbiAgfVxuXG4gIGNvbnN0IG51bUJpbmRzID0gY291bnRCaW5kaW5nKGNvbnRleHQuYmluZHMpO1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnbnVtQmluZHMgPSAlZCcsIG51bUJpbmRzKTtcbiAgbGV0IHRocmVzaG9sZCA9IFBhcmFtZXRlcnMuZ2V0VmFsdWUoUGFyYW1ldGVycy5uYW1lcy5DTElFTlRfU1RBR0VfQVJSQVlfQklORElOR19USFJFU0hPTEQpO1xuICBpZiAoY29ubmVjdGlvbkNvbmZpZy5nZXRiaW5kVGhyZXNob2xkKCkpIHtcbiAgICB0aHJlc2hvbGQgPSBjb25uZWN0aW9uQ29uZmlnLmdldGJpbmRUaHJlc2hvbGQoKTtcbiAgfVxuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygndGhyZXNob2xkID0gJWQnLCB0aHJlc2hvbGQpO1xuXG4gIC8vIGNoZWNrIGFycmF5IGJpbmRpbmcsXG4gIGlmIChudW1CaW5kcyA+IHRocmVzaG9sZCkge1xuICAgIHJldHVybiBjcmVhdGVTdGFnZVN0YXRlbWVudHByZUV4ZWMob3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBjcmVhdGVSb3dTdGF0ZW1lbnRQcmVFeGVjKFxuICAgICAgb3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpO1xuICB9XG59O1xuXG4vKipcbiAqIEV4ZWN1dGVzIGEgc3RhdGVtZW50IGFuZCByZXR1cm5zIGEgc3RhdGVtZW50IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGZldGNoXG4gKiBpdHMgcmVzdWx0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50Q29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHNlcnZpY2VzXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVJvd1N0YXRlbWVudFByZUV4ZWMoXG4gIHN0YXRlbWVudE9wdGlvbnMsIHN0YXRlbWVudENvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gIC8vIHNldCB0aGUgc3RhdGVtZW50IHR5cGVcbiAgc3RhdGVtZW50Q29udGV4dC50eXBlID0gc3RhdGVtZW50VHlwZXMuUk9XX1BSRV9FWEVDO1xuXG4gIHJldHVybiBuZXcgUm93U3RhdGVtZW50UHJlRXhlYyhcbiAgICBzdGF0ZW1lbnRPcHRpb25zLCBzdGF0ZW1lbnRDb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YXRlbWVudCBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBmZXRjaCB0aGUgcmVzdWx0IG9mIGFcbiAqIHByZXZpb3VzbHkgZXhlY3V0ZWQgc3RhdGVtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gc2VydmljZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZXhwb3J0cy5jcmVhdGVTdGF0ZW1lbnRQb3N0RXhlYyA9IGZ1bmN0aW9uIChcbiAgc3RhdGVtZW50T3B0aW9ucywgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgLy8gY2hlY2sgZm9yIG1pc3Npbmcgb3B0aW9uc1xuICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zKSxcbiAgICBFcnJvckNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9NSVNTSU5HX09QVElPTlMpO1xuXG4gIC8vIGNoZWNrIGZvciBpbnZhbGlkIG9wdGlvbnNcbiAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzT2JqZWN0KHN0YXRlbWVudE9wdGlvbnMpLFxuICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfT1BUSU9OUyk7XG5cbiAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgcXVlcnkgaWRcbiAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5xdWVyeUlkKSxcbiAgICBFcnJvckNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9NSVNTSU5HX1FVRVJZX0lEKTtcblxuICAvLyBjaGVjayBmb3IgaW52YWxpZCBxdWVyeSBpZFxuICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcoc3RhdGVtZW50T3B0aW9ucy5xdWVyeUlkKSxcbiAgICBFcnJvckNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX1FVRVJZX0lEKTtcblxuICAvLyBjaGVjayBmb3IgaW52YWxpZCBjb21wbGV0ZSBjYWxsYmFja1xuICBjb25zdCBjb21wbGV0ZSA9IHN0YXRlbWVudE9wdGlvbnMuY29tcGxldGU7XG4gIGlmIChVdGlsLmV4aXN0cyhjb21wbGV0ZSkpIHtcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNGdW5jdGlvbihjb21wbGV0ZSksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX0NPTVBMRVRFKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBpbnZhbGlkIHN0cmVhbVJlc3VsdFxuICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5zdHJlYW1SZXN1bHQpKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihzdGF0ZW1lbnRPcHRpb25zLnN0cmVhbVJlc3VsdCksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX1NUUkVBTV9SRVNVTFQpO1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIGludmFsaWQgZmV0Y2hBc1N0cmluZ1xuICBjb25zdCBmZXRjaEFzU3RyaW5nID0gc3RhdGVtZW50T3B0aW9ucy5mZXRjaEFzU3RyaW5nO1xuICBpZiAoVXRpbC5leGlzdHMoZmV0Y2hBc1N0cmluZykpIHtcbiAgICAvLyBjaGVjayB0aGF0IHRoZSB2YWx1ZSBpcyBhbiBhcnJheVxuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0FycmF5KGZldGNoQXNTdHJpbmcpLFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkcpO1xuXG4gICAgLy8gY2hlY2sgdGhhdCBhbGwgdGhlIGFycmF5IGVsZW1lbnRzIGFyZSB2YWxpZFxuICAgIGNvbnN0IGludmFsaWRWYWx1ZUluZGV4ID0gTmF0aXZlVHlwZXMuZmluZEludmFsaWRWYWx1ZShmZXRjaEFzU3RyaW5nKTtcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKGludmFsaWRWYWx1ZUluZGV4ID09PSAtMSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HX1ZBTFVFUyxcbiAgICAgIEpTT04uc3RyaW5naWZ5KGZldGNoQXNTdHJpbmdbaW52YWxpZFZhbHVlSW5kZXhdKSk7XG4gIH1cblxuICBjb25zdCByb3dNb2RlID0gc3RhdGVtZW50T3B0aW9ucy5yb3dNb2RlO1xuICBpZiAoVXRpbC5leGlzdHMocm93TW9kZSkpIHtcbiAgICBSb3dNb2RlLmNoZWNrUm93TW9kZVZhbGlkKHJvd01vZGUpO1xuICB9XG4gIGNvbnN0IGN3ZCA9IHN0YXRlbWVudE9wdGlvbnMuY3dkO1xuICBpZiAoVXRpbC5leGlzdHMoY3dkKSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhjd2QpLCBFcnJvckNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX0NXRCk7XG4gIH1cblxuICAvLyB2YWxpZGF0ZSBub24tdXNlci1zcGVjaWZpZWQgYXJndW1lbnRzXG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KHNlcnZpY2VzKSk7XG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGNvbm5lY3Rpb25Db25maWcpKTtcblxuICAvLyBjcmVhdGUgYSBzdGF0ZW1lbnQgY29udGV4dFxuICBjb25zdCBzdGF0ZW1lbnRDb250ZXh0ID0gY3JlYXRlU3RhdGVtZW50Q29udGV4dCgpO1xuXG4gIHN0YXRlbWVudENvbnRleHQucXVlcnlJZCA9IHN0YXRlbWVudE9wdGlvbnMucXVlcnlJZDtcbiAgc3RhdGVtZW50Q29udGV4dC5jb21wbGV0ZSA9IGNvbXBsZXRlO1xuICBzdGF0ZW1lbnRDb250ZXh0LnN0cmVhbVJlc3VsdCA9IHN0YXRlbWVudE9wdGlvbnMuc3RyZWFtUmVzdWx0O1xuICBzdGF0ZW1lbnRDb250ZXh0LmZldGNoQXNTdHJpbmcgPSBzdGF0ZW1lbnRPcHRpb25zLmZldGNoQXNTdHJpbmc7XG4gIHN0YXRlbWVudENvbnRleHQubXVsdGlSZXN1bHRJZHMgPSBzdGF0ZW1lbnRPcHRpb25zLm11bHRpUmVzdWx0SWRzO1xuICBzdGF0ZW1lbnRDb250ZXh0Lm11bHRpQ3VySWQgPSBzdGF0ZW1lbnRPcHRpb25zLm11bHRpQ3VySWQ7XG4gIHN0YXRlbWVudENvbnRleHQucm93TW9kZSA9IHN0YXRlbWVudE9wdGlvbnMucm93TW9kZTtcbiAgc3RhdGVtZW50Q29udGV4dC5jd2QgPSBzdGF0ZW1lbnRPcHRpb25zLmN3ZDtcblxuICAvLyBzZXQgdGhlIHN0YXRlbWVudCB0eXBlXG4gIHN0YXRlbWVudENvbnRleHQudHlwZSA9IChzdGF0ZW1lbnRDb250ZXh0LnR5cGUgPT09IHN0YXRlbWVudFR5cGVzLlJPV19QUkVfRVhFQykgPyBzdGF0ZW1lbnRUeXBlcy5ST1dfUE9TVF9FWEVDIDogc3RhdGVtZW50VHlwZXMuRklMRV9QT1NUX0VYRUM7XG5cbiAgcmV0dXJuIG5ldyBTdGF0ZW1lbnRQb3N0RXhlYyhcbiAgICBzdGF0ZW1lbnRPcHRpb25zLCBzdGF0ZW1lbnRDb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgc3RhdGVtZW50IGNvbnRleHQgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0YXRlbWVudENvbnRleHQoKSB7XG4gIHJldHVybiBuZXcgRXZlbnRFbWl0dGVyKCk7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIHN0YXRlbWVudCBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBleGVjdXRlIGEgUFVUIG9yIEdFVCBmaWxlXG4gKiBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudE9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRDb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc2VydmljZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRmlsZVN0YXRlbWVudFByZUV4ZWMoXG4gIHN0YXRlbWVudE9wdGlvbnMsIHN0YXRlbWVudENvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gIC8vIHNldCB0aGUgc3RhdGVtZW50IHR5cGVcbiAgc3RhdGVtZW50Q29udGV4dC50eXBlID0gc3RhdGVtZW50VHlwZXMuRklMRV9QUkVfRVhFQztcblxuICByZXR1cm4gbmV3IEZpbGVTdGF0ZW1lbnRQcmVFeGVjKFxuICAgIHN0YXRlbWVudE9wdGlvbnMsIHN0YXRlbWVudENvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhdGVtZW50IG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIHRvIGV4ZWN1dGUgc3RhZ2UgYmluZGluZ1xuICogb3BlcmF0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50Q29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHNlcnZpY2VzXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVN0YWdlU3RhdGVtZW50cHJlRXhlYyhcbiAgc3RhdGVtZW50T3B0aW9ucywgc3RhdGVtZW50Q29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgcmV0dXJuIG5ldyBTdGFnZUJpbmRpbmdTdGF0ZW1lbnRQcmVFeGVjKHN0YXRlbWVudE9wdGlvbnMsIHN0YXRlbWVudENvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RhdGVtZW50IGNvbnRleHQgb2JqZWN0IGZvciBwcmUtZXhlYyBzdGF0ZW1lbnQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudE9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXJ2aWNlc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBjcmVhdGVDb250ZXh0UHJlRXhlYyhcbiAgc3RhdGVtZW50T3B0aW9ucywgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgLy8gY2hlY2sgZm9yIG1pc3Npbmcgb3B0aW9uc1xuICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zKSxcbiAgICBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9NSVNTSU5HX09QVElPTlMpO1xuXG4gIC8vIGNoZWNrIGZvciBpbnZhbGlkIG9wdGlvbnNcbiAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzT2JqZWN0KHN0YXRlbWVudE9wdGlvbnMpLFxuICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfT1BUSU9OUyk7XG5cbiAgaWYgKCFVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLnJlcXVlc3RJZCkpIHtcbiAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBzcWwgdGV4dFxuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKHN0YXRlbWVudE9wdGlvbnMuc3FsVGV4dCksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9NSVNTSU5HX1NRTF9URVhUKTtcblxuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHNxbCB0ZXh0XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHN0YXRlbWVudE9wdGlvbnMuc3FsVGV4dCksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX1NRTF9URVhUKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBpbnZhbGlkIGNvbXBsZXRlIGNhbGxiYWNrXG4gIGNvbnN0IGNvbXBsZXRlID0gc3RhdGVtZW50T3B0aW9ucy5jb21wbGV0ZTtcbiAgaWYgKFV0aWwuZXhpc3RzKGNvbXBsZXRlKSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Z1bmN0aW9uKGNvbXBsZXRlKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfQ09NUExFVEUpO1xuICB9XG5cbiAgLy8gY2hlY2sgZm9yIGludmFsaWQgc3RyZWFtUmVzdWx0XG4gIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLnN0cmVhbVJlc3VsdCkpIHtcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKHN0YXRlbWVudE9wdGlvbnMuc3RyZWFtUmVzdWx0KSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfU1RSRUFNX1JFU1VMVCk7XG4gIH1cblxuICAvLyBjaGVjayBmb3IgaW52YWxpZCBmZXRjaEFzU3RyaW5nXG4gIGNvbnN0IGZldGNoQXNTdHJpbmcgPSBzdGF0ZW1lbnRPcHRpb25zLmZldGNoQXNTdHJpbmc7XG4gIGlmIChVdGlsLmV4aXN0cyhmZXRjaEFzU3RyaW5nKSkge1xuICAgIC8vIGNoZWNrIHRoYXQgdGhlIHZhbHVlIGlzIGFuIGFycmF5XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQXJyYXkoZmV0Y2hBc1N0cmluZyksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0ZFVENIX0FTX1NUUklORyk7XG5cbiAgICAvLyBjaGVjayB0aGF0IGFsbCB0aGUgYXJyYXkgZWxlbWVudHMgYXJlIHZhbGlkXG4gICAgY29uc3QgaW52YWxpZFZhbHVlSW5kZXggPSBOYXRpdmVUeXBlcy5maW5kSW52YWxpZFZhbHVlKGZldGNoQXNTdHJpbmcpO1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoaW52YWxpZFZhbHVlSW5kZXggPT09IC0xLFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkdfVkFMVUVTLFxuICAgICAgSlNPTi5zdHJpbmdpZnkoZmV0Y2hBc1N0cmluZ1tpbnZhbGlkVmFsdWVJbmRleF0pKTtcbiAgfVxuXG4gIC8vIGNoZWNrIGZvciBpbnZhbGlkIHJlcXVlc3RJZFxuICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5yZXF1ZXN0SWQpKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHN0YXRlbWVudE9wdGlvbnMucmVxdWVzdElkKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfUkVRVUVTVF9JRCk7XG4gIH1cblxuICAvLyBpZiBwYXJhbWV0ZXJzIGFyZSBzcGVjaWZpZWQsIG1ha2Ugc3VyZSB0aGUgc3BlY2lmaWVkIHZhbHVlIGlzIGFuIG9iamVjdFxuICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5wYXJhbWV0ZXJzKSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc09iamVjdChzdGF0ZW1lbnRPcHRpb25zLnBhcmFtZXRlcnMpLFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9QQVJBTUVURVJTKTtcbiAgfVxuXG4gIC8vIGlmIGJpbmRzIGFyZSBzcGVjaWZpZWRcbiAgY29uc3QgYmluZHMgPSBzdGF0ZW1lbnRPcHRpb25zLmJpbmRzO1xuICBpZiAoVXRpbC5leGlzdHMoYmluZHMpKSB7XG4gICAgLy8gbWFrZSBzdXJlIHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYW4gYXJyYXlcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNBcnJheShiaW5kcyksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0JJTkRTKTtcblxuICAgIC8vIG1ha2Ugc3VyZSBldmVyeXRoaW5nIGluIHRoZSBiaW5kcyBhcnJheSBpcyBzdHJpbmdpZmlhYmxlXG4gICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBiaW5kcy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKEpTT04uc3RyaW5naWZ5KGJpbmRzW2luZGV4XSkgIT09IHVuZGVmaW5lZCxcbiAgICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9CSU5EX1ZBTFVFUywgYmluZHNbaW5kZXhdKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiBhbiBpbnRlcm5hbCBvcHRpb24gaXMgc3BlY2lmaWVkLCBtYWtlIHN1cmUgaXQncyBib29sZWFuXG4gIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLmludGVybmFsKSkge1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4oc3RhdGVtZW50T3B0aW9ucy5pbnRlcm5hbCksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0lOVEVSTkFMKTtcbiAgfVxuICBjb25zdCByb3dNb2RlID0gc3RhdGVtZW50T3B0aW9ucy5yb3dNb2RlO1xuICBpZiAoVXRpbC5leGlzdHMocm93TW9kZSkpIHtcbiAgICBSb3dNb2RlLmNoZWNrUm93TW9kZVZhbGlkKHJvd01vZGUpO1xuICB9XG5cbiAgLy8gaWYgYW4gYXN5bmNFeGVjIGZsYWcgaXMgc3BlY2lmaWVkLCBtYWtlIHN1cmUgaXQncyBib29sZWFuXG4gIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLmFzeW5jRXhlYykpIHtcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNCb29sZWFuKHN0YXRlbWVudE9wdGlvbnMuYXN5bmNFeGVjKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfQVNZTkNfRVhFQyk7XG4gIH1cblxuICAvLyBpZiBhIGRlc2NyaWJlT25seSBmbGFnIGlzIHNwZWNpZmllZCwgbWFrZSBzdXJlIGl0J3MgYm9vbGVhblxuICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5kZXNjcmliZU9ubHkpKSB7XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihzdGF0ZW1lbnRPcHRpb25zLmRlc2NyaWJlT25seSksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0RFU0NSSUJFX09OTFkpO1xuICB9XG5cbiAgLy8gY3JlYXRlIGEgc3RhdGVtZW50IGNvbnRleHRcbiAgY29uc3Qgc3RhdGVtZW50Q29udGV4dCA9IGNyZWF0ZVN0YXRlbWVudENvbnRleHQoKTtcblxuICBzdGF0ZW1lbnRDb250ZXh0LnNxbFRleHQgPSBzdGF0ZW1lbnRPcHRpb25zLnNxbFRleHQ7XG4gIHN0YXRlbWVudENvbnRleHQuY29tcGxldGUgPSBjb21wbGV0ZTtcbiAgc3RhdGVtZW50Q29udGV4dC5zdHJlYW1SZXN1bHQgPSBzdGF0ZW1lbnRPcHRpb25zLnN0cmVhbVJlc3VsdDtcbiAgc3RhdGVtZW50Q29udGV4dC5mZXRjaEFzU3RyaW5nID0gc3RhdGVtZW50T3B0aW9ucy5mZXRjaEFzU3RyaW5nO1xuICBzdGF0ZW1lbnRDb250ZXh0Lm11bHRpUmVzdWx0SWRzID0gc3RhdGVtZW50T3B0aW9ucy5tdWx0aVJlc3VsdElkcztcbiAgc3RhdGVtZW50Q29udGV4dC5tdWx0aUN1cklkID0gc3RhdGVtZW50T3B0aW9ucy5tdWx0aUN1cklkO1xuICBzdGF0ZW1lbnRDb250ZXh0LnJvd01vZGUgPSBzdGF0ZW1lbnRPcHRpb25zLnJvd01vZGU7XG4gIHN0YXRlbWVudENvbnRleHQuYXN5bmNFeGVjID0gc3RhdGVtZW50T3B0aW9ucy5hc3luY0V4ZWM7XG5cbiAgLy8gaWYgYSBiaW5kcyBhcnJheSBpcyBzcGVjaWZpZWQsIGFkZCBpdCB0byB0aGUgc3RhdGVtZW50IGNvbnRleHRcbiAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudE9wdGlvbnMuYmluZHMpKSB7XG4gICAgc3RhdGVtZW50Q29udGV4dC5iaW5kcyA9IHN0YXRlbWVudE9wdGlvbnMuYmluZHM7XG4gIH1cblxuICAvLyBpZiBwYXJhbWV0ZXJzIGFyZSBzcGVjaWZpZWQsIGFkZCB0aGVtIHRvIHRoZSBzdGF0ZW1lbnQgY29udGV4dFxuICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5wYXJhbWV0ZXJzKSkge1xuICAgIHN0YXRlbWVudENvbnRleHQucGFyYW1ldGVycyA9IHN0YXRlbWVudE9wdGlvbnMucGFyYW1ldGVycztcbiAgfVxuXG4gIC8vIGlmIHRoZSBpbnRlcm5hbCBmbGFnIGlzIHNwZWNpZmllZCwgYWRkIGl0IHRvIHRoZSBzdGF0ZW1lbnQgY29udGV4dFxuICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5pbnRlcm5hbCkpIHtcbiAgICBzdGF0ZW1lbnRDb250ZXh0LmludGVybmFsID0gc3RhdGVtZW50T3B0aW9ucy5pbnRlcm5hbDtcbiAgfVxuXG4gIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRPcHRpb25zLmN3ZCkpIHtcbiAgICBzdGF0ZW1lbnRDb250ZXh0LmN3ZCA9IHN0YXRlbWVudE9wdGlvbnMuY3dkO1xuICB9XG5cbiAgLy8gaWYgdGhlIGRlc2NyaWJlT25seSBmbGFnIGlzIHNwZWNpZmllZCwgYWRkIGl0IHRvIHRoZSBzdGF0ZW1lbnQgY29udGV4dFxuICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50T3B0aW9ucy5kZXNjcmliZU9ubHkpKSB7XG4gICAgc3RhdGVtZW50Q29udGV4dC5kZXNjcmliZU9ubHkgPSBzdGF0ZW1lbnRPcHRpb25zLmRlc2NyaWJlT25seTtcbiAgfVxuXG4gIC8vIHZhbGlkYXRlIG5vbi11c2VyLXNwZWNpZmllZCBhcmd1bWVudHNcbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qoc2VydmljZXMpKTtcbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3QoY29ubmVjdGlvbkNvbmZpZykpO1xuXG4gIC8vIHVzZSByZXF1ZXN0IGlkIHBhc3NlZCBieSB1c2VyXG4gIGlmIChzdGF0ZW1lbnRPcHRpb25zLnJlcXVlc3RJZCkge1xuICAgIHN0YXRlbWVudENvbnRleHQucmVxdWVzdElkID0gc3RhdGVtZW50T3B0aW9ucy5yZXF1ZXN0SWQ7XG4gICAgc3RhdGVtZW50Q29udGV4dC5yZXN1Ym1pdFJlcXVlc3QgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIC8vIHVzZSBhIHJhbmRvbSB1dWlkIGZvciB0aGUgc3RhdGVtZW50IHJlcXVlc3QgaWRcbiAgICBzdGF0ZW1lbnRDb250ZXh0LnJlcXVlc3RJZCA9IHV1aWR2NCgpO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlbWVudENvbnRleHQ7XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBCYXNlU3RhdGVtZW50LlxuICpcbiAqIEBwYXJhbSBzdGF0ZW1lbnRPcHRpb25zXG4gKiBAcGFyYW0gY29udGV4dFxuICogQHBhcmFtIHNlcnZpY2VzXG4gKiBAcGFyYW0gY29ubmVjdGlvbkNvbmZpZ1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEJhc2VTdGF0ZW1lbnQoXG4gIHN0YXRlbWVudE9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gIC8vIGNhbGwgc3VwZXJcbiAgRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG5cbiAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qoc3RhdGVtZW50T3B0aW9ucykpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjb250ZXh0KSk7XG5cbiAgY29udGV4dC5zZXJ2aWNlcyA9IHNlcnZpY2VzO1xuICBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcgPSBjb25uZWN0aW9uQ29uZmlnO1xuICBjb250ZXh0LmlzRmV0Y2hpbmdSZXN1bHQgPSB0cnVlO1xuICBjb250ZXh0LnJvd01vZGUgPSBzdGF0ZW1lbnRPcHRpb25zLnJvd01vZGUgfHwgY29ubmVjdGlvbkNvbmZpZy5nZXRSb3dNb2RlKCk7XG5cbiAgLy8gVE9ETzogYWRkIHRoZSBwYXJhbWV0ZXJzIG1hcCB0byB0aGUgc3RhdGVtZW50IGNvbnRleHRcblxuICBjb25zdCBzdGF0ZW1lbnQgPSB0aGlzO1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMgc3RhdGVtZW50J3MgU1FMIHRleHQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICB0aGlzLmdldFNxbFRleHQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnRleHQuc3FsVGV4dDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBzdGF0dXMgb2YgdGhpcyBzdGF0ZW1lbnQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAqL1xuICB0aGlzLmdldFN0YXR1cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29udGV4dC5pc0ZldGNoaW5nUmVzdWx0ID8gc3RhdGVzLkZFVENISU5HIDogc3RhdGVzLkNPTVBMRVRFO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBjb2x1bW5zIHByb2R1Y2VkIGJ5IHRoaXMgc3RhdGVtZW50LlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0W119XG4gICAqL1xuICB0aGlzLmdldENvbHVtbnMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnRleHQucmVzdWx0ID8gY29udGV4dC5yZXN1bHQuZ2V0Q29sdW1ucygpIDogdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHaXZlbiBhIGNvbHVtbiBpZGVudGlmaWVyLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGNvbHVtbi4gVGhlIGNvbHVtblxuICAgKiBpZGVudGlmaWVyIGNhbiBiZSBlaXRoZXIgdGhlIGNvbHVtbiBuYW1lIChTdHJpbmcpIG9yIHRoZSBjb2x1bW4gaW5kZXhcbiAgICogKE51bWJlcikuIElmIGEgY29sdW1uIGlzIHNwZWNpZmllZCBhbmQgdGhlcmUgaXMgbW9yZSB0aGFuIG9uZSBjb2x1bW4gd2l0aFxuICAgKiB0aGF0IG5hbWUsIHRoZSBmaXJzdCBjb2x1bW4gd2l0aCB0aGUgc3BlY2lmaWVkIG5hbWUgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmcgfCBOdW1iZXJ9IGNvbHVtbklkZW50aWZpZXJcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHRoaXMuZ2V0Q29sdW1uID0gZnVuY3Rpb24gKGNvbHVtbklkZW50aWZpZXIpIHtcbiAgICByZXR1cm4gY29udGV4dC5yZXN1bHQgPyBjb250ZXh0LnJlc3VsdC5nZXRDb2x1bW4oY29sdW1uSWRlbnRpZmllcikgOlxuICAgICAgdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBudW1iZXIgb2Ygcm93cyByZXR1cm5lZCBieSB0aGlzIHN0YXRlbWVudC5cbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIHRoaXMuZ2V0TnVtUm93cyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29udGV4dC5yZXN1bHQgPyBjb250ZXh0LnJlc3VsdC5nZXRSZXR1cm5lZFJvd3MoKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHJvd3MgdXBkYXRlZCBieSB0aGlzIHN0YXRlbWVudC5cbiAgICpcbiAgICogQHJldHVybnMge051bWJlcn1cbiAgICovXG4gIHRoaXMuZ2V0TnVtVXBkYXRlZFJvd3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnRleHQucmVzdWx0ID8gY29udGV4dC5yZXN1bHQuZ2V0TnVtVXBkYXRlZFJvd3MoKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgdmFsdWVzIG9mIHRoZVxuICAgKiBjdXJyZW50IHdhcmVob3VzZSwgY3VycmVudCBkYXRhYmFzZSwgZXRjLiwgd2hlbiB0aGlzIHN0YXRlbWVudCBmaW5pc2hlZFxuICAgKiBleGVjdXRpbmcuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmdldFNlc3Npb25TdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29udGV4dC5yZXN1bHQgPyBjb250ZXh0LnJlc3VsdC5nZXRTZXNzaW9uU3RhdGUoKSA6IHVuZGVmaW5lZDtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgcmVxdWVzdCBpZCB0aGF0IHdhcyB1c2VkIHdoZW4gdGhlIHN0YXRlbWVudCB3YXMgaXNzdWVkLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy5nZXRSZXF1ZXN0SWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbnRleHQucmVxdWVzdElkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBxdWVyeSBpZCBnZW5lcmF0ZWQgYnkgdGhlIHNlcnZlciBmb3IgdGhpcyBzdGF0ZW1lbnQuXG4gICAqIElmIHRoZSBzdGF0ZW1lbnQgaXMgc3RpbGwgZXhlY3V0aW5nIGFuZCB3ZSBkb24ndCBrbm93IHRoZSBxdWVyeSBpZFxuICAgKiB5ZXQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICpcbiAgICogU2hvdWxkIHVzZSBnZXRRdWVyeUlkIGluc3RlYWQuXG4gICAqIEBkZXByZWNhdGVkIFxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy5nZXRTdGF0ZW1lbnRJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29udGV4dC5xdWVyeUlkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBxdWVyeSBpZCBnZW5lcmF0ZWQgYnkgdGhlIHNlcnZlciBmb3IgdGhpcyBzdGF0ZW1lbnQuXG4gICAqIElmIHRoZSBzdGF0ZW1lbnQgaXMgc3RpbGwgZXhlY3V0aW5nIGFuZCB3ZSBkb24ndCBrbm93IHRoZSBxdWVyeSBpZFxuICAgKiB5ZXQsIHRoaXMgbWV0aG9kIHdpbGwgcmV0dXJuIHVuZGVmaW5lZC5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRoaXMuZ2V0UXVlcnlJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29udGV4dC5xdWVyeUlkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYW5jZWxzIHRoaXMgc3RhdGVtZW50IGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdXG4gICAqL1xuICB0aGlzLmNhbmNlbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIHNlbmRDYW5jZWxTdGF0ZW1lbnQoY29udGV4dCwgc3RhdGVtZW50LCBjYWxsYmFjayk7XG4gIH07XG5cbiAgLy9JbnRlZ3JhdGlvbiBUZXN0aW5nIHB1cnBvc2UuXG4gIHRoaXMuZ2V0UXVlcnlDb250ZXh0Q2FjaGVTaXplID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBzZXJ2aWNlcy5zZi5nZXRRdWVyeUNvbnRleHRDYWNoZVNpemUoKTtcbiAgfTtcblxuICB0aGlzLmdldFF1ZXJ5Q29udGV4dERUT1NpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNlcnZpY2VzLnNmLmdldFF1ZXJ5Q29udGV4dERUTygpLmVudHJpZXMubGVuZ3RoO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJc3N1ZXMgYSByZXF1ZXN0IHRvIGdldCB0aGUgc3RhdGVtZW50IHJlc3VsdCBhZ2Fpbi5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICovXG4gIGNvbnRleHQucmVmcmVzaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIC8vIHBpY2sgdGhlIGFwcHJvcHJpYXRlIGZ1bmN0aW9uIHRvIGdldCB0aGUgcmVzdWx0IGJhc2VkIG9uIHdoZXRoZXIgd2VcbiAgICAvLyBoYXZlIHRoZSBxdWVyeSBpZCBvciByZXF1ZXN0IGlkICh3ZSBzaG91bGQgaGF2ZSBhdCBsZWFzdCBvbmUpXG4gICAgY29uc3Qgc2VuZFJlcXVlc3RGbiA9IGNvbnRleHQucXVlcnlJZCA/XG4gICAgICBzZW5kUmVxdWVzdFBvc3RFeGVjIDogc2VuZFJlcXVlc3RQcmVFeGVjO1xuXG4gICAgLy8gdGhlIGN1cnJlbnQgcmVzdWx0IGVycm9yIG1pZ2h0IGJlIHRyYW5zaWVudCxcbiAgICAvLyBzbyBpc3N1ZSBhIHJlcXVlc3QgdG8gZ2V0IHRoZSByZXN1bHQgYWdhaW5cbiAgICBzZW5kUmVxdWVzdEZuKGNvbnRleHQsIGZ1bmN0aW9uIChlcnIsIGJvZHkpIHtcbiAgICAgIC8vIHJlZnJlc2ggdGhlIHJlc3VsdFxuICAgICAgY29udGV4dC5vblN0YXRlbWVudFJlcXVlc3RDb21wKGVyciwgYm9keSk7XG5cbiAgICAgIC8vIGlmIGEgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgaW52b2tlIGl0XG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICBjYWxsYmFjayhjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXRlbWVudCByZXF1ZXN0IGlzIGNvbXBsZXRlLlxuICAgKlxuICAgKiBAcGFyYW0gZXJyXG4gICAqIEBwYXJhbSBib2R5XG4gICAqL1xuICBjb250ZXh0Lm9uU3RhdGVtZW50UmVxdWVzdENvbXAgPSBhc3luYyBmdW5jdGlvbiAoZXJyLCBib2R5KSB7XG4gICAgLy8gaWYgd2UgYWxyZWFkeSBoYXZlIGEgcmVzdWx0IG9yIGEgcmVzdWx0IGVycm9yLCB3ZSBpbnZva2VkIHRoZSBjb21wbGV0ZVxuICAgIC8vIGNhbGxiYWNrIG9uY2UsIHNvIGRvbid0IGludm9rZSBpdCBhZ2FpblxuICAgIGNvbnN0IHN1cHByZXNzQ29tcGxldGUgPSBjb250ZXh0LnJlc3VsdCB8fCBjb250ZXh0LnJlc3VsdEVycm9yO1xuXG4gICAgLy8gY2xlYXIgdGhlIHByZXZpb3VzIHJlc3VsdCBlcnJvclxuICAgIGNvbnRleHQucmVzdWx0RXJyb3IgPSBudWxsO1xuXG4gICAgLy8gaWYgdGhlcmUgd2FzIG5vIGVycm9yLCBjYWxsIHRoZSBzdWNjZXNzIGZ1bmN0aW9uXG4gICAgaWYgKCFlcnIpIHtcbiAgICAgIGF3YWl0IGNvbnRleHQub25TdGF0ZW1lbnRSZXF1ZXN0U3VjYyhib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gc2F2ZSB0aGUgZXJyb3JcbiAgICAgIGNvbnRleHQucmVzdWx0RXJyb3IgPSBlcnI7XG5cbiAgICAgIC8vIGlmIHdlIGRvbid0IGhhdmUgYSBxdWVyeSBpZCBhbmQgd2UgZ290IGEgcmVzcG9uc2UgZnJvbSBHUywgZXh0cmFjdFxuICAgICAgLy8gdGhlIHF1ZXJ5IGlkIGZyb20gdGhlIGRhdGFcbiAgICAgIGlmICghY29udGV4dC5xdWVyeUlkICYmXG4gICAgICAgIEVycm9ycy5pc09wZXJhdGlvbkZhaWxlZEVycm9yKGVycikgJiYgZXJyLmRhdGEpIHtcbiAgICAgICAgY29udGV4dC5xdWVyeUlkID0gZXJyLmRhdGEucXVlcnlJZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSdyZSBubyBsb25nZXIgZmV0Y2hpbmcgdGhlIHJlc3VsdFxuICAgIGNvbnRleHQuaXNGZXRjaGluZ1Jlc3VsdCA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdXBwcmVzc0NvbXBsZXRlKSB7XG4gICAgICAvLyBlbWl0IGEgY29tcGxldGUgZXZlbnRcbiAgICAgIGNvbnRleHQuZW1pdCgnc3RhdGVtZW50LWNvbXBsZXRlJywgRXJyb3JzLmV4dGVybmFsaXplKGVyciksIHN0YXRlbWVudCk7XG5cbiAgICAgIC8vIGlmIGEgY29tcGxldGUgZnVuY3Rpb24gd2FzIHNwZWNpZmllZCwgaW52b2tlIGl0XG4gICAgICBpZiAoVXRpbC5leGlzdHMoY29udGV4dC5jb21wbGV0ZSkpIHtcbiAgICAgICAgaW52b2tlU3RhdGVtZW50Q29tcGxldGUoc3RhdGVtZW50LCBjb250ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ3JlZnJlc2hlZCByZXN1bHQgb2Ygc3RhdGVtZW50IHdpdGggJXMnLFxuICAgICAgICBjb250ZXh0LnJlcXVlc3RJZCA/XG4gICAgICAgICAgVXRpbC5mb3JtYXQoJ3JlcXVlc3QgaWQgPSAlcycsIGNvbnRleHQucmVxdWVzdElkKSA6XG4gICAgICAgICAgVXRpbC5mb3JtYXQoJ3F1ZXJ5IGlkID0gJXMnLCBjb250ZXh0LnF1ZXJ5SWQpKTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSBzdGF0ZW1lbnQgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLiBTdWJjbGFzc2VzIG11c3QgcHJvdmlkZVxuICAgKiB0aGVpciBvd24gaW1wbGVtZW50YXRpb24uXG4gICAqL1xuICBjb250ZXh0Lm9uU3RhdGVtZW50UmVxdWVzdFN1Y2MgPSBmdW5jdGlvbiAoKSB7XG4gIH07XG59XG5cblV0aWwuaW5oZXJpdHMoQmFzZVN0YXRlbWVudCwgRXZlbnRFbWl0dGVyKTtcblxuLyoqXG4gKiBJbnZva2VzIHRoZSBzdGF0ZW1lbnQgY29tcGxldGUgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gaW52b2tlU3RhdGVtZW50Q29tcGxldGUoc3RhdGVtZW50LCBjb250ZXh0KSB7XG4gIC8vIGZpbmQgb3V0IGlmIHRoZSByZXN1bHQgd2lsbCBiZSBzdHJlYW1lZDtcbiAgLy8gaWYgYSB2YWx1ZSBpcyBub3Qgc3BlY2lmaWVkLCBnZXQgaXQgZnJvbSB0aGUgY29ubmVjdGlvblxuICBsZXQgc3RyZWFtUmVzdWx0ID0gY29udGV4dC5zdHJlYW1SZXN1bHQ7XG4gIGlmICghVXRpbC5leGlzdHMoc3RyZWFtUmVzdWx0KSkge1xuICAgIHN0cmVhbVJlc3VsdCA9IGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZy5nZXRTdHJlYW1SZXN1bHQoKTtcbiAgfVxuXG4gIC8vIGlmIHRoZSByZXN1bHQgd2lsbCBiZSBzdHJlYW1lZCBsYXRlciBvciBpbiBhc3luY0V4ZWMgbW9kZSxcbiAgLy8gaW52b2tlIHRoZSBjb21wbGV0ZSBjYWxsYmFjayByaWdodCBhd2F5XG4gIGlmIChzdHJlYW1SZXN1bHQpIHtcbiAgICBjb250ZXh0LmNvbXBsZXRlKEVycm9ycy5leHRlcm5hbGl6ZShjb250ZXh0LnJlc3VsdEVycm9yKSwgc3RhdGVtZW50KTtcbiAgfSBlbHNlIGlmIChjb250ZXh0LmFzeW5jRXhlYykge1xuICAgIC8vIHJldHVybiB0aGUgcmVzdWx0IG9iamVjdCB3aXRoIHRoZSBxdWVyeSBJRCBpbnNpZGUuXG4gICAgY29udGV4dC5jb21wbGV0ZShudWxsLCBzdGF0ZW1lbnQsIGNvbnRleHQucmVzdWx0KTtcbiAgfSBlbHNlIHtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgIC8vIGFnZ3JlZ2F0ZSBhbGwgdGhlIHJvd3MgaW50byBhbiBhcnJheSBhbmQgcGFzcyB0aGlzXG4gICAgICAvLyBhcnJheSB0byB0aGUgY29tcGxldGUgY2FsbGJhY2sgYXMgdGhlIGxhc3QgYXJndW1lbnRcbiAgICAgIGNvbnN0IHJvd3MgPSBbXTtcbiAgICAgIHN0YXRlbWVudC5zdHJlYW1Sb3dzKClcbiAgICAgICAgLm9uKCdyZWFkYWJsZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyByZWFkIG9ubHkgd2hlbiBkYXRhIGlzIGF2YWlsYWJsZVxuICAgICAgICAgIGxldCByb3c7XG5cbiAgICAgICAgICAvLyB3aGlsZSB0aGVyZSBhcmUgcm93cyBhdmFpbGFibGUgdG8gcmVhZCwgcHVzaCByb3cgdG8gcmVzdWx0cyBhcnJheVxuICAgICAgICAgIHdoaWxlICgocm93ID0gdGhpcy5yZWFkKCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICByb3dzLnB1c2gocm93KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbnRleHQuY29tcGxldGUobnVsbCwgc3RhdGVtZW50LCByb3dzKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBjb250ZXh0LmNvbXBsZXRlKEVycm9ycy5leHRlcm5hbGl6ZShlcnIpLCBzdGF0ZW1lbnQpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgUm93U3RhdGVtZW50UHJlRXhlYyBpbnN0YW5jZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50T3B0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqIEBwYXJhbSB7T2JqZWN0fSBzZXJ2aWNlc1xuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBSb3dTdGF0ZW1lbnRQcmVFeGVjKFxuICBzdGF0ZW1lbnRPcHRpb25zLFxuICBjb250ZXh0LFxuICBzZXJ2aWNlcyxcbiAgY29ubmVjdGlvbkNvbmZpZykge1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUm93U3RhdGVtZW50UHJlRXhlYycpO1xuICAvLyBjYWxsIHN1cGVyXG4gIEJhc2VTdGF0ZW1lbnQuYXBwbHkodGhpcywgW3N0YXRlbWVudE9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnXSk7XG5cbiAgLy8gYWRkIHRoZSByZXN1bHQgcmVxdWVzdCBoZWFkZXJzIHRvIHRoZSBjb250ZXh0XG4gIGNvbnRleHQucmVzdWx0UmVxdWVzdEhlYWRlcnMgPSBidWlsZFJlc3VsdFJlcXVlc3RIZWFkZXJzUm93KCk7XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSByZXF1ZXN0IHRvIGdldCB0aGUgc3RhdGVtZW50IHJlc3VsdCBpcyBzdWNjZXNzZnVsLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gYm9keVxuICAgKi9cbiAgY29udGV4dC5vblN0YXRlbWVudFJlcXVlc3RTdWNjID1cbiAgICBjcmVhdGVPblN0YXRlbWVudFJlcXVlc3RTdWNjUm93KHRoaXMsIGNvbnRleHQpO1xuXG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSByb3dzIGluIHRoaXMgc3RhdGVtZW50J3MgcmVzdWx0IGFuZCBpbnZva2VzIHRoZSBlYWNoKClcbiAgICogY2FsbGJhY2sgb24gZWFjaCByb3cuIElmIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGFyZSBzcGVjaWZpZWQsIHRoZSBlYWNoKClcbiAgICogY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGludm9rZWQgb24gcm93cyBpbiB0aGUgc3BlY2lmaWVkIHJhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5mZXRjaFJvd3MgPSBjcmVhdGVGbkZldGNoUm93cyh0aGlzLCBjb250ZXh0KTtcblxuICAvKipcbiAgICogU3RyZWFtcyB0aGUgcm93cyBpbiB0aGlzIHN0YXRlbWVudCdzIHJlc3VsdC4gSWYgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgYXJlXG4gICAqIHNwZWNpZmllZCwgb25seSByb3dzIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UgYXJlIHN0cmVhbWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5zdHJlYW1Sb3dzID0gY3JlYXRlRm5TdHJlYW1Sb3dzKHRoaXMsIGNvbnRleHQpO1xuXG4gIC8vIHNlbmQgYSByZXF1ZXN0IHRvIGV4ZWN1dGUgdGhlIHN0YXRlbWVudFxuICBzZW5kUmVxdWVzdFByZUV4ZWMoY29udGV4dCwgY29udGV4dC5vblN0YXRlbWVudFJlcXVlc3RDb21wKTtcbn1cblxuVXRpbC5pbmhlcml0cyhSb3dTdGF0ZW1lbnRQcmVFeGVjLCBCYXNlU3RhdGVtZW50KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBieSByb3cgc3RhdGVtZW50cyB0byBwcm9jZXNzIHRoZSByZXNwb25zZVxuICogd2hlbiB0aGUgcmVxdWVzdCBpcyBzdWNjZXNzZnVsLlxuICpcbiAqIEBwYXJhbSBzdGF0ZW1lbnRcbiAqIEBwYXJhbSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZU9uU3RhdGVtZW50UmVxdWVzdFN1Y2NSb3coc3RhdGVtZW50LCBjb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYm9keSkge1xuICAgIC8vIGlmIHdlIGRvbid0IGFscmVhZHkgaGF2ZSBhIHJlc3VsdFxuICAgIGlmICghY29udGV4dC5yZXN1bHQpIHtcbiAgICAgIGlmIChib2R5LmNvZGUgPT09IHF1ZXJ5Q29kZXMuUVVFUllfSU5fUFJPR1JFU1NfQVNZTkMpIHtcbiAgICAgICAgY29udGV4dC5yZXN1bHQgPSB7XG4gICAgICAgICAgcXVlcnlJZDogYm9keS5kYXRhLnF1ZXJ5SWRcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGJvZHkuZGF0YS5yZXN1bHRJZHMgIT0gbnVsbCAmJiBib2R5LmRhdGEucmVzdWx0SWRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy9tdWx0aSBzdGF0ZW1lbnRzXG4gICAgICAgIHRoaXMuX3Jlc3VsdElkcyA9IGJvZHkuZGF0YS5yZXN1bHRJZHMuc3BsaXQoJywnKTtcbiAgICAgICAgY29udGV4dC5pc011bHRpID0gdHJ1ZTtcbiAgICAgICAgY29udGV4dC5tdWx0aVJlc3VsdElkcyA9IHRoaXMuX3Jlc3VsdElkcztcbiAgICAgICAgY29udGV4dC5tdWx0aUN1cklkID0gMDtcbiAgICAgICAgY29udGV4dC5xdWVyeUlkID0gdGhpcy5fcmVzdWx0SWRzW2NvbnRleHQubXVsdGlDdXJJZF07XG4gICAgICAgIGV4cG9ydHMuY3JlYXRlU3RhdGVtZW50UG9zdEV4ZWMoY29udGV4dCwgY29udGV4dC5zZXJ2aWNlcywgY29udGV4dC5jb25uZWN0aW9uQ29uZmlnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGJ1aWxkIGEgcmVzdWx0IGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICAgIGNvbnRleHQucmVzdWx0ID0gbmV3IFJlc3VsdChcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXNwb25zZTogYm9keSxcbiAgICAgICAgICAgIHN0YXRlbWVudDogc3RhdGVtZW50LFxuICAgICAgICAgICAgc2VydmljZXM6IGNvbnRleHQuc2VydmljZXMsXG4gICAgICAgICAgICBjb25uZWN0aW9uQ29uZmlnOiBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcsXG4gICAgICAgICAgICByb3dNb2RlOiBjb250ZXh0LnJvd01vZGVcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjb250ZXh0LnF1ZXJ5SWQgPSBjb250ZXh0LnJlc3VsdC5nZXRRdWVyeUlkKCk7XG4gICAgICAgIHRoaXMuc2VydmljZXMuc2YuZGVzZXJpYWxpemVRdWVyeUNvbnRleHQoY29udGV4dC5yZXN1bHQuZ2V0UXVlcnlDb250ZXh0KCkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZWZyZXNoIHRoZSBleGlzdGluZyByZXN1bHRcbiAgICAgIGNvbnRleHQucmVzdWx0LnJlZnJlc2goYm9keSk7XG4gICAgfVxuXG4gICAgaWYgKGNvbnRleHQuaXNNdWx0aSA9PSBudWxsIHx8IGNvbnRleHQuaXNNdWx0aSA9PT0gZmFsc2UpIHtcbiAgICAgIC8vIG9ubHkgdXBkYXRlIHRoZSBwYXJhbWV0ZXJzIGlmIHRoZSBzdGF0ZW1lbnQgaXNuJ3QgYSBwb3N0LWV4ZWMgc3RhdGVtZW50XG4gICAgICBpZiAoY29udGV4dC50eXBlICE9PSBzdGF0ZW1lbnRUeXBlcy5ST1dfUE9TVF9FWEVDIHx8IGNvbnRleHQudHlwZSAhPT0gc3RhdGVtZW50VHlwZXMuRklMRV9QT1NUX0VYRUMpIHtcbiAgICAgICAgUGFyYW1ldGVycy51cGRhdGUoY29udGV4dC5yZXN1bHQuZ2V0UGFyYW1ldGVyc0FycmF5KCkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEZpbGVTdGF0ZW1lbnRQcmVFeGVjIGluc3RhbmNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRPcHRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICogQHBhcmFtIHtPYmplY3R9IHNlcnZpY2VzXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEZpbGVTdGF0ZW1lbnRQcmVFeGVjKFxuICBzdGF0ZW1lbnRPcHRpb25zLCBjb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZykge1xuICAvLyBjYWxsIHN1cGVyXG4gIEJhc2VTdGF0ZW1lbnQuYXBwbHkodGhpcywgW3N0YXRlbWVudE9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnXSk7XG5cbiAgLy8gYWRkIHRoZSByZXN1bHQgcmVxdWVzdCBoZWFkZXJzIHRvIHRoZSBjb250ZXh0XG4gIGNvbnRleHQucmVzdWx0UmVxdWVzdEhlYWRlcnMgPSBidWlsZFJlc3VsdFJlcXVlc3RIZWFkZXJzRmlsZSgpO1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgc3RhdGVtZW50IHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGJvZHlcbiAgICovXG4gIGNvbnRleHQub25TdGF0ZW1lbnRSZXF1ZXN0U3VjYyA9IGFzeW5jIGZ1bmN0aW9uIChib2R5KSB7XG4gICAgYXdhaXQgZXhlY3V0ZUZpbGVUcmFuc2ZlclJlcXVlc3QoY29udGV4dCwgYm9keSwgdGhpcyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFN0cmVhbXMgdGhlIHJvd3MgaW4gdGhpcyBzdGF0ZW1lbnQncyByZXN1bHQuIElmIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGFyZVxuICAgKiBzcGVjaWZpZWQsIG9ubHkgcm93cyBpbiB0aGUgc3BlY2lmaWVkIHJhbmdlIGFyZSBzdHJlYW1lZC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIHRoaXMuc3RyZWFtUm93cyA9IGNyZWF0ZUZuU3RyZWFtUm93cyh0aGlzLCBjb250ZXh0KTtcbiAgdGhpcy5oYXNOZXh0ID0gaGFzTmV4dFJlc3VsdCh0aGlzLCBjb250ZXh0KTtcbiAgdGhpcy5OZXh0UmVzdWx0ID0gY3JlYXRlTmV4dFJldXNsdCh0aGlzLCBjb250ZXh0KTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZmlsZSBtZXRhZGF0YSBnZW5lcmF0ZWQgYnkgdGhlIHN0YXRlbWVudC5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHRoaXMuZ2V0RmlsZU1ldGFkYXRhID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb250ZXh0LmZpbGVNZXRhZGF0YTtcbiAgfTtcblxuICAvLyBzZW5kIGEgcmVxdWVzdCB0byBleGVjdXRlIHRoZSBmaWxlIHN0YXRlbWVudFxuICBzZW5kUmVxdWVzdFByZUV4ZWMoY29udGV4dCwgY29udGV4dC5vblN0YXRlbWVudFJlcXVlc3RDb21wKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZXhlY3V0ZUZpbGVUcmFuc2ZlclJlcXVlc3QoY29udGV4dCwgYm9keSwgc3RhdGVtZW50LCBmaWxlVHJhbnNmZXJBZ2VudCkge1xuICBjb250ZXh0LmZpbGVNZXRhZGF0YSA9IGJvZHk7XG5cbiAgY29uc3QgZnRhID0gZmlsZVRyYW5zZmVyQWdlbnQgPz8gbmV3IEZpbGVUcmFuc2ZlckFnZW50KGNvbnRleHQpO1xuICBhd2FpdCBmdGEuZXhlY3V0ZSgpO1xuXG4gIHRyeSB7XG4gICAgLy8gYnVpbGQgYSByZXN1bHQgZnJvbSB0aGUgcmVzcG9uc2VcbiAgICBjb25zdCByZXN1bHQgPSBmdGEucmVzdWx0KCk7XG5cbiAgICAvLyBpbml0IHJlc3VsdCBhbmQgbWV0YVxuICAgIGJvZHkuZGF0YSA9IHtcbiAgICAgIHJvd3NldDogcmVzdWx0LnJvd3NldCxcbiAgICAgIHJldHVybmVkOiByZXN1bHQucm93c2V0Lmxlbmd0aCxcbiAgICAgIHJvd3R5cGU6IHJlc3VsdC5yb3d0eXBlLFxuICAgICAgcGFyYW1ldGVyczogW10sXG4gICAgfTtcblxuICAgIGNvbnRleHQucmVzdWx0ID0gbmV3IFJlc3VsdCh7XG4gICAgICByZXNwb25zZTogYm9keSxcbiAgICAgIHN0YXRlbWVudDogc3RhdGVtZW50LFxuICAgICAgc2VydmljZXM6IGNvbnRleHQuc2VydmljZXMsXG4gICAgICBjb25uZWN0aW9uQ29uZmlnOiBjb250ZXh0LmNvbm5lY3Rpb25Db25maWdcbiAgICB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb250ZXh0LnJlc3VsdEVycm9yID0gZXJyb3I7XG4gIH1cbn1cblxuZXhwb3J0cy5leGVjdXRlRmlsZVRyYW5zZmVyUmVxdWVzdCA9IGV4ZWN1dGVGaWxlVHJhbnNmZXJSZXF1ZXN0O1xuXG5VdGlsLmluaGVyaXRzKEZpbGVTdGF0ZW1lbnRQcmVFeGVjLCBCYXNlU3RhdGVtZW50KTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFN0YWdlQmluZGluZ1N0YXRlbWVudFByZUV4ZWMgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudE9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc2VydmljZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3RhZ2VCaW5kaW5nU3RhdGVtZW50UHJlRXhlYyhcbiAgc3RhdGVtZW50T3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcpIHtcbiAgLy8gY2FsbCBzdXBlclxuICBCYXNlU3RhdGVtZW50LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgLy8gYWRkIHRoZSByZXN1bHQgcmVxdWVzdCBoZWFkZXJzIHRvIHRoZSBjb250ZXh0XG4gIGNvbnRleHQucmVzdWx0UmVxdWVzdEhlYWRlcnMgPSBidWlsZFJlc3VsdFJlcXVlc3RIZWFkZXJzRmlsZSgpO1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgc3RhdGVtZW50IHJlcXVlc3QgaXMgc3VjY2Vzc2Z1bC4gU3ViY2xhc3NlcyBtdXN0IHByb3ZpZGVcbiAgICogdGhlaXIgb3duIGltcGxlbWVudGF0aW9uLlxuICAgKi9cbiAgY29udGV4dC5vblN0YXRlbWVudFJlcXVlc3RTdWNjID0gZnVuY3Rpb24gKCkge1xuICAgIC8vZG8gbm90aGluZ1xuICB9O1xuXG4gIC8qKlxuICAgKiBDYWxsZWQgdGhlIHN0YWdlIGJpbmRpbmcgcmVxdWVzdFxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICAgKiBAcGFyYW0ge09iamVjdH0gc2VydmljZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAgICovXG4gIHRoaXMuU3RhZ2VCaW5kaW5nUmVxdWVzdCA9IGFzeW5jIGZ1bmN0aW9uIChvcHRpb25zLCBjb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZykge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBiaW5kVXBsb2FkZXJSZXF1ZXN0SWQgPSB1dWlkdjQoKTtcbiAgICAgIGNvbnN0IGJpbmQgPSBuZXcgQmluZC5CaW5kVXBsb2FkZXIob3B0aW9ucywgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWcsIGJpbmRVcGxvYWRlclJlcXVlc3RJZCk7XG4gICAgICBjb250ZXh0LmJpbmRTdGFnZSA9IEJpbmQuR2V0U3RhZ2VOYW1lKGJpbmRVcGxvYWRlclJlcXVlc3RJZCk7XG4gICAgICBhd2FpdCBiaW5kLlVwbG9hZChjb250ZXh0LmJpbmRzKTtcbiAgICAgIHJldHVybiBjcmVhdGVSb3dTdGF0ZW1lbnRQcmVFeGVjKFxuICAgICAgICBvcHRpb25zLCBjb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRleHQuYmluZFN0YWdlID0gbnVsbDtcbiAgICAgIHJldHVybiBjcmVhdGVSb3dTdGF0ZW1lbnRQcmVFeGVjKFxuICAgICAgICBvcHRpb25zLCBjb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgfVxuICB9O1xuICAgXG4gIC8qKlxuICAgKiBGZXRjaGVzIHRoZSByb3dzIGluIHRoaXMgc3RhdGVtZW50J3MgcmVzdWx0IGFuZCBpbnZva2VzIHRoZSBlYWNoKClcbiAgICogY2FsbGJhY2sgb24gZWFjaCByb3cuIElmIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGFyZSBzcGVjaWZpZWQsIHRoZSBlYWNoKClcbiAgICogY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGludm9rZWQgb24gcm93cyBpbiB0aGUgc3BlY2lmaWVkIHJhbmdlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5mZXRjaFJvd3MgPSBjcmVhdGVGbkZldGNoUm93cyh0aGlzLCBjb250ZXh0KTtcblxuICAvKipcbiAgICogU3RyZWFtcyB0aGUgcm93cyBpbiB0aGlzIHN0YXRlbWVudCdzIHJlc3VsdC4gSWYgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgYXJlXG4gICAqIHNwZWNpZmllZCwgb25seSByb3dzIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UgYXJlIHN0cmVhbWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5zdHJlYW1Sb3dzID0gY3JlYXRlRm5TdHJlYW1Sb3dzKHRoaXMsIGNvbnRleHQpO1xuICB0aGlzLmhhc05leHQgPSBoYXNOZXh0UmVzdWx0KHRoaXMsIGNvbnRleHQpO1xuICB0aGlzLk5leHRSZXN1bHQgPSBjcmVhdGVOZXh0UmV1c2x0KHRoaXMsIGNvbnRleHQpO1xuXG4gIHRoaXMuU3RhZ2VCaW5kaW5nUmVxdWVzdChzdGF0ZW1lbnRPcHRpb25zLCBjb250ZXh0LCBzZXJ2aWNlcywgY29ubmVjdGlvbkNvbmZpZyk7XG4gIFxufVxuXG5VdGlsLmluaGVyaXRzKFN0YWdlQmluZGluZ1N0YXRlbWVudFByZUV4ZWMsIEJhc2VTdGF0ZW1lbnQpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgU3RhdGVtZW50UG9zdEV4ZWMgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudE9wdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc2VydmljZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gU3RhdGVtZW50UG9zdEV4ZWMoXG4gIHN0YXRlbWVudE9wdGlvbnMsIGNvbnRleHQsIHNlcnZpY2VzLCBjb25uZWN0aW9uQ29uZmlnKSB7XG4gIC8vIGNhbGwgc3VwZXJcbiAgQmFzZVN0YXRlbWVudC5hcHBseSh0aGlzLCBbc3RhdGVtZW50T3B0aW9ucywgY29udGV4dCwgc2VydmljZXMsIGNvbm5lY3Rpb25Db25maWddKTtcblxuICAvLyBhZGQgdGhlIHJlc3VsdCByZXF1ZXN0IGhlYWRlcnMgdG8gdGhlIGNvbnRleHRcbiAgY29udGV4dC5yZXN1bHRSZXF1ZXN0SGVhZGVycyA9IGJ1aWxkUmVzdWx0UmVxdWVzdEhlYWRlcnNSb3coKTtcblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHN0YXRlbWVudCByZXF1ZXN0IGlzIHN1Y2Nlc3NmdWwuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBib2R5XG4gICAqL1xuICBjb250ZXh0Lm9uU3RhdGVtZW50UmVxdWVzdFN1Y2MgPVxuICAgIGNyZWF0ZU9uU3RhdGVtZW50UmVxdWVzdFN1Y2NSb3codGhpcywgY29udGV4dCk7XG5cbiAgLyoqXG4gICAqIEZldGNoZXMgdGhlIHJvd3MgaW4gdGhpcyBzdGF0ZW1lbnQncyByZXN1bHQgYW5kIGludm9rZXMgdGhlIGVhY2goKVxuICAgKiBjYWxsYmFjayBvbiBlYWNoIHJvdy4gSWYgc3RhcnRJbmRleCBhbmQgZW5kSW5kZXggdmFsdWVzIGFyZSBzcGVjaWZpZWQsIHRoZVxuICAgKiBlYWNoKCkgY2FsbGJhY2sgd2lsbCBvbmx5IGJlIGludm9rZWQgb24gcm93cyBpbiB0aGUgcmVxdWVzdGVkIHJhbmdlLiBUaGVcbiAgICogZW5kKCkgY2FsbGJhY2sgd2lsbCBiZSBpbnZva2VkIHdoZW4gZWl0aGVyIGFsbCB0aGUgcmVxdWVzdGVkIHJvd3MgaGF2ZSBiZWVuXG4gICAqIHN1Y2Nlc3NmdWxseSBwcm9jZXNzZWQsIG9yIGlmIGFuIGVycm9yIHdhcyBlbmNvdW50ZXJlZCB3aGlsZSB0cnlpbmcgdG9cbiAgICogZmV0Y2ggdGhlIHJlcXVlc3RlZCByb3dzLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5mZXRjaFJvd3MgPSBjcmVhdGVGbkZldGNoUm93cyh0aGlzLCBjb250ZXh0KTtcblxuICAvKipcbiAgICogU3RyZWFtcyB0aGUgcm93cyBpbiB0aGlzIHN0YXRlbWVudCdzIHJlc3VsdC4gSWYgc3RhcnQgYW5kIGVuZCB2YWx1ZXMgYXJlXG4gICAqIHNwZWNpZmllZCwgb25seSByb3dzIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UgYXJlIHN0cmVhbWVkLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5zdHJlYW1Sb3dzID0gY3JlYXRlRm5TdHJlYW1Sb3dzKHRoaXMsIGNvbnRleHQpO1xuICB0aGlzLmhhc05leHQgPSBoYXNOZXh0UmVzdWx0KHRoaXMsIGNvbnRleHQpO1xuICB0aGlzLk5leHRSZXN1bHQgPSBjcmVhdGVOZXh0UmV1c2x0KHRoaXMsIGNvbnRleHQpO1xuICBcbiAgLy8gc2VuZCBhIHJlcXVlc3QgdG8gZmV0Y2ggdGhlIHJlc3VsdFxuICBzZW5kUmVxdWVzdFBvc3RFeGVjKGNvbnRleHQsIGNvbnRleHQub25TdGF0ZW1lbnRSZXF1ZXN0Q29tcCk7XG59XG5cblV0aWwuaW5oZXJpdHMoU3RhdGVtZW50UG9zdEV4ZWMsIEJhc2VTdGF0ZW1lbnQpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGZldGNoZXMgdGhlIHJvd3MgaW4gYSBzdGF0ZW1lbnQncyByZXN1bHQgYW5kXG4gKiBpbnZva2VzIHRoZSBlYWNoKCkgY2FsbGJhY2sgb24gZWFjaCByb3cuIElmIHN0YXJ0IGFuZCBlbmQgdmFsdWVzIGFyZVxuICogc3BlY2lmaWVkLCB0aGUgZWFjaCgpIGNhbGxiYWNrIHdpbGwgb25seSBiZSBpbnZva2VkIG9uIHJvd3MgaW4gdGhlXG4gKiBzcGVjaWZpZWQgcmFuZ2UuXG4gKlxuICogQHBhcmFtIHN0YXRlbWVudFxuICogQHBhcmFtIGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gY3JlYXRlRm5GZXRjaFJvd3Moc3RhdGVtZW50LCBjb250ZXh0KSB7XG4gIHJldHVybiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIC8vIGNoZWNrIGZvciBtaXNzaW5nIG9wdGlvbnNcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX1NUTVRfRkVUQ0hfUk9XU19NSVNTSU5HX09QVElPTlMpO1xuXG4gICAgLy8gY2hlY2sgZm9yIGludmFsaWQgb3B0aW9uc1xuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc09iamVjdChvcHRpb25zKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX1NUTVRfRkVUQ0hfUk9XU19JTlZBTElEX09QVElPTlMpO1xuXG4gICAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgZWFjaCgpXG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRFeGlzdHMoVXRpbC5leGlzdHMob3B0aW9ucy5lYWNoKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX1NUTVRfRkVUQ0hfUk9XU19NSVNTSU5HX0VBQ0gpO1xuXG4gICAgLy8gY2hlY2sgZm9yIGludmFsaWQgZWFjaCgpXG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzRnVuY3Rpb24ob3B0aW9ucy5lYWNoKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX1NUTVRfRkVUQ0hfUk9XU19JTlZBTElEX0VBQ0gpO1xuXG4gICAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgZW5kKClcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhvcHRpb25zLmVuZCksXG4gICAgICBFcnJvckNvZGVzLkVSUl9TVE1UX0ZFVENIX1JPV1NfTUlTU0lOR19FTkQpO1xuXG4gICAgLy8gY2hlY2sgZm9yIGludmFsaWQgZW5kKClcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNGdW5jdGlvbihvcHRpb25zLmVuZCksXG4gICAgICBFcnJvckNvZGVzLkVSUl9TVE1UX0ZFVENIX1JPV1NfSU5WQUxJRF9FTkQpO1xuXG4gICAgY29uc3Qgcm93TW9kZSA9IG9wdGlvbnMucm93TW9kZTtcbiAgICBpZiAoVXRpbC5leGlzdHMocm93TW9kZSkpIHtcbiAgICAgIFJvd01vZGUuY2hlY2tSb3dNb2RlVmFsaWQocm93TW9kZSk7XG4gICAgfVxuXG4gICAgLy8gaWYgd2UncmUgc3RpbGwgdHJ5aW5nIHRvIGZldGNoIHRoZSByZXN1bHQsIGNyZWF0ZSBhbiBlcnJvciBvZiBvdXIgb3duXG4gICAgLy8gYW5kIGludm9rZSB0aGUgZW5kKCkgY2FsbGJhY2tcbiAgICBpZiAoY29udGV4dC5pc0ZldGNoaW5nUmVzdWx0KSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQoRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKFxuICAgICAgICAgIEVycm9yQ29kZXMuRVJSX1NUTVRfRkVUQ0hfUk9XU19GRVRDSElOR19SRVNVTFQpLmV4dGVybmFsaXplKCksXG4gICAgICAgIHN0YXRlbWVudCk7XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNvbnRleHQucmVzdWx0RXJyb3IpIHtcbiAgICAgIC8vIGlmIHRoZXJlIHdhcyBhbiBlcnJvciB0aGUgbGFzdCB0aW1lIHdlIHRyaWVkIHRvIGdldCB0aGUgcmVzdWx0XG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgZmF0YWwgZXJyb3IsIGVuZCB0aGUgZmV0Y2ggcm93cyBvcGVyYXRpb24gc2luY2Ugd2UncmUgbm90XG4gICAgICAvLyBnb2luZyB0byBiZSBhYmxlIHRvIGdldCBhbnkgcm93cywgZWl0aGVyIGJlY2F1c2UgdGhlIHN0YXRlbWVudCBmYWlsZWRcbiAgICAgIC8vIG9yIGJlY2F1c2UgdGhlIHJlc3VsdCdzIGJlZW4gcHVyZ2VkXG4gICAgICBpZiAoRXJyb3JzLmlzT3BlcmF0aW9uRmFpbGVkRXJyb3IoY29udGV4dC5yZXN1bHRFcnJvcikgJiZcbiAgICAgICAgY29udGV4dC5yZXN1bHRFcnJvci5zcWxTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbmRGZXRjaFJvd3Mob3B0aW9ucywgc3RhdGVtZW50LCBjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250ZXh0LnJlZnJlc2goZnVuY3Rpb24gKCkge1xuICAgICAgICAgIC8vIGlmIHRoZXJlIHdhcyBubyBlcnJvciwgZmV0Y2ggcm93cyBmcm9tIHRoZSByZXN1bHRcbiAgICAgICAgICBpZiAoIWNvbnRleHQucmVzdWx0RXJyb3IpIHtcbiAgICAgICAgICAgIGZldGNoUm93c0Zyb21SZXN1bHQob3B0aW9ucywgc3RhdGVtZW50LCBjb250ZXh0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gZ2l2ZSB1cCBiZWNhdXNlIGl0J3MgdW5saWtlbHkgd2UnbGwgc3VjY2VlZCBpZiB3ZSByZXRyeSBhZ2FpblxuICAgICAgICAgICAgZW5kRmV0Y2hSb3dzKG9wdGlvbnMsIHN0YXRlbWVudCwgY29udGV4dCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZmV0Y2hSb3dzRnJvbVJlc3VsdChvcHRpb25zLCBzdGF0ZW1lbnQsIGNvbnRleHQpO1xuICAgIH1cbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBzdHJlYW1zIHRoZSByb3dzIGluIGEgc3RhdGVtZW50J3MgcmVzdWx0LiBJZiBzdGFydFxuICogYW5kIGVuZCB2YWx1ZXMgYXJlIHNwZWNpZmllZCwgb25seSByb3dzIGluIHRoZSBzcGVjaWZpZWQgcmFuZ2UgYXJlIHN0cmVhbWVkLlxuICpcbiAqIEBwYXJhbSBzdGF0ZW1lbnRcbiAqIEBwYXJhbSBjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUZuU3RyZWFtUm93cyhzdGF0ZW1lbnQsIGNvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgLy8gaWYgc29tZSBvcHRpb25zIGFyZSBzcGVjaWZpZWRcbiAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucykpIHtcbiAgICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIG9wdGlvbnNcbiAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc09iamVjdChvcHRpb25zKSxcbiAgICAgICAgRXJyb3JDb2Rlcy5FUlJfU1RNVF9GRVRDSF9ST1dTX0lOVkFMSURfT1BUSU9OUyk7XG5cbiAgICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHN0YXJ0XG4gICAgICBpZiAoVXRpbC5leGlzdHMob3B0aW9ucy5zdGFydCkpIHtcbiAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzTnVtYmVyKG9wdGlvbnMuc3RhcnQpLFxuICAgICAgICAgIEVycm9yQ29kZXMuRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9TVEFSVCk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIGVuZFxuICAgICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMuZW5kKSkge1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNOdW1iZXIob3B0aW9ucy5lbmQpLFxuICAgICAgICAgIEVycm9yQ29kZXMuRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9FTkQpO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBmZXRjaEFzU3RyaW5nXG4gICAgICBjb25zdCBmZXRjaEFzU3RyaW5nID0gb3B0aW9ucy5mZXRjaEFzU3RyaW5nO1xuICAgICAgaWYgKFV0aWwuZXhpc3RzKGZldGNoQXNTdHJpbmcpKSB7XG4gICAgICAgIC8vIGNoZWNrIHRoYXQgdGhlIHZhbHVlIGlzIGFuIGFycmF5XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0FycmF5KGZldGNoQXNTdHJpbmcpLFxuICAgICAgICAgIEVycm9yQ29kZXMuRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9GRVRDSF9BU19TVFJJTkcpO1xuXG4gICAgICAgIC8vIGNoZWNrIHRoYXQgYWxsIHRoZSBhcnJheSBlbGVtZW50cyBhcmUgdmFsaWRcbiAgICAgICAgY29uc3QgaW52YWxpZFZhbHVlSW5kZXggPSBOYXRpdmVUeXBlcy5maW5kSW52YWxpZFZhbHVlKGZldGNoQXNTdHJpbmcpO1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKGludmFsaWRWYWx1ZUluZGV4ID09PSAtMSxcbiAgICAgICAgICBFcnJvckNvZGVzLkVSUl9TVE1UX1NUUkVBTV9ST1dTX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HX1ZBTFVFUyxcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShmZXRjaEFzU3RyaW5nW2ludmFsaWRWYWx1ZUluZGV4XSkpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCByb3dNb2RlID0gY29udGV4dC5yb3dNb2RlO1xuICAgICAgaWYgKFV0aWwuZXhpc3RzKHJvd01vZGUpKSB7XG4gICAgICAgIFJvd01vZGUuY2hlY2tSb3dNb2RlVmFsaWQocm93TW9kZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBSb3dTdHJlYW0oc3RhdGVtZW50LCBjb250ZXh0LCBvcHRpb25zKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBFbmRzIHRoZSBmZXRjaFJvd3MoKSBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgdGhlIG9wdGlvbnMgcGFzc2VkIHRvIGZldGNoUm93cygpLlxuICogQHBhcmFtIHtPYmplY3R9IHN0YXRlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZW5kRmV0Y2hSb3dzKG9wdGlvbnMsIHN0YXRlbWVudCwgY29udGV4dCkge1xuICBvcHRpb25zLmVuZChFcnJvcnMuZXh0ZXJuYWxpemUoY29udGV4dC5yZXN1bHRFcnJvciksIHN0YXRlbWVudCk7XG59XG5cbi8qKlxuICogRmV0Y2hlcyByb3dzIGZyb20gdGhlIHN0YXRlbWVudCdzIHJlc3VsdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gZmV0Y2hSb3dzKCkuXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gY29udGV4dFxuICovXG5mdW5jdGlvbiBmZXRjaFJvd3NGcm9tUmVzdWx0KG9wdGlvbnMsIHN0YXRlbWVudCwgY29udGV4dCkge1xuICBsZXQgbnVtSW50ZXJydXB0cyA9IDA7XG5cbiAgLy8gZm9yd2FyZCB0byB0aGUgcmVzdWx0IHRvIGdldCBhIEZldGNoUm93c09wZXJhdGlvbiBvYmplY3RcbiAgY29uc3Qgb3BlcmF0aW9uID0gY29udGV4dC5yZXN1bHQuZmV0Y2hSb3dzKG9wdGlvbnMpO1xuXG4gIC8vIHN1YnNjcmliZSB0byB0aGUgb3BlcmF0aW9uJ3MgJ2NvbXBsZXRlJyBldmVudFxuICBvcGVyYXRpb24ub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gKGVyciwgY29udGludWVDYWxsYmFjaykge1xuICAgIC8vIHdlIHdhbnQgdG8gcmV0cnkgaWYgdGhlIGVycm9yIGlzIHJldHJ5YWJsZSBhbmQgdGhlXG4gICAgLy8gcmVzdWx0IHN0cmVhbSBoYXNuJ3QgYmVlbiBjbG9zZWQgdG9vIG1hbnkgdGltZXNcbiAgICBpZiAoRXJyb3JzLmlzTGFyZ2VSZXN1bHRTZXRFcnJvcihlcnIpICYmIGVyci5yZXNwb25zZSAmJlxuICAgICAgKGVyci5yZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDMpICYmXG4gICAgICAobnVtSW50ZXJydXB0cyA8XG4gICAgICAgIGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZy5nZXRSZXN1bHRTdHJlYW1JbnRlcnJ1cHRzKCkpKSB7XG4gICAgICAvLyBpbmNyZW1lbnQgdGhlIGludGVycnVwdCBjb3VudGVyXG4gICAgICBudW1JbnRlcnJ1cHRzKys7XG5cbiAgICAgIC8vIGlzc3VlIGEgcmVxdWVzdCB0byBmZXRjaCB0aGUgcmVzdWx0IGFnYWluXG4gICAgICBzZW5kUmVxdWVzdFBvc3RFeGVjKGNvbnRleHQsIGZ1bmN0aW9uIChlcnIsIGJvZHkpIHtcbiAgICAgICAgLy8gcmVmcmVzaCB0aGUgcmVzdWx0XG4gICAgICAgIGNvbnRleHQub25TdGF0ZW1lbnRSZXF1ZXN0Q29tcChlcnIsIGJvZHkpO1xuXG4gICAgICAgIC8vIGlmIHRoZXJlIHdhcyBubyBlcnJvciwgY29udGludWUgZnJvbSB3aGVyZSB3ZSBnb3QgaW50ZXJydXB0ZWRcbiAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICBjb250aW51ZUNhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmRGZXRjaFJvd3Mob3B0aW9ucywgc3RhdGVtZW50LCBjb250ZXh0KTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIElzc3VlcyBhIHJlcXVlc3QgdG8gY2FuY2VsIGEgc3RhdGVtZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRDb250ZXh0XG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVtZW50XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICovXG5mdW5jdGlvbiBzZW5kQ2FuY2VsU3RhdGVtZW50KHN0YXRlbWVudENvbnRleHQsIHN0YXRlbWVudCwgY2FsbGJhY2spIHtcbiAgbGV0IHVybDtcbiAgbGV0IGpzb247XG5cbiAgLy8gdXNlIGRpZmZlcmVudCByZXN0IGVuZHBvaW50cyBiYXNlZCBvbiB3aGV0aGVyIHRoZSBxdWVyeSBpZCBpcyBhdmFpbGFibGVcbiAgaWYgKHN0YXRlbWVudENvbnRleHQucXVlcnlJZCkge1xuICAgIHVybCA9ICcvcXVlcmllcy8nICsgc3RhdGVtZW50Q29udGV4dC5xdWVyeUlkICsgJy9hYm9ydC1yZXF1ZXN0JztcbiAgfSBlbHNlIHtcbiAgICB1cmwgPSAnL3F1ZXJpZXMvdjEvYWJvcnQtcmVxdWVzdCc7XG4gICAganNvbiA9XG4gICAgICB7XG4gICAgICAgIHJlcXVlc3RJZDogc3RhdGVtZW50Q29udGV4dC5yZXF1ZXN0SWRcbiAgICAgIH07XG4gIH1cblxuICAvLyBpc3N1ZSBhIHJlcXVlc3QgdG8gY2FuY2VsIHRoZSBzdGF0ZW1lbnRcbiAgc3RhdGVtZW50Q29udGV4dC5zZXJ2aWNlcy5zZi5yZXF1ZXN0KFxuICAgIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBqc29uOiBqc29uLFxuICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gaWYgYSBjYWxsYmFjayB3YXMgc3BlY2lmaWVkLCBpbnZva2UgaXRcbiAgICAgICAgaWYgKFV0aWwuaXNGdW5jdGlvbihjYWxsYmFjaykpIHtcbiAgICAgICAgICBjYWxsYmFjayhFcnJvcnMuZXh0ZXJuYWxpemUoZXJyKSwgc3RhdGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIElzc3VlcyBhIHJlcXVlc3QgdG8gZ2V0IHRoZSByZXN1bHQgb2YgYSBzdGF0ZW1lbnQgdGhhdCBoYXNuJ3QgYmVlbiBwcmV2aW91c2x5XG4gKiBleGVjdXRlZC5cbiAqXG4gKiBAcGFyYW0gc3RhdGVtZW50Q29udGV4dFxuICogQHBhcmFtIG9uUmVzdWx0QXZhaWxhYmxlXG4gKi9cbmZ1bmN0aW9uIHNlbmRSZXF1ZXN0UHJlRXhlYyhzdGF0ZW1lbnRDb250ZXh0LCBvblJlc3VsdEF2YWlsYWJsZSkge1xuICAvLyBnZXQgdGhlIHJlcXVlc3QgaGVhZGVyc1xuICBjb25zdCBoZWFkZXJzID0gc3RhdGVtZW50Q29udGV4dC5yZXN1bHRSZXF1ZXN0SGVhZGVycztcblxuICAvLyBidWlsZCB0aGUgYmFzaWMganNvbiBmb3IgdGhlIHJlcXVlc3RcbiAgY29uc3QganNvbiA9XG4gIHtcbiAgICBkaXNhYmxlT2ZmbGluZUNodW5rczogZmFsc2UsXG4gIH07XG4gIGpzb24uc3FsVGV4dCA9IHN0YXRlbWVudENvbnRleHQuc3FsVGV4dDtcblxuICBpZiAoc3RhdGVtZW50Q29udGV4dC5yZXN1Ym1pdFJlcXVlc3QgJiYgIWpzb24uc3FsVGV4dCkge1xuICAgIGpzb24uc3FsVGV4dCA9IGBTRUxFQ1QgJ0Vycm9yIHJldHJpZXZpbmcgcXVlcnkgcmVzdWx0cyBmb3IgcmVxdWVzdCBpZDogJHtzdGF0ZW1lbnRDb250ZXh0LnJlcXVlc3RJZH0sIGBcbiAgICAgICArICdwbGVhc2UgdXNlIFJFU1VMVF9TQ0FOIGluc3RlYWRcXCcgQVMgRXJyb3JNZXNzYWdlOyc7XG4gIH1cblxuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnY29udGV4dC5iaW5kU3RhZ2U9JyArIHN0YXRlbWVudENvbnRleHQuYmluZFN0YWdlKTtcbiAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudENvbnRleHQuYmluZFN0YWdlKSkge1xuICAgIGpzb24uYmluZFN0YWdlID0gc3RhdGVtZW50Q29udGV4dC5iaW5kU3RhZ2U7XG4gIH0gZWxzZSBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50Q29udGV4dC5iaW5kcykpIHtcbiAgICAvLyBpZiBiaW5kcyBhcmUgc3BlY2lmaWVkLCBidWlsZCBhIGJpbmRzIG1hcCBhbmQgaW5jbHVkZSBpdCBpbiB0aGUgcmVxdWVzdFxuICAgIGpzb24uYmluZGluZ3MgPSBidWlsZEJpbmRzTWFwKHN0YXRlbWVudENvbnRleHQuYmluZHMpO1xuICB9XG5cbiAgLy8gaW5jbHVkZSBzdGF0ZW1lbnQgcGFyYW1ldGVycyBpZiBhIHZhbHVlIHdhcyBzcGVjaWZpZWRcbiAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudENvbnRleHQucGFyYW1ldGVycykpIHtcbiAgICBqc29uLnBhcmFtZXRlcnMgPSBzdGF0ZW1lbnRDb250ZXh0LnBhcmFtZXRlcnM7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ2NvbnRleHQucGFyYW1ldGVycz0nICsgc3RhdGVtZW50Q29udGV4dC5wYXJhbWV0ZXJzKTtcbiAgfVxuXG4gIC8vIGluY2x1ZGUgdGhlIGludGVybmFsIGZsYWcgaWYgYSB2YWx1ZSB3YXMgc3BlY2lmaWVkXG4gIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRDb250ZXh0LmludGVybmFsKSkge1xuICAgIGpzb24uaXNJbnRlcm5hbCA9IHN0YXRlbWVudENvbnRleHQuaW50ZXJuYWw7XG4gIH1cblxuICBpZiAoIXN0YXRlbWVudENvbnRleHQuZGlzYWJsZVF1ZXJ5Q29udGV4dENhY2hlKXtcbiAgICBqc29uLnF1ZXJ5Q29udGV4dERUTyA9IHN0YXRlbWVudENvbnRleHQuc2VydmljZXMuc2YuZ2V0UXVlcnlDb250ZXh0RFRPKCk7XG4gIH1cblxuICAvLyBpbmNsdWRlIHRoZSBhc3luY0V4ZWMgZmxhZyBpZiBhIHZhbHVlIHdhcyBzcGVjaWZpZWRcbiAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudENvbnRleHQuYXN5bmNFeGVjKSkge1xuICAgIGpzb24uYXN5bmNFeGVjID0gc3RhdGVtZW50Q29udGV4dC5hc3luY0V4ZWM7XG4gIH1cblxuICAvLyBpbmNsdWRlIGRlc2NyaWJlT25seSBmbGFnIGlmIGEgdmFsdWUgd2FzIHNwZWNpZmllZFxuICBpZiAoVXRpbC5leGlzdHMoc3RhdGVtZW50Q29udGV4dC5kZXNjcmliZU9ubHkpKSB7XG4gICAganNvbi5kZXNjcmliZU9ubHkgPSBzdGF0ZW1lbnRDb250ZXh0LmRlc2NyaWJlT25seTtcbiAgfVxuXG4gIC8vIHVzZSB0aGUgc25vd2ZsYWtlIHNlcnZpY2UgdG8gaXNzdWUgdGhlIHJlcXVlc3RcbiAgc2VuZFNmUmVxdWVzdChzdGF0ZW1lbnRDb250ZXh0LFxuICAgIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgIHVybDogVXJsLmZvcm1hdChcbiAgICAgICAge1xuICAgICAgICAgIHBhdGhuYW1lOiAnL3F1ZXJpZXMvdjEvcXVlcnktcmVxdWVzdCcsXG4gICAgICAgICAgc2VhcmNoOiBRdWVyeVN0cmluZy5zdHJpbmdpZnkoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHJlcXVlc3RJZDogc3RhdGVtZW50Q29udGV4dC5yZXF1ZXN0SWRcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0pLFxuICAgICAganNvbjoganNvbixcbiAgICAgIGNhbGxiYWNrOiBidWlsZFJlc3VsdFJlcXVlc3RDYWxsYmFjayhcbiAgICAgICAgc3RhdGVtZW50Q29udGV4dCwgaGVhZGVycywgb25SZXN1bHRBdmFpbGFibGUpXG4gICAgfSxcbiAgICB0cnVlKTtcbn1cblxudGhpcy5zZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIChzdGF0ZW1lbnRDb250ZXh0LCBvblJlc3VsdEF2YWlsYWJsZSkge1xuICAvLyBnZXQgdGhlIHJlcXVlc3QgaGVhZGVyc1xuICBjb25zdCBoZWFkZXJzID0gc3RhdGVtZW50Q29udGV4dC5yZXN1bHRSZXF1ZXN0SGVhZGVycztcblxuICAvLyBidWlsZCB0aGUgYmFzaWMganNvbiBmb3IgdGhlIHJlcXVlc3RcbiAgY29uc3QganNvbiA9XG4gIHtcbiAgICBkaXNhYmxlT2ZmbGluZUNodW5rczogZmFsc2UsXG4gICAgc3FsVGV4dDogc3RhdGVtZW50Q29udGV4dC5zcWxUZXh0XG4gIH07XG5cbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ2NvbnRleHQuYmluZFN0YWdlPScgKyBzdGF0ZW1lbnRDb250ZXh0LmJpbmRTdGFnZSk7XG4gIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRDb250ZXh0LmJpbmRTdGFnZSkpIHtcbiAgICBqc29uLmJpbmRTdGFnZSA9IHN0YXRlbWVudENvbnRleHQuYmluZFN0YWdlO1xuICB9IGVsc2UgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudENvbnRleHQuYmluZHMpKSB7XG4gICAgLy8gaWYgYmluZHMgYXJlIHNwZWNpZmllZCwgYnVpbGQgYSBiaW5kcyBtYXAgYW5kIGluY2x1ZGUgaXQgaW4gdGhlIHJlcXVlc3RcbiAgICBqc29uLmJpbmRpbmdzID0gYnVpbGRCaW5kc01hcChzdGF0ZW1lbnRDb250ZXh0LmJpbmRzKTtcbiAgfVxuXG4gIC8vIGluY2x1ZGUgc3RhdGVtZW50IHBhcmFtZXRlcnMgaWYgYSB2YWx1ZSB3YXMgc3BlY2lmaWVkXG4gIGlmIChVdGlsLmV4aXN0cyhzdGF0ZW1lbnRDb250ZXh0LnBhcmFtZXRlcnMpKSB7XG4gICAganNvbi5wYXJhbWV0ZXJzID0gc3RhdGVtZW50Q29udGV4dC5wYXJhbWV0ZXJzO1xuICB9XG5cbiAgLy8gaW5jbHVkZSB0aGUgaW50ZXJuYWwgZmxhZyBpZiBhIHZhbHVlIHdhcyBzcGVjaWZpZWRcbiAgaWYgKFV0aWwuZXhpc3RzKHN0YXRlbWVudENvbnRleHQuaW50ZXJuYWwpKSB7XG4gICAganNvbi5pc0ludGVybmFsID0gc3RhdGVtZW50Q29udGV4dC5pbnRlcm5hbDtcbiAgfVxuXG4gIGlmICghc3RhdGVtZW50Q29udGV4dC5kaXNhYmxlUXVlcnlDb250ZXh0Q2FjaGUpe1xuICAgIGpzb24ucXVlcnlDb250ZXh0RFRPID0gc3RhdGVtZW50Q29udGV4dC5zZXJ2aWNlcy5zZi5nZXRRdWVyeUNvbnRleHREVE8oKTtcbiAgfVxuXG4gIGxldCBvcHRpb25zID1cbiAge1xuICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgdXJsOiBVcmwuZm9ybWF0KFxuICAgICAge1xuICAgICAgICBwYXRobmFtZTogJy9xdWVyaWVzL3YxL3F1ZXJ5LXJlcXVlc3QnLFxuICAgICAgICBzZWFyY2g6IFF1ZXJ5U3RyaW5nLnN0cmluZ2lmeShcbiAgICAgICAgICB7XG4gICAgICAgICAgICByZXF1ZXN0SWQ6IHN0YXRlbWVudENvbnRleHQucmVxdWVzdElkXG4gICAgICAgICAgfSlcbiAgICAgIH0pLFxuICAgIGpzb246IGpzb24sXG4gICAgY2FsbGJhY2s6IGJ1aWxkUmVzdWx0UmVxdWVzdENhbGxiYWNrKFxuICAgICAgc3RhdGVtZW50Q29udGV4dCwgaGVhZGVycywgb25SZXN1bHRBdmFpbGFibGUpXG4gIH07XG5cbiAgY29uc3Qgc2YgPSBzdGF0ZW1lbnRDb250ZXh0LnNlcnZpY2VzLnNmO1xuXG4gIC8vIGNsb25lIHRoZSBvcHRpb25zXG4gIG9wdGlvbnMgPSBVdGlsLmFwcGx5KHt9LCBvcHRpb25zKTtcblxuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICByZXNvbHZlKHNmLnBvc3RBc3luYyhvcHRpb25zKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJpbmQgdmFyaWFibGVzIGFycmF5IHRvIGEgbWFwIHRoYXQgY2FuIGJlIGluY2x1ZGVkIGluIHRoZVxuICogUE9TVC1ib2R5IHdoZW4gaXNzdWluZyBhIHByZS1leGVjIHN0YXRlbWVudCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSBiaW5kc0FycmF5XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gYnVpbGRCaW5kc01hcChiaW5kc0FycmF5KSB7XG4gIGNvbnN0IGJpbmRzTWFwID0ge307XG4gIGNvbnN0IGlzQXJyYXlCaW5kaW5nID0gYmluZHNBcnJheS5sZW5ndGggPiAwICYmIFV0aWwuaXNBcnJheShiaW5kc0FycmF5WzBdKTtcbiAgY29uc3Qgc2luZ2xlQXJyYXkgPSBpc0FycmF5QmluZGluZyA/IGJpbmRzQXJyYXlbMF0gOiBiaW5kc0FycmF5O1xuXG4gIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gc2luZ2xlQXJyYXkubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgIGxldCB2YWx1ZSA9IHNpbmdsZUFycmF5W2luZGV4XTtcblxuICAgIC8vIHBpY2sgdGhlIGFwcHJvcHJpYXRlIGxvZ2ljYWwgZGF0YSB0eXBlIGJhc2VkIG9uIHRoZSBiaW5kIHZhbHVlXG4gICAgbGV0IHR5cGU7XG4gICAgaWYgKFV0aWwuaXNCb29sZWFuKHZhbHVlKSkge1xuICAgICAgdHlwZSA9ICdCT09MRUFOJztcbiAgICB9IGVsc2UgaWYgKFV0aWwuaXNPYmplY3QodmFsdWUpIHx8IFV0aWwuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHR5cGUgPSAnVkFSSUFOVCc7XG4gICAgfSBlbHNlIGlmIChVdGlsLmlzTnVtYmVyKHZhbHVlKSkge1xuICAgICAgaWYgKE51bWJlcih2YWx1ZSkgPT09IHZhbHVlICYmIHZhbHVlICUgMSA9PT0gMCkge1xuICAgICAgICAvLyBpZiB2YWx1ZSBpcyBpbnRlZ2VyXG4gICAgICAgIHR5cGUgPSAnRklYRUQnO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9ICdSRUFMJztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdHlwZSA9ICdURVhUJztcbiAgICB9XG5cbiAgICAvLyBjb252ZXJ0IG5vbi1udWxsIHZhbHVlcyB0byBhIHN0cmluZyBpZiBuZWNlc3Nhcnk7IHdlIGRvbid0IGNvbnZlcnQgbnVsbFxuICAgIC8vIGJlY2F1c2UgdGhlIGNsaWVudCBtaWdodCB3YW50IHRvIHJ1biBzb21ldGhpbmcgbGlrZVxuICAgIC8vICAgc3FsIHRleHQgPSB1cGRhdGUgdCBzZXQgbmFtZSA9IDoxIHdoZXJlIGlkID0gMTssIGJpbmRzID0gW251bGxdXG4gICAgLy8gYW5kIGNvbnZlcnRpbmcgbnVsbCB0byBhIHN0cmluZyB3b3VsZCByZXN1bHQgaW4gdXMgZXhlY3V0aW5nXG4gICAgLy8gICBzcWwgdGV4dCA9IHVwZGF0ZSB0IHNldCBuYW1lID0gJ251bGwnIHdoZXJlIGlkID0gMTtcbiAgICAvLyBpbnN0ZWFkIG9mXG4gICAgLy8gICBzcWwgdGV4dCA9IHVwZGF0ZSB0IHNldCBuYW1lID0gbnVsbCB3aGVyZSBpZCA9IDE7XG4gICAgaWYgKCFpc0FycmF5QmluZGluZykge1xuICAgICAgaWYgKHZhbHVlICE9PSBudWxsICYmICFVdGlsLmlzU3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0pTT04oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YWx1ZSA9IEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSA9IFtdO1xuICAgICAgZm9yIChsZXQgcm93SW5kZXggPSAwOyByb3dJbmRleCA8IGJpbmRzQXJyYXkubGVuZ3RoOyByb3dJbmRleCsrKSB7XG4gICAgICAgIGxldCB2YWx1ZTAgPSBiaW5kc0FycmF5W3Jvd0luZGV4XVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZTAgIT09IG51bGwgJiYgIVV0aWwuaXNTdHJpbmcodmFsdWUwKSkge1xuICAgICAgICAgIGlmICh2YWx1ZTAgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgICAgICB2YWx1ZTAgPSB2YWx1ZTAudG9KU09OKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhbHVlMCA9IEpTT04uc3RyaW5naWZ5KHZhbHVlMCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhbHVlLnB1c2godmFsdWUwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhZGQgYW4gZW50cnkgZm9yIHRoZSBiaW5kIHZhcmlhYmxlIHRvIHRoZSBtYXBcbiAgICBiaW5kc01hcFtpbmRleCArIDFdID1cbiAgICAgIHtcbiAgICAgICAgdHlwZTogdHlwZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICB9O1xuICB9XG5cbiAgcmV0dXJuIGJpbmRzTWFwO1xufVxuXG4vKipcbiAqIElzc3VlcyBhIHJlcXVlc3QgdG8gZ2V0IHRoZSByZXN1bHQgb2YgYSBzdGF0ZW1lbnQgdGhhdCBoYXMgYmVlbiBwcmV2aW91c2x5XG4gKiBleGVjdXRlZC5cbiAqXG4gKiBAcGFyYW0gc3RhdGVtZW50Q29udGV4dFxuICogQHBhcmFtIG9uUmVzdWx0QXZhaWxhYmxlXG4gKi9cbmZ1bmN0aW9uIHNlbmRSZXF1ZXN0UG9zdEV4ZWMoc3RhdGVtZW50Q29udGV4dCwgb25SZXN1bHRBdmFpbGFibGUpIHtcbiAgLy8gZ2V0IHRoZSByZXF1ZXN0IGhlYWRlcnNcbiAgY29uc3QgaGVhZGVycyA9IHN0YXRlbWVudENvbnRleHQucmVzdWx0UmVxdWVzdEhlYWRlcnM7XG5cbiAgLy8gdXNlIHRoZSBzbm93Zmxha2Ugc2VydmljZSB0byBpc3N1ZSB0aGUgcmVxdWVzdFxuICBzZW5kU2ZSZXF1ZXN0KHN0YXRlbWVudENvbnRleHQsXG4gICAge1xuICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgICB1cmw6IFVybC5mb3JtYXQoXG4gICAgICAgIHtcbiAgICAgICAgICBwYXRobmFtZTogJy9xdWVyaWVzLycgKyBzdGF0ZW1lbnRDb250ZXh0LnF1ZXJ5SWQgKyAnL3Jlc3VsdCcsXG4gICAgICAgICAgc2VhcmNoOiBRdWVyeVN0cmluZy5zdHJpbmdpZnkoXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIGRpc2FibGVPZmZsaW5lQ2h1bmtzOiBmYWxzZVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSksXG4gICAgICBjYWxsYmFjazogYnVpbGRSZXN1bHRSZXF1ZXN0Q2FsbGJhY2soXG4gICAgICAgIHN0YXRlbWVudENvbnRleHQsIGhlYWRlcnMsIG9uUmVzdWx0QXZhaWxhYmxlKVxuICAgIH0pO1xufVxuXG4vKipcbiAqIElzc3VlcyBhIHN0YXRlbWVudC1yZWxhdGVkIHJlcXVlc3QgdXNpbmcgdGhlIFNub3dmbGFrZSBzZXJ2aWNlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBzdGF0ZW1lbnRDb250ZXh0IHRoZSBzdGF0ZW1lbnQgY29udGV4dC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIHRoZSByZXF1ZXN0IG9wdGlvbnMuXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFthcHBlbmRRdWVyeVBhcmFtT25SZXRyeV0gd2hldGhlciByZXRyeT10cnVlIHNob3VsZCBiZVxuICogICBhcHBlbmRlZCB0byB0aGUgdXJsIGlmIHRoZSByZXF1ZXN0IGlzIHJldHJpZWQuXG4gKi9cbmZ1bmN0aW9uIHNlbmRTZlJlcXVlc3Qoc3RhdGVtZW50Q29udGV4dCwgb3B0aW9ucywgYXBwZW5kUXVlcnlQYXJhbU9uUmV0cnkpIHtcbiAgY29uc3Qgc2YgPSBzdGF0ZW1lbnRDb250ZXh0LnNlcnZpY2VzLnNmO1xuICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0gc3RhdGVtZW50Q29udGV4dC5jb25uZWN0aW9uQ29uZmlnO1xuXG4gIC8vIGNsb25lIHRoZSBvcHRpb25zXG4gIG9wdGlvbnMgPSBVdGlsLmFwcGx5KHt9LCBvcHRpb25zKTtcblxuICAvLyBnZXQgdGhlIG9yaWdpbmFsIHVybCBhbmQgY2FsbGJhY2tcbiAgY29uc3QgdXJsT3JpZyA9IG9wdGlvbnMudXJsO1xuICBjb25zdCBjYWxsYmFja09yaWcgPSBvcHRpb25zLmNhbGxiYWNrO1xuXG4gIGxldCBudW1SZXRyaWVzID0gMDtcbiAgY29uc3QgbWF4TnVtUmV0cmllcyA9IGNvbm5lY3Rpb25Db25maWcuZ2V0UmV0cnlTZk1heE51bVJldHJpZXMoKTtcbiAgbGV0IHNsZWVwID0gY29ubmVjdGlvbkNvbmZpZy5nZXRSZXRyeVNmU3RhcnRpbmdTbGVlcFRpbWUoKTtcbiAgbGV0IGxhc3RTdGF0dXNDb2RlRm9yUmV0cnk7XG5cbiAgLy8gY3JlYXRlIGEgZnVuY3Rpb24gdG8gc2VuZCB0aGUgcmVxdWVzdFxuICBjb25zdCBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBpZiB0aGlzIGlzIGEgcmV0cnkgYW5kIGEgcXVlcnkgcGFyYW1ldGVyIHNob3VsZCBiZSBhcHBlbmRlZCB0byB0aGUgdXJsIG9uXG4gICAgLy8gcmV0cnksIHVwZGF0ZSB0aGUgdXJsXG4gICAgaWYgKChudW1SZXRyaWVzID4gMCkgJiYgYXBwZW5kUXVlcnlQYXJhbU9uUmV0cnkpIHtcbiAgICAgIGNvbnN0IHJldHJ5T3B0aW9uID0ge1xuICAgICAgICB1cmw6IHVybE9yaWcsXG4gICAgICAgIHJldHJ5Q291bnQ6IG51bVJldHJpZXMsXG4gICAgICAgIHJldHJ5UmVhc29uOiBsYXN0U3RhdHVzQ29kZUZvclJldHJ5LFxuICAgICAgICBpbmNsdWRlUmV0cnlSZWFzb246IGNvbm5lY3Rpb25Db25maWcuZ2V0SW5jbHVkZVJldHJ5UmVhc29uKCksXG4gICAgICB9O1xuICAgICAgXG4gICAgICBvcHRpb25zLnVybCA9IFV0aWwudXJsLmFwcGVuZFJldHJ5UGFyYW0ocmV0cnlPcHRpb24pO1xuICAgIH1cblxuICAgIHNmLnJlcXVlc3Qob3B0aW9ucyk7XG4gIH07XG5cbiAgLy8gcmVwbGFjZSB0aGUgc3BlY2lmaWVkIGNhbGxiYWNrIHdpdGggYSBuZXcgb25lIHRoYXQgcmV0cmllc1xuICBvcHRpb25zLmNhbGxiYWNrID0gYXN5bmMgZnVuY3Rpb24gKGVycikge1xuICAgIC8vIGlmIHdlIGhhdmVuJ3QgZXhjZWVkZWQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJldHJpZXMgeWV0IGFuZCB0aGUgc2VydmVyXG4gICAgLy8gY2FtZSBiYWNrIHdpdGggYSByZXRyeWFibGUgZXJyb3IgY29kZVxuICAgIGlmIChudW1SZXRyaWVzIDwgbWF4TnVtUmV0cmllcyAmJlxuICAgICAgZXJyICYmIFV0aWwuaXNSZXRyeWFibGVIdHRwRXJyb3IoXG4gICAgICBlcnIucmVzcG9uc2UsIGZhbHNlIC8vIG5vIHJldHJ5IGZvciBIVFRQIDQwM1xuICAgICkpIHtcbiAgICAgIC8vIGluY3JlbWVudCB0aGUgcmV0cnkgY291bnRcbiAgICAgIG51bVJldHJpZXMrKztcbiAgICAgIGxhc3RTdGF0dXNDb2RlRm9yUmV0cnkgPSBlcnIucmVzcG9uc2UgPyBlcnIucmVzcG9uc2Uuc3RhdHVzQ29kZSA6IDA7XG5cbiAgICAgIC8vIHVzZSBleHBvbmVudGlhbCBiYWNrb2ZmIHdpdGggZGVjb3JyZWxhdGVkIGppdHRlciB0byBjb21wdXRlIHRoZVxuICAgICAgLy8gbmV4dCBzbGVlcCB0aW1lLlxuICAgICAgY29uc3QgY2FwID0gY29ubmVjdGlvbkNvbmZpZy5nZXRSZXRyeVNmTWF4U2xlZXBUaW1lKCk7XG4gICAgICBzbGVlcCA9IFV0aWwubmV4dFNsZWVwVGltZSgxLCBjYXAsIHNsZWVwKTtcblxuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoXG4gICAgICAgICdSZXRyeWluZyBzdGF0ZW1lbnQgd2l0aCByZXF1ZXN0IGlkICVzLCByZXRyeSBjb3VudCA9ICVzJyxcbiAgICAgICAgc3RhdGVtZW50Q29udGV4dC5yZXF1ZXN0SWQsIG51bVJldHJpZXMpO1xuXG4gICAgICAvLyB3YWl0IHRoZSBhcHByb3ByaWF0ZSBhbW91bnQgb2YgdGltZSBiZWZvcmUgcmV0cnlpbmcgdGhlIHJlcXVlc3RcbiAgICAgIHNldFRpbWVvdXQoc2VuZFJlcXVlc3QsIHNsZWVwICogMTAwMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGludm9rZSB0aGUgb3JpZ2luYWwgY2FsbGJhY2tcbiAgICAgIGF3YWl0IGNhbGxiYWNrT3JpZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfTtcblxuICAvLyBpc3N1ZSB0aGUgcmVxdWVzdFxuICBzZW5kUmVxdWVzdCgpO1xufVxuXG4vKipcbiAqIEJ1aWxkcyBhIGNhbGxiYWNrIGZvciB1c2UgaW4gYW4gZXhlYy1zdGF0ZW1lbnQgb3IgZmV0Y2gtcmVzdWx0IHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHN0YXRlbWVudENvbnRleHRcbiAqIEBwYXJhbSBoZWFkZXJzXG4gKiBAcGFyYW0gb25SZXN1bHRBdmFpbGFibGVcbiAqXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUmVzdWx0UmVxdWVzdENhbGxiYWNrKFxuICBzdGF0ZW1lbnRDb250ZXh0LCBoZWFkZXJzLCBvblJlc3VsdEF2YWlsYWJsZSkge1xuICBjb25zdCBjYWxsYmFjayA9IGFzeW5jIGZ1bmN0aW9uIChlcnIsIGJvZHkpIHtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBhd2FpdCBvblJlc3VsdEF2YWlsYWJsZS5jYWxsKG51bGwsIGVyciwgbnVsbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4dHJhY3QgdGhlIHF1ZXJ5IGlkIGZyb20gdGhlIHJlc3BvbnNlIGFuZCBzYXZlIGl0XG4gICAgICBzdGF0ZW1lbnRDb250ZXh0LnF1ZXJ5SWQgPSBib2R5LmRhdGEucXVlcnlJZDtcblxuICAgICAgLy8gaWYgdGhlIHJlc3VsdCBpcyBub3QgcmVhZHkgeWV0LCBleHRyYWN0IHRoZSByZXN1bHQgdXJsIGZyb20gdGhlIHJlc3BvbnNlXG4gICAgICAvLyBhbmQgaXNzdWUgYSBHRVQgcmVxdWVzdCB0byB0cnkgdG8gZmV0Y2ggdGhlIHJlc3VsdCBhZ2FpbiB1bmxlc3MgYXN5bmNFeGVjIGlzIGVuYWJsZWQuXG4gICAgICBpZiAoYm9keSAmJiAoYm9keS5jb2RlID09PSBxdWVyeUNvZGVzLlFVRVJZX0lOX1BST0dSRVNTXG4gICAgICAgIHx8IGJvZHkuY29kZSA9PT0gcXVlcnlDb2Rlcy5RVUVSWV9JTl9QUk9HUkVTU19BU1lOQykpIHtcblxuICAgICAgICBpZiAoc3RhdGVtZW50Q29udGV4dC5hc3luY0V4ZWMpIHtcbiAgICAgICAgICBhd2FpdCBvblJlc3VsdEF2YWlsYWJsZS5jYWxsKG51bGwsIGVyciwgYm9keSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gZXh0cmFjdCB0aGUgcmVzdWx0IHVybCBmcm9tIHRoZSByZXNwb25zZSBhbmQgdHJ5IHRvIGdldCB0aGUgcmVzdWx0XG4gICAgICAgIC8vIGFnYWluXG4gICAgICAgIHNlbmRTZlJlcXVlc3Qoc3RhdGVtZW50Q29udGV4dCxcbiAgICAgICAgICB7XG4gICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgaGVhZGVyczogaGVhZGVycyxcbiAgICAgICAgICAgIHVybDogYm9keS5kYXRhLmdldFJlc3VsdFVybCxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBjYWxsYmFja1xuICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXdhaXQgb25SZXN1bHRBdmFpbGFibGUuY2FsbChudWxsLCBlcnIsIGJvZHkpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICByZXR1cm4gY2FsbGJhY2s7XG59XG5cbi8qKlxuICogQnVpbGRzIHRoZSByZXF1ZXN0IGhlYWRlcnMgZm9yIGEgcm93IHN0YXRlbWVudCByZXF1ZXN0LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGJ1aWxkUmVzdWx0UmVxdWVzdEhlYWRlcnNSb3coKSB7XG4gIHJldHVybiB7XG4gICAgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9zbm93Zmxha2UnXG4gIH07XG59XG5cbi8qKlxuICogQnVpbGRzIHRoZSByZXF1ZXN0IGhlYWRlcnMgZm9yIGEgZmlsZSBzdGF0ZW1lbnQgcmVxdWVzdC5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBidWlsZFJlc3VsdFJlcXVlc3RIZWFkZXJzRmlsZSgpIHtcbiAgcmV0dXJuIHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nXG4gIH07XG59XG5cbi8qKlxuICogQ291bnQgbnVtYmVyIG9mIGJpbmRpbmdzXG4gKiBcbiAqIEByZXR1cm5zIHtpbnR9XG4gKi9cbmZ1bmN0aW9uIGNvdW50QmluZGluZyhiaW5kcykge1xuICBpZiAoIVV0aWwuaXNBcnJheShiaW5kcykpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnLS0gYmluZHMubGVuZ3RoPSAlZCcsIGJpbmRzLmxlbmd0aCk7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBiaW5kcy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICBpZiAoYmluZHNbaW5kZXhdICE9IG51bGwgJiYgVXRpbC5pc0FycmF5KGJpbmRzW2luZGV4XSkpIHtcbiAgICAgIGNvdW50ICs9IGJpbmRzW2luZGV4XS5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cblxuZnVuY3Rpb24gaGFzTmV4dFJlc3VsdChzdGF0ZW1lbnQsIGNvbnRleHQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gKGNvbnRleHQubXVsdGlSZXN1bHRJZHMgIT0gbnVsbCAmJiBjb250ZXh0Lm11bHRpQ3VySWQgKyAxIDwgY29udGV4dC5tdWx0aVJlc3VsdElkcy5sZW5ndGgpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBjcmVhdGVOZXh0UmV1c2x0KHN0YXRlbWVudCwgY29udGV4dCkge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChoYXNOZXh0UmVzdWx0KHN0YXRlbWVudCwgY29udGV4dCkpIHtcbiAgICAgIGNvbnRleHQubXVsdGlDdXJJZCsrO1xuICAgICAgY29udGV4dC5xdWVyeUlkID0gY29udGV4dC5tdWx0aVJlc3VsdElkc1tjb250ZXh0Lm11bHRpQ3VySWRdO1xuICAgICAgZXhwb3J0cy5jcmVhdGVTdGF0ZW1lbnRQb3N0RXhlYyhjb250ZXh0LCBjb250ZXh0LnNlcnZpY2VzLCBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcpO1xuICAgIH1cbiAgfTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/connection/statement.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/constants/connection_constants.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/constants/connection_constants.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("exports.HEARTBEAT_FREQUENCY_MASTER_VALIDITY = 14400;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29uc3RhbnRzL2Nvbm5lY3Rpb25fY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBLDJDQUEyQyIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9jb25zdGFudHMvY29ubmVjdGlvbl9jb25zdGFudHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0cy5IRUFSVEJFQVRfRlJFUVVFTkNZX01BU1RFUl9WQUxJRElUWSA9IDE0NDAwO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/constants/connection_constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/constants/error_messages.js":
/*!********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/constants/error_messages.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("// 400001\nexports[400001] = 'An internal error has occurred. Please contact Snowflake support.';\nexports[400002] = 'You are using an unsupported version of Node.js. Please use %s or above.';\n\n// 401001\nexports[401001] = 'Network error. Could not reach Snowflake.';\nexports[401002] = 'Request to Snowflake failed.';\nexports[401003] = 'Snowflake responded with non-JSON content.';\nexports[401004] = 'Request to Snowflake failed.  Invalid token';\n\n// 402001\nexports[402001] = 'Network error. Could not reach S3/Blob.';\nexports[402002] = 'Request to S3/Blob failed.';\n\n// 403001\nexports[403001] = 'Invalid logLevel. The specified value must be one of these five levels: error, warn, debug, info and trace.';\nexports[403002] = 'Invalid disableOCSPChecks option. The specified value must be a boolean.';\nexports[403003] = 'Invalid OCSP mode. The specified value must be FAIL_CLOSED, FAIL_OPEN, or INSECURE_MODE.';\nexports[403004] = 'Invalid custom JSON parser. The specified value must be a function.';\nexports[403005] = 'Invalid custom XML parser. The specified value must be a function.';\nexports[403006] = 'Invalid keep alive value. The specified value must be a boolean.';\nexports[403007] = 'Invalid custom credential manager value. The specified value must be an object, and it should have three methods: write, read, remove';\nexports[403008] = 'Invalid useEnvProxy value. The specified value must be a boolean.';\n\n// 404001\nexports[404001] = 'Connection options must be specified.';\nexports[404002] = 'Invalid connection options. The specified value must be an object.';\nexports[404003] = 'A user name must be specified.';\nexports[404004] = 'Invalid user name. The specified value must be a string.';\nexports[404005] = 'A password must be specified.';\nexports[404006] = 'Invalid password. The specified value must be a string.';\nexports[404007] = 'An account must be specified.';\nexports[404008] = 'Invalid account. The specified value must be a string.';\nexports[404009] = 'An accessUrl must be specified.';\nexports[404010] = 'Invalid accessUrl. The specified value must be a string.';\nexports[404011] = 'Invalid warehouse. The specified value must be a string.';\nexports[404012] = 'Invalid database. The specified value must be a string.';\nexports[404013] = 'Invalid schema. The specified value must be a string.';\nexports[404014] = 'Invalid role. The specified value must be a string.';\nexports[404015] = 'A proxyHost must be specified';\nexports[404016] = 'Invalid proxyHost. The specified value must be a string.';\nexports[404017] = 'A proxyPort must be specified.';\nexports[404018] = 'Invalid proxyPort. The specified value must be a number.';\nexports[404019] = 'Invalid streamResult flag. The specified value must be a boolean.';\nexports[404020] = 'Invalid fetchAsString option. The specified value must be an Array.';\nexports[404021] = 'Invalid fetchAsString type: %s. The supported types are: String, Boolean, Number, Date, Buffer, and JSON.';\nexports[404022] = 'Invalid region. The specified value must be a string.';\nexports[404023] = 'Invalid clientSessionKeepAlive. The specified value must be a boolean.';\nexports[404024] = 'Invalid clientSessionKeepAliveHeartbeatFrequency. The specified value must be a number.';\nexports[404025] = 'Invalid jsTreatIntegerAsBigInt. The specified value must be a boolean';\nexports[404026] = 'Invalid private key. The specified value must be a string in pem format of type pkcs8';\nexports[404027] = 'Invalid private key file location. The specified value must be a string';\nexports[404028] = 'Invalid private key passphrase. The specified value must be a string';\nexports[404029] = 'Invalid oauth token. The specified value must be a string';\nexports[404030] = 'Invalid validate default parameters value. The specified value must be a boolean';\nexports[404031] = 'Invalid application value. The specified value must be a string that starts with a letter and a length between 1-50';\nexports[404032] = 'A proxyUser must be specified';\nexports[404033] = 'Invalid proxyUser. The specified value must be a string.';\nexports[404034] = 'A proxyPassword must be specified.';\nexports[404035] = 'Invalid proxyPassword. The specified value must be a string.';\nexports[404036] = 'Invalid noProxy. The specified value must be a string.';\nexports[404037] = 'Invalid arrayBindingThreshold. The specified value must be a number.';\nexports[404038] = 'Invalid gcsUseDownscopedCredential. The specified value must be a boolean.';\nexports[404039] = 'Invalid forceStageBindError. The specified value must be a number.';\nexports[404040] = 'Invalid browser timeout value. The specified value must be a positive number.';\nexports[404041] = 'Invalid disableQueryContextCache. The specified value must be a boolean.';\nexports[404042] = 'Invalid includeRetryReason. The specified value must be a boolean.';\nexports[404043] = 'Invalid clientConfigFile value. The specified value must be a string.';\nexports[404044] = 'Invalid retryTimeout value. The specified value must be a number.';\nexports[404045] = 'Invalid account. The specified value must be a valid subdomain string.';\nexports[404046] = 'Invalid region. The specified value must be a valid subdomain string.';\nexports[404047] = 'Invalid disableConsoleLogin. The specified value must be a boolean';\nexports[404048] = 'Invalid disableGCPTokenUpload. The specified value must be a boolean';\nexports[404048] = 'Invalid forceGCPUseDownscopedCredential. The specified value must be a boolean';\nexports[404049] = 'Invalid clientStoreTemporaryCredential. The specified value must be a boolean.';\nexports[404050] = 'Invalid representNullAsStringNull. The specified value must be a boolean';\nexports[404051] = 'Invalid disableSamlURLCheck. The specified value must be a boolean';\nexports[404052] = 'Invalid clientRequestMFAToken. The specified value must be a boolean.';\nexports[404053] = 'A host must be specified.';\nexports[404054] = 'Invalid host. The specified value must be a string.';\nexports[404055] = 'Invalid passcodeInPassword. The specified value must be a boolean';\nexports[404056] = 'Invalid passcode. The specified value must be a string';\n\n// 405001\nexports[405001] = 'Invalid callback. The specified value must be a function.';\n\n// 405501\nexports[405501] = 'Connection already in progress.';\nexports[405502] = 'Already connected.';\nexports[405503] = 'Connection already terminated. Cannot connect again.';\nexports[405504] = 'connect() does not work with external browser or okta authenticators, call connectAsync() instead';\nexports[405505] = 'Configuration from client config file failed';\n\n// 406001\nexports[406001] = 'Invalid callback. The specified value must be a function.';\n\n// 406501\nexports[406501] = 'Not connected, so nothing to destroy.';\nexports[406502] = 'Already disconnected.';\n\n// 407001\nexports[407001] = 'Unable to perform operation because a connection was never established.';\nexports[407002] = 'Unable to perform operation using terminated connection.';\n\n// 408001\nexports[408001] = 'A serializedConnection must be specified.';\nexports[408002] = 'Invalid serializedConnection. The specified value must be a string.';\nexports[408003] = 'Invalid serializedConnection. The value must be a string obtained by calling another connection\\'s serialize() method.';\n\n// 409001\nexports[409001] = 'Execute options must be specified.';\nexports[409002] = 'Invalid execute options. The specified value must be an object.';\nexports[409003] = 'A sqlText value must be specified.';\nexports[409004] = 'Invalid sqlText. The specified value must be a string.';\nexports[409005] = 'Invalid internal flag. The specified value must be a boolean.';\nexports[409006] = 'Invalid parameters. The specified value must be an object.';\nexports[409007] = 'Invalid binds. The specified value must be an array.';\nexports[409008] = 'Invalid bind variable: %s. Only stringifiable values are supported.';\nexports[409009] = 'Invalid complete callback. The specified value must be a function.';\nexports[409010] = 'Invalid streamResult flag. The specified value must be a boolean.';\nexports[409011] = 'Invalid fetchAsString value. The specified value must be an Array.';\nexports[409012] = 'Invalid fetchAsString type: %s. The supported types are: String, Boolean, Number, Date, Buffer, and JSON.';\nexports[409013] = 'Invalid requestId. The specified value must be a string.';\nexports[409014] = 'Invalid asyncExec. The specified value must be a boolean.';\nexports[409015] = 'Invalid describeOnly. The specified value must be a boolean.';\n\n// 410001\nexports[410001] = 'Fetch-result options must be specified.';\nexports[410002] = 'Invalid options. The specified value must be an object.';\nexports[410003] = 'A query id/statement id must be specified.';\nexports[410004] = 'Invalid query id/statement id. The specified value must be a string.';\nexports[410005] = 'Invalid complete callback. The specified value must be a function.';\nexports[410006] = 'Invalid streamResult flag. The specified value must be a boolean.';\nexports[410007] = 'Invalid fetchAsString value. The specified value must be an Array.';\nexports[410008] = 'Invalid fetchAsString type: %s. The supported types are: String, Boolean, Number, Date, Buffer, and JSON.';\nexports[410009] = 'Invalid cwd (current working directory) type: %s. The specified value must be a string.';\n\n// 411001\nexports[411001] = 'Invalid options. The specified value must be an object.';\nexports[411002] = 'Invalid start index. The specified value must be a number.';\nexports[411003] = 'Invalid end index. The specified value must be a number.';\nexports[411004] = 'Invalid fetchAsString value. The specified value must be an Array.';\nexports[411005] = 'Invalid fetchAsString type: %s. The supported types are: String, Boolean, Number, Date, Buffer, and JSON.';\nexports[411006] = 'Invalid row mode value. The specified value should be array or object or object_with_renamed_duplicated_columns';\n\nexports[412001] = 'Certificate is REVOKED.';\nexports[412002] = 'Certificate status is UNKNOWN.';\nexports[412003] = 'Not recognize signature algorithm.';\nexports[412004] = 'Invalid signature.';\nexports[412005] = 'No OCSP response data is attached.';\nexports[412006] = 'Invalid validity.';\nexports[412007] = 'Could not verify the certificate revocation status.';\nexports[412008] = 'Not two elements are in the cache.';\nexports[412009] = 'Cache entry expired.';\nexports[412010] = 'Failed to parse OCSP response.';\nexports[412011] = 'Invalid Signing Certificate validity.';\nexports[412012] = 'Timeout OCSP responder.';\nexports[412013] = 'Timeout OCSP Cache server.';\nexports[412014] = 'Failed to obtain OCSP response: %s';\n\n// 450001\nexports[450001] = 'Fetch-row options must be specified.';\nexports[450002] = 'Invalid options. The specified value must be an object.';\nexports[450003] = 'An each() callback must be specified.';\nexports[450004] = 'Invalid each() callback. The specified value must be a function.';\nexports[450005] = 'An end() callback must be specified.';\nexports[450006] = 'Invalid end() callback. The specified value must be a function.';\nexports[450007] = 'Operation failed because the statement is still in progress.';\n\n// 460001\nexports[460001] = 'Invalid queryId: %s';\nexports[460002] = 'Cannot retrieve data. No information returned from server for query %s';\nexports[460003] = 'Status of query %s is %s, results are unavailable';\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29uc3RhbnRzL2Vycm9yX21lc3NhZ2VzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsZUFBZTtBQUNmLGVBQWU7O0FBRWY7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlOztBQUVmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7O0FBRWY7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTs7QUFFZjtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTs7QUFFZjtBQUNBLGVBQWU7O0FBRWY7QUFDQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTs7QUFFZjtBQUNBLGVBQWU7O0FBRWY7QUFDQSxlQUFlO0FBQ2YsZUFBZTs7QUFFZjtBQUNBLGVBQWU7QUFDZixlQUFlOztBQUVmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlOztBQUVmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlOztBQUVmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlOztBQUVmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlOztBQUVmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlOztBQUVmO0FBQ0EsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTs7QUFFZjtBQUNBLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9jb25zdGFudHMvZXJyb3JfbWVzc2FnZXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gNDAwMDAxXG5leHBvcnRzWzQwMDAwMV0gPSAnQW4gaW50ZXJuYWwgZXJyb3IgaGFzIG9jY3VycmVkLiBQbGVhc2UgY29udGFjdCBTbm93Zmxha2Ugc3VwcG9ydC4nO1xuZXhwb3J0c1s0MDAwMDJdID0gJ1lvdSBhcmUgdXNpbmcgYW4gdW5zdXBwb3J0ZWQgdmVyc2lvbiBvZiBOb2RlLmpzLiBQbGVhc2UgdXNlICVzIG9yIGFib3ZlLic7XG5cbi8vIDQwMTAwMVxuZXhwb3J0c1s0MDEwMDFdID0gJ05ldHdvcmsgZXJyb3IuIENvdWxkIG5vdCByZWFjaCBTbm93Zmxha2UuJztcbmV4cG9ydHNbNDAxMDAyXSA9ICdSZXF1ZXN0IHRvIFNub3dmbGFrZSBmYWlsZWQuJztcbmV4cG9ydHNbNDAxMDAzXSA9ICdTbm93Zmxha2UgcmVzcG9uZGVkIHdpdGggbm9uLUpTT04gY29udGVudC4nO1xuZXhwb3J0c1s0MDEwMDRdID0gJ1JlcXVlc3QgdG8gU25vd2ZsYWtlIGZhaWxlZC4gIEludmFsaWQgdG9rZW4nO1xuXG4vLyA0MDIwMDFcbmV4cG9ydHNbNDAyMDAxXSA9ICdOZXR3b3JrIGVycm9yLiBDb3VsZCBub3QgcmVhY2ggUzMvQmxvYi4nO1xuZXhwb3J0c1s0MDIwMDJdID0gJ1JlcXVlc3QgdG8gUzMvQmxvYiBmYWlsZWQuJztcblxuLy8gNDAzMDAxXG5leHBvcnRzWzQwMzAwMV0gPSAnSW52YWxpZCBsb2dMZXZlbC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIG9uZSBvZiB0aGVzZSBmaXZlIGxldmVsczogZXJyb3IsIHdhcm4sIGRlYnVnLCBpbmZvIGFuZCB0cmFjZS4nO1xuZXhwb3J0c1s0MDMwMDJdID0gJ0ludmFsaWQgZGlzYWJsZU9DU1BDaGVja3Mgb3B0aW9uLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG5leHBvcnRzWzQwMzAwM10gPSAnSW52YWxpZCBPQ1NQIG1vZGUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBGQUlMX0NMT1NFRCwgRkFJTF9PUEVOLCBvciBJTlNFQ1VSRV9NT0RFLic7XG5leHBvcnRzWzQwMzAwNF0gPSAnSW52YWxpZCBjdXN0b20gSlNPTiBwYXJzZXIuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGZ1bmN0aW9uLic7XG5leHBvcnRzWzQwMzAwNV0gPSAnSW52YWxpZCBjdXN0b20gWE1MIHBhcnNlci4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgZnVuY3Rpb24uJztcbmV4cG9ydHNbNDAzMDA2XSA9ICdJbnZhbGlkIGtlZXAgYWxpdmUgdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDAzMDA3XSA9ICdJbnZhbGlkIGN1c3RvbSBjcmVkZW50aWFsIG1hbmFnZXIgdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBvYmplY3QsIGFuZCBpdCBzaG91bGQgaGF2ZSB0aHJlZSBtZXRob2RzOiB3cml0ZSwgcmVhZCwgcmVtb3ZlJztcbmV4cG9ydHNbNDAzMDA4XSA9ICdJbnZhbGlkIHVzZUVudlByb3h5IHZhbHVlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG5cbi8vIDQwNDAwMVxuZXhwb3J0c1s0MDQwMDFdID0gJ0Nvbm5lY3Rpb24gb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MDQwMDJdID0gJ0ludmFsaWQgY29ubmVjdGlvbiBvcHRpb25zLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYW4gb2JqZWN0Lic7XG5leHBvcnRzWzQwNDAwM10gPSAnQSB1c2VyIG5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDA0MDA0XSA9ICdJbnZhbGlkIHVzZXIgbmFtZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAwNV0gPSAnQSBwYXNzd29yZCBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MDQwMDZdID0gJ0ludmFsaWQgcGFzc3dvcmQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwMDddID0gJ0FuIGFjY291bnQgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDA0MDA4XSA9ICdJbnZhbGlkIGFjY291bnQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwMDldID0gJ0FuIGFjY2Vzc1VybCBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MDQwMTBdID0gJ0ludmFsaWQgYWNjZXNzVXJsLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDExXSA9ICdJbnZhbGlkIHdhcmVob3VzZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAxMl0gPSAnSW52YWxpZCBkYXRhYmFzZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAxM10gPSAnSW52YWxpZCBzY2hlbWEuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwMTRdID0gJ0ludmFsaWQgcm9sZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAxNV0gPSAnQSBwcm94eUhvc3QgbXVzdCBiZSBzcGVjaWZpZWQnO1xuZXhwb3J0c1s0MDQwMTZdID0gJ0ludmFsaWQgcHJveHlIb3N0LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDE3XSA9ICdBIHByb3h5UG9ydCBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MDQwMThdID0gJ0ludmFsaWQgcHJveHlQb3J0LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuJztcbmV4cG9ydHNbNDA0MDE5XSA9ICdJbnZhbGlkIHN0cmVhbVJlc3VsdCBmbGFnLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG5leHBvcnRzWzQwNDAyMF0gPSAnSW52YWxpZCBmZXRjaEFzU3RyaW5nIG9wdGlvbi4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGFuIEFycmF5Lic7XG5leHBvcnRzWzQwNDAyMV0gPSAnSW52YWxpZCBmZXRjaEFzU3RyaW5nIHR5cGU6ICVzLiBUaGUgc3VwcG9ydGVkIHR5cGVzIGFyZTogU3RyaW5nLCBCb29sZWFuLCBOdW1iZXIsIERhdGUsIEJ1ZmZlciwgYW5kIEpTT04uJztcbmV4cG9ydHNbNDA0MDIyXSA9ICdJbnZhbGlkIHJlZ2lvbi4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAyM10gPSAnSW52YWxpZCBjbGllbnRTZXNzaW9uS2VlcEFsaXZlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG5leHBvcnRzWzQwNDAyNF0gPSAnSW52YWxpZCBjbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBudW1iZXIuJztcbmV4cG9ydHNbNDA0MDI1XSA9ICdJbnZhbGlkIGpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4nO1xuZXhwb3J0c1s0MDQwMjZdID0gJ0ludmFsaWQgcHJpdmF0ZSBrZXkuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBpbiBwZW0gZm9ybWF0IG9mIHR5cGUgcGtjczgnO1xuZXhwb3J0c1s0MDQwMjddID0gJ0ludmFsaWQgcHJpdmF0ZSBrZXkgZmlsZSBsb2NhdGlvbi4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nJztcbmV4cG9ydHNbNDA0MDI4XSA9ICdJbnZhbGlkIHByaXZhdGUga2V5IHBhc3NwaHJhc2UuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyc7XG5leHBvcnRzWzQwNDAyOV0gPSAnSW52YWxpZCBvYXV0aCB0b2tlbi4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nJztcbmV4cG9ydHNbNDA0MDMwXSA9ICdJbnZhbGlkIHZhbGlkYXRlIGRlZmF1bHQgcGFyYW1ldGVycyB2YWx1ZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbic7XG5leHBvcnRzWzQwNDAzMV0gPSAnSW52YWxpZCBhcHBsaWNhdGlvbiB2YWx1ZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nIHRoYXQgc3RhcnRzIHdpdGggYSBsZXR0ZXIgYW5kIGEgbGVuZ3RoIGJldHdlZW4gMS01MCc7XG5leHBvcnRzWzQwNDAzMl0gPSAnQSBwcm94eVVzZXIgbXVzdCBiZSBzcGVjaWZpZWQnO1xuZXhwb3J0c1s0MDQwMzNdID0gJ0ludmFsaWQgcHJveHlVc2VyLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDM0XSA9ICdBIHByb3h5UGFzc3dvcmQgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDA0MDM1XSA9ICdJbnZhbGlkIHByb3h5UGFzc3dvcmQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDQwMzZdID0gJ0ludmFsaWQgbm9Qcm94eS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nLic7XG5leHBvcnRzWzQwNDAzN10gPSAnSW52YWxpZCBhcnJheUJpbmRpbmdUaHJlc2hvbGQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIG51bWJlci4nO1xuZXhwb3J0c1s0MDQwMzhdID0gJ0ludmFsaWQgZ2NzVXNlRG93bnNjb3BlZENyZWRlbnRpYWwuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDA0MDM5XSA9ICdJbnZhbGlkIGZvcmNlU3RhZ2VCaW5kRXJyb3IuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIG51bWJlci4nO1xuZXhwb3J0c1s0MDQwNDBdID0gJ0ludmFsaWQgYnJvd3NlciB0aW1lb3V0IHZhbHVlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXIuJztcbmV4cG9ydHNbNDA0MDQxXSA9ICdJbnZhbGlkIGRpc2FibGVRdWVyeUNvbnRleHRDYWNoZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbi4nO1xuZXhwb3J0c1s0MDQwNDJdID0gJ0ludmFsaWQgaW5jbHVkZVJldHJ5UmVhc29uLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG5leHBvcnRzWzQwNDA0M10gPSAnSW52YWxpZCBjbGllbnRDb25maWdGaWxlIHZhbHVlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDQ0XSA9ICdJbnZhbGlkIHJldHJ5VGltZW91dCB2YWx1ZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLic7XG5leHBvcnRzWzQwNDA0NV0gPSAnSW52YWxpZCBhY2NvdW50LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBzdWJkb21haW4gc3RyaW5nLic7XG5leHBvcnRzWzQwNDA0Nl0gPSAnSW52YWxpZCByZWdpb24uIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIHN1YmRvbWFpbiBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDQ3XSA9ICdJbnZhbGlkIGRpc2FibGVDb25zb2xlTG9naW4uIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4nO1xuZXhwb3J0c1s0MDQwNDhdID0gJ0ludmFsaWQgZGlzYWJsZUdDUFRva2VuVXBsb2FkLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuJztcbmV4cG9ydHNbNDA0MDQ4XSA9ICdJbnZhbGlkIGZvcmNlR0NQVXNlRG93bnNjb3BlZENyZWRlbnRpYWwuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4nO1xuZXhwb3J0c1s0MDQwNDldID0gJ0ludmFsaWQgY2xpZW50U3RvcmVUZW1wb3JhcnlDcmVkZW50aWFsLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG5leHBvcnRzWzQwNDA1MF0gPSAnSW52YWxpZCByZXByZXNlbnROdWxsQXNTdHJpbmdOdWxsLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuJztcbmV4cG9ydHNbNDA0MDUxXSA9ICdJbnZhbGlkIGRpc2FibGVTYW1sVVJMQ2hlY2suIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4nO1xuZXhwb3J0c1s0MDQwNTJdID0gJ0ludmFsaWQgY2xpZW50UmVxdWVzdE1GQVRva2VuLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG5leHBvcnRzWzQwNDA1M10gPSAnQSBob3N0IG11c3QgYmUgc3BlY2lmaWVkLic7XG5leHBvcnRzWzQwNDA1NF0gPSAnSW52YWxpZCBob3N0LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA0MDU1XSA9ICdJbnZhbGlkIHBhc3Njb2RlSW5QYXNzd29yZC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgYm9vbGVhbic7XG5leHBvcnRzWzQwNDA1Nl0gPSAnSW52YWxpZCBwYXNzY29kZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgc3RyaW5nJztcblxuLy8gNDA1MDAxXG5leHBvcnRzWzQwNTAwMV0gPSAnSW52YWxpZCBjYWxsYmFjay4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgZnVuY3Rpb24uJztcblxuLy8gNDA1NTAxXG5leHBvcnRzWzQwNTUwMV0gPSAnQ29ubmVjdGlvbiBhbHJlYWR5IGluIHByb2dyZXNzLic7XG5leHBvcnRzWzQwNTUwMl0gPSAnQWxyZWFkeSBjb25uZWN0ZWQuJztcbmV4cG9ydHNbNDA1NTAzXSA9ICdDb25uZWN0aW9uIGFscmVhZHkgdGVybWluYXRlZC4gQ2Fubm90IGNvbm5lY3QgYWdhaW4uJztcbmV4cG9ydHNbNDA1NTA0XSA9ICdjb25uZWN0KCkgZG9lcyBub3Qgd29yayB3aXRoIGV4dGVybmFsIGJyb3dzZXIgb3Igb2t0YSBhdXRoZW50aWNhdG9ycywgY2FsbCBjb25uZWN0QXN5bmMoKSBpbnN0ZWFkJztcbmV4cG9ydHNbNDA1NTA1XSA9ICdDb25maWd1cmF0aW9uIGZyb20gY2xpZW50IGNvbmZpZyBmaWxlIGZhaWxlZCc7XG5cbi8vIDQwNjAwMVxuZXhwb3J0c1s0MDYwMDFdID0gJ0ludmFsaWQgY2FsbGJhY2suIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGZ1bmN0aW9uLic7XG5cbi8vIDQwNjUwMVxuZXhwb3J0c1s0MDY1MDFdID0gJ05vdCBjb25uZWN0ZWQsIHNvIG5vdGhpbmcgdG8gZGVzdHJveS4nO1xuZXhwb3J0c1s0MDY1MDJdID0gJ0FscmVhZHkgZGlzY29ubmVjdGVkLic7XG5cbi8vIDQwNzAwMVxuZXhwb3J0c1s0MDcwMDFdID0gJ1VuYWJsZSB0byBwZXJmb3JtIG9wZXJhdGlvbiBiZWNhdXNlIGEgY29ubmVjdGlvbiB3YXMgbmV2ZXIgZXN0YWJsaXNoZWQuJztcbmV4cG9ydHNbNDA3MDAyXSA9ICdVbmFibGUgdG8gcGVyZm9ybSBvcGVyYXRpb24gdXNpbmcgdGVybWluYXRlZCBjb25uZWN0aW9uLic7XG5cbi8vIDQwODAwMVxuZXhwb3J0c1s0MDgwMDFdID0gJ0Egc2VyaWFsaXplZENvbm5lY3Rpb24gbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDA4MDAyXSA9ICdJbnZhbGlkIHNlcmlhbGl6ZWRDb25uZWN0aW9uLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA4MDAzXSA9ICdJbnZhbGlkIHNlcmlhbGl6ZWRDb25uZWN0aW9uLiBUaGUgdmFsdWUgbXVzdCBiZSBhIHN0cmluZyBvYnRhaW5lZCBieSBjYWxsaW5nIGFub3RoZXIgY29ubmVjdGlvblxcJ3Mgc2VyaWFsaXplKCkgbWV0aG9kLic7XG5cbi8vIDQwOTAwMVxuZXhwb3J0c1s0MDkwMDFdID0gJ0V4ZWN1dGUgb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MDkwMDJdID0gJ0ludmFsaWQgZXhlY3V0ZSBvcHRpb25zLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYW4gb2JqZWN0Lic7XG5leHBvcnRzWzQwOTAwM10gPSAnQSBzcWxUZXh0IHZhbHVlIG11c3QgYmUgc3BlY2lmaWVkLic7XG5leHBvcnRzWzQwOTAwNF0gPSAnSW52YWxpZCBzcWxUZXh0LiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDA5MDA1XSA9ICdJbnZhbGlkIGludGVybmFsIGZsYWcuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDA5MDA2XSA9ICdJbnZhbGlkIHBhcmFtZXRlcnMuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBvYmplY3QuJztcbmV4cG9ydHNbNDA5MDA3XSA9ICdJbnZhbGlkIGJpbmRzLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYW4gYXJyYXkuJztcbmV4cG9ydHNbNDA5MDA4XSA9ICdJbnZhbGlkIGJpbmQgdmFyaWFibGU6ICVzLiBPbmx5IHN0cmluZ2lmaWFibGUgdmFsdWVzIGFyZSBzdXBwb3J0ZWQuJztcbmV4cG9ydHNbNDA5MDA5XSA9ICdJbnZhbGlkIGNvbXBsZXRlIGNhbGxiYWNrLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBmdW5jdGlvbi4nO1xuZXhwb3J0c1s0MDkwMTBdID0gJ0ludmFsaWQgc3RyZWFtUmVzdWx0IGZsYWcuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDA5MDExXSA9ICdJbnZhbGlkIGZldGNoQXNTdHJpbmcgdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBBcnJheS4nO1xuZXhwb3J0c1s0MDkwMTJdID0gJ0ludmFsaWQgZmV0Y2hBc1N0cmluZyB0eXBlOiAlcy4gVGhlIHN1cHBvcnRlZCB0eXBlcyBhcmU6IFN0cmluZywgQm9vbGVhbiwgTnVtYmVyLCBEYXRlLCBCdWZmZXIsIGFuZCBKU09OLic7XG5leHBvcnRzWzQwOTAxM10gPSAnSW52YWxpZCByZXF1ZXN0SWQuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIHN0cmluZy4nO1xuZXhwb3J0c1s0MDkwMTRdID0gJ0ludmFsaWQgYXN5bmNFeGVjLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBib29sZWFuLic7XG5leHBvcnRzWzQwOTAxNV0gPSAnSW52YWxpZCBkZXNjcmliZU9ubHkuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcblxuLy8gNDEwMDAxXG5leHBvcnRzWzQxMDAwMV0gPSAnRmV0Y2gtcmVzdWx0IG9wdGlvbnMgbXVzdCBiZSBzcGVjaWZpZWQuJztcbmV4cG9ydHNbNDEwMDAyXSA9ICdJbnZhbGlkIG9wdGlvbnMuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBvYmplY3QuJztcbmV4cG9ydHNbNDEwMDAzXSA9ICdBIHF1ZXJ5IGlkL3N0YXRlbWVudCBpZCBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0MTAwMDRdID0gJ0ludmFsaWQgcXVlcnkgaWQvc3RhdGVtZW50IGlkLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcbmV4cG9ydHNbNDEwMDA1XSA9ICdJbnZhbGlkIGNvbXBsZXRlIGNhbGxiYWNrLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBmdW5jdGlvbi4nO1xuZXhwb3J0c1s0MTAwMDZdID0gJ0ludmFsaWQgc3RyZWFtUmVzdWx0IGZsYWcuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIGJvb2xlYW4uJztcbmV4cG9ydHNbNDEwMDA3XSA9ICdJbnZhbGlkIGZldGNoQXNTdHJpbmcgdmFsdWUuIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhbiBBcnJheS4nO1xuZXhwb3J0c1s0MTAwMDhdID0gJ0ludmFsaWQgZmV0Y2hBc1N0cmluZyB0eXBlOiAlcy4gVGhlIHN1cHBvcnRlZCB0eXBlcyBhcmU6IFN0cmluZywgQm9vbGVhbiwgTnVtYmVyLCBEYXRlLCBCdWZmZXIsIGFuZCBKU09OLic7XG5leHBvcnRzWzQxMDAwOV0gPSAnSW52YWxpZCBjd2QgKGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkpIHR5cGU6ICVzLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBzdHJpbmcuJztcblxuLy8gNDExMDAxXG5leHBvcnRzWzQxMTAwMV0gPSAnSW52YWxpZCBvcHRpb25zLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYW4gb2JqZWN0Lic7XG5leHBvcnRzWzQxMTAwMl0gPSAnSW52YWxpZCBzdGFydCBpbmRleC4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgbnVtYmVyLic7XG5leHBvcnRzWzQxMTAwM10gPSAnSW52YWxpZCBlbmQgaW5kZXguIFRoZSBzcGVjaWZpZWQgdmFsdWUgbXVzdCBiZSBhIG51bWJlci4nO1xuZXhwb3J0c1s0MTEwMDRdID0gJ0ludmFsaWQgZmV0Y2hBc1N0cmluZyB2YWx1ZS4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGFuIEFycmF5Lic7XG5leHBvcnRzWzQxMTAwNV0gPSAnSW52YWxpZCBmZXRjaEFzU3RyaW5nIHR5cGU6ICVzLiBUaGUgc3VwcG9ydGVkIHR5cGVzIGFyZTogU3RyaW5nLCBCb29sZWFuLCBOdW1iZXIsIERhdGUsIEJ1ZmZlciwgYW5kIEpTT04uJztcbmV4cG9ydHNbNDExMDA2XSA9ICdJbnZhbGlkIHJvdyBtb2RlIHZhbHVlLiBUaGUgc3BlY2lmaWVkIHZhbHVlIHNob3VsZCBiZSBhcnJheSBvciBvYmplY3Qgb3Igb2JqZWN0X3dpdGhfcmVuYW1lZF9kdXBsaWNhdGVkX2NvbHVtbnMnO1xuXG5leHBvcnRzWzQxMjAwMV0gPSAnQ2VydGlmaWNhdGUgaXMgUkVWT0tFRC4nO1xuZXhwb3J0c1s0MTIwMDJdID0gJ0NlcnRpZmljYXRlIHN0YXR1cyBpcyBVTktOT1dOLic7XG5leHBvcnRzWzQxMjAwM10gPSAnTm90IHJlY29nbml6ZSBzaWduYXR1cmUgYWxnb3JpdGhtLic7XG5leHBvcnRzWzQxMjAwNF0gPSAnSW52YWxpZCBzaWduYXR1cmUuJztcbmV4cG9ydHNbNDEyMDA1XSA9ICdObyBPQ1NQIHJlc3BvbnNlIGRhdGEgaXMgYXR0YWNoZWQuJztcbmV4cG9ydHNbNDEyMDA2XSA9ICdJbnZhbGlkIHZhbGlkaXR5Lic7XG5leHBvcnRzWzQxMjAwN10gPSAnQ291bGQgbm90IHZlcmlmeSB0aGUgY2VydGlmaWNhdGUgcmV2b2NhdGlvbiBzdGF0dXMuJztcbmV4cG9ydHNbNDEyMDA4XSA9ICdOb3QgdHdvIGVsZW1lbnRzIGFyZSBpbiB0aGUgY2FjaGUuJztcbmV4cG9ydHNbNDEyMDA5XSA9ICdDYWNoZSBlbnRyeSBleHBpcmVkLic7XG5leHBvcnRzWzQxMjAxMF0gPSAnRmFpbGVkIHRvIHBhcnNlIE9DU1AgcmVzcG9uc2UuJztcbmV4cG9ydHNbNDEyMDExXSA9ICdJbnZhbGlkIFNpZ25pbmcgQ2VydGlmaWNhdGUgdmFsaWRpdHkuJztcbmV4cG9ydHNbNDEyMDEyXSA9ICdUaW1lb3V0IE9DU1AgcmVzcG9uZGVyLic7XG5leHBvcnRzWzQxMjAxM10gPSAnVGltZW91dCBPQ1NQIENhY2hlIHNlcnZlci4nO1xuZXhwb3J0c1s0MTIwMTRdID0gJ0ZhaWxlZCB0byBvYnRhaW4gT0NTUCByZXNwb25zZTogJXMnO1xuXG4vLyA0NTAwMDFcbmV4cG9ydHNbNDUwMDAxXSA9ICdGZXRjaC1yb3cgb3B0aW9ucyBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0NTAwMDJdID0gJ0ludmFsaWQgb3B0aW9ucy4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdC4nO1xuZXhwb3J0c1s0NTAwMDNdID0gJ0FuIGVhY2goKSBjYWxsYmFjayBtdXN0IGJlIHNwZWNpZmllZC4nO1xuZXhwb3J0c1s0NTAwMDRdID0gJ0ludmFsaWQgZWFjaCgpIGNhbGxiYWNrLiBUaGUgc3BlY2lmaWVkIHZhbHVlIG11c3QgYmUgYSBmdW5jdGlvbi4nO1xuZXhwb3J0c1s0NTAwMDVdID0gJ0FuIGVuZCgpIGNhbGxiYWNrIG11c3QgYmUgc3BlY2lmaWVkLic7XG5leHBvcnRzWzQ1MDAwNl0gPSAnSW52YWxpZCBlbmQoKSBjYWxsYmFjay4gVGhlIHNwZWNpZmllZCB2YWx1ZSBtdXN0IGJlIGEgZnVuY3Rpb24uJztcbmV4cG9ydHNbNDUwMDA3XSA9ICdPcGVyYXRpb24gZmFpbGVkIGJlY2F1c2UgdGhlIHN0YXRlbWVudCBpcyBzdGlsbCBpbiBwcm9ncmVzcy4nO1xuXG4vLyA0NjAwMDFcbmV4cG9ydHNbNDYwMDAxXSA9ICdJbnZhbGlkIHF1ZXJ5SWQ6ICVzJztcbmV4cG9ydHNbNDYwMDAyXSA9ICdDYW5ub3QgcmV0cmlldmUgZGF0YS4gTm8gaW5mb3JtYXRpb24gcmV0dXJuZWQgZnJvbSBzZXJ2ZXIgZm9yIHF1ZXJ5ICVzJztcbmV4cG9ydHNbNDYwMDAzXSA9ICdTdGF0dXMgb2YgcXVlcnkgJXMgaXMgJXMsIHJlc3VsdHMgYXJlIHVuYXZhaWxhYmxlJztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/constants/error_messages.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/constants/gs_errors.js":
/*!***************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/constants/gs_errors.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("const code = {};\n\ncode.INCORRECT_USERNAME_PASSWORD = '390100';\ncode.SESSION_TOKEN_INVALID = '390104';\ncode.GONE_SESSION = '390111';\ncode.SESSION_TOKEN_EXPIRED = '390112';\ncode.MASTER_TOKEN_EXPIRED = '390114';\ncode.ID_TOKEN_INVALID = '390195';\n\nexports.code = code;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29uc3RhbnRzL2dzX2Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9jb25zdGFudHMvZ3NfZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGNvZGUgPSB7fTtcblxuY29kZS5JTkNPUlJFQ1RfVVNFUk5BTUVfUEFTU1dPUkQgPSAnMzkwMTAwJztcbmNvZGUuU0VTU0lPTl9UT0tFTl9JTlZBTElEID0gJzM5MDEwNCc7XG5jb2RlLkdPTkVfU0VTU0lPTiA9ICczOTAxMTEnO1xuY29kZS5TRVNTSU9OX1RPS0VOX0VYUElSRUQgPSAnMzkwMTEyJztcbmNvZGUuTUFTVEVSX1RPS0VOX0VYUElSRUQgPSAnMzkwMTE0JztcbmNvZGUuSURfVE9LRU5fSU5WQUxJRCA9ICczOTAxOTUnO1xuXG5leHBvcnRzLmNvZGUgPSBjb2RlOyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/constants/gs_errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/constants/query_status.js":
/*!******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/constants/query_status.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("const code = {};\n\ncode.RUNNING = 'RUNNING';\ncode.ABORTING = 'ABORTING';\ncode.SUCCESS = 'SUCCESS';\ncode.FAILED_WITH_ERROR = 'FAILED_WITH_ERROR';\ncode.ABORTED = 'ABORTED';\ncode.QUEUED = 'QUEUED';\ncode.FAILED_WITH_INCIDENT = 'FAILED_WITH_INCIDENT';\ncode.DISCONNECTED = 'DISCONNECTED';\ncode.RESUMING_WAREHOUSE = 'RESUMING_WAREHOUSE';\n// purposeful typo.Is present in QueryDTO.java\ncode.QUEUED_REPARING_WAREHOUSE = 'QUEUED_REPARING_WAREHOUSE';\ncode.RESTARTED = 'RESTARTED';\ncode.BLOCKED = 'BLOCKED';\ncode.NO_DATA = 'NO_DATA';\ncode.NO_QUERY_DATA = 'NO_QUERY_DATA';\n\n// All running query statuses\nconst runningStatuses =\n  [\n    code.RUNNING,\n    code.RESUMING_WAREHOUSE,\n    code.QUEUED,\n    code.QUEUED_REPARING_WAREHOUSE,\n    code.NO_DATA,\n  ];\n\n// All error query statuses\nconst errorStatuses =\n  [\n    code.ABORTING,\n    code.FAILED_WITH_ERROR,\n    code.ABORTED,\n    code.FAILED_WITH_INCIDENT,\n    code.DISCONNECTED,\n    code.BLOCKED,\n  ];\n\nexports.code = code;\nexports.runningStatuses = runningStatuses;\nexports.errorStatuses = errorStatuses;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29uc3RhbnRzL3F1ZXJ5X3N0YXR1cy5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWix1QkFBdUI7QUFDdkIscUJBQXFCIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2NvbnN0YW50cy9xdWVyeV9zdGF0dXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY29kZSA9IHt9O1xuXG5jb2RlLlJVTk5JTkcgPSAnUlVOTklORyc7XG5jb2RlLkFCT1JUSU5HID0gJ0FCT1JUSU5HJztcbmNvZGUuU1VDQ0VTUyA9ICdTVUNDRVNTJztcbmNvZGUuRkFJTEVEX1dJVEhfRVJST1IgPSAnRkFJTEVEX1dJVEhfRVJST1InO1xuY29kZS5BQk9SVEVEID0gJ0FCT1JURUQnO1xuY29kZS5RVUVVRUQgPSAnUVVFVUVEJztcbmNvZGUuRkFJTEVEX1dJVEhfSU5DSURFTlQgPSAnRkFJTEVEX1dJVEhfSU5DSURFTlQnO1xuY29kZS5ESVNDT05ORUNURUQgPSAnRElTQ09OTkVDVEVEJztcbmNvZGUuUkVTVU1JTkdfV0FSRUhPVVNFID0gJ1JFU1VNSU5HX1dBUkVIT1VTRSc7XG4vLyBwdXJwb3NlZnVsIHR5cG8uSXMgcHJlc2VudCBpbiBRdWVyeURUTy5qYXZhXG5jb2RlLlFVRVVFRF9SRVBBUklOR19XQVJFSE9VU0UgPSAnUVVFVUVEX1JFUEFSSU5HX1dBUkVIT1VTRSc7XG5jb2RlLlJFU1RBUlRFRCA9ICdSRVNUQVJURUQnO1xuY29kZS5CTE9DS0VEID0gJ0JMT0NLRUQnO1xuY29kZS5OT19EQVRBID0gJ05PX0RBVEEnO1xuY29kZS5OT19RVUVSWV9EQVRBID0gJ05PX1FVRVJZX0RBVEEnO1xuXG4vLyBBbGwgcnVubmluZyBxdWVyeSBzdGF0dXNlc1xuY29uc3QgcnVubmluZ1N0YXR1c2VzID1cbiAgW1xuICAgIGNvZGUuUlVOTklORyxcbiAgICBjb2RlLlJFU1VNSU5HX1dBUkVIT1VTRSxcbiAgICBjb2RlLlFVRVVFRCxcbiAgICBjb2RlLlFVRVVFRF9SRVBBUklOR19XQVJFSE9VU0UsXG4gICAgY29kZS5OT19EQVRBLFxuICBdO1xuXG4vLyBBbGwgZXJyb3IgcXVlcnkgc3RhdHVzZXNcbmNvbnN0IGVycm9yU3RhdHVzZXMgPVxuICBbXG4gICAgY29kZS5BQk9SVElORyxcbiAgICBjb2RlLkZBSUxFRF9XSVRIX0VSUk9SLFxuICAgIGNvZGUuQUJPUlRFRCxcbiAgICBjb2RlLkZBSUxFRF9XSVRIX0lOQ0lERU5ULFxuICAgIGNvZGUuRElTQ09OTkVDVEVELFxuICAgIGNvZGUuQkxPQ0tFRCxcbiAgXTtcblxuZXhwb3J0cy5jb2RlID0gY29kZTtcbmV4cG9ydHMucnVubmluZ1N0YXR1c2VzID0gcnVubmluZ1N0YXR1c2VzO1xuZXhwb3J0cy5lcnJvclN0YXR1c2VzID0gZXJyb3JTdGF0dXNlcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/constants/query_status.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/constants/row_mode.js":
/*!**************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/constants/row_mode.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\n\nconst ErrorCodes = Errors.codes;\nconst ARRAY = 'array';\nconst OBJECT = 'object';\nconst OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS = 'object_with_renamed_duplicated_columns';\n\nconst isValidRowMode = (rowMode) => [ARRAY, OBJECT, OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS].includes(rowMode);\n\nconst checkRowModeValid = (rowMode) => {\n  Errors.checkArgumentValid(isValidRowMode(rowMode),\n    ErrorCodes.ERR_STMT_STREAM_ROWS_INVALID_ROW_MODE, JSON.stringify(rowMode));\n};\n\nexports.ARRAY = ARRAY;\nexports.OBJECT = OBJECT;\nexports.OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS = OBJECT_WITH_RENAMED_DUPLICATED_COLUMNS;\nexports.isValidRowMode = isValidRowMode;\nexports.checkRowModeValid = checkRowModeValid;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29uc3RhbnRzL3Jvd19tb2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVzs7QUFFbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiLGNBQWM7QUFDZCw4Q0FBOEM7QUFDOUMsc0JBQXNCO0FBQ3RCLHlCQUF5QiIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9jb25zdGFudHMvcm93X21vZGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5cbmNvbnN0IEVycm9yQ29kZXMgPSBFcnJvcnMuY29kZXM7XG5jb25zdCBBUlJBWSA9ICdhcnJheSc7XG5jb25zdCBPQkpFQ1QgPSAnb2JqZWN0JztcbmNvbnN0IE9CSkVDVF9XSVRIX1JFTkFNRURfRFVQTElDQVRFRF9DT0xVTU5TID0gJ29iamVjdF93aXRoX3JlbmFtZWRfZHVwbGljYXRlZF9jb2x1bW5zJztcblxuY29uc3QgaXNWYWxpZFJvd01vZGUgPSAocm93TW9kZSkgPT4gW0FSUkFZLCBPQkpFQ1QsIE9CSkVDVF9XSVRIX1JFTkFNRURfRFVQTElDQVRFRF9DT0xVTU5TXS5pbmNsdWRlcyhyb3dNb2RlKTtcblxuY29uc3QgY2hlY2tSb3dNb2RlVmFsaWQgPSAocm93TW9kZSkgPT4ge1xuICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKGlzVmFsaWRSb3dNb2RlKHJvd01vZGUpLFxuICAgIEVycm9yQ29kZXMuRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9ST1dfTU9ERSwgSlNPTi5zdHJpbmdpZnkocm93TW9kZSkpO1xufTtcblxuZXhwb3J0cy5BUlJBWSA9IEFSUkFZO1xuZXhwb3J0cy5PQkpFQ1QgPSBPQkpFQ1Q7XG5leHBvcnRzLk9CSkVDVF9XSVRIX1JFTkFNRURfRFVQTElDQVRFRF9DT0xVTU5TID0gT0JKRUNUX1dJVEhfUkVOQU1FRF9EVVBMSUNBVEVEX0NPTFVNTlM7XG5leHBvcnRzLmlzVmFsaWRSb3dNb2RlID0gaXNWYWxpZFJvd01vZGU7XG5leHBvcnRzLmNoZWNrUm93TW9kZVZhbGlkID0gY2hlY2tSb3dNb2RlVmFsaWQ7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/constants/row_mode.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/constants/sf_params.js":
/*!***************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/constants/sf_params.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("exports.paramsNames = Object.freeze({\n  SF_REQUEST_GUID: 'request_guid',\n  SF_REQUEST_ID: 'requestId',\n  SF_TOKEN: 'token',\n  SF_WAREHOUSE_NAME: 'warehouse',\n  SF_DB_NAME: 'databaseName',\n  SF_SCHEMA_NAME: 'schemaName',\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29uc3RhbnRzL3NmX3BhcmFtcy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9jb25zdGFudHMvc2ZfcGFyYW1zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydHMucGFyYW1zTmFtZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgU0ZfUkVRVUVTVF9HVUlEOiAncmVxdWVzdF9ndWlkJyxcbiAgU0ZfUkVRVUVTVF9JRDogJ3JlcXVlc3RJZCcsXG4gIFNGX1RPS0VOOiAndG9rZW4nLFxuICBTRl9XQVJFSE9VU0VfTkFNRTogJ3dhcmVob3VzZScsXG4gIFNGX0RCX05BTUU6ICdkYXRhYmFzZU5hbWUnLFxuICBTRl9TQ0hFTUFfTkFNRTogJ3NjaGVtYU5hbWUnLFxufSk7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/constants/sf_params.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/core.js":
/*!************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/core.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Connection = __webpack_require__(/*! ./connection/connection */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/connection.js\");\nconst ConnectionConfig = __webpack_require__(/*! ./connection/connection_config */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/connection_config.js\");\nconst ConnectionContext = __webpack_require__(/*! ./connection/connection_context */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/connection_context.js\");\nconst GenericPool = __webpack_require__(/*! generic-pool */ \"(rsc)/./node_modules/generic-pool/index.js\");\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst LoggerCore = __webpack_require__(/*! ./logger/core */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger/core.js\");\nconst DataTypes = __webpack_require__(/*! ./connection/result/data_types */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/result/data_types.js\");\nconst GlobalConfig = __webpack_require__(/*! ./global_config */ \"(rsc)/./node_modules/snowflake-sdk/lib/global_config.js\");\nconst { loadConnectionConfiguration } = __webpack_require__(/*! ./configuration/connection_configuration */ \"(rsc)/./node_modules/snowflake-sdk/lib/configuration/connection_configuration.js\");\n\n/**\n * Creates a new instance of the Snowflake core module.\n *\n * @param {Object} options\n *\n * @returns {Object}\n * @constructor\n */\nfunction Core(options) {\n  // validate input\n  Errors.assertInternal(Util.isObject(options));\n  Errors.assertInternal(\n    Util.exists(options.httpClient || options.httpClientClass));\n  Errors.assertInternal(Util.exists(options.loggerClass));\n\n  // set the logger instance\n  Logger.setInstance(new (options.loggerClass)());\n  Logger.getInstance().trace('Logger was initialized.');\n\n  // if a connection class is specified, it must be an object or function\n  let connectionClass = options.connectionClass;\n  if (Util.exists(connectionClass)) {\n    Errors.assertInternal(\n      Util.isObject(connectionClass) || Util.isFunction(connectionClass));\n    Logger.getInstance().debug('Connection class provided in driver core options will be used.');\n  } else {\n    // fall back to Connection\n    connectionClass = Connection;\n    Logger.getInstance().debug('Connection class was not overridden. Default connection class will be used.');\n  }\n\n  const qaMode = options.qaMode;\n  const clientInfo = options.client;\n  const ocspModes = GlobalConfig.ocspModes;\n\n  /**\n   * Creates a new Connection instance.\n   *\n   * @param {Object} connectionOptions\n   * @param {Object} [config]\n   *\n   * @returns {Object}\n   */\n  const createConnection = function createConnection(connectionOptions, config) {\n    // create a new ConnectionConfig and skip credential-validation if a config\n    // object has been specified; this is because if a config object has been\n    // specified, we're trying to deserialize a connection and the account name,\n    // username and password don't need to be specified because the config\n    // object already contains the tokens we need\n    // Alternatively, if the connectionOptions includes token information then we will use that\n    // instead of the username/password\n\n    Logger.getInstance().info('Creating new connection object');\n\n    if (connectionOptions == null) {\n      Logger.getInstance().info('Connection options were not specified. Loading connection configuration.');\n      try {\n        connectionOptions = loadConnectionConfiguration();\n      } catch ( error ) {\n        Logger.getInstance().error('Unable to load the connection configuration. Error: %s',  error.message);\n        Errors.checkArgumentExists(Util.exists(connectionOptions),\n          ErrorCodes.ERR_CONN_CREATE_MISSING_OPTIONS);\n      }\n    }\n\n    const validateCredentials = !config && (connectionOptions && !connectionOptions.sessionToken);\n\n    const connectionConfig =\n      new ConnectionConfig(connectionOptions, validateCredentials, qaMode, clientInfo);\n    Logger.getInstance().debug('Connection configuration object created');\n\n    // if an http client was specified in the options passed to the module, use\n    // it, otherwise create a new HttpClient\n    const httpClient = options.httpClient ||\n      new options.httpClientClass(connectionConfig);\n    Logger.getInstance().debug('HttpClient setup finished');\n\n\n    const connection = new connectionClass(\n      new ConnectionContext(connectionConfig, httpClient, config)\n    );\n\n    Logger.getInstance().info('Connection[id: %s] - connection object created successfully.', connection.getId());\n    return connection;\n  };\n\n  const instance =\n    {\n      ocspModes: ocspModes,\n      /**\n       * Creates a connection object that can be used to communicate with\n       * Snowflake.\n       *\n       * @param {Object} options\n       *\n       * @returns {Object}\n       */\n      createConnection: function (options) {\n        return createConnection(options);\n      },\n\n      /**\n      * Creates a connection pool for Snowflake connections\n      *\n      * @param {Object} connectionOptions\n      * @param {Object} poolOptions\n      *\n      * @returns {Object}\n      */\n      createPool: function (connectionOptions, poolOptions) {\n        return createPool(connectionOptions, poolOptions);\n      },\n\n      /**\n       * Deserializes a serialized connection.\n       *\n       * @param {Object} options\n       * @param {String} serializedConnection\n       *\n       * @returns {Object}\n       */\n      deserializeConnection: function (options, serializedConnection) {\n        // check for missing serializedConfig\n        Logger.getInstance().trace('Deserializing connection');\n\n        Errors.checkArgumentExists(Util.exists(serializedConnection),\n          ErrorCodes.ERR_CONN_DESERIALIZE_MISSING_CONFIG);\n\n        // check for invalid serializedConfig\n        Errors.checkArgumentValid(Util.isString(serializedConnection),\n          ErrorCodes.ERR_CONN_DESERIALIZE_INVALID_CONFIG_TYPE);\n\n        Logger.getInstance().debug('Deserializing connection from string object');\n\n        // try to json-parse serializedConfig\n        let config;\n        try {\n          config = JSON.parse(serializedConnection);\n        } finally {\n          // if serializedConfig can't be parsed to json, throw an error\n          Errors.checkArgumentValid(Util.isObject(config),\n            ErrorCodes.ERR_CONN_DESERIALIZE_INVALID_CONFIG_FORM);\n        }\n        Logger.getInstance().debug('Connection deserialized successfully');\n\n        return createConnection(options, config);\n      },\n\n      /**\n       * Serializes a given connection.\n       *\n       * @param {Object} connection\n       *\n       * @returns {String} a serialized version of the connection.\n       */\n      serializeConnection: function (connection) {\n        Logger.getInstance().trace('Connection[id: %s] - serializing connection.', connection.getId());\n        return connection ? connection.serialize() : connection;\n      },\n\n      /**\n       * Configures this instance of the Snowflake core module.\n       *\n       * @param {Object} options\n       */\n      configure: function (options) {\n        Logger.getInstance().debug('Configuring Snowflake core module.');\n        const logLevel = extractLogLevel(options);\n        const logFilePath = options.logFilePath;\n        const additionalLogToConsole = options.additionalLogToConsole;\n\n        if (logLevel != null || logFilePath) {\n          Logger.getInstance().configure(\n            {\n              level: logLevel,\n              filePath: logFilePath,\n              additionalLogToConsole: additionalLogToConsole\n            });\n          Logger.getInstance().info('Configuring logger with level: %s, filePath: %s, additionalLogToConsole: %s', logLevel, logFilePath, additionalLogToConsole);\n        }\n\n        const disableOCSPChecks = options.disableOCSPChecks;\n        if (Util.exists(disableOCSPChecks)) {\n          // check that the specified value is a boolean\n          Errors.checkArgumentValid(Util.isBoolean(disableOCSPChecks),\n            ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_DISABLE_OCSP_CHECKS);\n\n          GlobalConfig.setDisableOCSPChecks(disableOCSPChecks);\n          Logger.getInstance().debug('Setting disableOCSPChecks to value from core options: %s', disableOCSPChecks);\n        }\n\n        const ocspFailOpen = options.ocspFailOpen;\n        if (Util.exists(ocspFailOpen)) {\n          Errors.checkArgumentValid(Util.isBoolean(ocspFailOpen),\n            ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_OCSP_MODE);\n\n          GlobalConfig.setOcspFailOpen(ocspFailOpen);\n          Logger.getInstance().debug('Setting ocspFailOpen to value from core options: %s ', ocspFailOpen);\n        }\n\n        const jsonColumnVariantParser = options.jsonColumnVariantParser;\n        if (Util.exists(jsonColumnVariantParser)) {\n          Errors.checkArgumentValid(Util.isFunction(jsonColumnVariantParser),\n            ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_JSON_PARSER);\n\n          GlobalConfig.setJsonColumnVariantParser(jsonColumnVariantParser);\n          Logger.getInstance().debug('Setting JSON Column Variant Parser to value from core options');\n        }\n\n        const xmlColumnVariantParser = options.xmlColumnVariantParser;\n        const xmlParserConfig = options.xmlParserConfig;\n        if (Util.exists(xmlColumnVariantParser)) {\n          Errors.checkArgumentValid(Util.isFunction(xmlColumnVariantParser),\n            ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_XML_PARSER);\n\n          GlobalConfig.setXmlColumnVariantParser(xmlColumnVariantParser);\n          Logger.getInstance().debug('Setting XML Column Variant Parser to value from core options');\n        } else if (Util.exists(xmlParserConfig)) {\n          GlobalConfig.createXmlColumnVariantParserWithParameters(xmlParserConfig);\n          Logger.getInstance().debug('Creating XML Column Variant Parser with parameters from core options');\n        }\n\n        const keepAlive = options.keepAlive;\n        if (Util.exists(keepAlive)) {\n          Errors.checkArgumentValid(Util.isBoolean(keepAlive),\n            ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_KEEP_ALIVE);\n\n          GlobalConfig.setKeepAlive(keepAlive);\n          Logger.getInstance().debug('Setting keepAlive to value from core options: %s', keepAlive);\n        }\n\n        const useEnvProxy = options.useEnvProxy;\n        if (Util.exists(useEnvProxy)) {\n          Errors.checkArgumentValid(Util.isBoolean(useEnvProxy),\n            ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_USE_ENV_PROXY);\n\n          GlobalConfig.setEnvProxy(useEnvProxy);\n        }\n\n        const customCredentialManager = options.customCredentialManager;\n        if (Util.exists(customCredentialManager)) {\n          Errors.checkArgumentValid(Util.isObject(customCredentialManager),\n            ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_CUSTOM_CREDENTIAL_MANAGER);\n\n          GlobalConfig.setCustomCredentialManager(customCredentialManager);\n          Logger.getInstance().debug('Setting customCredentialManager to value from core options %s', customCredentialManager);\n        }\n      }\n    };\n\n  function extractLogLevel(options) {\n    const logTag = options.logLevel;\n    if (Util.exists(logTag)) {\n      Errors.checkArgumentValid(LoggerCore.isValidLogTag(logTag),\n        ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_LOG_LEVEL);\n\n      return LoggerCore.logTagToLevel(logTag);\n    }\n    return null;\n  }\n\n  // add some read-only constants\n  const nativeTypeValues = DataTypes.NativeTypes.values;\n  Object.defineProperties(instance,\n    {\n      STRING: { value: nativeTypeValues.STRING },\n      BOOLEAN: { value: nativeTypeValues.BOOLEAN },\n      NUMBER: { value: nativeTypeValues.NUMBER },\n      DATE: { value: nativeTypeValues.DATE },\n      OBJECT: { value: nativeTypeValues.OBJECT },\n      ARRAY: { value: nativeTypeValues.ARRAY },\n      MAP: { value: nativeTypeValues.MAP },\n      JSON: { value: nativeTypeValues.JSON }\n    });\n\n  /**\n  * Factory for Snowflake connections based on Generic Pool\n  *\n  * @param {Object} connectionOptions\n  *\n  * @returns {null}\n  */\n  function ConnectionFactory(connectionOptions) {\n    /**\n     * Creates a new connection instance.\n     *\n     * @returns {Object}\n     */\n    this.create = function () {\n      Logger.getInstance().debug('Creating new connection from factory.');\n      const connection = new createConnection(connectionOptions);\n\n      return new Promise((resolve, reject) => {\n        connection.connect(\n          function (err, conn) {\n            if (err) {\n              Logger.getInstance().error('Connection[id: %s] - Unable to connect. Error: %s', conn.getId(), err.message);\n              reject(new Error(err.message));\n            } else {\n              Logger.getInstance().debug('Connection[id: %s] - connected successfully. Callback called.', conn.getId());\n              resolve(conn);\n            }\n          }\n        );\n      });\n    };\n\n    /**\n    * Destroys the specified connection instance.\n    *\n    * @param {Object} connection\n    *\n    * @returns {Object}\n    */\n    this.destroy = function (connection) {\n      Logger.getInstance().debug('Destroying connection instance.');\n      return new Promise((resolve) => {\n        connection.destroy(function (err, conn) {\n          if (err) {\n            Logger.getInstance().error('Connection[id: %s] - disconnecting failed with error: %s', conn.getId(), err.message);\n          } else {\n            Logger.getInstance().debug('Connection[id: %s] - connection disconnected successfully. Callback called.', conn.getId());\n          }\n          resolve();\n        });\n      });\n    };\n\n    /**\n    * Returns the status of the connection.\n    *\n    * @param {Object} connection\n    *\n    * @returns {Boolean}\n    */\n    this.validate = async function (connection) {\n      Logger.getInstance().debug('Connection[id: %s] - validating connection instance', connection.getId());\n      return await connection.isValidAsync();\n    };\n  }\n\n  /**\n  * Creates a connection pool for Snowflake connections\n  *\n  * @param {Object} connectionOptions\n  * @param {Object} poolOptions\n  *\n  * @returns {Object}\n  */\n  const createPool = function createPool(connectionOptions, poolOptions) {\n    Logger.getInstance().info('Creating connection pool with provided options');\n\n    const connectionPool = GenericPool.createPool(\n      new ConnectionFactory(connectionOptions),\n      poolOptions\n    );\n    Logger.getInstance().debug('Base for connection pool created');\n\n    // avoid infinite loop if factory creation fails\n    connectionPool.on('factoryCreateError', function (err) {\n      Logger.getInstance().error('Connection pool factory creation failed: %s',  err.message);\n      const clientResourceRequest = connectionPool._waitingClientsQueue.dequeue();\n      if (clientResourceRequest) {\n        clientResourceRequest.reject(err);\n      }\n    });\n\n    Logger.getInstance().info('Connection pool object created successfully');\n\n    return connectionPool;\n  };\n\n  return instance;\n}\n\nmodule.exports = Core;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvY29yZS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsOERBQVE7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLGtFQUFVO0FBQ2pDO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsZ0dBQXlCO0FBQ3BELHlCQUF5QixtQkFBTyxDQUFDLDhHQUFnQztBQUNqRSwwQkFBMEIsbUJBQU8sQ0FBQyxnSEFBaUM7QUFDbkUsb0JBQW9CLG1CQUFPLENBQUMsZ0VBQWM7QUFDMUMsZUFBZSxtQkFBTyxDQUFDLGtFQUFVO0FBQ2pDLG1CQUFtQixtQkFBTyxDQUFDLDRFQUFlO0FBQzFDLGtCQUFrQixtQkFBTyxDQUFDLDhHQUFnQztBQUMxRCxxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBaUI7QUFDOUMsUUFBUSw4QkFBOEIsRUFBRSxtQkFBTyxDQUFDLGtJQUEwQzs7QUFFMUY7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLFFBQVE7QUFDekI7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsUUFBUTtBQUN4QixnQkFBZ0IsUUFBUTtBQUN4QjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGdDQUFnQztBQUNoRCxpQkFBaUIsaUNBQWlDO0FBQ2xELGdCQUFnQixnQ0FBZ0M7QUFDaEQsY0FBYyw4QkFBOEI7QUFDNUMsZ0JBQWdCLGdDQUFnQztBQUNoRCxlQUFlLCtCQUErQjtBQUM5QyxhQUFhLDZCQUE2QjtBQUMxQyxjQUFjO0FBQ2QsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9jb3JlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5jb25zdCBFcnJvckNvZGVzID0gRXJyb3JzLmNvZGVzO1xuY29uc3QgQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi9jb25uZWN0aW9uJyk7XG5jb25zdCBDb25uZWN0aW9uQ29uZmlnID0gcmVxdWlyZSgnLi9jb25uZWN0aW9uL2Nvbm5lY3Rpb25fY29uZmlnJyk7XG5jb25zdCBDb25uZWN0aW9uQ29udGV4dCA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi9jb25uZWN0aW9uX2NvbnRleHQnKTtcbmNvbnN0IEdlbmVyaWNQb29sID0gcmVxdWlyZSgnZ2VuZXJpYy1wb29sJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuY29uc3QgTG9nZ2VyQ29yZSA9IHJlcXVpcmUoJy4vbG9nZ2VyL2NvcmUnKTtcbmNvbnN0IERhdGFUeXBlcyA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbi9yZXN1bHQvZGF0YV90eXBlcycpO1xuY29uc3QgR2xvYmFsQ29uZmlnID0gcmVxdWlyZSgnLi9nbG9iYWxfY29uZmlnJyk7XG5jb25zdCB7IGxvYWRDb25uZWN0aW9uQ29uZmlndXJhdGlvbiB9ID0gcmVxdWlyZSgnLi9jb25maWd1cmF0aW9uL2Nvbm5lY3Rpb25fY29uZmlndXJhdGlvbicpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgaW5zdGFuY2Ugb2YgdGhlIFNub3dmbGFrZSBjb3JlIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQ29yZShvcHRpb25zKSB7XG4gIC8vIHZhbGlkYXRlIGlucHV0XG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpKTtcbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFxuICAgIFV0aWwuZXhpc3RzKG9wdGlvbnMuaHR0cENsaWVudCB8fCBvcHRpb25zLmh0dHBDbGllbnRDbGFzcykpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5leGlzdHMob3B0aW9ucy5sb2dnZXJDbGFzcykpO1xuXG4gIC8vIHNldCB0aGUgbG9nZ2VyIGluc3RhbmNlXG4gIExvZ2dlci5zZXRJbnN0YW5jZShuZXcgKG9wdGlvbnMubG9nZ2VyQ2xhc3MpKCkpO1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnTG9nZ2VyIHdhcyBpbml0aWFsaXplZC4nKTtcblxuICAvLyBpZiBhIGNvbm5lY3Rpb24gY2xhc3MgaXMgc3BlY2lmaWVkLCBpdCBtdXN0IGJlIGFuIG9iamVjdCBvciBmdW5jdGlvblxuICBsZXQgY29ubmVjdGlvbkNsYXNzID0gb3B0aW9ucy5jb25uZWN0aW9uQ2xhc3M7XG4gIGlmIChVdGlsLmV4aXN0cyhjb25uZWN0aW9uQ2xhc3MpKSB7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFxuICAgICAgVXRpbC5pc09iamVjdChjb25uZWN0aW9uQ2xhc3MpIHx8IFV0aWwuaXNGdW5jdGlvbihjb25uZWN0aW9uQ2xhc3MpKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbiBjbGFzcyBwcm92aWRlZCBpbiBkcml2ZXIgY29yZSBvcHRpb25zIHdpbGwgYmUgdXNlZC4nKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBmYWxsIGJhY2sgdG8gQ29ubmVjdGlvblxuICAgIGNvbm5lY3Rpb25DbGFzcyA9IENvbm5lY3Rpb247XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb24gY2xhc3Mgd2FzIG5vdCBvdmVycmlkZGVuLiBEZWZhdWx0IGNvbm5lY3Rpb24gY2xhc3Mgd2lsbCBiZSB1c2VkLicpO1xuICB9XG5cbiAgY29uc3QgcWFNb2RlID0gb3B0aW9ucy5xYU1vZGU7XG4gIGNvbnN0IGNsaWVudEluZm8gPSBvcHRpb25zLmNsaWVudDtcbiAgY29uc3Qgb2NzcE1vZGVzID0gR2xvYmFsQ29uZmlnLm9jc3BNb2RlcztcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBDb25uZWN0aW9uIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbk9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IFtjb25maWddXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICBjb25zdCBjcmVhdGVDb25uZWN0aW9uID0gZnVuY3Rpb24gY3JlYXRlQ29ubmVjdGlvbihjb25uZWN0aW9uT3B0aW9ucywgY29uZmlnKSB7XG4gICAgLy8gY3JlYXRlIGEgbmV3IENvbm5lY3Rpb25Db25maWcgYW5kIHNraXAgY3JlZGVudGlhbC12YWxpZGF0aW9uIGlmIGEgY29uZmlnXG4gICAgLy8gb2JqZWN0IGhhcyBiZWVuIHNwZWNpZmllZDsgdGhpcyBpcyBiZWNhdXNlIGlmIGEgY29uZmlnIG9iamVjdCBoYXMgYmVlblxuICAgIC8vIHNwZWNpZmllZCwgd2UncmUgdHJ5aW5nIHRvIGRlc2VyaWFsaXplIGEgY29ubmVjdGlvbiBhbmQgdGhlIGFjY291bnQgbmFtZSxcbiAgICAvLyB1c2VybmFtZSBhbmQgcGFzc3dvcmQgZG9uJ3QgbmVlZCB0byBiZSBzcGVjaWZpZWQgYmVjYXVzZSB0aGUgY29uZmlnXG4gICAgLy8gb2JqZWN0IGFscmVhZHkgY29udGFpbnMgdGhlIHRva2VucyB3ZSBuZWVkXG4gICAgLy8gQWx0ZXJuYXRpdmVseSwgaWYgdGhlIGNvbm5lY3Rpb25PcHRpb25zIGluY2x1ZGVzIHRva2VuIGluZm9ybWF0aW9uIHRoZW4gd2Ugd2lsbCB1c2UgdGhhdFxuICAgIC8vIGluc3RlYWQgb2YgdGhlIHVzZXJuYW1lL3Bhc3N3b3JkXG5cbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDcmVhdGluZyBuZXcgY29ubmVjdGlvbiBvYmplY3QnKTtcblxuICAgIGlmIChjb25uZWN0aW9uT3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDb25uZWN0aW9uIG9wdGlvbnMgd2VyZSBub3Qgc3BlY2lmaWVkLiBMb2FkaW5nIGNvbm5lY3Rpb24gY29uZmlndXJhdGlvbi4nKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbm5lY3Rpb25PcHRpb25zID0gbG9hZENvbm5lY3Rpb25Db25maWd1cmF0aW9uKCk7XG4gICAgICB9IGNhdGNoICggZXJyb3IgKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdVbmFibGUgdG8gbG9hZCB0aGUgY29ubmVjdGlvbiBjb25maWd1cmF0aW9uLiBFcnJvcjogJXMnLCAgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKGNvbm5lY3Rpb25PcHRpb25zKSxcbiAgICAgICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX09QVElPTlMpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHZhbGlkYXRlQ3JlZGVudGlhbHMgPSAhY29uZmlnICYmIChjb25uZWN0aW9uT3B0aW9ucyAmJiAhY29ubmVjdGlvbk9wdGlvbnMuc2Vzc2lvblRva2VuKTtcblxuICAgIGNvbnN0IGNvbm5lY3Rpb25Db25maWcgPVxuICAgICAgbmV3IENvbm5lY3Rpb25Db25maWcoY29ubmVjdGlvbk9wdGlvbnMsIHZhbGlkYXRlQ3JlZGVudGlhbHMsIHFhTW9kZSwgY2xpZW50SW5mbyk7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb24gY29uZmlndXJhdGlvbiBvYmplY3QgY3JlYXRlZCcpO1xuXG4gICAgLy8gaWYgYW4gaHR0cCBjbGllbnQgd2FzIHNwZWNpZmllZCBpbiB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIG1vZHVsZSwgdXNlXG4gICAgLy8gaXQsIG90aGVyd2lzZSBjcmVhdGUgYSBuZXcgSHR0cENsaWVudFxuICAgIGNvbnN0IGh0dHBDbGllbnQgPSBvcHRpb25zLmh0dHBDbGllbnQgfHxcbiAgICAgIG5ldyBvcHRpb25zLmh0dHBDbGllbnRDbGFzcyhjb25uZWN0aW9uQ29uZmlnKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnSHR0cENsaWVudCBzZXR1cCBmaW5pc2hlZCcpO1xuXG5cbiAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IGNvbm5lY3Rpb25DbGFzcyhcbiAgICAgIG5ldyBDb25uZWN0aW9uQ29udGV4dChjb25uZWN0aW9uQ29uZmlnLCBodHRwQ2xpZW50LCBjb25maWcpXG4gICAgKTtcblxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGNvbm5lY3Rpb24gb2JqZWN0IGNyZWF0ZWQgc3VjY2Vzc2Z1bGx5LicsIGNvbm5lY3Rpb24uZ2V0SWQoKSk7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gIH07XG5cbiAgY29uc3QgaW5zdGFuY2UgPVxuICAgIHtcbiAgICAgIG9jc3BNb2Rlczogb2NzcE1vZGVzLFxuICAgICAgLyoqXG4gICAgICAgKiBDcmVhdGVzIGEgY29ubmVjdGlvbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byBjb21tdW5pY2F0ZSB3aXRoXG4gICAgICAgKiBTbm93Zmxha2UuXG4gICAgICAgKlxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBjcmVhdGVDb25uZWN0aW9uOiBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gY3JlYXRlQ29ubmVjdGlvbihvcHRpb25zKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgKiBDcmVhdGVzIGEgY29ubmVjdGlvbiBwb29sIGZvciBTbm93Zmxha2UgY29ubmVjdGlvbnNcbiAgICAgICpcbiAgICAgICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25PcHRpb25zXG4gICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwb29sT3B0aW9uc1xuICAgICAgKlxuICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgKi9cbiAgICAgIGNyZWF0ZVBvb2w6IGZ1bmN0aW9uIChjb25uZWN0aW9uT3B0aW9ucywgcG9vbE9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVBvb2woY29ubmVjdGlvbk9wdGlvbnMsIHBvb2xPcHRpb25zKTtcbiAgICAgIH0sXG5cbiAgICAgIC8qKlxuICAgICAgICogRGVzZXJpYWxpemVzIGEgc2VyaWFsaXplZCBjb25uZWN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgKiBAcGFyYW0ge1N0cmluZ30gc2VyaWFsaXplZENvbm5lY3Rpb25cbiAgICAgICAqXG4gICAgICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICAgICovXG4gICAgICBkZXNlcmlhbGl6ZUNvbm5lY3Rpb246IGZ1bmN0aW9uIChvcHRpb25zLCBzZXJpYWxpemVkQ29ubmVjdGlvbikge1xuICAgICAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBzZXJpYWxpemVkQ29uZmlnXG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdEZXNlcmlhbGl6aW5nIGNvbm5lY3Rpb24nKTtcblxuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhzZXJpYWxpemVkQ29ubmVjdGlvbiksXG4gICAgICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9ERVNFUklBTElaRV9NSVNTSU5HX0NPTkZJRyk7XG5cbiAgICAgICAgLy8gY2hlY2sgZm9yIGludmFsaWQgc2VyaWFsaXplZENvbmZpZ1xuICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNTdHJpbmcoc2VyaWFsaXplZENvbm5lY3Rpb24pLFxuICAgICAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fREVTRVJJQUxJWkVfSU5WQUxJRF9DT05GSUdfVFlQRSk7XG5cbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Rlc2VyaWFsaXppbmcgY29ubmVjdGlvbiBmcm9tIHN0cmluZyBvYmplY3QnKTtcblxuICAgICAgICAvLyB0cnkgdG8ganNvbi1wYXJzZSBzZXJpYWxpemVkQ29uZmlnXG4gICAgICAgIGxldCBjb25maWc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uZmlnID0gSlNPTi5wYXJzZShzZXJpYWxpemVkQ29ubmVjdGlvbik7XG4gICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgLy8gaWYgc2VyaWFsaXplZENvbmZpZyBjYW4ndCBiZSBwYXJzZWQgdG8ganNvbiwgdGhyb3cgYW4gZXJyb3JcbiAgICAgICAgICBFcnJvcnMuY2hlY2tBcmd1bWVudFZhbGlkKFV0aWwuaXNPYmplY3QoY29uZmlnKSxcbiAgICAgICAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fREVTRVJJQUxJWkVfSU5WQUxJRF9DT05GSUdfRk9STSk7XG4gICAgICAgIH1cbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nvbm5lY3Rpb24gZGVzZXJpYWxpemVkIHN1Y2Nlc3NmdWxseScpO1xuXG4gICAgICAgIHJldHVybiBjcmVhdGVDb25uZWN0aW9uKG9wdGlvbnMsIGNvbmZpZyk7XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIFNlcmlhbGl6ZXMgYSBnaXZlbiBjb25uZWN0aW9uLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uXG4gICAgICAgKlxuICAgICAgICogQHJldHVybnMge1N0cmluZ30gYSBzZXJpYWxpemVkIHZlcnNpb24gb2YgdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgKi9cbiAgICAgIHNlcmlhbGl6ZUNvbm5lY3Rpb246IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdDb25uZWN0aW9uW2lkOiAlc10gLSBzZXJpYWxpemluZyBjb25uZWN0aW9uLicsIGNvbm5lY3Rpb24uZ2V0SWQoKSk7XG4gICAgICAgIHJldHVybiBjb25uZWN0aW9uID8gY29ubmVjdGlvbi5zZXJpYWxpemUoKSA6IGNvbm5lY3Rpb247XG4gICAgICB9LFxuXG4gICAgICAvKipcbiAgICAgICAqIENvbmZpZ3VyZXMgdGhpcyBpbnN0YW5jZSBvZiB0aGUgU25vd2ZsYWtlIGNvcmUgbW9kdWxlLlxuICAgICAgICpcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgKi9cbiAgICAgIGNvbmZpZ3VyZTogZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0NvbmZpZ3VyaW5nIFNub3dmbGFrZSBjb3JlIG1vZHVsZS4nKTtcbiAgICAgICAgY29uc3QgbG9nTGV2ZWwgPSBleHRyYWN0TG9nTGV2ZWwob3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGxvZ0ZpbGVQYXRoID0gb3B0aW9ucy5sb2dGaWxlUGF0aDtcbiAgICAgICAgY29uc3QgYWRkaXRpb25hbExvZ1RvQ29uc29sZSA9IG9wdGlvbnMuYWRkaXRpb25hbExvZ1RvQ29uc29sZTtcblxuICAgICAgICBpZiAobG9nTGV2ZWwgIT0gbnVsbCB8fCBsb2dGaWxlUGF0aCkge1xuICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmNvbmZpZ3VyZShcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgbGV2ZWw6IGxvZ0xldmVsLFxuICAgICAgICAgICAgICBmaWxlUGF0aDogbG9nRmlsZVBhdGgsXG4gICAgICAgICAgICAgIGFkZGl0aW9uYWxMb2dUb0NvbnNvbGU6IGFkZGl0aW9uYWxMb2dUb0NvbnNvbGVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0NvbmZpZ3VyaW5nIGxvZ2dlciB3aXRoIGxldmVsOiAlcywgZmlsZVBhdGg6ICVzLCBhZGRpdGlvbmFsTG9nVG9Db25zb2xlOiAlcycsIGxvZ0xldmVsLCBsb2dGaWxlUGF0aCwgYWRkaXRpb25hbExvZ1RvQ29uc29sZSk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkaXNhYmxlT0NTUENoZWNrcyA9IG9wdGlvbnMuZGlzYWJsZU9DU1BDaGVja3M7XG4gICAgICAgIGlmIChVdGlsLmV4aXN0cyhkaXNhYmxlT0NTUENoZWNrcykpIHtcbiAgICAgICAgICAvLyBjaGVjayB0aGF0IHRoZSBzcGVjaWZpZWQgdmFsdWUgaXMgYSBib29sZWFuXG4gICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzQm9vbGVhbihkaXNhYmxlT0NTUENoZWNrcyksXG4gICAgICAgICAgICBFcnJvckNvZGVzLkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfRElTQUJMRV9PQ1NQX0NIRUNLUyk7XG5cbiAgICAgICAgICBHbG9iYWxDb25maWcuc2V0RGlzYWJsZU9DU1BDaGVja3MoZGlzYWJsZU9DU1BDaGVja3MpO1xuICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdTZXR0aW5nIGRpc2FibGVPQ1NQQ2hlY2tzIHRvIHZhbHVlIGZyb20gY29yZSBvcHRpb25zOiAlcycsIGRpc2FibGVPQ1NQQ2hlY2tzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IG9jc3BGYWlsT3BlbiA9IG9wdGlvbnMub2NzcEZhaWxPcGVuO1xuICAgICAgICBpZiAoVXRpbC5leGlzdHMob2NzcEZhaWxPcGVuKSkge1xuICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4ob2NzcEZhaWxPcGVuKSxcbiAgICAgICAgICAgIEVycm9yQ29kZXMuRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9PQ1NQX01PREUpO1xuXG4gICAgICAgICAgR2xvYmFsQ29uZmlnLnNldE9jc3BGYWlsT3BlbihvY3NwRmFpbE9wZW4pO1xuICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdTZXR0aW5nIG9jc3BGYWlsT3BlbiB0byB2YWx1ZSBmcm9tIGNvcmUgb3B0aW9uczogJXMgJywgb2NzcEZhaWxPcGVuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGpzb25Db2x1bW5WYXJpYW50UGFyc2VyID0gb3B0aW9ucy5qc29uQ29sdW1uVmFyaWFudFBhcnNlcjtcbiAgICAgICAgaWYgKFV0aWwuZXhpc3RzKGpzb25Db2x1bW5WYXJpYW50UGFyc2VyKSkge1xuICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Z1bmN0aW9uKGpzb25Db2x1bW5WYXJpYW50UGFyc2VyKSxcbiAgICAgICAgICAgIEVycm9yQ29kZXMuRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9KU09OX1BBUlNFUik7XG5cbiAgICAgICAgICBHbG9iYWxDb25maWcuc2V0SnNvbkNvbHVtblZhcmlhbnRQYXJzZXIoanNvbkNvbHVtblZhcmlhbnRQYXJzZXIpO1xuICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdTZXR0aW5nIEpTT04gQ29sdW1uIFZhcmlhbnQgUGFyc2VyIHRvIHZhbHVlIGZyb20gY29yZSBvcHRpb25zJyk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB4bWxDb2x1bW5WYXJpYW50UGFyc2VyID0gb3B0aW9ucy54bWxDb2x1bW5WYXJpYW50UGFyc2VyO1xuICAgICAgICBjb25zdCB4bWxQYXJzZXJDb25maWcgPSBvcHRpb25zLnhtbFBhcnNlckNvbmZpZztcbiAgICAgICAgaWYgKFV0aWwuZXhpc3RzKHhtbENvbHVtblZhcmlhbnRQYXJzZXIpKSB7XG4gICAgICAgICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzRnVuY3Rpb24oeG1sQ29sdW1uVmFyaWFudFBhcnNlciksXG4gICAgICAgICAgICBFcnJvckNvZGVzLkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfWE1MX1BBUlNFUik7XG5cbiAgICAgICAgICBHbG9iYWxDb25maWcuc2V0WG1sQ29sdW1uVmFyaWFudFBhcnNlcih4bWxDb2x1bW5WYXJpYW50UGFyc2VyKTtcbiAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnU2V0dGluZyBYTUwgQ29sdW1uIFZhcmlhbnQgUGFyc2VyIHRvIHZhbHVlIGZyb20gY29yZSBvcHRpb25zJyk7XG4gICAgICAgIH0gZWxzZSBpZiAoVXRpbC5leGlzdHMoeG1sUGFyc2VyQ29uZmlnKSkge1xuICAgICAgICAgIEdsb2JhbENvbmZpZy5jcmVhdGVYbWxDb2x1bW5WYXJpYW50UGFyc2VyV2l0aFBhcmFtZXRlcnMoeG1sUGFyc2VyQ29uZmlnKTtcbiAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ3JlYXRpbmcgWE1MIENvbHVtbiBWYXJpYW50IFBhcnNlciB3aXRoIHBhcmFtZXRlcnMgZnJvbSBjb3JlIG9wdGlvbnMnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGtlZXBBbGl2ZSA9IG9wdGlvbnMua2VlcEFsaXZlO1xuICAgICAgICBpZiAoVXRpbC5leGlzdHMoa2VlcEFsaXZlKSkge1xuICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4oa2VlcEFsaXZlKSxcbiAgICAgICAgICAgIEVycm9yQ29kZXMuRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9LRUVQX0FMSVZFKTtcblxuICAgICAgICAgIEdsb2JhbENvbmZpZy5zZXRLZWVwQWxpdmUoa2VlcEFsaXZlKTtcbiAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnU2V0dGluZyBrZWVwQWxpdmUgdG8gdmFsdWUgZnJvbSBjb3JlIG9wdGlvbnM6ICVzJywga2VlcEFsaXZlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHVzZUVudlByb3h5ID0gb3B0aW9ucy51c2VFbnZQcm94eTtcbiAgICAgICAgaWYgKFV0aWwuZXhpc3RzKHVzZUVudlByb3h5KSkge1xuICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc0Jvb2xlYW4odXNlRW52UHJveHkpLFxuICAgICAgICAgICAgRXJyb3JDb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX1VTRV9FTlZfUFJPWFkpO1xuXG4gICAgICAgICAgR2xvYmFsQ29uZmlnLnNldEVudlByb3h5KHVzZUVudlByb3h5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyID0gb3B0aW9ucy5jdXN0b21DcmVkZW50aWFsTWFuYWdlcjtcbiAgICAgICAgaWYgKFV0aWwuZXhpc3RzKGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyKSkge1xuICAgICAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc09iamVjdChjdXN0b21DcmVkZW50aWFsTWFuYWdlciksXG4gICAgICAgICAgICBFcnJvckNvZGVzLkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfQ1VTVE9NX0NSRURFTlRJQUxfTUFOQUdFUik7XG5cbiAgICAgICAgICBHbG9iYWxDb25maWcuc2V0Q3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIoY3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIpO1xuICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdTZXR0aW5nIGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyIHRvIHZhbHVlIGZyb20gY29yZSBvcHRpb25zICVzJywgY3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICBmdW5jdGlvbiBleHRyYWN0TG9nTGV2ZWwob3B0aW9ucykge1xuICAgIGNvbnN0IGxvZ1RhZyA9IG9wdGlvbnMubG9nTGV2ZWw7XG4gICAgaWYgKFV0aWwuZXhpc3RzKGxvZ1RhZykpIHtcbiAgICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoTG9nZ2VyQ29yZS5pc1ZhbGlkTG9nVGFnKGxvZ1RhZyksXG4gICAgICAgIEVycm9yQ29kZXMuRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9MT0dfTEVWRUwpO1xuXG4gICAgICByZXR1cm4gTG9nZ2VyQ29yZS5sb2dUYWdUb0xldmVsKGxvZ1RhZyk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gYWRkIHNvbWUgcmVhZC1vbmx5IGNvbnN0YW50c1xuICBjb25zdCBuYXRpdmVUeXBlVmFsdWVzID0gRGF0YVR5cGVzLk5hdGl2ZVR5cGVzLnZhbHVlcztcbiAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoaW5zdGFuY2UsXG4gICAge1xuICAgICAgU1RSSU5HOiB7IHZhbHVlOiBuYXRpdmVUeXBlVmFsdWVzLlNUUklORyB9LFxuICAgICAgQk9PTEVBTjogeyB2YWx1ZTogbmF0aXZlVHlwZVZhbHVlcy5CT09MRUFOIH0sXG4gICAgICBOVU1CRVI6IHsgdmFsdWU6IG5hdGl2ZVR5cGVWYWx1ZXMuTlVNQkVSIH0sXG4gICAgICBEQVRFOiB7IHZhbHVlOiBuYXRpdmVUeXBlVmFsdWVzLkRBVEUgfSxcbiAgICAgIE9CSkVDVDogeyB2YWx1ZTogbmF0aXZlVHlwZVZhbHVlcy5PQkpFQ1QgfSxcbiAgICAgIEFSUkFZOiB7IHZhbHVlOiBuYXRpdmVUeXBlVmFsdWVzLkFSUkFZIH0sXG4gICAgICBNQVA6IHsgdmFsdWU6IG5hdGl2ZVR5cGVWYWx1ZXMuTUFQIH0sXG4gICAgICBKU09OOiB7IHZhbHVlOiBuYXRpdmVUeXBlVmFsdWVzLkpTT04gfVxuICAgIH0pO1xuXG4gIC8qKlxuICAqIEZhY3RvcnkgZm9yIFNub3dmbGFrZSBjb25uZWN0aW9ucyBiYXNlZCBvbiBHZW5lcmljIFBvb2xcbiAgKlxuICAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uT3B0aW9uc1xuICAqXG4gICogQHJldHVybnMge251bGx9XG4gICovXG4gIGZ1bmN0aW9uIENvbm5lY3Rpb25GYWN0b3J5KGNvbm5lY3Rpb25PcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIG5ldyBjb25uZWN0aW9uIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICB0aGlzLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDcmVhdGluZyBuZXcgY29ubmVjdGlvbiBmcm9tIGZhY3RvcnkuJyk7XG4gICAgICBjb25zdCBjb25uZWN0aW9uID0gbmV3IGNyZWF0ZUNvbm5lY3Rpb24oY29ubmVjdGlvbk9wdGlvbnMpO1xuXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25uZWN0aW9uLmNvbm5lY3QoXG4gICAgICAgICAgZnVuY3Rpb24gKGVyciwgY29ubikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignQ29ubmVjdGlvbltpZDogJXNdIC0gVW5hYmxlIHRvIGNvbm5lY3QuIEVycm9yOiAlcycsIGNvbm4uZ2V0SWQoKSwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKGVyci5tZXNzYWdlKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ29ubmVjdGlvbltpZDogJXNdIC0gY29ubmVjdGVkIHN1Y2Nlc3NmdWxseS4gQ2FsbGJhY2sgY2FsbGVkLicsIGNvbm4uZ2V0SWQoKSk7XG4gICAgICAgICAgICAgIHJlc29sdmUoY29ubik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICogRGVzdHJveXMgdGhlIHNwZWNpZmllZCBjb25uZWN0aW9uIGluc3RhbmNlLlxuICAgICpcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uXG4gICAgKlxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uIChjb25uZWN0aW9uKSB7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnRGVzdHJveWluZyBjb25uZWN0aW9uIGluc3RhbmNlLicpO1xuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgIGNvbm5lY3Rpb24uZGVzdHJveShmdW5jdGlvbiAoZXJyLCBjb25uKSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoJ0Nvbm5lY3Rpb25baWQ6ICVzXSAtIGRpc2Nvbm5lY3RpbmcgZmFpbGVkIHdpdGggZXJyb3I6ICVzJywgY29ubi5nZXRJZCgpLCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSBjb25uZWN0aW9uIGRpc2Nvbm5lY3RlZCBzdWNjZXNzZnVsbHkuIENhbGxiYWNrIGNhbGxlZC4nLCBjb25uLmdldElkKCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICogUmV0dXJucyB0aGUgc3RhdHVzIG9mIHRoZSBjb25uZWN0aW9uLlxuICAgICpcbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBjb25uZWN0aW9uXG4gICAgKlxuICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgKi9cbiAgICB0aGlzLnZhbGlkYXRlID0gYXN5bmMgZnVuY3Rpb24gKGNvbm5lY3Rpb24pIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdDb25uZWN0aW9uW2lkOiAlc10gLSB2YWxpZGF0aW5nIGNvbm5lY3Rpb24gaW5zdGFuY2UnLCBjb25uZWN0aW9uLmdldElkKCkpO1xuICAgICAgcmV0dXJuIGF3YWl0IGNvbm5lY3Rpb24uaXNWYWxpZEFzeW5jKCk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAqIENyZWF0ZXMgYSBjb25uZWN0aW9uIHBvb2wgZm9yIFNub3dmbGFrZSBjb25uZWN0aW9uc1xuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25PcHRpb25zXG4gICogQHBhcmFtIHtPYmplY3R9IHBvb2xPcHRpb25zXG4gICpcbiAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAqL1xuICBjb25zdCBjcmVhdGVQb29sID0gZnVuY3Rpb24gY3JlYXRlUG9vbChjb25uZWN0aW9uT3B0aW9ucywgcG9vbE9wdGlvbnMpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdDcmVhdGluZyBjb25uZWN0aW9uIHBvb2wgd2l0aCBwcm92aWRlZCBvcHRpb25zJyk7XG5cbiAgICBjb25zdCBjb25uZWN0aW9uUG9vbCA9IEdlbmVyaWNQb29sLmNyZWF0ZVBvb2woXG4gICAgICBuZXcgQ29ubmVjdGlvbkZhY3RvcnkoY29ubmVjdGlvbk9wdGlvbnMpLFxuICAgICAgcG9vbE9wdGlvbnNcbiAgICApO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdCYXNlIGZvciBjb25uZWN0aW9uIHBvb2wgY3JlYXRlZCcpO1xuXG4gICAgLy8gYXZvaWQgaW5maW5pdGUgbG9vcCBpZiBmYWN0b3J5IGNyZWF0aW9uIGZhaWxzXG4gICAgY29ubmVjdGlvblBvb2wub24oJ2ZhY3RvcnlDcmVhdGVFcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmVycm9yKCdDb25uZWN0aW9uIHBvb2wgZmFjdG9yeSBjcmVhdGlvbiBmYWlsZWQ6ICVzJywgIGVyci5tZXNzYWdlKTtcbiAgICAgIGNvbnN0IGNsaWVudFJlc291cmNlUmVxdWVzdCA9IGNvbm5lY3Rpb25Qb29sLl93YWl0aW5nQ2xpZW50c1F1ZXVlLmRlcXVldWUoKTtcbiAgICAgIGlmIChjbGllbnRSZXNvdXJjZVJlcXVlc3QpIHtcbiAgICAgICAgY2xpZW50UmVzb3VyY2VSZXF1ZXN0LnJlamVjdChlcnIpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnQ29ubmVjdGlvbiBwb29sIG9iamVjdCBjcmVhdGVkIHN1Y2Nlc3NmdWxseScpO1xuXG4gICAgcmV0dXJuIGNvbm5lY3Rpb25Qb29sO1xuICB9O1xuXG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBDb3JlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/errors.js":
/*!**************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/errors.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst errorMessages = __webpack_require__(/*! ./constants/error_messages */ \"(rsc)/./node_modules/snowflake-sdk/lib/constants/error_messages.js\");\n\nconst codes = {};\n\n// 400001\ncodes.ERR_INTERNAL_ASSERT_FAILED = 400001;\ncodes.ERR_UNSUPPORTED_NODE_JS_VERSION = 400002;\n\n// 401001\ncodes.ERR_SF_NETWORK_COULD_NOT_CONNECT = 401001;\ncodes.ERR_SF_RESPONSE_FAILURE = 401002;\ncodes.ERR_SF_RESPONSE_NOT_JSON = 401003;\ncodes.ERR_SF_RESPONSE_INVALID_TOKEN = 401004;\n\n// 402001\ncodes.ERR_LARGE_RESULT_SET_NETWORK_COULD_NOT_CONNECT = 402001;\ncodes.ERR_LARGE_RESULT_SET_RESPONSE_FAILURE = 402002;\n\n// 403001\ncodes.ERR_GLOBAL_CONFIGURE_INVALID_LOG_LEVEL = 403001;\ncodes.ERR_GLOBAL_CONFIGURE_INVALID_DISABLE_OCSP_CHECKS = 403002;\ncodes.ERR_GLOBAL_CONFIGURE_INVALID_OCSP_MODE = 403003;\ncodes.ERR_GLOBAL_CONFIGURE_INVALID_JSON_PARSER = 403004;\ncodes.ERR_GLOBAL_CONFIGURE_INVALID_XML_PARSER = 403005;\ncodes.ERR_GLOBAL_CONFIGURE_INVALID_KEEP_ALIVE = 403006;\ncodes.ERR_GLOBAL_CONFIGURE_INVALID_CUSTOM_CREDENTIAL_MANAGER = 403007;\ncodes.ERR_GLOBAL_CONFIGURE_INVALID_USE_ENV_PROXY = 403008;\n\n// 404001\ncodes.ERR_CONN_CREATE_MISSING_OPTIONS = 404001;\ncodes.ERR_CONN_CREATE_INVALID_OPTIONS = 404002;\ncodes.ERR_CONN_CREATE_MISSING_USERNAME = 404003;\ncodes.ERR_CONN_CREATE_INVALID_USERNAME = 404004;\ncodes.ERR_CONN_CREATE_MISSING_PASSWORD = 404005;\ncodes.ERR_CONN_CREATE_INVALID_PASSWORD = 404006;\ncodes.ERR_CONN_CREATE_MISSING_ACCOUNT = 404007;\ncodes.ERR_CONN_CREATE_INVALID_ACCOUNT = 404008;\ncodes.ERR_CONN_CREATE_MISSING_ACCESS_URL = 404009;\ncodes.ERR_CONN_CREATE_INVALID_ACCESS_URL = 404010;\ncodes.ERR_CONN_CREATE_INVALID_WAREHOUSE = 404011;\ncodes.ERR_CONN_CREATE_INVALID_DATABASE = 404012;\ncodes.ERR_CONN_CREATE_INVALID_SCHEMA = 404013;\ncodes.ERR_CONN_CREATE_INVALID_ROLE = 404014;\ncodes.ERR_CONN_CREATE_MISSING_PROXY_HOST = 404015;\ncodes.ERR_CONN_CREATE_INVALID_PROXY_HOST = 404016;\ncodes.ERR_CONN_CREATE_MISSING_PROXY_PORT = 404017;\ncodes.ERR_CONN_CREATE_INVALID_PROXY_PORT = 404018;\ncodes.ERR_CONN_CREATE_INVALID_STREAM_RESULT = 404019;\ncodes.ERR_CONN_CREATE_INVALID_FETCH_AS_STRING = 404020;\ncodes.ERR_CONN_CREATE_INVALID_FETCH_AS_STRING_VALUES = 404021;\ncodes.ERR_CONN_CREATE_INVALID_REGION = 404022;\ncodes.ERR_CONN_CREATE_INVALID_KEEP_ALIVE = 404023;\ncodes.ERR_CONN_CREATE_INVALID_KEEP_ALIVE_HEARTBEAT_FREQ = 404024;\ncodes.ERR_CONN_CREATE_INVALID_TREAT_INTEGER_AS_BIGINT = 404025;\ncodes.ERR_CONN_CREATE_INVALID_PRIVATE_KEY = 404026;\ncodes.ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PATH = 404027;\ncodes.ERR_CONN_CREATE_INVALID_PRIVATE_KEY_PASS = 404028;\ncodes.ERR_CONN_CREATE_INVALID_OAUTH_TOKEN = 404029;\ncodes.ERR_CONN_CREATE_INVALID_VALIDATE_DEFAULT_PARAMETERS = 404030;\ncodes.ERR_CONN_CREATE_INVALID_APPLICATION = 404031;\ncodes.ERR_CONN_CREATE_MISSING_PROXY_USER = 404032;\ncodes.ERR_CONN_CREATE_INVALID_PROXY_USER = 404033;\ncodes.ERR_CONN_CREATE_MISSING_PROXY_PASS = 404034;\ncodes.ERR_CONN_CREATE_INVALID_PROXY_PASS = 404035;\ncodes.ERR_CONN_CREATE_INVALID_NO_PROXY = 404036;\ncodes.ERR_CONN_CREATE_INVALID_ARRAY_BINDING_THRESHOLD = 404037;\ncodes.ERR_CONN_CREATE_INVALID_GCS_USE_DOWNSCOPED_CREDENTIAL = 404038;\ncodes.ERR_CONN_CREATE_INVALID_FORCE_STAGE_BIND_ERROR = 404039;\ncodes.ERR_CONN_CREATE_INVALID_BROWSER_TIMEOUT = 404040;\ncodes.ERR_CONN_CREATE_INVALID_DISABLED_QUERY_CONTEXT_CACHE = 404041;\ncodes.ERR_CONN_CREATE_INVALID_INCLUDE_RETRY_REASON = 404042;\ncodes.ERR_CONN_CREATE_INVALID_CLIENT_CONFIG_FILE = 404043;\ncodes.ERR_CONN_CREATE_INVALID_RETRY_TIMEOUT = 404044;\ncodes.ERR_CONN_CREATE_INVALID_ACCOUNT_REGEX = 404045;\ncodes.ERR_CONN_CREATE_INVALID_REGION_REGEX = 404046;\ncodes.ERR_CONN_CREATE_INVALID_DISABLE_CONSOLE_LOGIN = 404047;\ncodes.ERR_CONN_CREATE_INVALID_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL = 404048;\ncodes.ERR_CONN_CREATE_INVALID_CLIENT_STORE_TEMPORARY_CREDENTIAL = 404049;\ncodes.ERR_CONN_CREATE_INVALID_REPRESENT_NULL_AS_STRING_NULL = 404050;\ncodes.ERR_CONN_CREATE_INVALID_DISABLE_SAML_URL_CHECK = 404051;\ncodes.ERR_CONN_CREATE_INVALID_CLIENT_REQUEST_MFA_TOKEN = 404052;\ncodes.ERR_CONN_CREATE_MISSING_HOST = 404053;\ncodes.ERR_CONN_CREATE_INVALID_HOST = 404054;\ncodes.ERR_CONN_CREATE_INVALID_PASSCODE_IN_PASSWORD = 404055;\ncodes.ERR_CONN_CREATE_INVALID_PASSCODE = 404056;\n\n// 405001\ncodes.ERR_CONN_CONNECT_INVALID_CALLBACK = 405001;\n\n// 405501\ncodes.ERR_CONN_CONNECT_STATUS_CONNECTING = 405501; // sql state: 08002\ncodes.ERR_CONN_CONNECT_STATUS_CONNECTED = 405502; // sql state: 08002\ncodes.ERR_CONN_CONNECT_STATUS_DISCONNECTED = 405503; // sql state: 08002\ncodes.ERR_CONN_CREATE_INVALID_AUTH_CONNECT = 405504;\ncodes.ERR_CONN_CONNECT_INVALID_CLIENT_CONFIG = 405505;\n\n// 406001\ncodes.ERR_CONN_DESTROY_INVALID_CALLBACK = 406001;\n\n// 406501\ncodes.ERR_CONN_DESTROY_STATUS_PRISTINE = 406501;\ncodes.ERR_CONN_DESTROY_STATUS_DISCONNECTED = 406502;\n\n// 407001\ncodes.ERR_CONN_REQUEST_STATUS_PRISTINE = 407001; // sql state: 08003\ncodes.ERR_CONN_REQUEST_STATUS_DISCONNECTED = 407002; // sql state: 08003\n\n// 408001\ncodes.ERR_CONN_DESERIALIZE_MISSING_CONFIG = 408001;\ncodes.ERR_CONN_DESERIALIZE_INVALID_CONFIG_TYPE = 408002;\ncodes.ERR_CONN_DESERIALIZE_INVALID_CONFIG_FORM = 408003;\n\n// 409001\ncodes.ERR_CONN_EXEC_STMT_MISSING_OPTIONS = 409001;\ncodes.ERR_CONN_EXEC_STMT_INVALID_OPTIONS = 409002;\ncodes.ERR_CONN_EXEC_STMT_MISSING_SQL_TEXT = 409003;\ncodes.ERR_CONN_EXEC_STMT_INVALID_SQL_TEXT = 409004;\ncodes.ERR_CONN_EXEC_STMT_INVALID_INTERNAL = 409005;\ncodes.ERR_CONN_EXEC_STMT_INVALID_PARAMETERS = 409006;\ncodes.ERR_CONN_EXEC_STMT_INVALID_BINDS = 409007;\ncodes.ERR_CONN_EXEC_STMT_INVALID_BIND_VALUES = 409008;\ncodes.ERR_CONN_EXEC_STMT_INVALID_COMPLETE = 409009;\ncodes.ERR_CONN_EXEC_STMT_INVALID_STREAM_RESULT = 409010;\ncodes.ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING = 409011;\ncodes.ERR_CONN_EXEC_STMT_INVALID_FETCH_AS_STRING_VALUES = 409012;\ncodes.ERR_CONN_EXEC_STMT_INVALID_REQUEST_ID = 409013;\ncodes.ERR_CONN_EXEC_STMT_INVALID_ASYNC_EXEC = 409014;\ncodes.ERR_CONN_EXEC_STMT_INVALID_DESCRIBE_ONLY = 409015;\n\n// 410001\ncodes.ERR_CONN_FETCH_RESULT_MISSING_OPTIONS = 410001;\ncodes.ERR_CONN_FETCH_RESULT_INVALID_OPTIONS = 410002;\ncodes.ERR_CONN_FETCH_RESULT_MISSING_QUERY_ID = 410003;\ncodes.ERR_CONN_FETCH_RESULT_INVALID_QUERY_ID = 410004;\ncodes.ERR_CONN_FETCH_RESULT_INVALID_COMPLETE = 410005;\ncodes.ERR_CONN_FETCH_RESULT_INVALID_STREAM_RESULT = 410006;\ncodes.ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING = 410007;\ncodes.ERR_CONN_FETCH_RESULT_INVALID_FETCH_AS_STRING_VALUES = 410008;\ncodes.ERR_CONN_FETCH_RESULT_INVALID_CWD = 410009;\n\n// 411001\ncodes.ERR_STMT_STREAM_ROWS_INVALID_OPTIONS = 411001;\ncodes.ERR_STMT_STREAM_ROWS_INVALID_START = 411002;\ncodes.ERR_STMT_STREAM_ROWS_INVALID_END = 411003;\ncodes.ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING = 411004;\ncodes.ERR_STMT_STREAM_ROWS_INVALID_FETCH_AS_STRING_VALUES = 411005;\ncodes.ERR_STMT_STREAM_ROWS_INVALID_ROW_MODE = 411006;\n\n// 412001\ncodes.ERR_OCSP_REVOKED = 412001;\ncodes.ERR_OCSP_UNKNOWN = 412002;\ncodes.ERR_OCSP_NO_SIGNATURE_ALGORITHM = 412003;\ncodes.ERR_OCSP_INVALID_SIGNATURE = 412004;\ncodes.ERR_OCSP_NO_RESPONSE = 412005;\ncodes.ERR_OCSP_INVALID_VALIDITY = 412006;\ncodes.ERR_OCSP_UNKNOWN_STATE = 412007;\ncodes.ERR_OCSP_NOT_TWO_ELEMENTS = 412008;\ncodes.ERR_OCSP_CACHE_EXPIRED = 412009;\ncodes.ERR_OCSP_FAILED_PARSE_RESPONSE = 412010;\ncodes.ERR_OCSP_INVALID_CERTIFICATE_VALIDITY = 412011;\ncodes.ERR_OCSP_RESPONDER_TIMEOUT = 412012;\ncodes.ERR_OCSP_CACHE_SERVER_TIMEOUT = 412013;\ncodes.ERR_OCSP_FAILED_OBTAIN_OCSP_RESPONSE = 412014;\n\n// 450001\ncodes.ERR_STMT_FETCH_ROWS_MISSING_OPTIONS = 450001;\ncodes.ERR_STMT_FETCH_ROWS_INVALID_OPTIONS = 450002;\ncodes.ERR_STMT_FETCH_ROWS_MISSING_EACH = 450003;\ncodes.ERR_STMT_FETCH_ROWS_INVALID_EACH = 450004;\ncodes.ERR_STMT_FETCH_ROWS_MISSING_END = 450005;\ncodes.ERR_STMT_FETCH_ROWS_INVALID_END = 450006;\ncodes.ERR_STMT_FETCH_ROWS_FETCHING_RESULT = 450007;\n\n// 460001\ncodes.ERR_GET_RESPONSE_QUERY_INVALID_UUID = 460001;\ncodes.ERR_GET_RESULTS_QUERY_ID_NO_DATA = 460002;\ncodes.ERR_GET_RESULTS_QUERY_ID_NOT_SUCCESS_STATUS = 460003;\n\nexports.codes = codes;\n\n/**\n * A map in which the keys are the error codes and the values are the\n * corresponding SQL-states.\n */\nconst errCodeToSqlState = exports.mapErrorCodeToSqlState =\n  {\n    405501: '08002',\n    405502: '08002',\n    405503: '08003',\n    407001: '08003',\n    407002: '08003'\n  };\n\n/**\n * An enumeration of all the different types of errors we create.\n */\nconst errorTypes =\n  {\n    // internal synchronous errors\n    InternalAssertError: 'InternalAssertError',\n\n    // external synchronous errors\n    MissingParameterError: 'MissingParameterError',\n    InvalidParameterError: 'InvalidParameterError',\n\n    // external asynchronous errors\n    NetworkError: 'NetworkError',\n    RequestFailedError: 'RequestFailedError',\n    UnexpectedContentError: 'UnexpectedContentError',\n    OperationFailedError: 'OperationFailedError',\n    LargeResultSetError: 'LargeResultSetError',\n    ClientError: 'ClientError',\n    OCSPError: 'OCSPError'\n  };\n\n/**\n * Ensures the truth of an expression. Used to catch internal programming\n * errors. If the given expression is false, an InternalAssertError will be\n * thrown.\n *\n * @param {Boolean} expression a boolean expression.\n * @param {String} [message] a message for the error should the check fail.\n */\nexports.assertInternal = function (expression, message) {\n  if (!expression) {\n    throw createError(errorTypes.InternalAssertError,\n      {\n        code: codes.ERR_INTERNAL_ASSERT_FAILED,\n        message: message,\n        synchronous: true\n      });\n  }\n};\n\n/**\n * Ensures the truth of an expression. Used to make sure all required arguments\n * are passed in to a method. If the specified expression is false, a\n * MissingParameterError will be thrown.\n *\n * @param {Boolean} expression a boolean expression.\n * @param {Number} errorCode a code for the error should the check fail.\n *\n * @throws will throw an MissingParameter error if the expression is false.\n */\nexports.checkArgumentExists = function (expression, errorCode) {\n  if (!expression) {\n    throw createError(errorTypes.MissingParameterError,\n      {\n        code: errorCode,\n        messageArgs: Array.prototype.slice.call(arguments, 2),\n        synchronous: true\n      });\n  }\n};\n\n/**\n * Ensures the truth of an expression. Used for validating arguments to methods.\n * If the specified expression is false, an InvalidParameterError will be\n * thrown.\n *\n * @param {Boolean} expression a boolean expression.\n * @param {Number} errorCode a code for the error should the check fail.\n *\n * @throws will throw an InvalidParameter error if the expression is false.\n */\nexports.checkArgumentValid = function (expression, errorCode) {\n  if (!expression) {\n    throw createError(errorTypes.InvalidParameterError,\n      {\n        code: errorCode,\n        messageArgs: Array.prototype.slice.call(arguments, 2),\n        synchronous: true\n      });\n  }\n};\n\n/**\n * Creates a new NetworkError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Error} cause the underlying cause of the network error.\n *\n * @returns {Error}\n */\nexports.createNetworkError = function (errorCode, cause) {\n  return createError(errorTypes.NetworkError,\n    {\n      code: errorCode,\n      cause: cause\n    });\n};\n\n/**\n * Creates a new RequestFailedError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Object} response the response sent by Global Services.\n *\n * @returns {Error}\n */\nexports.createRequestFailedError = function (errorCode, response) {\n  return createError(errorTypes.RequestFailedError,\n    {\n      code: errorCode,\n      response: response\n    });\n};\n\n/**\n * Creates a new UnexpectedContentError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {String} responseBody the response body sent by Global Services.\n *\n * @returns {Error}\n */\nexports.createUnexpectedContentError = function (errorCode, responseBody) {\n  return createError(errorTypes.UnexpectedContentError,\n    {\n      code: errorCode,\n      responseBody: responseBody\n    });\n};\n\n/**\n * Creates a new OperationFailedError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Object} data the data sent by Global Services.\n * @param {String} message the error message sent by Global Services.\n * @param {String} sqlState the sql state sent by Global Services.\n *\n * @returns {Error}\n */\nexports.createOperationFailedError = function (\n  errorCode, data, message, sqlState) {\n  return createError(errorTypes.OperationFailedError,\n    {\n      code: errorCode,\n      data: data,\n      message: message,\n      sqlState: sqlState\n    });\n};\n\n/**\n * Creates a new LargeResultSetError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Object} response the response sent by S3/Blob.\n *\n * @returns {Error}\n */\nexports.createLargeResultSetError = function (errorCode, response) {\n  return createError(errorTypes.LargeResultSetError,\n    {\n      code: errorCode,\n      response: response\n    });\n};\n\n/**\n * Creates a new ClientError.\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {Object} [isFatal] whether the error is fatal.\n *\n * @return {Error}\n */\nexports.createClientError = function (errorCode, isFatal) {\n  return createError(errorTypes.ClientError,\n    {\n      code: errorCode,\n      isFatal: isFatal,\n      messageArgs: Array.prototype.slice.call(arguments, 2)\n    });\n};\n\n/**\n * Creates a OCSPError\n *\n * @param {Number} errorCode the error code to use when building the error.\n * @param {String} message\n * @returns {Error}\n */\nexports.createOCSPError = function (errorCode) {\n  return createError(errorTypes.OCSPError,\n    {\n      code: errorCode,\n      messageArgs: Array.prototype.slice.call(arguments, 1)\n    }\n  );\n};\n\n/**\n * Creates a new error by combining the error messages from the json parser and xml parser\n *\n * @param {Object} jsonParseError contains the JSON parse error message\n * @param {Object} xmlParseError contains the XML parse error message\n * @returns {Error}\n */\nexports.VariantParseError = function (jsonParseError, xmlParseError) {\n  const errMessage = 'VariantParseError: Variant cannot be parsed neither as JSON nor as XML:\\n' +\n    ` - JSON parse error message: ${jsonParseError.message}\\n` +\n    ` - XML parse error message: ${xmlParseError.message}`;\n  return new Error(errMessage);\n};\n\n/**\n * Determines if a given error is an InternalAssertError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isInternalAssertError = function (error) {\n  return isErrorOfType(error, errorTypes.InternalAssertError);\n};\n\n/**\n * Determines if a given error is a MissingParameterError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isMissingParameterError = function (error) {\n  return isErrorOfType(error, errorTypes.MissingParameterError);\n};\n\n/**\n * Determines if a given error is an InvalidParameterError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isInvalidParameterError = function (error) {\n  return isErrorOfType(error, errorTypes.InvalidParameterError);\n};\n\n/**\n * Determines if a given error is a NetworkError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isNetworkError = function (error) {\n  return isErrorOfType(error, errorTypes.NetworkError);\n};\n\n/**\n * Determines if a given error is a RequestFailedError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isRequestFailedError = function (error) {\n  return isErrorOfType(error, errorTypes.RequestFailedError);\n};\n\n/**\n * Determines if a given error is an UnexpectedContentError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isUnexpectedContentError = function (error) {\n  return isErrorOfType(error, errorTypes.UnexpectedContentError);\n};\n\n/**\n * Determines if a given error is an OperationFailedError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isOperationFailedError = function (error) {\n  return isErrorOfType(error, errorTypes.OperationFailedError);\n};\n\n/**\n * Determines if a given error is an LargeResultSetError.\n *\n * @param {Error} error\n *\n * @returns {Boolean}\n */\nexports.isLargeResultSetError = function (error) {\n  return isErrorOfType(error, errorTypes.LargeResultSetError);\n};\n\n/**\n * Externalizes an error.\n *\n * @param {Error} error\n *\n * @returns {Error}\n */\nexports.externalize = function (error) {\n  return error && error.externalize ? error.externalize() : error;\n};\n\n/**\n * Determines if a given error is of a specific type.\n *\n * @param {Error} error\n * @param {String} type\n *\n * @returns {Boolean}\n */\nfunction isErrorOfType(error, type) {\n  return error && (error.name === type);\n}\n\n/**\n * Creates a generic error.\n *\n * @param {String} name\n * @param {Object} options\n *\n * @returns {Error}\n */\nfunction createError(name, options) {\n  // TODO: validate that name is a string and options is an object\n\n  // TODO: this code is a bit of a mess and needs to be cleaned up\n\n  // create a new error\n  const error = new Error();\n\n  // set its name\n  error.name = name;\n\n  // set the error code\n  let code;\n  error.code = code = options.code;\n\n  // if no error message was specified in the options\n  let message = options.message;\n  if (!message) {\n    // use the error code to get the error message template\n    const messageTemplate = errorMessages[code];\n\n    // if some error message arguments were specified, substitute them into the\n    // error message template to get the full error message, otherwise just use\n    // the error message template as the error message\n    let messageArgs = options.messageArgs;\n    if (messageArgs) {\n      messageArgs = messageArgs.slice();\n      messageArgs.unshift(messageTemplate);\n      message = Util.format.apply(Util, messageArgs);\n    } else {\n      message = messageTemplate;\n    }\n  }\n  error.message = message;\n\n  // if no sql state was specified in the options, use the error code to try to\n  // get the appropriate sql state\n  let sqlState = options.sqlState;\n  if (!sqlState) {\n    sqlState = errCodeToSqlState[code];\n  }\n  error.sqlState = sqlState;\n\n  // set the error data\n  error.data = options.data;\n\n  // set the error response and response body\n  error.response = options.response;\n  error.responseBody = options.responseBody;\n\n  // set the error cause\n  error.cause = options.cause;\n\n  // set the error's fatal flag\n  error.isFatal = options.isFatal;\n\n  // if the error is not synchronous, add an externalize() method\n  if (!options.synchronous) {\n    error.externalize = function () {\n      const propNames =\n        [\n          'name',\n          'code',\n          'message',\n          'sqlState',\n          'data',\n          'response',\n          'responseBody',\n          'cause',\n          'isFatal',\n          'stack'\n        ];\n\n      const externalizedError = new Error();\n\n      let propName, propValue;\n      for (let index = 0, length = propNames.length; index < length; index++) {\n        propName = propNames[index];\n        propValue = this[propName];\n        if (Util.exists(propValue)) {\n          externalizedError[propName] = propValue;\n        }\n      }\n\n      return externalizedError;\n    };\n  }\n\n  return error;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZXJyb3JzLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyw4REFBUTtBQUM3QixzQkFBc0IsbUJBQU8sQ0FBQyxzR0FBNEI7O0FBRTFEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxtREFBbUQ7QUFDbkQsa0RBQWtEO0FBQ2xELHFEQUFxRDtBQUNyRDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pELHFEQUFxRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiw4QkFBOEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEI7QUFDQSxhQUFhO0FBQ2I7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0QsbUNBQW1DLHNCQUFzQjtBQUN6RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLCtCQUErQjtBQUMvQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLGdDQUFnQztBQUNoQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWE7QUFDYjtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EscURBQXFELGdCQUFnQjtBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZXJyb3JzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IGVycm9yTWVzc2FnZXMgPSByZXF1aXJlKCcuL2NvbnN0YW50cy9lcnJvcl9tZXNzYWdlcycpO1xuXG5jb25zdCBjb2RlcyA9IHt9O1xuXG4vLyA0MDAwMDFcbmNvZGVzLkVSUl9JTlRFUk5BTF9BU1NFUlRfRkFJTEVEID0gNDAwMDAxO1xuY29kZXMuRVJSX1VOU1VQUE9SVEVEX05PREVfSlNfVkVSU0lPTiA9IDQwMDAwMjtcblxuLy8gNDAxMDAxXG5jb2Rlcy5FUlJfU0ZfTkVUV09SS19DT1VMRF9OT1RfQ09OTkVDVCA9IDQwMTAwMTtcbmNvZGVzLkVSUl9TRl9SRVNQT05TRV9GQUlMVVJFID0gNDAxMDAyO1xuY29kZXMuRVJSX1NGX1JFU1BPTlNFX05PVF9KU09OID0gNDAxMDAzO1xuY29kZXMuRVJSX1NGX1JFU1BPTlNFX0lOVkFMSURfVE9LRU4gPSA0MDEwMDQ7XG5cbi8vIDQwMjAwMVxuY29kZXMuRVJSX0xBUkdFX1JFU1VMVF9TRVRfTkVUV09SS19DT1VMRF9OT1RfQ09OTkVDVCA9IDQwMjAwMTtcbmNvZGVzLkVSUl9MQVJHRV9SRVNVTFRfU0VUX1JFU1BPTlNFX0ZBSUxVUkUgPSA0MDIwMDI7XG5cbi8vIDQwMzAwMVxuY29kZXMuRVJSX0dMT0JBTF9DT05GSUdVUkVfSU5WQUxJRF9MT0dfTEVWRUwgPSA0MDMwMDE7XG5jb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0RJU0FCTEVfT0NTUF9DSEVDS1MgPSA0MDMwMDI7XG5jb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX09DU1BfTU9ERSA9IDQwMzAwMztcbmNvZGVzLkVSUl9HTE9CQUxfQ09ORklHVVJFX0lOVkFMSURfSlNPTl9QQVJTRVIgPSA0MDMwMDQ7XG5jb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX1hNTF9QQVJTRVIgPSA0MDMwMDU7XG5jb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0tFRVBfQUxJVkUgPSA0MDMwMDY7XG5jb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0NVU1RPTV9DUkVERU5USUFMX01BTkFHRVIgPSA0MDMwMDc7XG5jb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX1VTRV9FTlZfUFJPWFkgPSA0MDMwMDg7XG5cbi8vIDQwNDAwMVxuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfT1BUSU9OUyA9IDQwNDAwMTtcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09QVElPTlMgPSA0MDQwMDI7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19VU0VSTkFNRSA9IDQwNDAwMztcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1VTRVJOQU1FID0gNDA0MDA0O1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUEFTU1dPUkQgPSA0MDQwMDU7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QQVNTV09SRCA9IDQwNDAwNjtcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX0FDQ09VTlQgPSA0MDQwMDc7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BQ0NPVU5UID0gNDA0MDA4O1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfQUNDRVNTX1VSTCA9IDQwNDAwOTtcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0FDQ0VTU19VUkwgPSA0MDQwMTA7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9XQVJFSE9VU0UgPSA0MDQwMTE7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9EQVRBQkFTRSA9IDQwNDAxMjtcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1NDSEVNQSA9IDQwNDAxMztcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1JPTEUgPSA0MDQwMTQ7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QUk9YWV9IT1NUID0gNDA0MDE1O1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJPWFlfSE9TVCA9IDQwNDAxNjtcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX1BST1hZX1BPUlQgPSA0MDQwMTc7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUk9YWV9QT1JUID0gNDA0MDE4O1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfU1RSRUFNX1JFU1VMVCA9IDQwNDAxOTtcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0ZFVENIX0FTX1NUUklORyA9IDQwNDAyMDtcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0ZFVENIX0FTX1NUUklOR19WQUxVRVMgPSA0MDQwMjE7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9SRUdJT04gPSA0MDQwMjI7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9LRUVQX0FMSVZFID0gNDA0MDIzO1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfS0VFUF9BTElWRV9IRUFSVEJFQVRfRlJFUSA9IDQwNDAyNDtcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1RSRUFUX0lOVEVHRVJfQVNfQklHSU5UID0gNDA0MDI1O1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJJVkFURV9LRVkgPSA0MDQwMjY7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUklWQVRFX0tFWV9QQVRIID0gNDA0MDI3O1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJJVkFURV9LRVlfUEFTUyA9IDQwNDAyODtcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX09BVVRIX1RPS0VOID0gNDA0MDI5O1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfVkFMSURBVEVfREVGQVVMVF9QQVJBTUVURVJTID0gNDA0MDMwO1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfQVBQTElDQVRJT04gPSA0MDQwMzE7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19QUk9YWV9VU0VSID0gNDA0MDMyO1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJPWFlfVVNFUiA9IDQwNDAzMztcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX1BST1hZX1BBU1MgPSA0MDQwMzQ7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9QUk9YWV9QQVNTID0gNDA0MDM1O1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfTk9fUFJPWFkgPSA0MDQwMzY7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BUlJBWV9CSU5ESU5HX1RIUkVTSE9MRCA9IDQwNDAzNztcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0dDU19VU0VfRE9XTlNDT1BFRF9DUkVERU5USUFMID0gNDA0MDM4O1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRk9SQ0VfU1RBR0VfQklORF9FUlJPUiA9IDQwNDAzOTtcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0JST1dTRVJfVElNRU9VVCA9IDQwNDA0MDtcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0RJU0FCTEVEX1FVRVJZX0NPTlRFWFRfQ0FDSEUgPSA0MDQwNDE7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9JTkNMVURFX1JFVFJZX1JFQVNPTiA9IDQwNDA0MjtcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0NMSUVOVF9DT05GSUdfRklMRSA9IDQwNDA0MztcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1JFVFJZX1RJTUVPVVQgPSA0MDQwNDQ7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BQ0NPVU5UX1JFR0VYID0gNDA0MDQ1O1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUkVHSU9OX1JFR0VYID0gNDA0MDQ2O1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRElTQUJMRV9DT05TT0xFX0xPR0lOID0gNDA0MDQ3O1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfRk9SQ0VfR0NQX1VTRV9ET1dOU0NPUEVEX0NSRURFTlRJQUwgPSA0MDQwNDg7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9DTElFTlRfU1RPUkVfVEVNUE9SQVJZX0NSRURFTlRJQUwgPSA0MDQwNDk7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9SRVBSRVNFTlRfTlVMTF9BU19TVFJJTkdfTlVMTCA9IDQwNDA1MDtcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX0RJU0FCTEVfU0FNTF9VUkxfQ0hFQ0sgPSA0MDQwNTE7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9DTElFTlRfUkVRVUVTVF9NRkFfVE9LRU4gPSA0MDQwNTI7XG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfTUlTU0lOR19IT1NUID0gNDA0MDUzO1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfSE9TVCA9IDQwNDA1NDtcbmNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BBU1NDT0RFX0lOX1BBU1NXT1JEID0gNDA0MDU1O1xuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUEFTU0NPREUgPSA0MDQwNTY7XG5cbi8vIDQwNTAwMVxuY29kZXMuRVJSX0NPTk5fQ09OTkVDVF9JTlZBTElEX0NBTExCQUNLID0gNDA1MDAxO1xuXG4vLyA0MDU1MDFcbmNvZGVzLkVSUl9DT05OX0NPTk5FQ1RfU1RBVFVTX0NPTk5FQ1RJTkcgPSA0MDU1MDE7IC8vIHNxbCBzdGF0ZTogMDgwMDJcbmNvZGVzLkVSUl9DT05OX0NPTk5FQ1RfU1RBVFVTX0NPTk5FQ1RFRCA9IDQwNTUwMjsgLy8gc3FsIHN0YXRlOiAwODAwMlxuY29kZXMuRVJSX0NPTk5fQ09OTkVDVF9TVEFUVVNfRElTQ09OTkVDVEVEID0gNDA1NTAzOyAvLyBzcWwgc3RhdGU6IDA4MDAyXG5jb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9BVVRIX0NPTk5FQ1QgPSA0MDU1MDQ7XG5jb2Rlcy5FUlJfQ09OTl9DT05ORUNUX0lOVkFMSURfQ0xJRU5UX0NPTkZJRyA9IDQwNTUwNTtcblxuLy8gNDA2MDAxXG5jb2Rlcy5FUlJfQ09OTl9ERVNUUk9ZX0lOVkFMSURfQ0FMTEJBQ0sgPSA0MDYwMDE7XG5cbi8vIDQwNjUwMVxuY29kZXMuRVJSX0NPTk5fREVTVFJPWV9TVEFUVVNfUFJJU1RJTkUgPSA0MDY1MDE7XG5jb2Rlcy5FUlJfQ09OTl9ERVNUUk9ZX1NUQVRVU19ESVNDT05ORUNURUQgPSA0MDY1MDI7XG5cbi8vIDQwNzAwMVxuY29kZXMuRVJSX0NPTk5fUkVRVUVTVF9TVEFUVVNfUFJJU1RJTkUgPSA0MDcwMDE7IC8vIHNxbCBzdGF0ZTogMDgwMDNcbmNvZGVzLkVSUl9DT05OX1JFUVVFU1RfU1RBVFVTX0RJU0NPTk5FQ1RFRCA9IDQwNzAwMjsgLy8gc3FsIHN0YXRlOiAwODAwM1xuXG4vLyA0MDgwMDFcbmNvZGVzLkVSUl9DT05OX0RFU0VSSUFMSVpFX01JU1NJTkdfQ09ORklHID0gNDA4MDAxO1xuY29kZXMuRVJSX0NPTk5fREVTRVJJQUxJWkVfSU5WQUxJRF9DT05GSUdfVFlQRSA9IDQwODAwMjtcbmNvZGVzLkVSUl9DT05OX0RFU0VSSUFMSVpFX0lOVkFMSURfQ09ORklHX0ZPUk0gPSA0MDgwMDM7XG5cbi8vIDQwOTAwMVxuY29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX01JU1NJTkdfT1BUSU9OUyA9IDQwOTAwMTtcbmNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX09QVElPTlMgPSA0MDkwMDI7XG5jb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfTUlTU0lOR19TUUxfVEVYVCA9IDQwOTAwMztcbmNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX1NRTF9URVhUID0gNDA5MDA0O1xuY29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfSU5URVJOQUwgPSA0MDkwMDU7XG5jb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9QQVJBTUVURVJTID0gNDA5MDA2O1xuY29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfQklORFMgPSA0MDkwMDc7XG5jb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9CSU5EX1ZBTFVFUyA9IDQwOTAwODtcbmNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0NPTVBMRVRFID0gNDA5MDA5O1xuY29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfU1RSRUFNX1JFU1VMVCA9IDQwOTAxMDtcbmNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0ZFVENIX0FTX1NUUklORyA9IDQwOTAxMTtcbmNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0ZFVENIX0FTX1NUUklOR19WQUxVRVMgPSA0MDkwMTI7XG5jb2Rlcy5FUlJfQ09OTl9FWEVDX1NUTVRfSU5WQUxJRF9SRVFVRVNUX0lEID0gNDA5MDEzO1xuY29kZXMuRVJSX0NPTk5fRVhFQ19TVE1UX0lOVkFMSURfQVNZTkNfRVhFQyA9IDQwOTAxNDtcbmNvZGVzLkVSUl9DT05OX0VYRUNfU1RNVF9JTlZBTElEX0RFU0NSSUJFX09OTFkgPSA0MDkwMTU7XG5cbi8vIDQxMDAwMVxuY29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX01JU1NJTkdfT1BUSU9OUyA9IDQxMDAwMTtcbmNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX09QVElPTlMgPSA0MTAwMDI7XG5jb2Rlcy5FUlJfQ09OTl9GRVRDSF9SRVNVTFRfTUlTU0lOR19RVUVSWV9JRCA9IDQxMDAwMztcbmNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX1FVRVJZX0lEID0gNDEwMDA0O1xuY29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfQ09NUExFVEUgPSA0MTAwMDU7XG5jb2Rlcy5FUlJfQ09OTl9GRVRDSF9SRVNVTFRfSU5WQUxJRF9TVFJFQU1fUkVTVUxUID0gNDEwMDA2O1xuY29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HID0gNDEwMDA3O1xuY29kZXMuRVJSX0NPTk5fRkVUQ0hfUkVTVUxUX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HX1ZBTFVFUyA9IDQxMDAwODtcbmNvZGVzLkVSUl9DT05OX0ZFVENIX1JFU1VMVF9JTlZBTElEX0NXRCA9IDQxMDAwOTtcblxuLy8gNDExMDAxXG5jb2Rlcy5FUlJfU1RNVF9TVFJFQU1fUk9XU19JTlZBTElEX09QVElPTlMgPSA0MTEwMDE7XG5jb2Rlcy5FUlJfU1RNVF9TVFJFQU1fUk9XU19JTlZBTElEX1NUQVJUID0gNDExMDAyO1xuY29kZXMuRVJSX1NUTVRfU1RSRUFNX1JPV1NfSU5WQUxJRF9FTkQgPSA0MTEwMDM7XG5jb2Rlcy5FUlJfU1RNVF9TVFJFQU1fUk9XU19JTlZBTElEX0ZFVENIX0FTX1NUUklORyA9IDQxMTAwNDtcbmNvZGVzLkVSUl9TVE1UX1NUUkVBTV9ST1dTX0lOVkFMSURfRkVUQ0hfQVNfU1RSSU5HX1ZBTFVFUyA9IDQxMTAwNTtcbmNvZGVzLkVSUl9TVE1UX1NUUkVBTV9ST1dTX0lOVkFMSURfUk9XX01PREUgPSA0MTEwMDY7XG5cbi8vIDQxMjAwMVxuY29kZXMuRVJSX09DU1BfUkVWT0tFRCA9IDQxMjAwMTtcbmNvZGVzLkVSUl9PQ1NQX1VOS05PV04gPSA0MTIwMDI7XG5jb2Rlcy5FUlJfT0NTUF9OT19TSUdOQVRVUkVfQUxHT1JJVEhNID0gNDEyMDAzO1xuY29kZXMuRVJSX09DU1BfSU5WQUxJRF9TSUdOQVRVUkUgPSA0MTIwMDQ7XG5jb2Rlcy5FUlJfT0NTUF9OT19SRVNQT05TRSA9IDQxMjAwNTtcbmNvZGVzLkVSUl9PQ1NQX0lOVkFMSURfVkFMSURJVFkgPSA0MTIwMDY7XG5jb2Rlcy5FUlJfT0NTUF9VTktOT1dOX1NUQVRFID0gNDEyMDA3O1xuY29kZXMuRVJSX09DU1BfTk9UX1RXT19FTEVNRU5UUyA9IDQxMjAwODtcbmNvZGVzLkVSUl9PQ1NQX0NBQ0hFX0VYUElSRUQgPSA0MTIwMDk7XG5jb2Rlcy5FUlJfT0NTUF9GQUlMRURfUEFSU0VfUkVTUE9OU0UgPSA0MTIwMTA7XG5jb2Rlcy5FUlJfT0NTUF9JTlZBTElEX0NFUlRJRklDQVRFX1ZBTElESVRZID0gNDEyMDExO1xuY29kZXMuRVJSX09DU1BfUkVTUE9OREVSX1RJTUVPVVQgPSA0MTIwMTI7XG5jb2Rlcy5FUlJfT0NTUF9DQUNIRV9TRVJWRVJfVElNRU9VVCA9IDQxMjAxMztcbmNvZGVzLkVSUl9PQ1NQX0ZBSUxFRF9PQlRBSU5fT0NTUF9SRVNQT05TRSA9IDQxMjAxNDtcblxuLy8gNDUwMDAxXG5jb2Rlcy5FUlJfU1RNVF9GRVRDSF9ST1dTX01JU1NJTkdfT1BUSU9OUyA9IDQ1MDAwMTtcbmNvZGVzLkVSUl9TVE1UX0ZFVENIX1JPV1NfSU5WQUxJRF9PUFRJT05TID0gNDUwMDAyO1xuY29kZXMuRVJSX1NUTVRfRkVUQ0hfUk9XU19NSVNTSU5HX0VBQ0ggPSA0NTAwMDM7XG5jb2Rlcy5FUlJfU1RNVF9GRVRDSF9ST1dTX0lOVkFMSURfRUFDSCA9IDQ1MDAwNDtcbmNvZGVzLkVSUl9TVE1UX0ZFVENIX1JPV1NfTUlTU0lOR19FTkQgPSA0NTAwMDU7XG5jb2Rlcy5FUlJfU1RNVF9GRVRDSF9ST1dTX0lOVkFMSURfRU5EID0gNDUwMDA2O1xuY29kZXMuRVJSX1NUTVRfRkVUQ0hfUk9XU19GRVRDSElOR19SRVNVTFQgPSA0NTAwMDc7XG5cbi8vIDQ2MDAwMVxuY29kZXMuRVJSX0dFVF9SRVNQT05TRV9RVUVSWV9JTlZBTElEX1VVSUQgPSA0NjAwMDE7XG5jb2Rlcy5FUlJfR0VUX1JFU1VMVFNfUVVFUllfSURfTk9fREFUQSA9IDQ2MDAwMjtcbmNvZGVzLkVSUl9HRVRfUkVTVUxUU19RVUVSWV9JRF9OT1RfU1VDQ0VTU19TVEFUVVMgPSA0NjAwMDM7XG5cbmV4cG9ydHMuY29kZXMgPSBjb2RlcztcblxuLyoqXG4gKiBBIG1hcCBpbiB3aGljaCB0aGUga2V5cyBhcmUgdGhlIGVycm9yIGNvZGVzIGFuZCB0aGUgdmFsdWVzIGFyZSB0aGVcbiAqIGNvcnJlc3BvbmRpbmcgU1FMLXN0YXRlcy5cbiAqL1xuY29uc3QgZXJyQ29kZVRvU3FsU3RhdGUgPSBleHBvcnRzLm1hcEVycm9yQ29kZVRvU3FsU3RhdGUgPVxuICB7XG4gICAgNDA1NTAxOiAnMDgwMDInLFxuICAgIDQwNTUwMjogJzA4MDAyJyxcbiAgICA0MDU1MDM6ICcwODAwMycsXG4gICAgNDA3MDAxOiAnMDgwMDMnLFxuICAgIDQwNzAwMjogJzA4MDAzJ1xuICB9O1xuXG4vKipcbiAqIEFuIGVudW1lcmF0aW9uIG9mIGFsbCB0aGUgZGlmZmVyZW50IHR5cGVzIG9mIGVycm9ycyB3ZSBjcmVhdGUuXG4gKi9cbmNvbnN0IGVycm9yVHlwZXMgPVxuICB7XG4gICAgLy8gaW50ZXJuYWwgc3luY2hyb25vdXMgZXJyb3JzXG4gICAgSW50ZXJuYWxBc3NlcnRFcnJvcjogJ0ludGVybmFsQXNzZXJ0RXJyb3InLFxuXG4gICAgLy8gZXh0ZXJuYWwgc3luY2hyb25vdXMgZXJyb3JzXG4gICAgTWlzc2luZ1BhcmFtZXRlckVycm9yOiAnTWlzc2luZ1BhcmFtZXRlckVycm9yJyxcbiAgICBJbnZhbGlkUGFyYW1ldGVyRXJyb3I6ICdJbnZhbGlkUGFyYW1ldGVyRXJyb3InLFxuXG4gICAgLy8gZXh0ZXJuYWwgYXN5bmNocm9ub3VzIGVycm9yc1xuICAgIE5ldHdvcmtFcnJvcjogJ05ldHdvcmtFcnJvcicsXG4gICAgUmVxdWVzdEZhaWxlZEVycm9yOiAnUmVxdWVzdEZhaWxlZEVycm9yJyxcbiAgICBVbmV4cGVjdGVkQ29udGVudEVycm9yOiAnVW5leHBlY3RlZENvbnRlbnRFcnJvcicsXG4gICAgT3BlcmF0aW9uRmFpbGVkRXJyb3I6ICdPcGVyYXRpb25GYWlsZWRFcnJvcicsXG4gICAgTGFyZ2VSZXN1bHRTZXRFcnJvcjogJ0xhcmdlUmVzdWx0U2V0RXJyb3InLFxuICAgIENsaWVudEVycm9yOiAnQ2xpZW50RXJyb3InLFxuICAgIE9DU1BFcnJvcjogJ09DU1BFcnJvcidcbiAgfTtcblxuLyoqXG4gKiBFbnN1cmVzIHRoZSB0cnV0aCBvZiBhbiBleHByZXNzaW9uLiBVc2VkIHRvIGNhdGNoIGludGVybmFsIHByb2dyYW1taW5nXG4gKiBlcnJvcnMuIElmIHRoZSBnaXZlbiBleHByZXNzaW9uIGlzIGZhbHNlLCBhbiBJbnRlcm5hbEFzc2VydEVycm9yIHdpbGwgYmVcbiAqIHRocm93bi5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGV4cHJlc3Npb24gYSBib29sZWFuIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIGEgbWVzc2FnZSBmb3IgdGhlIGVycm9yIHNob3VsZCB0aGUgY2hlY2sgZmFpbC5cbiAqL1xuZXhwb3J0cy5hc3NlcnRJbnRlcm5hbCA9IGZ1bmN0aW9uIChleHByZXNzaW9uLCBtZXNzYWdlKSB7XG4gIGlmICghZXhwcmVzc2lvbikge1xuICAgIHRocm93IGNyZWF0ZUVycm9yKGVycm9yVHlwZXMuSW50ZXJuYWxBc3NlcnRFcnJvcixcbiAgICAgIHtcbiAgICAgICAgY29kZTogY29kZXMuRVJSX0lOVEVSTkFMX0FTU0VSVF9GQUlMRUQsXG4gICAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgIHN5bmNocm9ub3VzOiB0cnVlXG4gICAgICB9KTtcbiAgfVxufTtcblxuLyoqXG4gKiBFbnN1cmVzIHRoZSB0cnV0aCBvZiBhbiBleHByZXNzaW9uLiBVc2VkIHRvIG1ha2Ugc3VyZSBhbGwgcmVxdWlyZWQgYXJndW1lbnRzXG4gKiBhcmUgcGFzc2VkIGluIHRvIGEgbWV0aG9kLiBJZiB0aGUgc3BlY2lmaWVkIGV4cHJlc3Npb24gaXMgZmFsc2UsIGFcbiAqIE1pc3NpbmdQYXJhbWV0ZXJFcnJvciB3aWxsIGJlIHRocm93bi5cbiAqXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGV4cHJlc3Npb24gYSBib29sZWFuIGV4cHJlc3Npb24uXG4gKiBAcGFyYW0ge051bWJlcn0gZXJyb3JDb2RlIGEgY29kZSBmb3IgdGhlIGVycm9yIHNob3VsZCB0aGUgY2hlY2sgZmFpbC5cbiAqXG4gKiBAdGhyb3dzIHdpbGwgdGhyb3cgYW4gTWlzc2luZ1BhcmFtZXRlciBlcnJvciBpZiB0aGUgZXhwcmVzc2lvbiBpcyBmYWxzZS5cbiAqL1xuZXhwb3J0cy5jaGVja0FyZ3VtZW50RXhpc3RzID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIGVycm9yQ29kZSkge1xuICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICB0aHJvdyBjcmVhdGVFcnJvcihlcnJvclR5cGVzLk1pc3NpbmdQYXJhbWV0ZXJFcnJvcixcbiAgICAgIHtcbiAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICBtZXNzYWdlQXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgc3luY2hyb25vdXM6IHRydWVcbiAgICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIEVuc3VyZXMgdGhlIHRydXRoIG9mIGFuIGV4cHJlc3Npb24uIFVzZWQgZm9yIHZhbGlkYXRpbmcgYXJndW1lbnRzIHRvIG1ldGhvZHMuXG4gKiBJZiB0aGUgc3BlY2lmaWVkIGV4cHJlc3Npb24gaXMgZmFsc2UsIGFuIEludmFsaWRQYXJhbWV0ZXJFcnJvciB3aWxsIGJlXG4gKiB0aHJvd24uXG4gKlxuICogQHBhcmFtIHtCb29sZWFufSBleHByZXNzaW9uIGEgYm9vbGVhbiBleHByZXNzaW9uLlxuICogQHBhcmFtIHtOdW1iZXJ9IGVycm9yQ29kZSBhIGNvZGUgZm9yIHRoZSBlcnJvciBzaG91bGQgdGhlIGNoZWNrIGZhaWwuXG4gKlxuICogQHRocm93cyB3aWxsIHRocm93IGFuIEludmFsaWRQYXJhbWV0ZXIgZXJyb3IgaWYgdGhlIGV4cHJlc3Npb24gaXMgZmFsc2UuXG4gKi9cbmV4cG9ydHMuY2hlY2tBcmd1bWVudFZhbGlkID0gZnVuY3Rpb24gKGV4cHJlc3Npb24sIGVycm9yQ29kZSkge1xuICBpZiAoIWV4cHJlc3Npb24pIHtcbiAgICB0aHJvdyBjcmVhdGVFcnJvcihlcnJvclR5cGVzLkludmFsaWRQYXJhbWV0ZXJFcnJvcixcbiAgICAgIHtcbiAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICBtZXNzYWdlQXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKSxcbiAgICAgICAgc3luY2hyb25vdXM6IHRydWVcbiAgICAgIH0pO1xuICB9XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTmV0d29ya0Vycm9yLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBlcnJvckNvZGUgdGhlIGVycm9yIGNvZGUgdG8gdXNlIHdoZW4gYnVpbGRpbmcgdGhlIGVycm9yLlxuICogQHBhcmFtIHtFcnJvcn0gY2F1c2UgdGhlIHVuZGVybHlpbmcgY2F1c2Ugb2YgdGhlIG5ldHdvcmsgZXJyb3IuXG4gKlxuICogQHJldHVybnMge0Vycm9yfVxuICovXG5leHBvcnRzLmNyZWF0ZU5ldHdvcmtFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIGNhdXNlKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihlcnJvclR5cGVzLk5ldHdvcmtFcnJvcixcbiAgICB7XG4gICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICBjYXVzZTogY2F1c2VcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBSZXF1ZXN0RmFpbGVkRXJyb3IuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGVycm9yQ29kZSB0aGUgZXJyb3IgY29kZSB0byB1c2Ugd2hlbiBidWlsZGluZyB0aGUgZXJyb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgdGhlIHJlc3BvbnNlIHNlbnQgYnkgR2xvYmFsIFNlcnZpY2VzLlxuICpcbiAqIEByZXR1cm5zIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5jcmVhdGVSZXF1ZXN0RmFpbGVkRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCByZXNwb25zZSkge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoZXJyb3JUeXBlcy5SZXF1ZXN0RmFpbGVkRXJyb3IsXG4gICAge1xuICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVW5leHBlY3RlZENvbnRlbnRFcnJvci5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZXJyb3JDb2RlIHRoZSBlcnJvciBjb2RlIHRvIHVzZSB3aGVuIGJ1aWxkaW5nIHRoZSBlcnJvci5cbiAqIEBwYXJhbSB7U3RyaW5nfSByZXNwb25zZUJvZHkgdGhlIHJlc3BvbnNlIGJvZHkgc2VudCBieSBHbG9iYWwgU2VydmljZXMuXG4gKlxuICogQHJldHVybnMge0Vycm9yfVxuICovXG5leHBvcnRzLmNyZWF0ZVVuZXhwZWN0ZWRDb250ZW50RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlLCByZXNwb25zZUJvZHkpIHtcbiAgcmV0dXJuIGNyZWF0ZUVycm9yKGVycm9yVHlwZXMuVW5leHBlY3RlZENvbnRlbnRFcnJvcixcbiAgICB7XG4gICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICByZXNwb25zZUJvZHk6IHJlc3BvbnNlQm9keVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IE9wZXJhdGlvbkZhaWxlZEVycm9yLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBlcnJvckNvZGUgdGhlIGVycm9yIGNvZGUgdG8gdXNlIHdoZW4gYnVpbGRpbmcgdGhlIGVycm9yLlxuICogQHBhcmFtIHtPYmplY3R9IGRhdGEgdGhlIGRhdGEgc2VudCBieSBHbG9iYWwgU2VydmljZXMuXG4gKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSB0aGUgZXJyb3IgbWVzc2FnZSBzZW50IGJ5IEdsb2JhbCBTZXJ2aWNlcy5cbiAqIEBwYXJhbSB7U3RyaW5nfSBzcWxTdGF0ZSB0aGUgc3FsIHN0YXRlIHNlbnQgYnkgR2xvYmFsIFNlcnZpY2VzLlxuICpcbiAqIEByZXR1cm5zIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5jcmVhdGVPcGVyYXRpb25GYWlsZWRFcnJvciA9IGZ1bmN0aW9uIChcbiAgZXJyb3JDb2RlLCBkYXRhLCBtZXNzYWdlLCBzcWxTdGF0ZSkge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoZXJyb3JUeXBlcy5PcGVyYXRpb25GYWlsZWRFcnJvcixcbiAgICB7XG4gICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSxcbiAgICAgIHNxbFN0YXRlOiBzcWxTdGF0ZVxuICAgIH0pO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IExhcmdlUmVzdWx0U2V0RXJyb3IuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGVycm9yQ29kZSB0aGUgZXJyb3IgY29kZSB0byB1c2Ugd2hlbiBidWlsZGluZyB0aGUgZXJyb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2UgdGhlIHJlc3BvbnNlIHNlbnQgYnkgUzMvQmxvYi5cbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9XG4gKi9cbmV4cG9ydHMuY3JlYXRlTGFyZ2VSZXN1bHRTZXRFcnJvciA9IGZ1bmN0aW9uIChlcnJvckNvZGUsIHJlc3BvbnNlKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihlcnJvclR5cGVzLkxhcmdlUmVzdWx0U2V0RXJyb3IsXG4gICAge1xuICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgcmVzcG9uc2U6IHJlc3BvbnNlXG4gICAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgQ2xpZW50RXJyb3IuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGVycm9yQ29kZSB0aGUgZXJyb3IgY29kZSB0byB1c2Ugd2hlbiBidWlsZGluZyB0aGUgZXJyb3IuXG4gKiBAcGFyYW0ge09iamVjdH0gW2lzRmF0YWxdIHdoZXRoZXIgdGhlIGVycm9yIGlzIGZhdGFsLlxuICpcbiAqIEByZXR1cm4ge0Vycm9yfVxuICovXG5leHBvcnRzLmNyZWF0ZUNsaWVudEVycm9yID0gZnVuY3Rpb24gKGVycm9yQ29kZSwgaXNGYXRhbCkge1xuICByZXR1cm4gY3JlYXRlRXJyb3IoZXJyb3JUeXBlcy5DbGllbnRFcnJvcixcbiAgICB7XG4gICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICBpc0ZhdGFsOiBpc0ZhdGFsLFxuICAgICAgbWVzc2FnZUFyZ3M6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMilcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIE9DU1BFcnJvclxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBlcnJvckNvZGUgdGhlIGVycm9yIGNvZGUgdG8gdXNlIHdoZW4gYnVpbGRpbmcgdGhlIGVycm9yLlxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAqIEByZXR1cm5zIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5jcmVhdGVPQ1NQRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3JDb2RlKSB7XG4gIHJldHVybiBjcmVhdGVFcnJvcihlcnJvclR5cGVzLk9DU1BFcnJvcixcbiAgICB7XG4gICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICBtZXNzYWdlQXJnczogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKVxuICAgIH1cbiAgKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBlcnJvciBieSBjb21iaW5pbmcgdGhlIGVycm9yIG1lc3NhZ2VzIGZyb20gdGhlIGpzb24gcGFyc2VyIGFuZCB4bWwgcGFyc2VyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGpzb25QYXJzZUVycm9yIGNvbnRhaW5zIHRoZSBKU09OIHBhcnNlIGVycm9yIG1lc3NhZ2VcbiAqIEBwYXJhbSB7T2JqZWN0fSB4bWxQYXJzZUVycm9yIGNvbnRhaW5zIHRoZSBYTUwgcGFyc2UgZXJyb3IgbWVzc2FnZVxuICogQHJldHVybnMge0Vycm9yfVxuICovXG5leHBvcnRzLlZhcmlhbnRQYXJzZUVycm9yID0gZnVuY3Rpb24gKGpzb25QYXJzZUVycm9yLCB4bWxQYXJzZUVycm9yKSB7XG4gIGNvbnN0IGVyck1lc3NhZ2UgPSAnVmFyaWFudFBhcnNlRXJyb3I6IFZhcmlhbnQgY2Fubm90IGJlIHBhcnNlZCBuZWl0aGVyIGFzIEpTT04gbm9yIGFzIFhNTDpcXG4nICtcbiAgICBgIC0gSlNPTiBwYXJzZSBlcnJvciBtZXNzYWdlOiAke2pzb25QYXJzZUVycm9yLm1lc3NhZ2V9XFxuYCArXG4gICAgYCAtIFhNTCBwYXJzZSBlcnJvciBtZXNzYWdlOiAke3htbFBhcnNlRXJyb3IubWVzc2FnZX1gO1xuICByZXR1cm4gbmV3IEVycm9yKGVyck1lc3NhZ2UpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gZXJyb3IgaXMgYW4gSW50ZXJuYWxBc3NlcnRFcnJvci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzSW50ZXJuYWxBc3NlcnRFcnJvciA9IGZ1bmN0aW9uIChlcnJvcikge1xuICByZXR1cm4gaXNFcnJvck9mVHlwZShlcnJvciwgZXJyb3JUeXBlcy5JbnRlcm5hbEFzc2VydEVycm9yKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGVycm9yIGlzIGEgTWlzc2luZ1BhcmFtZXRlckVycm9yLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNNaXNzaW5nUGFyYW1ldGVyRXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgcmV0dXJuIGlzRXJyb3JPZlR5cGUoZXJyb3IsIGVycm9yVHlwZXMuTWlzc2luZ1BhcmFtZXRlckVycm9yKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGVycm9yIGlzIGFuIEludmFsaWRQYXJhbWV0ZXJFcnJvci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzSW52YWxpZFBhcmFtZXRlckVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gIHJldHVybiBpc0Vycm9yT2ZUeXBlKGVycm9yLCBlcnJvclR5cGVzLkludmFsaWRQYXJhbWV0ZXJFcnJvcik7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBlcnJvciBpcyBhIE5ldHdvcmtFcnJvci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzTmV0d29ya0Vycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gIHJldHVybiBpc0Vycm9yT2ZUeXBlKGVycm9yLCBlcnJvclR5cGVzLk5ldHdvcmtFcnJvcik7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBlcnJvciBpcyBhIFJlcXVlc3RGYWlsZWRFcnJvci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzUmVxdWVzdEZhaWxlZEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gIHJldHVybiBpc0Vycm9yT2ZUeXBlKGVycm9yLCBlcnJvclR5cGVzLlJlcXVlc3RGYWlsZWRFcnJvcik7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBlcnJvciBpcyBhbiBVbmV4cGVjdGVkQ29udGVudEVycm9yLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVycm9yXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNVbmV4cGVjdGVkQ29udGVudEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gIHJldHVybiBpc0Vycm9yT2ZUeXBlKGVycm9yLCBlcnJvclR5cGVzLlVuZXhwZWN0ZWRDb250ZW50RXJyb3IpO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gZXJyb3IgaXMgYW4gT3BlcmF0aW9uRmFpbGVkRXJyb3IuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc09wZXJhdGlvbkZhaWxlZEVycm9yID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gIHJldHVybiBpc0Vycm9yT2ZUeXBlKGVycm9yLCBlcnJvclR5cGVzLk9wZXJhdGlvbkZhaWxlZEVycm9yKTtcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGVycm9yIGlzIGFuIExhcmdlUmVzdWx0U2V0RXJyb3IuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0xhcmdlUmVzdWx0U2V0RXJyb3IgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgcmV0dXJuIGlzRXJyb3JPZlR5cGUoZXJyb3IsIGVycm9yVHlwZXMuTGFyZ2VSZXN1bHRTZXRFcnJvcik7XG59O1xuXG4vKipcbiAqIEV4dGVybmFsaXplcyBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvclxuICpcbiAqIEByZXR1cm5zIHtFcnJvcn1cbiAqL1xuZXhwb3J0cy5leHRlcm5hbGl6ZSA9IGZ1bmN0aW9uIChlcnJvcikge1xuICByZXR1cm4gZXJyb3IgJiYgZXJyb3IuZXh0ZXJuYWxpemUgPyBlcnJvci5leHRlcm5hbGl6ZSgpIDogZXJyb3I7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBlcnJvciBpcyBvZiBhIHNwZWNpZmljIHR5cGUuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzRXJyb3JPZlR5cGUoZXJyb3IsIHR5cGUpIHtcbiAgcmV0dXJuIGVycm9yICYmIChlcnJvci5uYW1lID09PSB0eXBlKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgZ2VuZXJpYyBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7RXJyb3J9XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yKG5hbWUsIG9wdGlvbnMpIHtcbiAgLy8gVE9ETzogdmFsaWRhdGUgdGhhdCBuYW1lIGlzIGEgc3RyaW5nIGFuZCBvcHRpb25zIGlzIGFuIG9iamVjdFxuXG4gIC8vIFRPRE86IHRoaXMgY29kZSBpcyBhIGJpdCBvZiBhIG1lc3MgYW5kIG5lZWRzIHRvIGJlIGNsZWFuZWQgdXBcblxuICAvLyBjcmVhdGUgYSBuZXcgZXJyb3JcbiAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoKTtcblxuICAvLyBzZXQgaXRzIG5hbWVcbiAgZXJyb3IubmFtZSA9IG5hbWU7XG5cbiAgLy8gc2V0IHRoZSBlcnJvciBjb2RlXG4gIGxldCBjb2RlO1xuICBlcnJvci5jb2RlID0gY29kZSA9IG9wdGlvbnMuY29kZTtcblxuICAvLyBpZiBubyBlcnJvciBtZXNzYWdlIHdhcyBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnNcbiAgbGV0IG1lc3NhZ2UgPSBvcHRpb25zLm1lc3NhZ2U7XG4gIGlmICghbWVzc2FnZSkge1xuICAgIC8vIHVzZSB0aGUgZXJyb3IgY29kZSB0byBnZXQgdGhlIGVycm9yIG1lc3NhZ2UgdGVtcGxhdGVcbiAgICBjb25zdCBtZXNzYWdlVGVtcGxhdGUgPSBlcnJvck1lc3NhZ2VzW2NvZGVdO1xuXG4gICAgLy8gaWYgc29tZSBlcnJvciBtZXNzYWdlIGFyZ3VtZW50cyB3ZXJlIHNwZWNpZmllZCwgc3Vic3RpdHV0ZSB0aGVtIGludG8gdGhlXG4gICAgLy8gZXJyb3IgbWVzc2FnZSB0ZW1wbGF0ZSB0byBnZXQgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSwgb3RoZXJ3aXNlIGp1c3QgdXNlXG4gICAgLy8gdGhlIGVycm9yIG1lc3NhZ2UgdGVtcGxhdGUgYXMgdGhlIGVycm9yIG1lc3NhZ2VcbiAgICBsZXQgbWVzc2FnZUFyZ3MgPSBvcHRpb25zLm1lc3NhZ2VBcmdzO1xuICAgIGlmIChtZXNzYWdlQXJncykge1xuICAgICAgbWVzc2FnZUFyZ3MgPSBtZXNzYWdlQXJncy5zbGljZSgpO1xuICAgICAgbWVzc2FnZUFyZ3MudW5zaGlmdChtZXNzYWdlVGVtcGxhdGUpO1xuICAgICAgbWVzc2FnZSA9IFV0aWwuZm9ybWF0LmFwcGx5KFV0aWwsIG1lc3NhZ2VBcmdzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZSA9IG1lc3NhZ2VUZW1wbGF0ZTtcbiAgICB9XG4gIH1cbiAgZXJyb3IubWVzc2FnZSA9IG1lc3NhZ2U7XG5cbiAgLy8gaWYgbm8gc3FsIHN0YXRlIHdhcyBzcGVjaWZpZWQgaW4gdGhlIG9wdGlvbnMsIHVzZSB0aGUgZXJyb3IgY29kZSB0byB0cnkgdG9cbiAgLy8gZ2V0IHRoZSBhcHByb3ByaWF0ZSBzcWwgc3RhdGVcbiAgbGV0IHNxbFN0YXRlID0gb3B0aW9ucy5zcWxTdGF0ZTtcbiAgaWYgKCFzcWxTdGF0ZSkge1xuICAgIHNxbFN0YXRlID0gZXJyQ29kZVRvU3FsU3RhdGVbY29kZV07XG4gIH1cbiAgZXJyb3Iuc3FsU3RhdGUgPSBzcWxTdGF0ZTtcblxuICAvLyBzZXQgdGhlIGVycm9yIGRhdGFcbiAgZXJyb3IuZGF0YSA9IG9wdGlvbnMuZGF0YTtcblxuICAvLyBzZXQgdGhlIGVycm9yIHJlc3BvbnNlIGFuZCByZXNwb25zZSBib2R5XG4gIGVycm9yLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgZXJyb3IucmVzcG9uc2VCb2R5ID0gb3B0aW9ucy5yZXNwb25zZUJvZHk7XG5cbiAgLy8gc2V0IHRoZSBlcnJvciBjYXVzZVxuICBlcnJvci5jYXVzZSA9IG9wdGlvbnMuY2F1c2U7XG5cbiAgLy8gc2V0IHRoZSBlcnJvcidzIGZhdGFsIGZsYWdcbiAgZXJyb3IuaXNGYXRhbCA9IG9wdGlvbnMuaXNGYXRhbDtcblxuICAvLyBpZiB0aGUgZXJyb3IgaXMgbm90IHN5bmNocm9ub3VzLCBhZGQgYW4gZXh0ZXJuYWxpemUoKSBtZXRob2RcbiAgaWYgKCFvcHRpb25zLnN5bmNocm9ub3VzKSB7XG4gICAgZXJyb3IuZXh0ZXJuYWxpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zdCBwcm9wTmFtZXMgPVxuICAgICAgICBbXG4gICAgICAgICAgJ25hbWUnLFxuICAgICAgICAgICdjb2RlJyxcbiAgICAgICAgICAnbWVzc2FnZScsXG4gICAgICAgICAgJ3NxbFN0YXRlJyxcbiAgICAgICAgICAnZGF0YScsXG4gICAgICAgICAgJ3Jlc3BvbnNlJyxcbiAgICAgICAgICAncmVzcG9uc2VCb2R5JyxcbiAgICAgICAgICAnY2F1c2UnLFxuICAgICAgICAgICdpc0ZhdGFsJyxcbiAgICAgICAgICAnc3RhY2snXG4gICAgICAgIF07XG5cbiAgICAgIGNvbnN0IGV4dGVybmFsaXplZEVycm9yID0gbmV3IEVycm9yKCk7XG5cbiAgICAgIGxldCBwcm9wTmFtZSwgcHJvcFZhbHVlO1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBwcm9wTmFtZXMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBwcm9wTmFtZSA9IHByb3BOYW1lc1tpbmRleF07XG4gICAgICAgIHByb3BWYWx1ZSA9IHRoaXNbcHJvcE5hbWVdO1xuICAgICAgICBpZiAoVXRpbC5leGlzdHMocHJvcFZhbHVlKSkge1xuICAgICAgICAgIGV4dGVybmFsaXplZEVycm9yW3Byb3BOYW1lXSA9IHByb3BWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gZXh0ZXJuYWxpemVkRXJyb3I7XG4gICAgfTtcbiAgfVxuXG4gIHJldHVybiBlcnJvcjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/errors.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/azure_util.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/file_transfer_agent/azure_util.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const EncryptionMetadata = (__webpack_require__(/*! ./encrypt_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/encrypt_util.js\").EncryptionMetadata);\nconst FileHeader = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\").FileHeader);\nconst expandTilde = __webpack_require__(/*! expand-tilde */ \"(rsc)/./node_modules/expand-tilde/index.js\");\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\").resultStatus);\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/proxy_util.js\");\nconst { isBypassProxy } = __webpack_require__(/*! ../http/node */ \"(rsc)/./node_modules/snowflake-sdk/lib/http/node.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\n\nconst EXPIRED_TOKEN = 'ExpiredToken';\n\n// Azure Location\nfunction AzureLocation(containerName, path) {\n  return {\n    'containerName': containerName,\n    'path': path\n  };\n}\n\n/**\n * Creates an Azure utility object.\n *\n * @param {module} azure\n * @param {module} filestream\n *\n * @returns {Object}\n * @constructor\n */\nfunction AzureUtil(connectionConfig, azure, filestream) {\n  const AZURE = typeof azure !== 'undefined' ? azure : __webpack_require__(/*! @azure/storage-blob */ \"(rsc)/./node_modules/@azure/storage-blob/dist-esm/storage-blob/src/index.js\");\n  const fs = typeof filestream !== 'undefined' ? filestream : __webpack_require__(/*! fs */ \"fs\");\n\n  /**\n  * Create a blob service client using an Azure SAS token.\n  *\n  * @param {Object} stageInfo\n  *\n  * @returns {String}\n  */\n  this.createClient = function (stageInfo) {\n    const stageCredentials = stageInfo['creds'];\n    const sasToken = stageCredentials['AZURE_SAS_TOKEN'];\n\n    const account = stageInfo['storageAccount'];\n    const connectionString = `https://${account}.blob.core.windows.net${sasToken}`;\n    let proxy = ProxyUtil.getProxy(connectionConfig.getProxy(), 'Azure Util');\n    if (proxy && !isBypassProxy(proxy, connectionString)) {\n      Logger.getInstance().debug(`The destination host is: ${ProxyUtil.getHostFromURL(connectionString)} and the proxy host is: ${proxy.host}`);\n      Logger.getInstance().trace(`Initializing the proxy information for the Azure Client: ${ProxyUtil.describeProxy(proxy)}`);\n\n      proxy = ProxyUtil.getAzureProxy(proxy);\n    }\n    ProxyUtil.hideEnvironmentProxy();\n    const blobServiceClient = new AZURE.BlobServiceClient(\n      connectionString, null,\n      {\n        proxyOptions: proxy,\n      }\n    );\n    ProxyUtil.restoreEnvironmentProxy();\n    return blobServiceClient;\n  };\n\n  /**\n  * Extract the container name and path from the metadata's stage location.\n  *\n  * @param {String} stageLocation\n  *\n  * @returns {Object}\n  */\n  this.extractContainerNameAndPath = function (stageLocation) {\n    // expand '~' and '~user' expressions\n    if (process.platform !== 'win32') {\n      stageLocation = expandTilde(stageLocation);\n    }\n\n    let containerName = stageLocation;\n    let path;\n\n    // split stage location as bucket name and path\n    if (stageLocation.includes('/')) {\n      containerName = stageLocation.substring(0, stageLocation.indexOf('/'));\n\n      path = stageLocation.substring(stageLocation.indexOf('/') + 1, stageLocation.length);\n      if (path && !path.endsWith('/')) {\n        path += '/';\n      }\n    }\n\n    return AzureLocation(containerName, path);\n  };\n\n  /**\n  * Create file header based on file being uploaded or not.\n  *\n  * @param {Object} meta\n  * @param {String} filename\n  *\n  * @returns {Object}\n  */\n  this.getFileHeader = async function (meta, filename) {\n    const stageInfo = meta['stageInfo'];\n    const client = this.createClient(stageInfo);\n    const azureLocation = this.extractContainerNameAndPath(stageInfo['location']);\n\n    const containerClient = client.getContainerClient(azureLocation.containerName);\n    const blobClient = containerClient.getBlobClient(azureLocation.path + filename);\n\n    let blobDetails;\n\n    try {\n      await blobClient.getProperties()\n        .then(function (data) {\n          blobDetails = data;\n        });\n    } catch (err) {\n      if (err['code'] === EXPIRED_TOKEN) {\n        meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n        return null;\n      } else if (err['statusCode'] === 404) {\n        meta['resultStatus'] = resultStatus.NOT_FOUND_FILE;\n        return FileHeader(null, null, null);\n      } else if (err['statusCode'] === 400) {\n        meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n        return null;\n      } else {\n        meta['resultStatus'] = resultStatus.ERROR;\n        return null;\n      }\n    }\n\n    meta['resultStatus'] = resultStatus.UPLOADED;\n\n    let encryptionMetadata = null;\n    if (blobDetails.metadata['encryptiondata']) {\n      const encryptionData = JSON.parse(blobDetails.metadata['encryptiondata']);\n      encryptionMetadata = EncryptionMetadata(\n        encryptionData['WrappedContentKey']['EncryptedKey'],\n        encryptionData['ContentEncryptionIV'],\n        blobDetails.metadata['matdesc']\n      );\n    }\n\n    return FileHeader(\n      blobDetails.metadata['sfcdigest'],\n      blobDetails.contentLength,\n      encryptionMetadata\n    );\n  };\n\n  /**\n  * Create the file metadata then upload the file.\n  *\n  * @param {String} dataFile\n  * @param {Object} meta\n  * @param {Object} encryptionMetadata\n  * @param {Number} maxConcurrency\n  *\n  * @returns {null}\n  */\n  this.uploadFile = async function (dataFile, meta, encryptionMetadata, maxConcurrency) {\n    const fileStream = fs.readFileSync(dataFile);\n    await this.uploadFileStream(fileStream, meta, encryptionMetadata, maxConcurrency);\n  };\n\n  /**\n  * Create the file metadata then upload the file stream.\n  *\n  * @param {String} fileStream\n  * @param {Object} meta\n  * @param {Object} encryptionMetadata\n  *\n  * @returns {null}\n  */\n  this.uploadFileStream = async function (fileStream, meta, encryptionMetadata) {\n    const azureMetadata = {\n      'sfcdigest': meta['SHA256_DIGEST']\n    };\n\n    if (encryptionMetadata) {\n      azureMetadata['encryptiondata'] =\n        JSON.stringify({\n          'EncryptionMode': 'FullBlob',\n          'WrappedContentKey': {\n            'KeyId': 'symmKey1',\n            'EncryptedKey': encryptionMetadata.key,\n            'Algorithm': 'AES_CBC_256'\n          },\n          'EncryptionAgent': {\n            'Protocol': '1.0',\n            'EncryptionAlgorithm': 'AES_CBC_128',\n          },\n          'ContentEncryptionIV': encryptionMetadata.iv,\n          'KeyWrappingMetadata': {\n            'EncryptionLibrary': 'Java 5.3.0'\n          }\n        });\n      azureMetadata['matdesc'] = encryptionMetadata.matDesc;\n    }\n\n    const stageInfo = meta['stageInfo'];\n    const client = this.createClient(stageInfo);\n    const azureLocation = this.extractContainerNameAndPath(stageInfo['location']);\n    const blobName = azureLocation.path + meta['dstFileName'];\n\n    const containerClient = client.getContainerClient(azureLocation.containerName);\n    const blockBlobClient = containerClient.getBlockBlobClient(blobName);\n\n    try {\n      await blockBlobClient.upload(fileStream, fileStream.length, {\n        metadata: azureMetadata,\n        blobHTTPHeaders:\n        {\n          blobContentEncoding: 'UTF-8',\n          blobContentType: 'application/octet-stream'\n        }\n      });\n    } catch (err) {\n      if (err['statusCode'] === 403 && detectAzureTokenExpireError(err)) {\n        meta['lastError'] = err;\n        meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n        return;\n      } else {\n        meta['lastError'] = err;\n        meta['resultStatus'] = resultStatus.NEED_RETRY;\n      }\n      return;\n    }\n    meta['dstFileSize'] = meta['uploadSize'];\n    meta['resultStatus'] = resultStatus.UPLOADED;\n  };\n\n  /**\n   * Download the file blob then write the file.\n   *\n   * @param {Object} meta\n   * @param fullDstPath\n   *\n   * @returns {null}\n   */\n  this.nativeDownloadFile = async function (meta, fullDstPath) {\n    const stageInfo = meta['stageInfo'];\n    const client = this.createClient(stageInfo);\n    const azureLocation = this.extractContainerNameAndPath(stageInfo['location']);\n    const blobName = azureLocation.path + meta['srcFileName'];\n\n    const containerClient = client.getContainerClient(azureLocation.containerName);\n    const blockBlobClient = containerClient.getBlockBlobClient(blobName);\n\n    try {\n      const downloadBlockBlobResponse  = await blockBlobClient.download(0);\n      const readableStream = downloadBlockBlobResponse.readableStreamBody;\n\n      await new Promise((resolve, reject) => {\n        const writer = fs.createWriteStream(fullDstPath);\n        readableStream.on('data', (data) => {\n          writer.write(data);\n        });\n        readableStream.on('end', () => {\n          writer.end(resolve);\n        });\n        readableStream.on('error', reject);\n      });\n    } catch (err) {\n      if (err['statusCode'] === 403 && detectAzureTokenExpireError(err)) {\n        meta['lastError'] = err;\n        meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n        return;\n      } else {\n        meta['lastError'] = err;\n        meta['resultStatus'] = resultStatus.NEED_RETRY;\n      }\n      return;\n    }\n    meta['resultStatus'] = resultStatus.DOWNLOADED;\n  };\n\n  /**\n  * Detect if the Azure token has expired.\n  *\n  * @param {Object} err\n  *\n  * @returns {Boolean}\n  */\n  function detectAzureTokenExpireError(err) {\n    if (err['statusCode'] !== 403) {\n      return false;\n    }\n    const errstr = err.toString();\n    return errstr.includes('Signature not valid in the specified time frame') ||\n      errstr.includes('Server failed to authenticate the request.');\n  }\n}\nmodule.exports = AzureUtil;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9henVyZV91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBLDJCQUEyQiw0SUFBNEM7QUFDdkUsbUJBQW1CLDJHQUFrQztBQUNyRCxvQkFBb0IsbUJBQU8sQ0FBQyxnRUFBYztBQUMxQyxxQkFBcUIsNkdBQW9DO0FBQ3pELGtCQUFrQixtQkFBTyxDQUFDLDJFQUFlO0FBQ3pDLFFBQVEsZ0JBQWdCLEVBQUUsbUJBQU8sQ0FBQyx5RUFBYztBQUNoRCxlQUFlLG1CQUFPLENBQUMsbUVBQVc7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsdURBQXVELG1CQUFPLENBQUMsd0dBQXFCO0FBQ3BGLDhEQUE4RCxtQkFBTyxDQUFDLGNBQUk7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdDQUF3QyxRQUFRLHdCQUF3QixTQUFTO0FBQ2pGO0FBQ0E7QUFDQSw2REFBNkQsNENBQTRDLHlCQUF5QixXQUFXO0FBQzdJLDZGQUE2RiwrQkFBK0I7O0FBRTVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2ZpbGVfdHJhbnNmZXJfYWdlbnQvYXp1cmVfdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFbmNyeXB0aW9uTWV0YWRhdGEgPSByZXF1aXJlKCcuL2VuY3J5cHRfdXRpbCcpLkVuY3J5cHRpb25NZXRhZGF0YTtcbmNvbnN0IEZpbGVIZWFkZXIgPSByZXF1aXJlKCcuLi9maWxlX3V0aWwnKS5GaWxlSGVhZGVyO1xuY29uc3QgZXhwYW5kVGlsZGUgPSByZXF1aXJlKCdleHBhbmQtdGlsZGUnKTtcbmNvbnN0IHJlc3VsdFN0YXR1cyA9IHJlcXVpcmUoJy4uL2ZpbGVfdXRpbCcpLnJlc3VsdFN0YXR1cztcbmNvbnN0IFByb3h5VXRpbCA9IHJlcXVpcmUoJy4uL3Byb3h5X3V0aWwnKTtcbmNvbnN0IHsgaXNCeXBhc3NQcm94eSB9ID0gcmVxdWlyZSgnLi4vaHR0cC9ub2RlJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcblxuY29uc3QgRVhQSVJFRF9UT0tFTiA9ICdFeHBpcmVkVG9rZW4nO1xuXG4vLyBBenVyZSBMb2NhdGlvblxuZnVuY3Rpb24gQXp1cmVMb2NhdGlvbihjb250YWluZXJOYW1lLCBwYXRoKSB7XG4gIHJldHVybiB7XG4gICAgJ2NvbnRhaW5lck5hbWUnOiBjb250YWluZXJOYW1lLFxuICAgICdwYXRoJzogcGF0aFxuICB9O1xufVxuXG4vKipcbiAqIENyZWF0ZXMgYW4gQXp1cmUgdXRpbGl0eSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHttb2R1bGV9IGF6dXJlXG4gKiBAcGFyYW0ge21vZHVsZX0gZmlsZXN0cmVhbVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gQXp1cmVVdGlsKGNvbm5lY3Rpb25Db25maWcsIGF6dXJlLCBmaWxlc3RyZWFtKSB7XG4gIGNvbnN0IEFaVVJFID0gdHlwZW9mIGF6dXJlICE9PSAndW5kZWZpbmVkJyA/IGF6dXJlIDogcmVxdWlyZSgnQGF6dXJlL3N0b3JhZ2UtYmxvYicpO1xuICBjb25zdCBmcyA9IHR5cGVvZiBmaWxlc3RyZWFtICE9PSAndW5kZWZpbmVkJyA/IGZpbGVzdHJlYW0gOiByZXF1aXJlKCdmcycpO1xuXG4gIC8qKlxuICAqIENyZWF0ZSBhIGJsb2Igc2VydmljZSBjbGllbnQgdXNpbmcgYW4gQXp1cmUgU0FTIHRva2VuLlxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IHN0YWdlSW5mb1xuICAqXG4gICogQHJldHVybnMge1N0cmluZ31cbiAgKi9cbiAgdGhpcy5jcmVhdGVDbGllbnQgPSBmdW5jdGlvbiAoc3RhZ2VJbmZvKSB7XG4gICAgY29uc3Qgc3RhZ2VDcmVkZW50aWFscyA9IHN0YWdlSW5mb1snY3JlZHMnXTtcbiAgICBjb25zdCBzYXNUb2tlbiA9IHN0YWdlQ3JlZGVudGlhbHNbJ0FaVVJFX1NBU19UT0tFTiddO1xuXG4gICAgY29uc3QgYWNjb3VudCA9IHN0YWdlSW5mb1snc3RvcmFnZUFjY291bnQnXTtcbiAgICBjb25zdCBjb25uZWN0aW9uU3RyaW5nID0gYGh0dHBzOi8vJHthY2NvdW50fS5ibG9iLmNvcmUud2luZG93cy5uZXQke3Nhc1Rva2VufWA7XG4gICAgbGV0IHByb3h5ID0gUHJveHlVdGlsLmdldFByb3h5KGNvbm5lY3Rpb25Db25maWcuZ2V0UHJveHkoKSwgJ0F6dXJlIFV0aWwnKTtcbiAgICBpZiAocHJveHkgJiYgIWlzQnlwYXNzUHJveHkocHJveHksIGNvbm5lY3Rpb25TdHJpbmcpKSB7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgVGhlIGRlc3RpbmF0aW9uIGhvc3QgaXM6ICR7UHJveHlVdGlsLmdldEhvc3RGcm9tVVJMKGNvbm5lY3Rpb25TdHJpbmcpfSBhbmQgdGhlIHByb3h5IGhvc3QgaXM6ICR7cHJveHkuaG9zdH1gKTtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKGBJbml0aWFsaXppbmcgdGhlIHByb3h5IGluZm9ybWF0aW9uIGZvciB0aGUgQXp1cmUgQ2xpZW50OiAke1Byb3h5VXRpbC5kZXNjcmliZVByb3h5KHByb3h5KX1gKTtcblxuICAgICAgcHJveHkgPSBQcm94eVV0aWwuZ2V0QXp1cmVQcm94eShwcm94eSk7XG4gICAgfVxuICAgIFByb3h5VXRpbC5oaWRlRW52aXJvbm1lbnRQcm94eSgpO1xuICAgIGNvbnN0IGJsb2JTZXJ2aWNlQ2xpZW50ID0gbmV3IEFaVVJFLkJsb2JTZXJ2aWNlQ2xpZW50KFxuICAgICAgY29ubmVjdGlvblN0cmluZywgbnVsbCxcbiAgICAgIHtcbiAgICAgICAgcHJveHlPcHRpb25zOiBwcm94eSxcbiAgICAgIH1cbiAgICApO1xuICAgIFByb3h5VXRpbC5yZXN0b3JlRW52aXJvbm1lbnRQcm94eSgpO1xuICAgIHJldHVybiBibG9iU2VydmljZUNsaWVudDtcbiAgfTtcblxuICAvKipcbiAgKiBFeHRyYWN0IHRoZSBjb250YWluZXIgbmFtZSBhbmQgcGF0aCBmcm9tIHRoZSBtZXRhZGF0YSdzIHN0YWdlIGxvY2F0aW9uLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IHN0YWdlTG9jYXRpb25cbiAgKlxuICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICovXG4gIHRoaXMuZXh0cmFjdENvbnRhaW5lck5hbWVBbmRQYXRoID0gZnVuY3Rpb24gKHN0YWdlTG9jYXRpb24pIHtcbiAgICAvLyBleHBhbmQgJ34nIGFuZCAnfnVzZXInIGV4cHJlc3Npb25zXG4gICAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcbiAgICAgIHN0YWdlTG9jYXRpb24gPSBleHBhbmRUaWxkZShzdGFnZUxvY2F0aW9uKTtcbiAgICB9XG5cbiAgICBsZXQgY29udGFpbmVyTmFtZSA9IHN0YWdlTG9jYXRpb247XG4gICAgbGV0IHBhdGg7XG5cbiAgICAvLyBzcGxpdCBzdGFnZSBsb2NhdGlvbiBhcyBidWNrZXQgbmFtZSBhbmQgcGF0aFxuICAgIGlmIChzdGFnZUxvY2F0aW9uLmluY2x1ZGVzKCcvJykpIHtcbiAgICAgIGNvbnRhaW5lck5hbWUgPSBzdGFnZUxvY2F0aW9uLnN1YnN0cmluZygwLCBzdGFnZUxvY2F0aW9uLmluZGV4T2YoJy8nKSk7XG5cbiAgICAgIHBhdGggPSBzdGFnZUxvY2F0aW9uLnN1YnN0cmluZyhzdGFnZUxvY2F0aW9uLmluZGV4T2YoJy8nKSArIDEsIHN0YWdlTG9jYXRpb24ubGVuZ3RoKTtcbiAgICAgIGlmIChwYXRoICYmICFwYXRoLmVuZHNXaXRoKCcvJykpIHtcbiAgICAgICAgcGF0aCArPSAnLyc7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIEF6dXJlTG9jYXRpb24oY29udGFpbmVyTmFtZSwgcGF0aCk7XG4gIH07XG5cbiAgLyoqXG4gICogQ3JlYXRlIGZpbGUgaGVhZGVyIGJhc2VkIG9uIGZpbGUgYmVpbmcgdXBsb2FkZWQgb3Igbm90LlxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAgKlxuICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICovXG4gIHRoaXMuZ2V0RmlsZUhlYWRlciA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhLCBmaWxlbmFtZSkge1xuICAgIGNvbnN0IHN0YWdlSW5mbyA9IG1ldGFbJ3N0YWdlSW5mbyddO1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY3JlYXRlQ2xpZW50KHN0YWdlSW5mbyk7XG4gICAgY29uc3QgYXp1cmVMb2NhdGlvbiA9IHRoaXMuZXh0cmFjdENvbnRhaW5lck5hbWVBbmRQYXRoKHN0YWdlSW5mb1snbG9jYXRpb24nXSk7XG5cbiAgICBjb25zdCBjb250YWluZXJDbGllbnQgPSBjbGllbnQuZ2V0Q29udGFpbmVyQ2xpZW50KGF6dXJlTG9jYXRpb24uY29udGFpbmVyTmFtZSk7XG4gICAgY29uc3QgYmxvYkNsaWVudCA9IGNvbnRhaW5lckNsaWVudC5nZXRCbG9iQ2xpZW50KGF6dXJlTG9jYXRpb24ucGF0aCArIGZpbGVuYW1lKTtcblxuICAgIGxldCBibG9iRGV0YWlscztcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBibG9iQ2xpZW50LmdldFByb3BlcnRpZXMoKVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIGJsb2JEZXRhaWxzID0gZGF0YTtcbiAgICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyWydjb2RlJ10gPT09IEVYUElSRURfVE9LRU4pIHtcbiAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU47XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIGlmIChlcnJbJ3N0YXR1c0NvZGUnXSA9PT0gNDA0KSB7XG4gICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLk5PVF9GT1VORF9GSUxFO1xuICAgICAgICByZXR1cm4gRmlsZUhlYWRlcihudWxsLCBudWxsLCBudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyWydzdGF0dXNDb2RlJ10gPT09IDQwMCkge1xuICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5SRU5FV19UT0tFTjtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5FUlJPUjtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuVVBMT0FERUQ7XG5cbiAgICBsZXQgZW5jcnlwdGlvbk1ldGFkYXRhID0gbnVsbDtcbiAgICBpZiAoYmxvYkRldGFpbHMubWV0YWRhdGFbJ2VuY3J5cHRpb25kYXRhJ10pIHtcbiAgICAgIGNvbnN0IGVuY3J5cHRpb25EYXRhID0gSlNPTi5wYXJzZShibG9iRGV0YWlscy5tZXRhZGF0YVsnZW5jcnlwdGlvbmRhdGEnXSk7XG4gICAgICBlbmNyeXB0aW9uTWV0YWRhdGEgPSBFbmNyeXB0aW9uTWV0YWRhdGEoXG4gICAgICAgIGVuY3J5cHRpb25EYXRhWydXcmFwcGVkQ29udGVudEtleSddWydFbmNyeXB0ZWRLZXknXSxcbiAgICAgICAgZW5jcnlwdGlvbkRhdGFbJ0NvbnRlbnRFbmNyeXB0aW9uSVYnXSxcbiAgICAgICAgYmxvYkRldGFpbHMubWV0YWRhdGFbJ21hdGRlc2MnXVxuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gRmlsZUhlYWRlcihcbiAgICAgIGJsb2JEZXRhaWxzLm1ldGFkYXRhWydzZmNkaWdlc3QnXSxcbiAgICAgIGJsb2JEZXRhaWxzLmNvbnRlbnRMZW5ndGgsXG4gICAgICBlbmNyeXB0aW9uTWV0YWRhdGFcbiAgICApO1xuICB9O1xuXG4gIC8qKlxuICAqIENyZWF0ZSB0aGUgZmlsZSBtZXRhZGF0YSB0aGVuIHVwbG9hZCB0aGUgZmlsZS5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmlsZVxuICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICogQHBhcmFtIHtPYmplY3R9IGVuY3J5cHRpb25NZXRhZGF0YVxuICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhDb25jdXJyZW5jeVxuICAqXG4gICogQHJldHVybnMge251bGx9XG4gICovXG4gIHRoaXMudXBsb2FkRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhRmlsZSwgbWV0YSwgZW5jcnlwdGlvbk1ldGFkYXRhLCBtYXhDb25jdXJyZW5jeSkge1xuICAgIGNvbnN0IGZpbGVTdHJlYW0gPSBmcy5yZWFkRmlsZVN5bmMoZGF0YUZpbGUpO1xuICAgIGF3YWl0IHRoaXMudXBsb2FkRmlsZVN0cmVhbShmaWxlU3RyZWFtLCBtZXRhLCBlbmNyeXB0aW9uTWV0YWRhdGEsIG1heENvbmN1cnJlbmN5KTtcbiAgfTtcblxuICAvKipcbiAgKiBDcmVhdGUgdGhlIGZpbGUgbWV0YWRhdGEgdGhlbiB1cGxvYWQgdGhlIGZpbGUgc3RyZWFtLlxuICAqXG4gICogQHBhcmFtIHtTdHJpbmd9IGZpbGVTdHJlYW1cbiAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAqIEBwYXJhbSB7T2JqZWN0fSBlbmNyeXB0aW9uTWV0YWRhdGFcbiAgKlxuICAqIEByZXR1cm5zIHtudWxsfVxuICAqL1xuICB0aGlzLnVwbG9hZEZpbGVTdHJlYW0gPSBhc3luYyBmdW5jdGlvbiAoZmlsZVN0cmVhbSwgbWV0YSwgZW5jcnlwdGlvbk1ldGFkYXRhKSB7XG4gICAgY29uc3QgYXp1cmVNZXRhZGF0YSA9IHtcbiAgICAgICdzZmNkaWdlc3QnOiBtZXRhWydTSEEyNTZfRElHRVNUJ11cbiAgICB9O1xuXG4gICAgaWYgKGVuY3J5cHRpb25NZXRhZGF0YSkge1xuICAgICAgYXp1cmVNZXRhZGF0YVsnZW5jcnlwdGlvbmRhdGEnXSA9XG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAnRW5jcnlwdGlvbk1vZGUnOiAnRnVsbEJsb2InLFxuICAgICAgICAgICdXcmFwcGVkQ29udGVudEtleSc6IHtcbiAgICAgICAgICAgICdLZXlJZCc6ICdzeW1tS2V5MScsXG4gICAgICAgICAgICAnRW5jcnlwdGVkS2V5JzogZW5jcnlwdGlvbk1ldGFkYXRhLmtleSxcbiAgICAgICAgICAgICdBbGdvcml0aG0nOiAnQUVTX0NCQ18yNTYnXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnRW5jcnlwdGlvbkFnZW50Jzoge1xuICAgICAgICAgICAgJ1Byb3RvY29sJzogJzEuMCcsXG4gICAgICAgICAgICAnRW5jcnlwdGlvbkFsZ29yaXRobSc6ICdBRVNfQ0JDXzEyOCcsXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnQ29udGVudEVuY3J5cHRpb25JVic6IGVuY3J5cHRpb25NZXRhZGF0YS5pdixcbiAgICAgICAgICAnS2V5V3JhcHBpbmdNZXRhZGF0YSc6IHtcbiAgICAgICAgICAgICdFbmNyeXB0aW9uTGlicmFyeSc6ICdKYXZhIDUuMy4wJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICBhenVyZU1ldGFkYXRhWydtYXRkZXNjJ10gPSBlbmNyeXB0aW9uTWV0YWRhdGEubWF0RGVzYztcbiAgICB9XG5cbiAgICBjb25zdCBzdGFnZUluZm8gPSBtZXRhWydzdGFnZUluZm8nXTtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNyZWF0ZUNsaWVudChzdGFnZUluZm8pO1xuICAgIGNvbnN0IGF6dXJlTG9jYXRpb24gPSB0aGlzLmV4dHJhY3RDb250YWluZXJOYW1lQW5kUGF0aChzdGFnZUluZm9bJ2xvY2F0aW9uJ10pO1xuICAgIGNvbnN0IGJsb2JOYW1lID0gYXp1cmVMb2NhdGlvbi5wYXRoICsgbWV0YVsnZHN0RmlsZU5hbWUnXTtcblxuICAgIGNvbnN0IGNvbnRhaW5lckNsaWVudCA9IGNsaWVudC5nZXRDb250YWluZXJDbGllbnQoYXp1cmVMb2NhdGlvbi5jb250YWluZXJOYW1lKTtcbiAgICBjb25zdCBibG9ja0Jsb2JDbGllbnQgPSBjb250YWluZXJDbGllbnQuZ2V0QmxvY2tCbG9iQ2xpZW50KGJsb2JOYW1lKTtcblxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBibG9ja0Jsb2JDbGllbnQudXBsb2FkKGZpbGVTdHJlYW0sIGZpbGVTdHJlYW0ubGVuZ3RoLCB7XG4gICAgICAgIG1ldGFkYXRhOiBhenVyZU1ldGFkYXRhLFxuICAgICAgICBibG9iSFRUUEhlYWRlcnM6XG4gICAgICAgIHtcbiAgICAgICAgICBibG9iQ29udGVudEVuY29kaW5nOiAnVVRGLTgnLFxuICAgICAgICAgIGJsb2JDb250ZW50VHlwZTogJ2FwcGxpY2F0aW9uL29jdGV0LXN0cmVhbSdcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyWydzdGF0dXNDb2RlJ10gPT09IDQwMyAmJiBkZXRlY3RBenVyZVRva2VuRXhwaXJlRXJyb3IoZXJyKSkge1xuICAgICAgICBtZXRhWydsYXN0RXJyb3InXSA9IGVycjtcbiAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU47XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBtZXRhWydkc3RGaWxlU2l6ZSddID0gbWV0YVsndXBsb2FkU2l6ZSddO1xuICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlVQTE9BREVEO1xuICB9O1xuXG4gIC8qKlxuICAgKiBEb3dubG9hZCB0aGUgZmlsZSBibG9iIHRoZW4gd3JpdGUgdGhlIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAqIEBwYXJhbSBmdWxsRHN0UGF0aFxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICovXG4gIHRoaXMubmF0aXZlRG93bmxvYWRGaWxlID0gYXN5bmMgZnVuY3Rpb24gKG1ldGEsIGZ1bGxEc3RQYXRoKSB7XG4gICAgY29uc3Qgc3RhZ2VJbmZvID0gbWV0YVsnc3RhZ2VJbmZvJ107XG4gICAgY29uc3QgY2xpZW50ID0gdGhpcy5jcmVhdGVDbGllbnQoc3RhZ2VJbmZvKTtcbiAgICBjb25zdCBhenVyZUxvY2F0aW9uID0gdGhpcy5leHRyYWN0Q29udGFpbmVyTmFtZUFuZFBhdGgoc3RhZ2VJbmZvWydsb2NhdGlvbiddKTtcbiAgICBjb25zdCBibG9iTmFtZSA9IGF6dXJlTG9jYXRpb24ucGF0aCArIG1ldGFbJ3NyY0ZpbGVOYW1lJ107XG5cbiAgICBjb25zdCBjb250YWluZXJDbGllbnQgPSBjbGllbnQuZ2V0Q29udGFpbmVyQ2xpZW50KGF6dXJlTG9jYXRpb24uY29udGFpbmVyTmFtZSk7XG4gICAgY29uc3QgYmxvY2tCbG9iQ2xpZW50ID0gY29udGFpbmVyQ2xpZW50LmdldEJsb2NrQmxvYkNsaWVudChibG9iTmFtZSk7XG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgZG93bmxvYWRCbG9ja0Jsb2JSZXNwb25zZSAgPSBhd2FpdCBibG9ja0Jsb2JDbGllbnQuZG93bmxvYWQoMCk7XG4gICAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IGRvd25sb2FkQmxvY2tCbG9iUmVzcG9uc2UucmVhZGFibGVTdHJlYW1Cb2R5O1xuXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IGZzLmNyZWF0ZVdyaXRlU3RyZWFtKGZ1bGxEc3RQYXRoKTtcbiAgICAgICAgcmVhZGFibGVTdHJlYW0ub24oJ2RhdGEnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgIHdyaXRlci53cml0ZShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlYWRhYmxlU3RyZWFtLm9uKCdlbmQnLCAoKSA9PiB7XG4gICAgICAgICAgd3JpdGVyLmVuZChyZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlYWRhYmxlU3RyZWFtLm9uKCdlcnJvcicsIHJlamVjdCk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnJbJ3N0YXR1c0NvZGUnXSA9PT0gNDAzICYmIGRldGVjdEF6dXJlVG9rZW5FeHBpcmVFcnJvcihlcnIpKSB7XG4gICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5SRU5FV19UT0tFTjtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWV0YVsnbGFzdEVycm9yJ10gPSBlcnI7XG4gICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLk5FRURfUkVUUlk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLkRPV05MT0FERUQ7XG4gIH07XG5cbiAgLyoqXG4gICogRGV0ZWN0IGlmIHRoZSBBenVyZSB0b2tlbiBoYXMgZXhwaXJlZC5cbiAgKlxuICAqIEBwYXJhbSB7T2JqZWN0fSBlcnJcbiAgKlxuICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAqL1xuICBmdW5jdGlvbiBkZXRlY3RBenVyZVRva2VuRXhwaXJlRXJyb3IoZXJyKSB7XG4gICAgaWYgKGVyclsnc3RhdHVzQ29kZSddICE9PSA0MDMpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZXJyc3RyID0gZXJyLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIGVycnN0ci5pbmNsdWRlcygnU2lnbmF0dXJlIG5vdCB2YWxpZCBpbiB0aGUgc3BlY2lmaWVkIHRpbWUgZnJhbWUnKSB8fFxuICAgICAgZXJyc3RyLmluY2x1ZGVzKCdTZXJ2ZXIgZmFpbGVkIHRvIGF1dGhlbnRpY2F0ZSB0aGUgcmVxdWVzdC4nKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBBenVyZVV0aWw7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/azure_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/encrypt_util.js":
/*!****************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/file_transfer_agent/encrypt_util.js ***!
  \****************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const path = __webpack_require__(/*! path */ \"path\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst AES_BLOCK_SIZE = 128;\nconst blockSize = parseInt(AES_BLOCK_SIZE / 8);  // in bytes\n\nconst QUERY_STAGE_MASTER_KEY = 'queryStageMasterKey';\nconst BASE64 = 'base64';\nconst DEFAULT_AAD = Buffer.from('');\nconst AUTH_TAG_LENGTH_IN_BYTES = 16;\n\nconst AES_CBC = {\n  cipherName: function (keySizeInBytes) {\n    return `aes-${keySizeInBytes * 8}-cbc`;\n  },\n  ivSize: 16\n};\n\nconst AES_ECB = {\n  cipherName: function (keySizeInBytes) {\n    return `aes-${keySizeInBytes * 8}-ecb`;\n  }\n};\n\nconst AES_GCM = {\n  cipherName: function (keySizeInBytes) {\n    return `aes-${keySizeInBytes * 8}-gcm`;\n  },\n  ivSize: 12\n};\n\n// Material Descriptor\nfunction MaterialDescriptor(smkId, queryId, keySize) {\n  return {\n    'smkId': smkId,\n    'queryId': queryId,\n    'keySize': keySize\n  };\n}\n\n// Encryption Material\nfunction EncryptionMetadata(key, dataIv, matDesc, keyIv, dataAad, keyAad) {\n  return {\n    'key': key,\n    'iv': dataIv,\n    'matDesc': matDesc,\n    'keyIv': keyIv,\n    'dataAad': dataAad,\n    'keyAad': keyAad\n  };\n}\n\nexports.EncryptionMetadata = EncryptionMetadata;\n\nfunction TempFileGenerator() {\n\n  this.fileSync = function (option = { dir: os.tmpdir(), prefix: '', postfix: '', extension: '' }) {\n    const randomName = crypto.randomUUID();\n    const fileName = `${option.prefix || ''}${randomName}${option.postfix || ''}${'.' + option.extension || 0}`;\n\n    if (!this.checkDirInTemp(option.dir)) {\n      option.dir = os.tmpdir();\n    }\n\n    const fullpath = path.join(option.dir, fileName);\n    \n    fs.writeFileSync(fullpath, '');\n    const fileDescriptor = fs.openSync(fullpath);\n    return { name: fullpath, fd: fileDescriptor };\n  };\n  \n  this.file = function (option = { dir: os.tmpdir(), prefix: '', postfix: '', extension: '' }, callback) {\n    try {\n      const { name, fd } = this.fileSync(option);\n      callback(null, name, fd);\n    } catch (err) {\n      callback(err);\n    }\n  };\n  \n  this.checkDirInTemp = function (directoryPath) {\n    if (!directoryPath || directoryPath.length === 0) {\n      return false;\n    }\n  \n    if (directoryPath.includes(os.tmpdir())) {\n      if (fs.existsSync(directoryPath)) {\n        return true;\n      } else {\n        Logger.getInstance().warn(`no such file or directory, open ${directoryPath}`);\n      }\n    } else {\n      Logger.getInstance().warn(`dir option must be relative to ${os.tmpdir()}, found ${directoryPath}`);\n    }\n    return false;\n  };\n}\n\n/**\n * Creates an encryption utility object.\n *\n * @param {module} encrypt\n * @param {module} filestream\n * @param {module} temp\n * \n * @returns {Object}\n * @constructor\n */\nfunction EncryptUtil(encrypt, filestream, temp) {\n  const crypto = typeof encrypt !== 'undefined' ? encrypt : __webpack_require__(/*! crypto */ \"crypto\");\n  // TODO: SNOW-1814883: Replace 'fs' with 'fs/promises'\n  const fs = typeof filestream !== 'undefined' ? filestream : __webpack_require__(/*! fs */ \"fs\");\n  const tmp = typeof temp !== 'undefined' ? temp : new TempFileGenerator();\n\n  /**\n   * Generate a buffer with random bytes given a size.\n   *\n   * @param {Number} byteLength\n   *\n   * @returns {Buffer} of size byteLength\n   */\n  function getSecureRandom(byteLength) {\n    return crypto.randomBytes(byteLength);\n  }\n\n  /**\n  * Convert a material descriptor object's values to unicode.\n  *\n  * @param {Object} matDesc\n  *\n  * @returns {Object}\n  */\n  function matDescToUnicode(matDesc) {\n    matDesc['smkId'] = matDesc['smkId'].toString();\n    matDesc['keySize'] = matDesc['keySize'].toString();\n    const newMatDesc = JSON.stringify(matDesc);\n    return newMatDesc;\n  }\n\n  function createEncryptionMetadata(encryptionMaterial, keySize, encryptedKey, dataIv, keyIv = null, dataAad = null, keyAad = null) {\n    const matDesc = new MaterialDescriptor(\n      encryptionMaterial.smkId,\n      encryptionMaterial.queryId,\n      keySize * 8\n    );\n\n    return new EncryptionMetadata(\n      encryptedKey.toString(BASE64),\n      dataIv.toString(BASE64),\n      matDescToUnicode(matDesc),\n      keyIv ? keyIv.toString(BASE64) : null,\n      dataAad ? dataAad.toString(BASE64) : null,\n      keyAad ? keyAad.toString(BASE64) : null\n    );\n  }\n\n  /**\n   * Encrypt content using AES-CBC algorithm.\n   */\n  this.encryptFileStream = async function (encryptionMaterial, content) {\n    return this.encryptDataCBC(encryptionMaterial, content);\n  };\n\n  this.encryptDataCBC = function (encryptionMaterial, data) {\n    const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n    const keySize = decodedKek.length;\n\n    const dataIv = getSecureRandom(AES_CBC.ivSize);\n    const fileKey = getSecureRandom(keySize);\n\n    const dataCipher = crypto.createCipheriv(AES_CBC.cipherName(keySize), fileKey, dataIv);\n    const encryptedData = performCrypto(dataCipher, data);\n\n    const keyCipher = crypto.createCipheriv(AES_ECB.cipherName(keySize), decodedKek, null);\n    const encryptedKey = performCrypto(keyCipher, fileKey);\n\n    return {\n      encryptionMetadata: createEncryptionMetadata(encryptionMaterial, keySize, encryptedKey, dataIv),\n      dataStream: encryptedData\n    };\n  };\n\n  //TODO: SNOW-940981: Add proper usage when feature is ready\n  this.encryptDataGCM = function (encryptionMaterial, data) {\n    const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n    const keySize = decodedKek.length;\n\n    const dataIv = getSecureRandom(AES_GCM.ivSize);\n    const fileKey = getSecureRandom(keySize);\n\n    const encryptedData = this.encryptGCM(data, fileKey, dataIv, DEFAULT_AAD);\n\n    const keyIv = getSecureRandom(AES_GCM.ivSize);\n    const encryptedKey = this.encryptGCM(fileKey, decodedKek, keyIv, DEFAULT_AAD);\n    return {\n      encryptionMetadata: createEncryptionMetadata(encryptionMaterial, keySize, encryptedKey, dataIv, keyIv, DEFAULT_AAD, DEFAULT_AAD),\n      dataStream: encryptedData\n    };\n  };\n\n  this.encryptGCM = function (data, key, iv, aad) {\n    const cipher = crypto.createCipheriv(AES_GCM.cipherName(key.length), key, iv, { authTagLength: AUTH_TAG_LENGTH_IN_BYTES });\n    if (aad) {\n      cipher.setAAD(aad);\n    }\n    const encryptedData = performCrypto(cipher, data);\n    return Buffer.concat([encryptedData, cipher.getAuthTag()]);\n  };\n\n  this.decryptGCM = function (data, key, iv, aad) {\n    const decipher = crypto.createDecipheriv(AES_GCM.cipherName(key.length), key, iv, { authTagLength: AUTH_TAG_LENGTH_IN_BYTES });\n    if (aad) {\n      decipher.setAAD(aad);\n    }\n    // last 16 bytes of data is the authentication tag\n    const authTag = data.slice(data.length - AUTH_TAG_LENGTH_IN_BYTES, data.length);\n    const cipherText = data.slice(0, data.length - AUTH_TAG_LENGTH_IN_BYTES);\n    decipher.setAuthTag(authTag);\n    return performCrypto(decipher, cipherText);\n  };\n  \n  /**\n   * Encrypt file using AES algorithm.\n   */\n  this.encryptFile = async function (encryptionMaterial, inputFilePath,\n    tmpDir = null, chunkSize = blockSize * 4 * 1024) {\n    return await this.encryptFileCBC(encryptionMaterial, inputFilePath, tmpDir, chunkSize);\n  };\n\n  this.encryptFileCBC = async function (encryptionMaterial, inputFilePath,\n    tmpDir = null, chunkSize = blockSize * 4 * 1024) {\n    const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n    const keySize = decodedKek.length;\n\n    const dataIv = getSecureRandom(AES_CBC.ivSize);\n    const fileKey = getSecureRandom(keySize);\n    const dataCipher = crypto.createCipheriv(AES_CBC.cipherName(keySize), fileKey, dataIv);\n    const encryptedFilePath = await performFileStreamCrypto(dataCipher, tmpDir, inputFilePath, chunkSize);\n\n    const keyCipher = crypto.createCipheriv(AES_ECB.cipherName(keySize), decodedKek, null);\n    const encryptedKey = performCrypto(keyCipher, fileKey);\n\n    return {\n      encryptionMetadata: createEncryptionMetadata(encryptionMaterial, keySize, encryptedKey, dataIv),\n      dataFile: encryptedFilePath\n    };\n  };\n\n  //TODO: SNOW-940981: Add proper usage when feature is ready\n  this.encryptFileGCM = async function (encryptionMaterial, inputFilePath, tmpDir = null) {\n    const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n\n    const dataIv = getSecureRandom(AES_GCM.ivSize);\n    const fileKey = getSecureRandom(decodedKek.length);\n\n    const fileContent = await new Promise((resolve, reject) => {\n      fs.readFile(inputFilePath, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n    });\n\n    const encryptedData = this.encryptGCM(fileContent, fileKey, dataIv, DEFAULT_AAD);\n    const encryptedFilePath = await writeContentToFile(tmpDir, path.basename(inputFilePath) + '#', encryptedData);\n\n    const keyIv = getSecureRandom(AES_GCM.ivSize);\n    const encryptedKey = this.encryptGCM(fileKey, decodedKek, keyIv, DEFAULT_AAD);\n\n    return {\n      encryptionMetadata: createEncryptionMetadata(encryptionMaterial, fileKey.length, encryptedKey, dataIv, keyIv, DEFAULT_AAD, DEFAULT_AAD),\n      dataFile: encryptedFilePath\n    };\n  };\n\n  /**\n   * Decrypt file using AES algorithm.\n   */\n  this.decryptFile = async function (metadata, encryptionMaterial, inputFilePath,\n    tmpDir = null, chunkSize = blockSize * 4 * 1024) {\n    return await this.decryptFileCBC(metadata, encryptionMaterial, inputFilePath, tmpDir, chunkSize);\n  };\n\n  this.decryptFileCBC = async function (metadata, encryptionMaterial, inputFilePath,\n    tmpDir = null, chunkSize = blockSize * 4 * 1024) {\n    const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n    const keyBytes = new Buffer.from(metadata.key, BASE64);\n    const ivBytes = new Buffer.from(metadata.iv, BASE64);\n    const keyDecipher = crypto.createDecipheriv(AES_ECB.cipherName(decodedKek.length), decodedKek, null);\n    const fileKey = performCrypto(keyDecipher, keyBytes);\n\n    const dataDecipher = crypto.createDecipheriv(AES_CBC.cipherName(fileKey.length), fileKey, ivBytes);\n    return await performFileStreamCrypto(dataDecipher, tmpDir, inputFilePath, chunkSize);\n  };\n\n  //TODO: SNOW-940981: Add proper usage when feature is ready\n  this.decryptFileGCM = async function (metadata, encryptionMaterial, inputFilePath, tmpDir = null) {\n    const decodedKek = Buffer.from(encryptionMaterial[QUERY_STAGE_MASTER_KEY], BASE64);\n    const keyBytes = new Buffer.from(metadata.key, BASE64);\n    const keyIvBytes = new Buffer.from(metadata.keyIv, BASE64);\n    const dataIvBytes = new Buffer.from(metadata.iv, BASE64);\n    const dataAadBytes = new Buffer.from(metadata.dataAad, BASE64);\n    const keyAadBytes = new Buffer.from(metadata.keyAad, BASE64);\n\n    const fileKey = this.decryptGCM(keyBytes, decodedKek, keyIvBytes, keyAadBytes);\n\n    const fileContent = await new Promise((resolve, reject) => {\n      fs.readFile(inputFilePath, (err, data) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve(data);\n        }\n      });\n    });\n\n    const decryptedData = this.decryptGCM(fileContent, fileKey, dataIvBytes, dataAadBytes);\n    return await writeContentToFile(tmpDir, path.basename(inputFilePath) + '#', decryptedData);\n  };\n  \n  function performCrypto(cipherOrDecipher, data) {\n    const encryptedOrDecrypted = cipherOrDecipher.update(data);\n    const final = cipherOrDecipher.final();\n    return Buffer.concat([encryptedOrDecrypted, final]);\n  }\n\n  async function performFileStreamCrypto(cipherOrDecipher, tmpDir, inputFilePath, chunkSize) {\n    const outputFile = await new Promise((resolve, reject) => {\n      tmp.file({ dir: tmpDir, prefix: path.basename(inputFilePath) + '#' }, (err, path, fd) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve({ path, fd });\n        }\n      });\n    });\n    await new Promise(function (resolve) {\n      const inputStream = fs.createReadStream(inputFilePath, { highWaterMark: chunkSize });\n      const outputStream = fs.createWriteStream(outputFile.path);\n\n      inputStream.on('data', function (chunk) {\n        const encrypted = cipherOrDecipher.update(chunk);\n        outputStream.write(encrypted);\n      });\n      inputStream.on('close', function () {\n        outputStream.write(cipherOrDecipher.final());\n        outputStream.close(resolve);\n      });\n    });\n\n    await new Promise((resolve, reject) => {\n      fs.close(outputFile.fd, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n    return outputFile.path;\n  }\n\n  async function writeContentToFile(tmpDir, prefix, content,) {\n    const outputFile = await new Promise((resolve, reject) => {\n      tmp.file({ dir: tmpDir, prefix: prefix }, (err, path, fd) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve({ path, fd });\n        }\n      });\n    });\n    await new Promise((resolve, reject) => {\n      fs.writeFile(outputFile.path, content, err => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n    await new Promise((resolve, reject) => {\n      fs.close(outputFile.fd, (err) => {\n        if (err) {\n          reject(err);\n        } else {\n          resolve();\n        }\n      });\n    });\n    return outputFile.path;\n  }\n}\n\nexports.EncryptUtil = EncryptUtil;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9lbmNyeXB0X3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixlQUFlLG1CQUFPLENBQUMsbUVBQVc7QUFDbEM7QUFDQSxpREFBaUQ7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsbUJBQW1CO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtCQUFrQixtQkFBbUI7QUFDckMsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjs7QUFFMUI7O0FBRUEsdUNBQXVDLDBEQUEwRDtBQUNqRztBQUNBLHdCQUF3QixvQkFBb0IsRUFBRSxXQUFXLEVBQUUscUJBQXFCLEVBQUUsMEJBQTBCLENBQUUsQ0FBQzs7QUFFL0c7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxtQ0FBbUMsMERBQTBEO0FBQzdGO0FBQ0EsY0FBYyxXQUFXO0FBQ3pCO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUixxRUFBcUUsY0FBYztBQUNuRjtBQUNBLE1BQU07QUFDTixrRUFBa0UsWUFBWSxVQUFVLGNBQWM7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsNERBQTRELG1CQUFPLENBQUMsc0JBQVE7QUFDNUU7QUFDQSw4REFBOEQsbUJBQU8sQ0FBQyxjQUFJO0FBQzFFOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG9GQUFvRix5Q0FBeUM7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0ZBQXdGLHlDQUF5QztBQUNqSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLHlEQUF5RDtBQUMxRTtBQUNBO0FBQ0EsVUFBVTtBQUNWLG9CQUFvQixVQUFVO0FBQzlCO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBLCtEQUErRCwwQkFBMEI7QUFDekY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQiw2QkFBNkI7QUFDOUM7QUFDQTtBQUNBLFVBQVU7QUFDVixvQkFBb0IsVUFBVTtBQUM5QjtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLG1CQUFtQiIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9maWxlX3RyYW5zZmVyX2FnZW50L2VuY3J5cHRfdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbmNvbnN0IEFFU19CTE9DS19TSVpFID0gMTI4O1xuY29uc3QgYmxvY2tTaXplID0gcGFyc2VJbnQoQUVTX0JMT0NLX1NJWkUgLyA4KTsgIC8vIGluIGJ5dGVzXG5cbmNvbnN0IFFVRVJZX1NUQUdFX01BU1RFUl9LRVkgPSAncXVlcnlTdGFnZU1hc3RlcktleSc7XG5jb25zdCBCQVNFNjQgPSAnYmFzZTY0JztcbmNvbnN0IERFRkFVTFRfQUFEID0gQnVmZmVyLmZyb20oJycpO1xuY29uc3QgQVVUSF9UQUdfTEVOR1RIX0lOX0JZVEVTID0gMTY7XG5cbmNvbnN0IEFFU19DQkMgPSB7XG4gIGNpcGhlck5hbWU6IGZ1bmN0aW9uIChrZXlTaXplSW5CeXRlcykge1xuICAgIHJldHVybiBgYWVzLSR7a2V5U2l6ZUluQnl0ZXMgKiA4fS1jYmNgO1xuICB9LFxuICBpdlNpemU6IDE2XG59O1xuXG5jb25zdCBBRVNfRUNCID0ge1xuICBjaXBoZXJOYW1lOiBmdW5jdGlvbiAoa2V5U2l6ZUluQnl0ZXMpIHtcbiAgICByZXR1cm4gYGFlcy0ke2tleVNpemVJbkJ5dGVzICogOH0tZWNiYDtcbiAgfVxufTtcblxuY29uc3QgQUVTX0dDTSA9IHtcbiAgY2lwaGVyTmFtZTogZnVuY3Rpb24gKGtleVNpemVJbkJ5dGVzKSB7XG4gICAgcmV0dXJuIGBhZXMtJHtrZXlTaXplSW5CeXRlcyAqIDh9LWdjbWA7XG4gIH0sXG4gIGl2U2l6ZTogMTJcbn07XG5cbi8vIE1hdGVyaWFsIERlc2NyaXB0b3JcbmZ1bmN0aW9uIE1hdGVyaWFsRGVzY3JpcHRvcihzbWtJZCwgcXVlcnlJZCwga2V5U2l6ZSkge1xuICByZXR1cm4ge1xuICAgICdzbWtJZCc6IHNta0lkLFxuICAgICdxdWVyeUlkJzogcXVlcnlJZCxcbiAgICAna2V5U2l6ZSc6IGtleVNpemVcbiAgfTtcbn1cblxuLy8gRW5jcnlwdGlvbiBNYXRlcmlhbFxuZnVuY3Rpb24gRW5jcnlwdGlvbk1ldGFkYXRhKGtleSwgZGF0YUl2LCBtYXREZXNjLCBrZXlJdiwgZGF0YUFhZCwga2V5QWFkKSB7XG4gIHJldHVybiB7XG4gICAgJ2tleSc6IGtleSxcbiAgICAnaXYnOiBkYXRhSXYsXG4gICAgJ21hdERlc2MnOiBtYXREZXNjLFxuICAgICdrZXlJdic6IGtleUl2LFxuICAgICdkYXRhQWFkJzogZGF0YUFhZCxcbiAgICAna2V5QWFkJzoga2V5QWFkXG4gIH07XG59XG5cbmV4cG9ydHMuRW5jcnlwdGlvbk1ldGFkYXRhID0gRW5jcnlwdGlvbk1ldGFkYXRhO1xuXG5mdW5jdGlvbiBUZW1wRmlsZUdlbmVyYXRvcigpIHtcblxuICB0aGlzLmZpbGVTeW5jID0gZnVuY3Rpb24gKG9wdGlvbiA9IHsgZGlyOiBvcy50bXBkaXIoKSwgcHJlZml4OiAnJywgcG9zdGZpeDogJycsIGV4dGVuc2lvbjogJycgfSkge1xuICAgIGNvbnN0IHJhbmRvbU5hbWUgPSBjcnlwdG8ucmFuZG9tVVVJRCgpO1xuICAgIGNvbnN0IGZpbGVOYW1lID0gYCR7b3B0aW9uLnByZWZpeCB8fCAnJ30ke3JhbmRvbU5hbWV9JHtvcHRpb24ucG9zdGZpeCB8fCAnJ30keycuJyArIG9wdGlvbi5leHRlbnNpb24gfHwgJyd9YDtcblxuICAgIGlmICghdGhpcy5jaGVja0RpckluVGVtcChvcHRpb24uZGlyKSkge1xuICAgICAgb3B0aW9uLmRpciA9IG9zLnRtcGRpcigpO1xuICAgIH1cblxuICAgIGNvbnN0IGZ1bGxwYXRoID0gcGF0aC5qb2luKG9wdGlvbi5kaXIsIGZpbGVOYW1lKTtcbiAgICBcbiAgICBmcy53cml0ZUZpbGVTeW5jKGZ1bGxwYXRoLCAnJyk7XG4gICAgY29uc3QgZmlsZURlc2NyaXB0b3IgPSBmcy5vcGVuU3luYyhmdWxscGF0aCk7XG4gICAgcmV0dXJuIHsgbmFtZTogZnVsbHBhdGgsIGZkOiBmaWxlRGVzY3JpcHRvciB9O1xuICB9O1xuICBcbiAgdGhpcy5maWxlID0gZnVuY3Rpb24gKG9wdGlvbiA9IHsgZGlyOiBvcy50bXBkaXIoKSwgcHJlZml4OiAnJywgcG9zdGZpeDogJycsIGV4dGVuc2lvbjogJycgfSwgY2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBuYW1lLCBmZCB9ID0gdGhpcy5maWxlU3luYyhvcHRpb24pO1xuICAgICAgY2FsbGJhY2sobnVsbCwgbmFtZSwgZmQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9XG4gIH07XG4gIFxuICB0aGlzLmNoZWNrRGlySW5UZW1wID0gZnVuY3Rpb24gKGRpcmVjdG9yeVBhdGgpIHtcbiAgICBpZiAoIWRpcmVjdG9yeVBhdGggfHwgZGlyZWN0b3J5UGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIFxuICAgIGlmIChkaXJlY3RvcnlQYXRoLmluY2x1ZGVzKG9zLnRtcGRpcigpKSkge1xuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZGlyZWN0b3J5UGF0aCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKGBubyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5LCBvcGVuICR7ZGlyZWN0b3J5UGF0aH1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihgZGlyIG9wdGlvbiBtdXN0IGJlIHJlbGF0aXZlIHRvICR7b3MudG1wZGlyKCl9LCBmb3VuZCAke2RpcmVjdG9yeVBhdGh9YCk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIGVuY3J5cHRpb24gdXRpbGl0eSBvYmplY3QuXG4gKlxuICogQHBhcmFtIHttb2R1bGV9IGVuY3J5cHRcbiAqIEBwYXJhbSB7bW9kdWxlfSBmaWxlc3RyZWFtXG4gKiBAcGFyYW0ge21vZHVsZX0gdGVtcFxuICogXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEVuY3J5cHRVdGlsKGVuY3J5cHQsIGZpbGVzdHJlYW0sIHRlbXApIHtcbiAgY29uc3QgY3J5cHRvID0gdHlwZW9mIGVuY3J5cHQgIT09ICd1bmRlZmluZWQnID8gZW5jcnlwdCA6IHJlcXVpcmUoJ2NyeXB0bycpO1xuICAvLyBUT0RPOiBTTk9XLTE4MTQ4ODM6IFJlcGxhY2UgJ2ZzJyB3aXRoICdmcy9wcm9taXNlcydcbiAgY29uc3QgZnMgPSB0eXBlb2YgZmlsZXN0cmVhbSAhPT0gJ3VuZGVmaW5lZCcgPyBmaWxlc3RyZWFtIDogcmVxdWlyZSgnZnMnKTtcbiAgY29uc3QgdG1wID0gdHlwZW9mIHRlbXAgIT09ICd1bmRlZmluZWQnID8gdGVtcCA6IG5ldyBUZW1wRmlsZUdlbmVyYXRvcigpO1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIGJ1ZmZlciB3aXRoIHJhbmRvbSBieXRlcyBnaXZlbiBhIHNpemUuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBieXRlTGVuZ3RoXG4gICAqXG4gICAqIEByZXR1cm5zIHtCdWZmZXJ9IG9mIHNpemUgYnl0ZUxlbmd0aFxuICAgKi9cbiAgZnVuY3Rpb24gZ2V0U2VjdXJlUmFuZG9tKGJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVMZW5ndGgpO1xuICB9XG5cbiAgLyoqXG4gICogQ29udmVydCBhIG1hdGVyaWFsIGRlc2NyaXB0b3Igb2JqZWN0J3MgdmFsdWVzIHRvIHVuaWNvZGUuXG4gICpcbiAgKiBAcGFyYW0ge09iamVjdH0gbWF0RGVzY1xuICAqXG4gICogQHJldHVybnMge09iamVjdH1cbiAgKi9cbiAgZnVuY3Rpb24gbWF0RGVzY1RvVW5pY29kZShtYXREZXNjKSB7XG4gICAgbWF0RGVzY1snc21rSWQnXSA9IG1hdERlc2NbJ3Nta0lkJ10udG9TdHJpbmcoKTtcbiAgICBtYXREZXNjWydrZXlTaXplJ10gPSBtYXREZXNjWydrZXlTaXplJ10udG9TdHJpbmcoKTtcbiAgICBjb25zdCBuZXdNYXREZXNjID0gSlNPTi5zdHJpbmdpZnkobWF0RGVzYyk7XG4gICAgcmV0dXJuIG5ld01hdERlc2M7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbmNyeXB0aW9uTWV0YWRhdGEoZW5jcnlwdGlvbk1hdGVyaWFsLCBrZXlTaXplLCBlbmNyeXB0ZWRLZXksIGRhdGFJdiwga2V5SXYgPSBudWxsLCBkYXRhQWFkID0gbnVsbCwga2V5QWFkID0gbnVsbCkge1xuICAgIGNvbnN0IG1hdERlc2MgPSBuZXcgTWF0ZXJpYWxEZXNjcmlwdG9yKFxuICAgICAgZW5jcnlwdGlvbk1hdGVyaWFsLnNta0lkLFxuICAgICAgZW5jcnlwdGlvbk1hdGVyaWFsLnF1ZXJ5SWQsXG4gICAgICBrZXlTaXplICogOFxuICAgICk7XG5cbiAgICByZXR1cm4gbmV3IEVuY3J5cHRpb25NZXRhZGF0YShcbiAgICAgIGVuY3J5cHRlZEtleS50b1N0cmluZyhCQVNFNjQpLFxuICAgICAgZGF0YUl2LnRvU3RyaW5nKEJBU0U2NCksXG4gICAgICBtYXREZXNjVG9Vbmljb2RlKG1hdERlc2MpLFxuICAgICAga2V5SXYgPyBrZXlJdi50b1N0cmluZyhCQVNFNjQpIDogbnVsbCxcbiAgICAgIGRhdGFBYWQgPyBkYXRhQWFkLnRvU3RyaW5nKEJBU0U2NCkgOiBudWxsLFxuICAgICAga2V5QWFkID8ga2V5QWFkLnRvU3RyaW5nKEJBU0U2NCkgOiBudWxsXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmNyeXB0IGNvbnRlbnQgdXNpbmcgQUVTLUNCQyBhbGdvcml0aG0uXG4gICAqL1xuICB0aGlzLmVuY3J5cHRGaWxlU3RyZWFtID0gYXN5bmMgZnVuY3Rpb24gKGVuY3J5cHRpb25NYXRlcmlhbCwgY29udGVudCkge1xuICAgIHJldHVybiB0aGlzLmVuY3J5cHREYXRhQ0JDKGVuY3J5cHRpb25NYXRlcmlhbCwgY29udGVudCk7XG4gIH07XG5cbiAgdGhpcy5lbmNyeXB0RGF0YUNCQyA9IGZ1bmN0aW9uIChlbmNyeXB0aW9uTWF0ZXJpYWwsIGRhdGEpIHtcbiAgICBjb25zdCBkZWNvZGVkS2VrID0gQnVmZmVyLmZyb20oZW5jcnlwdGlvbk1hdGVyaWFsW1FVRVJZX1NUQUdFX01BU1RFUl9LRVldLCBCQVNFNjQpO1xuICAgIGNvbnN0IGtleVNpemUgPSBkZWNvZGVkS2VrLmxlbmd0aDtcblxuICAgIGNvbnN0IGRhdGFJdiA9IGdldFNlY3VyZVJhbmRvbShBRVNfQ0JDLml2U2l6ZSk7XG4gICAgY29uc3QgZmlsZUtleSA9IGdldFNlY3VyZVJhbmRvbShrZXlTaXplKTtcblxuICAgIGNvbnN0IGRhdGFDaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoQUVTX0NCQy5jaXBoZXJOYW1lKGtleVNpemUpLCBmaWxlS2V5LCBkYXRhSXYpO1xuICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSBwZXJmb3JtQ3J5cHRvKGRhdGFDaXBoZXIsIGRhdGEpO1xuXG4gICAgY29uc3Qga2V5Q2lwaGVyID0gY3J5cHRvLmNyZWF0ZUNpcGhlcml2KEFFU19FQ0IuY2lwaGVyTmFtZShrZXlTaXplKSwgZGVjb2RlZEtlaywgbnVsbCk7XG4gICAgY29uc3QgZW5jcnlwdGVkS2V5ID0gcGVyZm9ybUNyeXB0byhrZXlDaXBoZXIsIGZpbGVLZXkpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY3J5cHRpb25NZXRhZGF0YTogY3JlYXRlRW5jcnlwdGlvbk1ldGFkYXRhKGVuY3J5cHRpb25NYXRlcmlhbCwga2V5U2l6ZSwgZW5jcnlwdGVkS2V5LCBkYXRhSXYpLFxuICAgICAgZGF0YVN0cmVhbTogZW5jcnlwdGVkRGF0YVxuICAgIH07XG4gIH07XG5cbiAgLy9UT0RPOiBTTk9XLTk0MDk4MTogQWRkIHByb3BlciB1c2FnZSB3aGVuIGZlYXR1cmUgaXMgcmVhZHlcbiAgdGhpcy5lbmNyeXB0RGF0YUdDTSA9IGZ1bmN0aW9uIChlbmNyeXB0aW9uTWF0ZXJpYWwsIGRhdGEpIHtcbiAgICBjb25zdCBkZWNvZGVkS2VrID0gQnVmZmVyLmZyb20oZW5jcnlwdGlvbk1hdGVyaWFsW1FVRVJZX1NUQUdFX01BU1RFUl9LRVldLCBCQVNFNjQpO1xuICAgIGNvbnN0IGtleVNpemUgPSBkZWNvZGVkS2VrLmxlbmd0aDtcblxuICAgIGNvbnN0IGRhdGFJdiA9IGdldFNlY3VyZVJhbmRvbShBRVNfR0NNLml2U2l6ZSk7XG4gICAgY29uc3QgZmlsZUtleSA9IGdldFNlY3VyZVJhbmRvbShrZXlTaXplKTtcblxuICAgIGNvbnN0IGVuY3J5cHRlZERhdGEgPSB0aGlzLmVuY3J5cHRHQ00oZGF0YSwgZmlsZUtleSwgZGF0YUl2LCBERUZBVUxUX0FBRCk7XG5cbiAgICBjb25zdCBrZXlJdiA9IGdldFNlY3VyZVJhbmRvbShBRVNfR0NNLml2U2l6ZSk7XG4gICAgY29uc3QgZW5jcnlwdGVkS2V5ID0gdGhpcy5lbmNyeXB0R0NNKGZpbGVLZXksIGRlY29kZWRLZWssIGtleUl2LCBERUZBVUxUX0FBRCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGVuY3J5cHRpb25NZXRhZGF0YTogY3JlYXRlRW5jcnlwdGlvbk1ldGFkYXRhKGVuY3J5cHRpb25NYXRlcmlhbCwga2V5U2l6ZSwgZW5jcnlwdGVkS2V5LCBkYXRhSXYsIGtleUl2LCBERUZBVUxUX0FBRCwgREVGQVVMVF9BQUQpLFxuICAgICAgZGF0YVN0cmVhbTogZW5jcnlwdGVkRGF0YVxuICAgIH07XG4gIH07XG5cbiAgdGhpcy5lbmNyeXB0R0NNID0gZnVuY3Rpb24gKGRhdGEsIGtleSwgaXYsIGFhZCkge1xuICAgIGNvbnN0IGNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihBRVNfR0NNLmNpcGhlck5hbWUoa2V5Lmxlbmd0aCksIGtleSwgaXYsIHsgYXV0aFRhZ0xlbmd0aDogQVVUSF9UQUdfTEVOR1RIX0lOX0JZVEVTIH0pO1xuICAgIGlmIChhYWQpIHtcbiAgICAgIGNpcGhlci5zZXRBQUQoYWFkKTtcbiAgICB9XG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IHBlcmZvcm1DcnlwdG8oY2lwaGVyLCBkYXRhKTtcbiAgICByZXR1cm4gQnVmZmVyLmNvbmNhdChbZW5jcnlwdGVkRGF0YSwgY2lwaGVyLmdldEF1dGhUYWcoKV0pO1xuICB9O1xuXG4gIHRoaXMuZGVjcnlwdEdDTSA9IGZ1bmN0aW9uIChkYXRhLCBrZXksIGl2LCBhYWQpIHtcbiAgICBjb25zdCBkZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KEFFU19HQ00uY2lwaGVyTmFtZShrZXkubGVuZ3RoKSwga2V5LCBpdiwgeyBhdXRoVGFnTGVuZ3RoOiBBVVRIX1RBR19MRU5HVEhfSU5fQllURVMgfSk7XG4gICAgaWYgKGFhZCkge1xuICAgICAgZGVjaXBoZXIuc2V0QUFEKGFhZCk7XG4gICAgfVxuICAgIC8vIGxhc3QgMTYgYnl0ZXMgb2YgZGF0YSBpcyB0aGUgYXV0aGVudGljYXRpb24gdGFnXG4gICAgY29uc3QgYXV0aFRhZyA9IGRhdGEuc2xpY2UoZGF0YS5sZW5ndGggLSBBVVRIX1RBR19MRU5HVEhfSU5fQllURVMsIGRhdGEubGVuZ3RoKTtcbiAgICBjb25zdCBjaXBoZXJUZXh0ID0gZGF0YS5zbGljZSgwLCBkYXRhLmxlbmd0aCAtIEFVVEhfVEFHX0xFTkdUSF9JTl9CWVRFUyk7XG4gICAgZGVjaXBoZXIuc2V0QXV0aFRhZyhhdXRoVGFnKTtcbiAgICByZXR1cm4gcGVyZm9ybUNyeXB0byhkZWNpcGhlciwgY2lwaGVyVGV4dCk7XG4gIH07XG4gIFxuICAvKipcbiAgICogRW5jcnlwdCBmaWxlIHVzaW5nIEFFUyBhbGdvcml0aG0uXG4gICAqL1xuICB0aGlzLmVuY3J5cHRGaWxlID0gYXN5bmMgZnVuY3Rpb24gKGVuY3J5cHRpb25NYXRlcmlhbCwgaW5wdXRGaWxlUGF0aCxcbiAgICB0bXBEaXIgPSBudWxsLCBjaHVua1NpemUgPSBibG9ja1NpemUgKiA0ICogMTAyNCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmVuY3J5cHRGaWxlQ0JDKGVuY3J5cHRpb25NYXRlcmlhbCwgaW5wdXRGaWxlUGF0aCwgdG1wRGlyLCBjaHVua1NpemUpO1xuICB9O1xuXG4gIHRoaXMuZW5jcnlwdEZpbGVDQkMgPSBhc3luYyBmdW5jdGlvbiAoZW5jcnlwdGlvbk1hdGVyaWFsLCBpbnB1dEZpbGVQYXRoLFxuICAgIHRtcERpciA9IG51bGwsIGNodW5rU2l6ZSA9IGJsb2NrU2l6ZSAqIDQgKiAxMDI0KSB7XG4gICAgY29uc3QgZGVjb2RlZEtlayA9IEJ1ZmZlci5mcm9tKGVuY3J5cHRpb25NYXRlcmlhbFtRVUVSWV9TVEFHRV9NQVNURVJfS0VZXSwgQkFTRTY0KTtcbiAgICBjb25zdCBrZXlTaXplID0gZGVjb2RlZEtlay5sZW5ndGg7XG5cbiAgICBjb25zdCBkYXRhSXYgPSBnZXRTZWN1cmVSYW5kb20oQUVTX0NCQy5pdlNpemUpO1xuICAgIGNvbnN0IGZpbGVLZXkgPSBnZXRTZWN1cmVSYW5kb20oa2V5U2l6ZSk7XG4gICAgY29uc3QgZGF0YUNpcGhlciA9IGNyeXB0by5jcmVhdGVDaXBoZXJpdihBRVNfQ0JDLmNpcGhlck5hbWUoa2V5U2l6ZSksIGZpbGVLZXksIGRhdGFJdik7XG4gICAgY29uc3QgZW5jcnlwdGVkRmlsZVBhdGggPSBhd2FpdCBwZXJmb3JtRmlsZVN0cmVhbUNyeXB0byhkYXRhQ2lwaGVyLCB0bXBEaXIsIGlucHV0RmlsZVBhdGgsIGNodW5rU2l6ZSk7XG5cbiAgICBjb25zdCBrZXlDaXBoZXIgPSBjcnlwdG8uY3JlYXRlQ2lwaGVyaXYoQUVTX0VDQi5jaXBoZXJOYW1lKGtleVNpemUpLCBkZWNvZGVkS2VrLCBudWxsKTtcbiAgICBjb25zdCBlbmNyeXB0ZWRLZXkgPSBwZXJmb3JtQ3J5cHRvKGtleUNpcGhlciwgZmlsZUtleSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZW5jcnlwdGlvbk1ldGFkYXRhOiBjcmVhdGVFbmNyeXB0aW9uTWV0YWRhdGEoZW5jcnlwdGlvbk1hdGVyaWFsLCBrZXlTaXplLCBlbmNyeXB0ZWRLZXksIGRhdGFJdiksXG4gICAgICBkYXRhRmlsZTogZW5jcnlwdGVkRmlsZVBhdGhcbiAgICB9O1xuICB9O1xuXG4gIC8vVE9ETzogU05PVy05NDA5ODE6IEFkZCBwcm9wZXIgdXNhZ2Ugd2hlbiBmZWF0dXJlIGlzIHJlYWR5XG4gIHRoaXMuZW5jcnlwdEZpbGVHQ00gPSBhc3luYyBmdW5jdGlvbiAoZW5jcnlwdGlvbk1hdGVyaWFsLCBpbnB1dEZpbGVQYXRoLCB0bXBEaXIgPSBudWxsKSB7XG4gICAgY29uc3QgZGVjb2RlZEtlayA9IEJ1ZmZlci5mcm9tKGVuY3J5cHRpb25NYXRlcmlhbFtRVUVSWV9TVEFHRV9NQVNURVJfS0VZXSwgQkFTRTY0KTtcblxuICAgIGNvbnN0IGRhdGFJdiA9IGdldFNlY3VyZVJhbmRvbShBRVNfR0NNLml2U2l6ZSk7XG4gICAgY29uc3QgZmlsZUtleSA9IGdldFNlY3VyZVJhbmRvbShkZWNvZGVkS2VrLmxlbmd0aCk7XG5cbiAgICBjb25zdCBmaWxlQ29udGVudCA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZzLnJlYWRGaWxlKGlucHV0RmlsZVBhdGgsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgY29uc3QgZW5jcnlwdGVkRGF0YSA9IHRoaXMuZW5jcnlwdEdDTShmaWxlQ29udGVudCwgZmlsZUtleSwgZGF0YUl2LCBERUZBVUxUX0FBRCk7XG4gICAgY29uc3QgZW5jcnlwdGVkRmlsZVBhdGggPSBhd2FpdCB3cml0ZUNvbnRlbnRUb0ZpbGUodG1wRGlyLCBwYXRoLmJhc2VuYW1lKGlucHV0RmlsZVBhdGgpICsgJyMnLCBlbmNyeXB0ZWREYXRhKTtcblxuICAgIGNvbnN0IGtleUl2ID0gZ2V0U2VjdXJlUmFuZG9tKEFFU19HQ00uaXZTaXplKTtcbiAgICBjb25zdCBlbmNyeXB0ZWRLZXkgPSB0aGlzLmVuY3J5cHRHQ00oZmlsZUtleSwgZGVjb2RlZEtlaywga2V5SXYsIERFRkFVTFRfQUFEKTtcblxuICAgIHJldHVybiB7XG4gICAgICBlbmNyeXB0aW9uTWV0YWRhdGE6IGNyZWF0ZUVuY3J5cHRpb25NZXRhZGF0YShlbmNyeXB0aW9uTWF0ZXJpYWwsIGZpbGVLZXkubGVuZ3RoLCBlbmNyeXB0ZWRLZXksIGRhdGFJdiwga2V5SXYsIERFRkFVTFRfQUFELCBERUZBVUxUX0FBRCksXG4gICAgICBkYXRhRmlsZTogZW5jcnlwdGVkRmlsZVBhdGhcbiAgICB9O1xuICB9O1xuXG4gIC8qKlxuICAgKiBEZWNyeXB0IGZpbGUgdXNpbmcgQUVTIGFsZ29yaXRobS5cbiAgICovXG4gIHRoaXMuZGVjcnlwdEZpbGUgPSBhc3luYyBmdW5jdGlvbiAobWV0YWRhdGEsIGVuY3J5cHRpb25NYXRlcmlhbCwgaW5wdXRGaWxlUGF0aCxcbiAgICB0bXBEaXIgPSBudWxsLCBjaHVua1NpemUgPSBibG9ja1NpemUgKiA0ICogMTAyNCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmRlY3J5cHRGaWxlQ0JDKG1ldGFkYXRhLCBlbmNyeXB0aW9uTWF0ZXJpYWwsIGlucHV0RmlsZVBhdGgsIHRtcERpciwgY2h1bmtTaXplKTtcbiAgfTtcblxuICB0aGlzLmRlY3J5cHRGaWxlQ0JDID0gYXN5bmMgZnVuY3Rpb24gKG1ldGFkYXRhLCBlbmNyeXB0aW9uTWF0ZXJpYWwsIGlucHV0RmlsZVBhdGgsXG4gICAgdG1wRGlyID0gbnVsbCwgY2h1bmtTaXplID0gYmxvY2tTaXplICogNCAqIDEwMjQpIHtcbiAgICBjb25zdCBkZWNvZGVkS2VrID0gQnVmZmVyLmZyb20oZW5jcnlwdGlvbk1hdGVyaWFsW1FVRVJZX1NUQUdFX01BU1RFUl9LRVldLCBCQVNFNjQpO1xuICAgIGNvbnN0IGtleUJ5dGVzID0gbmV3IEJ1ZmZlci5mcm9tKG1ldGFkYXRhLmtleSwgQkFTRTY0KTtcbiAgICBjb25zdCBpdkJ5dGVzID0gbmV3IEJ1ZmZlci5mcm9tKG1ldGFkYXRhLml2LCBCQVNFNjQpO1xuICAgIGNvbnN0IGtleURlY2lwaGVyID0gY3J5cHRvLmNyZWF0ZURlY2lwaGVyaXYoQUVTX0VDQi5jaXBoZXJOYW1lKGRlY29kZWRLZWsubGVuZ3RoKSwgZGVjb2RlZEtlaywgbnVsbCk7XG4gICAgY29uc3QgZmlsZUtleSA9IHBlcmZvcm1DcnlwdG8oa2V5RGVjaXBoZXIsIGtleUJ5dGVzKTtcblxuICAgIGNvbnN0IGRhdGFEZWNpcGhlciA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KEFFU19DQkMuY2lwaGVyTmFtZShmaWxlS2V5Lmxlbmd0aCksIGZpbGVLZXksIGl2Qnl0ZXMpO1xuICAgIHJldHVybiBhd2FpdCBwZXJmb3JtRmlsZVN0cmVhbUNyeXB0byhkYXRhRGVjaXBoZXIsIHRtcERpciwgaW5wdXRGaWxlUGF0aCwgY2h1bmtTaXplKTtcbiAgfTtcblxuICAvL1RPRE86IFNOT1ctOTQwOTgxOiBBZGQgcHJvcGVyIHVzYWdlIHdoZW4gZmVhdHVyZSBpcyByZWFkeVxuICB0aGlzLmRlY3J5cHRGaWxlR0NNID0gYXN5bmMgZnVuY3Rpb24gKG1ldGFkYXRhLCBlbmNyeXB0aW9uTWF0ZXJpYWwsIGlucHV0RmlsZVBhdGgsIHRtcERpciA9IG51bGwpIHtcbiAgICBjb25zdCBkZWNvZGVkS2VrID0gQnVmZmVyLmZyb20oZW5jcnlwdGlvbk1hdGVyaWFsW1FVRVJZX1NUQUdFX01BU1RFUl9LRVldLCBCQVNFNjQpO1xuICAgIGNvbnN0IGtleUJ5dGVzID0gbmV3IEJ1ZmZlci5mcm9tKG1ldGFkYXRhLmtleSwgQkFTRTY0KTtcbiAgICBjb25zdCBrZXlJdkJ5dGVzID0gbmV3IEJ1ZmZlci5mcm9tKG1ldGFkYXRhLmtleUl2LCBCQVNFNjQpO1xuICAgIGNvbnN0IGRhdGFJdkJ5dGVzID0gbmV3IEJ1ZmZlci5mcm9tKG1ldGFkYXRhLml2LCBCQVNFNjQpO1xuICAgIGNvbnN0IGRhdGFBYWRCeXRlcyA9IG5ldyBCdWZmZXIuZnJvbShtZXRhZGF0YS5kYXRhQWFkLCBCQVNFNjQpO1xuICAgIGNvbnN0IGtleUFhZEJ5dGVzID0gbmV3IEJ1ZmZlci5mcm9tKG1ldGFkYXRhLmtleUFhZCwgQkFTRTY0KTtcblxuICAgIGNvbnN0IGZpbGVLZXkgPSB0aGlzLmRlY3J5cHRHQ00oa2V5Qnl0ZXMsIGRlY29kZWRLZWssIGtleUl2Qnl0ZXMsIGtleUFhZEJ5dGVzKTtcblxuICAgIGNvbnN0IGZpbGVDb250ZW50ID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZnMucmVhZEZpbGUoaW5wdXRGaWxlUGF0aCwgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZShkYXRhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBkZWNyeXB0ZWREYXRhID0gdGhpcy5kZWNyeXB0R0NNKGZpbGVDb250ZW50LCBmaWxlS2V5LCBkYXRhSXZCeXRlcywgZGF0YUFhZEJ5dGVzKTtcbiAgICByZXR1cm4gYXdhaXQgd3JpdGVDb250ZW50VG9GaWxlKHRtcERpciwgcGF0aC5iYXNlbmFtZShpbnB1dEZpbGVQYXRoKSArICcjJywgZGVjcnlwdGVkRGF0YSk7XG4gIH07XG4gIFxuICBmdW5jdGlvbiBwZXJmb3JtQ3J5cHRvKGNpcGhlck9yRGVjaXBoZXIsIGRhdGEpIHtcbiAgICBjb25zdCBlbmNyeXB0ZWRPckRlY3J5cHRlZCA9IGNpcGhlck9yRGVjaXBoZXIudXBkYXRlKGRhdGEpO1xuICAgIGNvbnN0IGZpbmFsID0gY2lwaGVyT3JEZWNpcGhlci5maW5hbCgpO1xuICAgIHJldHVybiBCdWZmZXIuY29uY2F0KFtlbmNyeXB0ZWRPckRlY3J5cHRlZCwgZmluYWxdKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIHBlcmZvcm1GaWxlU3RyZWFtQ3J5cHRvKGNpcGhlck9yRGVjaXBoZXIsIHRtcERpciwgaW5wdXRGaWxlUGF0aCwgY2h1bmtTaXplKSB7XG4gICAgY29uc3Qgb3V0cHV0RmlsZSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRtcC5maWxlKHsgZGlyOiB0bXBEaXIsIHByZWZpeDogcGF0aC5iYXNlbmFtZShpbnB1dEZpbGVQYXRoKSArICcjJyB9LCAoZXJyLCBwYXRoLCBmZCkgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSh7IHBhdGgsIGZkIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgY29uc3QgaW5wdXRTdHJlYW0gPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGlucHV0RmlsZVBhdGgsIHsgaGlnaFdhdGVyTWFyazogY2h1bmtTaXplIH0pO1xuICAgICAgY29uc3Qgb3V0cHV0U3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0ob3V0cHV0RmlsZS5wYXRoKTtcblxuICAgICAgaW5wdXRTdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgY29uc3QgZW5jcnlwdGVkID0gY2lwaGVyT3JEZWNpcGhlci51cGRhdGUoY2h1bmspO1xuICAgICAgICBvdXRwdXRTdHJlYW0ud3JpdGUoZW5jcnlwdGVkKTtcbiAgICAgIH0pO1xuICAgICAgaW5wdXRTdHJlYW0ub24oJ2Nsb3NlJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBvdXRwdXRTdHJlYW0ud3JpdGUoY2lwaGVyT3JEZWNpcGhlci5maW5hbCgpKTtcbiAgICAgICAgb3V0cHV0U3RyZWFtLmNsb3NlKHJlc29sdmUpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBmcy5jbG9zZShvdXRwdXRGaWxlLmZkLCAoZXJyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBvdXRwdXRGaWxlLnBhdGg7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiB3cml0ZUNvbnRlbnRUb0ZpbGUodG1wRGlyLCBwcmVmaXgsIGNvbnRlbnQsKSB7XG4gICAgY29uc3Qgb3V0cHV0RmlsZSA9IGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRtcC5maWxlKHsgZGlyOiB0bXBEaXIsIHByZWZpeDogcHJlZml4IH0sIChlcnIsIHBhdGgsIGZkKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKHsgcGF0aCwgZmQgfSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZzLndyaXRlRmlsZShvdXRwdXRGaWxlLnBhdGgsIGNvbnRlbnQsIGVyciA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIGZzLmNsb3NlKG91dHB1dEZpbGUuZmQsIChlcnIpID0+IHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dHB1dEZpbGUucGF0aDtcbiAgfVxufVxuXG5leHBvcnRzLkVuY3J5cHRVdGlsID0gRW5jcnlwdFV0aWw7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/encrypt_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/file_compression_type.js":
/*!*************************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/file_transfer_agent/file_compression_type.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("const Types = [\n  {\n    'name': 'GZIP',\n    'file_extension': '.gz',\n    'mime_type': 'application',\n    'mime_subtypes': ['gzip', 'x-gzip'],\n    'is_supported': true,\n  },\n  {\n    'name': 'DEFLATE',\n    'file_extension': '.deflate',\n    'mime_type': 'application',\n    'mime_subtypes': ['zlib', 'deflate'],\n    'is_supported': true,\n  },\n  {\n    'name': 'RAW_DEFLATE',\n    'file_extension': '.raw_deflate',\n    'mime_type': 'application',\n    'mime_subtypes': ['raw_deflate'],\n    'is_supported': true,\n  },\n  {\n    'name': 'BZIP2',\n    'file_extension': '.bz2',\n    'mime_type': 'application',\n    'mime_subtypes': ['bzip2', 'x-bzip2', 'x-bz2', 'x-bzip', 'bz2'],\n    'is_supported': true,\n  },\n  {\n    'name': 'LZIP',\n    'file_extension': '.lz',\n    'mime_type': 'application',\n    'mime_subtypes': ['lzip', 'x-lzip'],\n    'is_supported': false,\n  },\n  {\n    'name': 'LZMA',\n    'file_extension': '.lzma',\n    'mime_type': 'application',\n    'mime_subtypes': ['lzma', 'x-lzma'],\n    'is_supported': false,\n  },\n  {\n    'name': 'LZO',\n    'file_extension': '.lzo',\n    'mime_type': 'application',\n    'mime_subtypes': ['lzo', 'x-lzo'],\n    'is_supported': false,\n  },\n  {\n    'name': 'XZ',\n    'file_extension': '.xz',\n    'mime_type': 'application',\n    'mime_subtypes': ['xz', 'x-xz'],\n    'is_supported': false,\n  },\n  {\n    'name': 'COMPRESS',\n    'file_extension': '.Z',\n    'mime_type': 'application',\n    'mime_subtypes': ['compress', 'x-compress'],\n    'is_supported': false,\n  },\n  {\n    'name': 'PARQUET',\n    'file_extension': '.parquet',\n    'mime_type': 'snowflake',\n    'mime_subtypes': ['parquet'],\n    'is_supported': true,\n  },\n  {\n    'name': 'ZSTD',\n    'file_extension': '.zst',\n    'mime_type': 'application',\n    'mime_subtypes': ['zstd', 'x-zstd'],\n    'is_supported': true,\n  },\n  {\n    'name': 'BROTLI',\n    'file_extension': '.br',\n    'mime_type': 'application',\n    'mime_subtypes': ['br', 'x-br'],\n    'is_supported': true,\n  },\n  {\n    'name': 'ORC',\n    'file_extension': '.orc',\n    'mime_type': 'snowflake',\n    'mime_subtypes': ['orc'],\n    'is_supported': true,\n  }\n];\n\nconst subtypeToMeta = [];\nfor (const type of Types) {\n  for (const ms of type['mime_subtypes']) {\n    subtypeToMeta[ms] = type;\n  }\n}\n\n/**\n * Return the file compression type based on subtype.\n *\n * @param {String} subtype\n *\n * @returns {Object} the file compression object\n */\nexports.lookupByMimeSubType = function lookupByMimeSubType(subtype) {\n  return subtypeToMeta[subtype.toLowerCase()];  \n};\n\n/**\n * Return the file compression type based on encoding.\n *\n * @param {String} encoding\n *\n * @returns {Object} the file compression object\n */\nexports.lookupByEncoding = function lookupByEncoding(encoding) {\n  encoding = encoding.substring(encoding.indexOf('/') + 1);\n  return subtypeToMeta[encoding];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9maWxlX2NvbXByZXNzaW9uX3R5cGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2ZpbGVfdHJhbnNmZXJfYWdlbnQvZmlsZV9jb21wcmVzc2lvbl90eXBlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFR5cGVzID0gW1xuICB7XG4gICAgJ25hbWUnOiAnR1pJUCcsXG4gICAgJ2ZpbGVfZXh0ZW5zaW9uJzogJy5neicsXG4gICAgJ21pbWVfdHlwZSc6ICdhcHBsaWNhdGlvbicsXG4gICAgJ21pbWVfc3VidHlwZXMnOiBbJ2d6aXAnLCAneC1nemlwJ10sXG4gICAgJ2lzX3N1cHBvcnRlZCc6IHRydWUsXG4gIH0sXG4gIHtcbiAgICAnbmFtZSc6ICdERUZMQVRFJyxcbiAgICAnZmlsZV9leHRlbnNpb24nOiAnLmRlZmxhdGUnLFxuICAgICdtaW1lX3R5cGUnOiAnYXBwbGljYXRpb24nLFxuICAgICdtaW1lX3N1YnR5cGVzJzogWyd6bGliJywgJ2RlZmxhdGUnXSxcbiAgICAnaXNfc3VwcG9ydGVkJzogdHJ1ZSxcbiAgfSxcbiAge1xuICAgICduYW1lJzogJ1JBV19ERUZMQVRFJyxcbiAgICAnZmlsZV9leHRlbnNpb24nOiAnLnJhd19kZWZsYXRlJyxcbiAgICAnbWltZV90eXBlJzogJ2FwcGxpY2F0aW9uJyxcbiAgICAnbWltZV9zdWJ0eXBlcyc6IFsncmF3X2RlZmxhdGUnXSxcbiAgICAnaXNfc3VwcG9ydGVkJzogdHJ1ZSxcbiAgfSxcbiAge1xuICAgICduYW1lJzogJ0JaSVAyJyxcbiAgICAnZmlsZV9leHRlbnNpb24nOiAnLmJ6MicsXG4gICAgJ21pbWVfdHlwZSc6ICdhcHBsaWNhdGlvbicsXG4gICAgJ21pbWVfc3VidHlwZXMnOiBbJ2J6aXAyJywgJ3gtYnppcDInLCAneC1iejInLCAneC1iemlwJywgJ2J6MiddLFxuICAgICdpc19zdXBwb3J0ZWQnOiB0cnVlLFxuICB9LFxuICB7XG4gICAgJ25hbWUnOiAnTFpJUCcsXG4gICAgJ2ZpbGVfZXh0ZW5zaW9uJzogJy5seicsXG4gICAgJ21pbWVfdHlwZSc6ICdhcHBsaWNhdGlvbicsXG4gICAgJ21pbWVfc3VidHlwZXMnOiBbJ2x6aXAnLCAneC1semlwJ10sXG4gICAgJ2lzX3N1cHBvcnRlZCc6IGZhbHNlLFxuICB9LFxuICB7XG4gICAgJ25hbWUnOiAnTFpNQScsXG4gICAgJ2ZpbGVfZXh0ZW5zaW9uJzogJy5sem1hJyxcbiAgICAnbWltZV90eXBlJzogJ2FwcGxpY2F0aW9uJyxcbiAgICAnbWltZV9zdWJ0eXBlcyc6IFsnbHptYScsICd4LWx6bWEnXSxcbiAgICAnaXNfc3VwcG9ydGVkJzogZmFsc2UsXG4gIH0sXG4gIHtcbiAgICAnbmFtZSc6ICdMWk8nLFxuICAgICdmaWxlX2V4dGVuc2lvbic6ICcubHpvJyxcbiAgICAnbWltZV90eXBlJzogJ2FwcGxpY2F0aW9uJyxcbiAgICAnbWltZV9zdWJ0eXBlcyc6IFsnbHpvJywgJ3gtbHpvJ10sXG4gICAgJ2lzX3N1cHBvcnRlZCc6IGZhbHNlLFxuICB9LFxuICB7XG4gICAgJ25hbWUnOiAnWFonLFxuICAgICdmaWxlX2V4dGVuc2lvbic6ICcueHonLFxuICAgICdtaW1lX3R5cGUnOiAnYXBwbGljYXRpb24nLFxuICAgICdtaW1lX3N1YnR5cGVzJzogWyd4eicsICd4LXh6J10sXG4gICAgJ2lzX3N1cHBvcnRlZCc6IGZhbHNlLFxuICB9LFxuICB7XG4gICAgJ25hbWUnOiAnQ09NUFJFU1MnLFxuICAgICdmaWxlX2V4dGVuc2lvbic6ICcuWicsXG4gICAgJ21pbWVfdHlwZSc6ICdhcHBsaWNhdGlvbicsXG4gICAgJ21pbWVfc3VidHlwZXMnOiBbJ2NvbXByZXNzJywgJ3gtY29tcHJlc3MnXSxcbiAgICAnaXNfc3VwcG9ydGVkJzogZmFsc2UsXG4gIH0sXG4gIHtcbiAgICAnbmFtZSc6ICdQQVJRVUVUJyxcbiAgICAnZmlsZV9leHRlbnNpb24nOiAnLnBhcnF1ZXQnLFxuICAgICdtaW1lX3R5cGUnOiAnc25vd2ZsYWtlJyxcbiAgICAnbWltZV9zdWJ0eXBlcyc6IFsncGFycXVldCddLFxuICAgICdpc19zdXBwb3J0ZWQnOiB0cnVlLFxuICB9LFxuICB7XG4gICAgJ25hbWUnOiAnWlNURCcsXG4gICAgJ2ZpbGVfZXh0ZW5zaW9uJzogJy56c3QnLFxuICAgICdtaW1lX3R5cGUnOiAnYXBwbGljYXRpb24nLFxuICAgICdtaW1lX3N1YnR5cGVzJzogWyd6c3RkJywgJ3gtenN0ZCddLFxuICAgICdpc19zdXBwb3J0ZWQnOiB0cnVlLFxuICB9LFxuICB7XG4gICAgJ25hbWUnOiAnQlJPVExJJyxcbiAgICAnZmlsZV9leHRlbnNpb24nOiAnLmJyJyxcbiAgICAnbWltZV90eXBlJzogJ2FwcGxpY2F0aW9uJyxcbiAgICAnbWltZV9zdWJ0eXBlcyc6IFsnYnInLCAneC1iciddLFxuICAgICdpc19zdXBwb3J0ZWQnOiB0cnVlLFxuICB9LFxuICB7XG4gICAgJ25hbWUnOiAnT1JDJyxcbiAgICAnZmlsZV9leHRlbnNpb24nOiAnLm9yYycsXG4gICAgJ21pbWVfdHlwZSc6ICdzbm93Zmxha2UnLFxuICAgICdtaW1lX3N1YnR5cGVzJzogWydvcmMnXSxcbiAgICAnaXNfc3VwcG9ydGVkJzogdHJ1ZSxcbiAgfVxuXTtcblxuY29uc3Qgc3VidHlwZVRvTWV0YSA9IFtdO1xuZm9yIChjb25zdCB0eXBlIG9mIFR5cGVzKSB7XG4gIGZvciAoY29uc3QgbXMgb2YgdHlwZVsnbWltZV9zdWJ0eXBlcyddKSB7XG4gICAgc3VidHlwZVRvTWV0YVttc10gPSB0eXBlO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJuIHRoZSBmaWxlIGNvbXByZXNzaW9uIHR5cGUgYmFzZWQgb24gc3VidHlwZS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3VidHlwZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBmaWxlIGNvbXByZXNzaW9uIG9iamVjdFxuICovXG5leHBvcnRzLmxvb2t1cEJ5TWltZVN1YlR5cGUgPSBmdW5jdGlvbiBsb29rdXBCeU1pbWVTdWJUeXBlKHN1YnR5cGUpIHtcbiAgcmV0dXJuIHN1YnR5cGVUb01ldGFbc3VidHlwZS50b0xvd2VyQ2FzZSgpXTsgIFxufTtcblxuLyoqXG4gKiBSZXR1cm4gdGhlIGZpbGUgY29tcHJlc3Npb24gdHlwZSBiYXNlZCBvbiBlbmNvZGluZy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RpbmdcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgZmlsZSBjb21wcmVzc2lvbiBvYmplY3RcbiAqL1xuZXhwb3J0cy5sb29rdXBCeUVuY29kaW5nID0gZnVuY3Rpb24gbG9va3VwQnlFbmNvZGluZyhlbmNvZGluZykge1xuICBlbmNvZGluZyA9IGVuY29kaW5nLnN1YnN0cmluZyhlbmNvZGluZy5pbmRleE9mKCcvJykgKyAxKTtcbiAgcmV0dXJuIHN1YnR5cGVUb01ldGFbZW5jb2RpbmddO1xufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/file_compression_type.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/file_transfer_agent.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/file_transfer_agent/file_transfer_agent.js ***!
  \***********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const binascii = __webpack_require__(/*! binascii */ \"(rsc)/./node_modules/binascii/index.js\");\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst mime = __webpack_require__(/*! mime-types */ \"(rsc)/./node_modules/mime-types/index.js\");\nconst path = __webpack_require__(/*! path */ \"path\");\n\nconst statement = __webpack_require__(/*! ../connection/statement */ \"(rsc)/./node_modules/snowflake-sdk/lib/connection/statement.js\");\nconst fileCompressionType = __webpack_require__(/*! ./file_compression_type */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/file_compression_type.js\");\nconst expandTilde = __webpack_require__(/*! expand-tilde */ \"(rsc)/./node_modules/expand-tilde/index.js\");\nconst SnowflakeRemoteStorageUtil = (__webpack_require__(/*! ./remote_storage_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/remote_storage_util.js\").RemoteStorageUtil);\nconst LocalUtil = (__webpack_require__(/*! ./local_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/local_util.js\").LocalUtil);\nconst SnowflakeFileEncryptionMaterial = (__webpack_require__(/*! ./remote_storage_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/remote_storage_util.js\").SnowflakeFileEncryptionMaterial);\nconst SnowflakeS3Util = __webpack_require__(/*! ./s3_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/s3_util.js\");\nconst { FileUtil, getMatchingFilePaths } = __webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\");\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\").resultStatus);\n\nconst SnowflakeFileUtil = new FileUtil();\nconst SnowflakeLocalUtil = new LocalUtil();\nconst S3_FS = 'S3';\nconst AZURE_FS = 'AZURE';\nconst GCS_FS = 'GCS';\nconst LOCAL_FS = 'LOCAL_FS';\nconst CMD_TYPE_UPLOAD = 'UPLOAD';\nconst CMD_TYPE_DOWNLOAD = 'DOWNLOAD';\nconst FILE_PROTOCOL = 'file://';\n\nconst INJECT_WAIT_IN_PUT = 0;\n\n\nconst RESULT_TEXT_COLUMN_DESC = function (name) {\n  return {\n    'name': name,\n    'type': 'text',\n    'length': 16777216,\n    'precision': null,\n    'scale': null,\n    'nullable': false\n  };\n};\nconst RESULT_FIXED_COLUMN_DESC = function (name) {\n  return {\n    'name': name,\n    'type': 'fixed',\n    'length': 5,\n    'precision': 0,\n    'scale': 0,\n    'nullable': false\n  };\n};\n/**\n * Creates a file transfer agent.\n *\n * @param {Object} context\n *\n * @returns {Object}\n * @constructor\n */\nfunction FileTransferAgent(context) {\n  const remoteStorageUtil = new SnowflakeRemoteStorageUtil(context.connectionConfig);\n  const response = context.fileMetadata;\n  const command = context.sqlText;\n  const cwd = context.cwd;\n\n  let commandType;\n  const encryptionMaterial = [];\n  let fileName;\n  const fileStream = context.fileStream ? context.fileStream : null;\n\n  let autoCompress;\n  let sourceCompression;\n  let parallel;\n  let stageInfo;\n  let stageLocationType;\n  let presignedUrls;\n  let overwrite;\n\n  let useAccelerateEndpoint = false;\n\n  let srcFiles;\n  const srcFilesToEncryptionMaterial = {};\n  let localLocation;\n\n  const results = [];\n\n  // Store info of files retrieved\n  const filesToPut = [];\n\n  // Store metadata of files retrieved\n  const fileMetadata = [];\n  const smallFileMetas = [];\n  const largeFileMetas = [];\n\n  /**\n  * Execute PUT or GET command.\n  *\n  * @returns {null}\n  */\n  this.execute = async function () {\n    if (fileStream) {\n      const data = response['data'];\n      commandType = data['command'];\n      autoCompress = data['autoCompress'];\n      sourceCompression = data['sourceCompression'];\n      parallel = data['parallel'];\n      stageInfo = data['stageInfo'];\n      stageLocationType = stageInfo['locationType'];\n      presignedUrls = data['presignedUrls'];\n      overwrite = data['overwrite'];\n\n      if (commandType !== CMD_TYPE_UPLOAD) {\n        throw new Error('Incorrect UploadFileStream command');\n      }\n\n      const currFileObj = {};\n      currFileObj['srcFileName'] = data.src_locations[0];\n      currFileObj['srcFilePath'] = '';\n      currFileObj['srcFileSize'] = fileStream.length;\n      filesToPut.push(currFileObj);\n\n      initEncryptionMaterial();\n      initFileMetadata();\n\n      await transferAccelerateConfig();\n      await updateFileMetasWithPresignedUrl();\n\n      if (fileMetadata.length !== 1) {\n        throw new Error('UploadFileStream only allow 1 file');\n      }\n\n      //upload \n      const storageClient = getStorageClient(stageLocationType);\n      const client = storageClient.createClient(stageInfo, false);\n      const meta = fileMetadata[0];\n      meta['parallel'] = parallel;\n      meta['client'] = client;\n      meta['fileStream'] = fileStream;\n\n      //for digest\n      const hash = crypto.createHash('sha256')\n        .update(fileStream)\n        .digest('base64');\n      meta['SHA256_DIGEST'] = hash;\n      meta['uploadSize'] = fileStream.length;\n      meta['dstCompressionType'] = fileCompressionType.lookupByEncoding(sourceCompression);\n      meta['requireCompress'] = false;\n      meta['dstFileName'] = meta['srcFileName'];\n\n      await storageClient.uploadOneFileStream(meta);\n    } else {\n      parseCommand();\n      initFileMetadata();\n\n      if (commandType === CMD_TYPE_UPLOAD) {\n        if (filesToPut.length === 0) {\n          throw new Error('No file found for: ' + fileName);\n        }\n\n        processFileCompressionType();\n      }\n\n      if (commandType === CMD_TYPE_DOWNLOAD) {\n        if (!fs.existsSync(localLocation)) {\n          fs.mkdirSync(localLocation);\n        }\n      }\n\n      if (stageLocationType === LOCAL_FS) {\n        process.umask(0);\n        if (!fs.existsSync(stageInfo['location'])) {\n          fs.mkdirSync(stageInfo['location'], { mode: 0o777, recursive: true });\n        }\n      }\n\n      await transferAccelerateConfig();\n      await updateFileMetasWithPresignedUrl();\n\n      for (const meta of fileMetadata) {\n        if (meta['srcFileSize'] > SnowflakeS3Util.DATA_SIZE_THRESHOLD) {\n          // Add to large file metas\n          meta['parallel'] = parallel;\n          largeFileMetas.push(meta);\n        } else {\n          // Add to small file metas and set parallel to 1\n          meta['parallel'] = 1;\n          smallFileMetas.push(meta);\n        }\n      }\n\n      if (commandType === CMD_TYPE_UPLOAD) {\n        await upload(largeFileMetas, smallFileMetas);\n      }\n\n      if (commandType === CMD_TYPE_DOWNLOAD) {\n        await download(largeFileMetas, smallFileMetas);\n      }\n    }\n  };\n\n  /**\n  * Generate the rowset and rowset types using the file metadatas.\n  *\n  * @returns {Object}\n  */\n  this.result = function () {\n    const rowset = [];\n    if (commandType === CMD_TYPE_UPLOAD) {\n      let srcFileSize;\n      let dstFileSize;\n      let srcCompressionType;\n      let dstCompressionType;\n      let errorDetails;\n\n      if (results) {\n        for (const meta of results) {\n          if (meta['resultStatus'] === 'ERROR') {\n            errorDetails = meta['errorDetails'];\n            if (!errorDetails) {\n              errorDetails = `Unknown error during PUT of file: ${meta['srcFilePath']}`;\n            }\n            throw new Error(errorDetails);\n          }\n          if (meta['srcCompressionType']) {\n            srcCompressionType = meta['srcCompressionType']['name'];\n          } else {\n            srcCompressionType = null;\n          }\n\n          if (meta['dstCompressionType']) {\n            dstCompressionType = meta['dstCompressionType']['name'];\n          } else {\n            dstCompressionType = null;\n          }\n\n          errorDetails = meta['errorDetails'];\n\n          srcFileSize = meta['srcFileSize'].toString();\n          dstFileSize = meta['dstFileSize'].toString();\n\n          rowset.push([\n            meta['srcFileName'],\n            meta['dstFileName'],\n            srcFileSize,\n            dstFileSize,\n            srcCompressionType,\n            dstCompressionType,\n            meta['resultStatus'],\n            errorDetails\n          ]);\n        }\n      }\n      return {\n        'rowset': rowset,\n        'rowtype': [\n          RESULT_TEXT_COLUMN_DESC('source'),\n          RESULT_TEXT_COLUMN_DESC('target'),\n          RESULT_FIXED_COLUMN_DESC('sourceSize'),\n          RESULT_FIXED_COLUMN_DESC('targetSize'),\n          RESULT_TEXT_COLUMN_DESC('sourceCompression'),\n          RESULT_TEXT_COLUMN_DESC('targetCompression'),\n          RESULT_TEXT_COLUMN_DESC('status'),\n          RESULT_TEXT_COLUMN_DESC('message'),\n        ]\n      };\n    } else if (commandType === CMD_TYPE_DOWNLOAD) {\n      let dstFileSize;\n      let errorDetails;\n\n      if (results) {\n        for (const meta of results) {\n          errorDetails = meta['errorDetails'];\n          dstFileSize = meta['dstFileSize'];\n\n          rowset.push([\n            meta['dstFileName'],\n            dstFileSize,\n            meta['resultStatus'],\n            errorDetails\n          ]);\n        }\n      }\n\n      return {\n        'rowset': rowset,\n        'rowtype': [\n          RESULT_TEXT_COLUMN_DESC('file'),\n          RESULT_FIXED_COLUMN_DESC('size'),\n          RESULT_TEXT_COLUMN_DESC('status'),\n          RESULT_TEXT_COLUMN_DESC('message')\n        ]\n      };\n    }\n  };\n\n  /**\n  * Upload files in the metadata list.\n  *\n  * @returns {null}\n  */\n  async function upload(largeFileMetas, smallFileMetas) {\n    const storageClient = getStorageClient(stageLocationType);\n    const client = storageClient.createClient(stageInfo, false);\n\n    for (const meta of smallFileMetas) {\n      meta['client'] = client;\n    }\n    for (const meta of largeFileMetas) {\n      meta['client'] = client;\n    }\n\n    if (smallFileMetas.length > 0) {\n      //await uploadFilesinParallel(smallFileMetas);\n      await uploadFilesinSequential(smallFileMetas);\n    }\n    if (largeFileMetas.length > 0) {\n      await uploadFilesinSequential(largeFileMetas);\n    }\n  }\n\n  /**\n  * Upload a file sequentially.\n  *\n  * @param {Object} fileMeta\n  *\n  * @returns {null}\n  */\n  async function uploadFilesinSequential(fileMeta) {\n    let index = 0;\n    const fileMetaLen = fileMeta.length;\n\n    while (index < fileMetaLen) {\n      const result = await uploadOneFile(fileMeta[index]);\n      if (result['resultStatus'] === resultStatus.RENEW_TOKEN) {\n        const client = renewExpiredClient();\n        for (let index2 = index; index2 < fileMetaLen; index2++) {\n          fileMeta[index2]['client'] = client;\n        }\n        continue;\n      } else if (result['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n        await updateFileMetasWithPresignedUrl();\n        continue;\n      }\n      results.push(result);\n      if (result['resultStatus'] === resultStatus.ERROR) {\n        break;\n      }\n      index += 1;\n      if (INJECT_WAIT_IN_PUT > 0) {\n        await new Promise(resolve => setTimeout(resolve, INJECT_WAIT_IN_PUT));\n      }\n    }\n  }\n\n  /**\n  * Generate a temporary directory for the file then upload.\n  *\n  * @param {Object} meta\n  *\n  * @returns {Object}\n  */\n  async function uploadOneFile(meta) {\n    meta['realSrcFilePath'] = meta['srcFilePath'];\n    const tmpDir = fs.mkdtempSync(path.join(os.tmpdir(), 'tmp'));\n    meta['tmpDir'] = tmpDir;\n    try {\n      if (meta['requireCompress']) {\n        const result = await SnowflakeFileUtil.compressFileWithGZIP(meta['srcFilePath'], meta['tmpDir']);\n        meta['realSrcFilePath'] = result.name;\n      }\n      const result = await SnowflakeFileUtil.getDigestAndSizeForFile(meta['realSrcFilePath']);\n      const sha256Digest = result.digest;\n      const uploadSize = result.size;\n\n      meta['SHA256_DIGEST'] = sha256Digest;\n      meta['uploadSize'] = uploadSize;\n\n      const storageClient = getStorageClient(meta['stageLocationType']);\n      await storageClient.uploadOneFileWithRetry(meta);\n    } catch (err) {\n      meta['dstFileSize'] = 0;\n      if (meta['resultStatus']) {\n        meta['resultStatus'] = resultStatus.ERROR;\n\n      }\n      meta['errorDetails'] = err.toString();\n      meta['errorDetails'] += ` file=${meta['srcFileName']}, real file=${meta['realSrcFilePath']}`;\n    } finally {\n      // Remove all files inside tmp folder\n      const matchingFileNames = getMatchingFilePaths(meta['tmpDir'], meta['srcFileName'] + '*');\n      for (const matchingFileName of matchingFileNames) {\n        await new Promise((resolve, reject) => {\n          fs.unlink(matchingFileName, err => {\n            if (err) {\n              reject(err);\n            }\n            resolve();\n          });\n        });\n      }\n      // Delete tmp folder\n      fs.rmdir(meta['tmpDir'], (err) => {\n        if (err) {\n          throw (err);\n        }\n\n      });\n    }\n\n    return meta;\n  }\n\n  /**\n  * Download files in the metadata list.\n  *\n  * @returns {null}\n  */\n  async function download(largeFileMetas, smallFileMetas) {\n    const storageClient = getStorageClient(stageLocationType);\n    const client = storageClient.createClient(stageInfo, false);\n\n    for (const meta of smallFileMetas) {\n      meta['client'] = client;\n    }\n    for (const meta of largeFileMetas) {\n      meta['client'] = client;\n    }\n\n    if (smallFileMetas.length > 0) {\n      //await downloadFilesinParallel(smallFileMetas);\n      await downloadFilesinSequential(smallFileMetas);\n    }\n    if (largeFileMetas.length > 0) {\n      await downloadFilesinSequential(largeFileMetas);\n    }\n  }\n\n  /**\n  * Download a file sequentially.\n  *\n  * @param {Object} fileMeta\n  *\n  * @returns {null}\n  */\n  async function downloadFilesinSequential(fileMeta) {\n    let index = 0;\n    const fileMetaLen = fileMeta.length;\n\n    while (index < fileMetaLen) {\n      const result = await downloadOneFile(fileMeta[index]);\n      if (result['resultStatus'] === resultStatus.RENEW_TOKEN) {\n        const client = renewExpiredClient();\n        for (let index2 = index; index2 < fileMetaLen; index2++) {\n          fileMeta[index2]['client'] = client;\n        }\n        continue;\n      } else if (result['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n        await updateFileMetasWithPresignedUrl();\n        continue;\n      }\n      results.push(result);\n      index += 1;\n      if (INJECT_WAIT_IN_PUT > 0) {\n        await new Promise(resolve => setTimeout(resolve, INJECT_WAIT_IN_PUT));\n      }\n    }\n  }\n\n  /**\n  * Download a file and place into the target directory.\n  *\n  * @param {Object} meta\n  *\n  * @returns {Object}\n  */\n  async function downloadOneFile(meta) {\n    meta['tmpDir'] = await new Promise((resolve, reject) => {\n      fs.mkdtemp(path.join(os.tmpdir(), 'tmp'), (err, dir) => {\n        if (err) {\n          reject(err);\n        }\n        resolve(dir);\n      });\n    });\n    try {\n      const storageClient = getStorageClient(meta['stageLocationType']);\n      await storageClient.downloadOneFile(meta);\n    } catch (err) {\n      meta['dstFileSize'] = -1;\n      if (meta['resultStatus']) {\n        meta['resultStatus'] = resultStatus.ERROR;\n\n      }\n      meta['errorDetails'] = err.toString();\n      meta['errorDetails'] += ` file=${meta['dstFileName']}`;\n    }\n\n    return meta;\n  }\n\n  /**\n  * Determine whether to acceleration configuration for S3 clients.\n  *\n  * @returns {null}\n  */\n  async function transferAccelerateConfig() {\n    if (stageLocationType === S3_FS) {\n      const client = remoteStorageUtil.createClient(stageInfo, false);\n      const s3location = SnowflakeS3Util.extractBucketNameAndPath(stageInfo['location']);\n\n      await client.getBucketAccelerateConfiguration({ Bucket: s3location.bucketName })\n        .then(function (data) {\n          useAccelerateEndpoint = data['Status'] === 'Enabled';\n        }).catch(function (err) {\n          if (err['code'] === 'AccessDenied') {\n            return;\n          }\n        });\n    }\n  }\n\n  /**\n  * Update presigned URLs of file metadata when using GCS client.\n  *\n  * @returns {null}\n  */\n  async function updateFileMetasWithPresignedUrl() {\n    const storageClient = getStorageClient(stageLocationType);\n\n    // presigned url only applies to remote storage\n    if (storageClient === remoteStorageUtil) {\n      // presigned url only applies to GCS\n      if (stageLocationType === GCS_FS) {\n        if (commandType === CMD_TYPE_UPLOAD) {\n          const filePathToReplace = getFileNameFromPutCommand(command);\n\n          for (const meta of fileMetadata) {\n            const fileNameToReplaceWith = meta['dstFileName'];\n            let commandWithSingleFile = command;\n            commandWithSingleFile = commandWithSingleFile.replace(filePathToReplace, fileNameToReplaceWith);\n\n            const options = { sqlText: commandWithSingleFile };\n            const newContext = statement.createContext(options, context.services, context.connectionConfig);\n\n            const ret = await statement.sendRequest(newContext);\n            meta['stageInfo'] = ret['data']['data']['stageInfo'];\n            meta['presignedUrl'] = meta['stageInfo']['presignedUrl'];\n          }\n        } else if (commandType === CMD_TYPE_DOWNLOAD) {\n          for (let index = 0; index < fileMetadata.length; index++) {\n            fileMetadata[index]['presignedUrl'] = presignedUrls[index];\n          }\n        }\n      }\n    }\n  }\n\n  /**\n  * Returns the local file path.\n  *\n  * @param {String} command\n  *\n  * @returns {String}\n  */\n  function getFileNameFromPutCommand(command) {\n    // Extract file path from PUT command:\n    // E.g. \"PUT file://C:<path-to-file> @DB.SCHEMA.%TABLE;\"\n    const startIndex = command.indexOf(FILE_PROTOCOL) + FILE_PROTOCOL.length;\n    const spaceIndex = command.substring(startIndex).indexOf(' ');\n    const quoteIndex = command.substring(startIndex).indexOf('\\'');\n    let endIndex = spaceIndex;\n    if (quoteIndex !== -1 && quoteIndex < spaceIndex) {\n      endIndex = quoteIndex; \n    }\n    const filePath = command.substring(startIndex, startIndex + endIndex);\n    return filePath;\n  }\n\n  /**\n  * Get the storage client based on stage location type.\n  *\n  * @param {String} stageLocationType\n  *\n  * @returns {Object}\n  */\n  function getStorageClient(stageLocationType) {\n    if (stageLocationType === LOCAL_FS) {\n      return SnowflakeLocalUtil;\n    } else if (stageLocationType === S3_FS ||\n      stageLocationType === AZURE_FS ||\n      stageLocationType === GCS_FS) {\n      return remoteStorageUtil;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n  * Parse the command and get list of files to upload/download.\n  *\n  * @returns {null}\n  */\n  function parseCommand() {\n    const data = response['data'];\n    commandType = data['command'];\n\n    if (commandType === CMD_TYPE_UPLOAD) {\n      const src = data['src_locations'][0];\n\n      // Get root directory of file path\n      let root = path.dirname(src);\n\n      // If cwd exists and root is relative . then replace with context's cwd\n      // Used for VS Code extension where extension cwd differs from user workspace dir      \n      if (cwd && !path.isAbsolute(src)) {\n        const absolutePath = path.resolve(cwd, src);\n        root = path.dirname(absolutePath);\n      }\n\n      let dir;\n\n      // Check root directory exists\n      if (fs.existsSync(root)) {\n        // Check the root path is a directory\n        dir = fs.statSync(root);\n\n        if (dir.isDirectory()) {\n          // Get file name to upload\n          fileName = path.basename(src);\n\n          // Full path name of the file\n          const fileNameFullPath = path.join(root, fileName);\n\n          // If file name has a wildcard\n          if (fileName.includes('*')) {\n            // Get all file names that matches the wildcard\n            const matchingFileNames = getMatchingFilePaths(root, fileName);\n\n            for (const matchingFileName of matchingFileNames) {\n              initEncryptionMaterial();\n\n              const fileInfo = fs.statSync(matchingFileName);\n              const currFileObj = {};\n              currFileObj['srcFileName'] = path.basename(matchingFileName);\n              currFileObj['srcFilePath'] = matchingFileName;\n              currFileObj['srcFileSize'] = fileInfo.size;\n\n              filesToPut.push(currFileObj);\n            }\n          } else {\n            // No wildcard, get single file\n            if (fs.existsSync(root)) {\n              initEncryptionMaterial();\n\n              const fileInfo = fs.statSync(fileNameFullPath);\n\n              const currFileObj = {};\n              currFileObj['srcFileName'] = fileName;\n              currFileObj['srcFilePath'] = fileNameFullPath;\n              currFileObj['srcFileSize'] = fileInfo.size;\n\n              filesToPut.push(currFileObj);\n            }\n          }\n        }\n      } else {\n        throw new Error(dir + ' is not a directory');\n      }\n\n      autoCompress = data['autoCompress'];\n      sourceCompression = data['sourceCompression'];\n    } else if (commandType === CMD_TYPE_DOWNLOAD) {\n      initEncryptionMaterial();\n      srcFiles = data['src_locations'];\n\n      if (srcFiles.length === encryptionMaterial.length) {\n        for (const idx in srcFiles) {\n          srcFilesToEncryptionMaterial[srcFiles[idx]] = encryptionMaterial[idx];\n        }\n      } else if (encryptionMaterial.length !== 0) {\n        // some encryption material exists. Zero means no encryption\n        throw new Error('The number of downloading files doesn\\'t match');\n      }\n      localLocation = expandTilde(data['localLocation']);\n\n      // If cwd exists and root is relative . then replace with context's cwd\n      // Used for VS Code extension where extension cwd differs from user workspace dir     \n      if (cwd && !path.isAbsolute(localLocation)) {\n        const absolutePath = path.resolve(cwd, localLocation);\n        localLocation = absolutePath;\n      }\n\n      const dir = fs.statSync(localLocation);\n      if (!dir.isDirectory()) {\n        throw new Error('The local path is not a directory: ' + localLocation);\n      }\n    }\n\n    parallel = data['parallel'];\n    stageInfo = data['stageInfo'];\n    stageLocationType = stageInfo['locationType'];\n    presignedUrls = data['presignedUrls'];\n    overwrite = data['overwrite'];\n  }\n\n  /**\n  * Generate encryption material for each metadata.\n  *\n  * @returns {null}\n  */\n  function initEncryptionMaterial() {\n    if (response['data'] && response['data']['encryptionMaterial']) {\n      const rootNode = response['data']['encryptionMaterial'];\n\n      if (commandType === CMD_TYPE_UPLOAD) {\n        encryptionMaterial.push(new SnowflakeFileEncryptionMaterial(\n          rootNode['queryStageMasterKey'],\n          rootNode['queryId'],\n          rootNode['smkId']));\n      } else if (commandType === CMD_TYPE_DOWNLOAD) {\n        for (const elem in rootNode) {\n          encryptionMaterial.push(new SnowflakeFileEncryptionMaterial(\n            rootNode[elem]['queryStageMasterKey'],\n            rootNode[elem]['queryId'],\n            rootNode[elem]['smkId']));\n        }\n      }\n    }\n  }\n\n  /**\n  * Generate metadata for files to upload/download.\n  *\n  * @returns {null}\n  */\n  function initFileMetadata() {\n    if (commandType === CMD_TYPE_UPLOAD) {\n      for (const file of filesToPut) {\n        const currFileObj = {};\n        currFileObj['srcFilePath'] = file['srcFilePath'];\n        currFileObj['srcFileName'] = file['srcFileName'];\n        currFileObj['srcFileSize'] = file['srcFileSize'];\n        currFileObj['stageLocationType'] = stageLocationType;\n        currFileObj['stageInfo'] = stageInfo;\n        currFileObj['overwrite'] = overwrite;\n\n        fileMetadata.push(currFileObj);\n      }\n    } else if (commandType === CMD_TYPE_DOWNLOAD) {\n      for (const fileName of srcFiles) {\n        const currFileObj = {};\n        currFileObj['srcFileName'] = fileName;\n        currFileObj['dstFileName'] = fileName;\n        currFileObj['stageLocationType'] = stageLocationType;\n        currFileObj['stageInfo'] = stageInfo;\n        currFileObj['useAccelerateEndpoint'] = useAccelerateEndpoint;\n        currFileObj['localLocation'] = localLocation;\n        currFileObj['encryptionMaterial'] = srcFilesToEncryptionMaterial[fileName];\n\n        fileMetadata.push(currFileObj);\n      }\n    }\n\n    if (encryptionMaterial.length > 0) {\n      let i = 0;\n      for (const file of fileMetadata) {\n        file['encryptionMaterial'] = encryptionMaterial[i];\n        i++;\n      }\n    }\n  }\n\n  /**\n  * Get the compression type of the file.\n  *\n  * @returns {null}\n  */\n  function processFileCompressionType() {\n    let userSpecifiedSourceCompression;\n    let autoDetect;\n    if (sourceCompression === 'auto_detect') {\n      autoDetect = true;\n\n    } else if (sourceCompression === typeof('undefined')) {\n      autoDetect = false;\n    } else {\n      userSpecifiedSourceCompression = fileCompressionType.lookupByMimeSubType(sourceCompression);\n      if (userSpecifiedSourceCompression === typeof ('undefined') || !userSpecifiedSourceCompression['is_supported']) {\n        throw new Error(sourceCompression + ' is not a supported compression type');\n      }\n      autoDetect = false;\n    }\n\n    for (const meta of fileMetadata) {\n      const fileName = meta['srcFileName'];\n      const filePath = meta['srcFilePath'];\n\n      let currentFileCompressionType;\n      let encoding;\n\n      if (autoDetect) {\n        encoding = mime.lookup(fileName);\n\n        if (!encoding) {\n          const test = Buffer.alloc(4);\n          const fd = fs.openSync(filePath, 'r+');\n          fs.readSync(fd, test, 0, 4, 0);\n          fs.closeSync(fd);\n\n          if (fileName.substring(fileName.lastIndexOf('.')) === '.br') {\n            encoding = 'br';\n          } else if (fileName.substring(fileName.lastIndexOf('.')) === '.deflate') {\n            encoding = 'deflate';\n          } else if (fileName.substring(fileName.lastIndexOf('.')) === '.raw_deflate') {\n            encoding = 'raw_deflate';\n          } else if (Buffer.from(test.toString()).slice(0, 3) === Buffer.from('ORC')) {\n            encoding = 'orc';\n          } else if (Buffer.from(test.toString()) === Buffer.from('PAR1')) {\n            encoding = 'parquet';\n          } else if (binascii.hexlify(test.toString()) === '28fd2ffd' ||\n            fileName.substring(fileName.lastIndexOf('.')) === '.zst') {\n            encoding = 'zstd';\n          }\n        }\n\n        if (encoding) {\n          currentFileCompressionType = fileCompressionType.lookupByEncoding(encoding);\n        }\n        // else {} No file encoding detected\n\n        if (currentFileCompressionType && !currentFileCompressionType['is_supported']) {\n          throw new Error(encoding + ' is not a a supported compression type');\n        }\n      } else {\n        currentFileCompressionType = userSpecifiedSourceCompression;\n      }\n\n      if (currentFileCompressionType) {\n        if (currentFileCompressionType['is_supported']) {\n          meta['dstCompressionType'] = currentFileCompressionType;\n          meta['requireCompress'] = false;\n          meta['dstFileName'] = meta['srcFileName'];\n        } else {\n          throw new Error(encoding + ' is not a a supported compression type');\n        }\n      } else {\n        meta['requireCompress'] = autoCompress;\n        meta['srcCompressionType'] = null;\n\n        // If requireCompress is true, destination file extension is changed to zip\n        if (autoCompress) {\n          // Compress with gzip\n          meta['dstCompressionType'] = fileCompressionType.lookupByMimeSubType('GZIP');\n          meta['dstFileName'] = meta['srcFileName'] + meta['dstCompressionType']['file_extension'];\n        } else {\n          meta['dstFileName'] = meta['srcFileName'];\n          meta['dstCompressionType'] = null;\n        }\n      }\n    }\n  }\n}\n\n//TODO SNOW-992387: Create a function to renew expired client\nfunction renewExpiredClient() {}\n\nmodule.exports = FileTransferAgent;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9maWxlX3RyYW5zZmVyX2FnZW50LmpzIiwibWFwcGluZ3MiOiJBQUFBLGlCQUFpQixtQkFBTyxDQUFDLHdEQUFVO0FBQ25DLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsNERBQVk7QUFDakMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQixrQkFBa0IsbUJBQU8sQ0FBQywrRkFBeUI7QUFDbkQsNEJBQTRCLG1CQUFPLENBQUMsb0hBQXlCO0FBQzdELG9CQUFvQixtQkFBTyxDQUFDLGdFQUFjO0FBQzFDLG1DQUFtQyx5SkFBa0Q7QUFDckYsa0JBQWtCLCtIQUFpQztBQUNuRCx3Q0FBd0MsdUtBQWdFO0FBQ3hHLHdCQUF3QixtQkFBTyxDQUFDLHdGQUFXO0FBQzNDLFFBQVEsaUNBQWlDLEVBQUUsbUJBQU8sQ0FBQyx5RUFBYztBQUNqRSxxQkFBcUIsNkdBQW9DOztBQUV6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsOEJBQThCO0FBQzlFO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLG9CQUFvQjtBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxzQkFBc0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUMsb0JBQW9CLGNBQWMsd0JBQXdCO0FBQ2pHLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLHNCQUFzQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0I7QUFDM0Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzREFBc0QsK0JBQStCO0FBQ3JGO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLDhCQUE4Qiw2QkFBNkI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjs7QUFFbkI7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2ZpbGVfdHJhbnNmZXJfYWdlbnQvZmlsZV90cmFuc2Zlcl9hZ2VudC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBiaW5hc2NpaSA9IHJlcXVpcmUoJ2JpbmFzY2lpJyk7XG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IG9zID0gcmVxdWlyZSgnb3MnKTtcbmNvbnN0IG1pbWUgPSByZXF1aXJlKCdtaW1lLXR5cGVzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuXG5jb25zdCBzdGF0ZW1lbnQgPSByZXF1aXJlKCcuLi9jb25uZWN0aW9uL3N0YXRlbWVudCcpO1xuY29uc3QgZmlsZUNvbXByZXNzaW9uVHlwZSA9IHJlcXVpcmUoJy4vZmlsZV9jb21wcmVzc2lvbl90eXBlJyk7XG5jb25zdCBleHBhbmRUaWxkZSA9IHJlcXVpcmUoJ2V4cGFuZC10aWxkZScpO1xuY29uc3QgU25vd2ZsYWtlUmVtb3RlU3RvcmFnZVV0aWwgPSByZXF1aXJlKCcuL3JlbW90ZV9zdG9yYWdlX3V0aWwnKS5SZW1vdGVTdG9yYWdlVXRpbDtcbmNvbnN0IExvY2FsVXRpbCA9IHJlcXVpcmUoJy4vbG9jYWxfdXRpbCcpLkxvY2FsVXRpbDtcbmNvbnN0IFNub3dmbGFrZUZpbGVFbmNyeXB0aW9uTWF0ZXJpYWwgPSByZXF1aXJlKCcuL3JlbW90ZV9zdG9yYWdlX3V0aWwnKS5Tbm93Zmxha2VGaWxlRW5jcnlwdGlvbk1hdGVyaWFsO1xuY29uc3QgU25vd2ZsYWtlUzNVdGlsID0gcmVxdWlyZSgnLi9zM191dGlsJyk7XG5jb25zdCB7IEZpbGVVdGlsLCBnZXRNYXRjaGluZ0ZpbGVQYXRocyB9ID0gcmVxdWlyZSgnLi4vZmlsZV91dGlsJyk7XG5jb25zdCByZXN1bHRTdGF0dXMgPSByZXF1aXJlKCcuLi9maWxlX3V0aWwnKS5yZXN1bHRTdGF0dXM7XG5cbmNvbnN0IFNub3dmbGFrZUZpbGVVdGlsID0gbmV3IEZpbGVVdGlsKCk7XG5jb25zdCBTbm93Zmxha2VMb2NhbFV0aWwgPSBuZXcgTG9jYWxVdGlsKCk7XG5jb25zdCBTM19GUyA9ICdTMyc7XG5jb25zdCBBWlVSRV9GUyA9ICdBWlVSRSc7XG5jb25zdCBHQ1NfRlMgPSAnR0NTJztcbmNvbnN0IExPQ0FMX0ZTID0gJ0xPQ0FMX0ZTJztcbmNvbnN0IENNRF9UWVBFX1VQTE9BRCA9ICdVUExPQUQnO1xuY29uc3QgQ01EX1RZUEVfRE9XTkxPQUQgPSAnRE9XTkxPQUQnO1xuY29uc3QgRklMRV9QUk9UT0NPTCA9ICdmaWxlOi8vJztcblxuY29uc3QgSU5KRUNUX1dBSVRfSU5fUFVUID0gMDtcblxuXG5jb25zdCBSRVNVTFRfVEVYVF9DT0xVTU5fREVTQyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiB7XG4gICAgJ25hbWUnOiBuYW1lLFxuICAgICd0eXBlJzogJ3RleHQnLFxuICAgICdsZW5ndGgnOiAxNjc3NzIxNixcbiAgICAncHJlY2lzaW9uJzogbnVsbCxcbiAgICAnc2NhbGUnOiBudWxsLFxuICAgICdudWxsYWJsZSc6IGZhbHNlXG4gIH07XG59O1xuY29uc3QgUkVTVUxUX0ZJWEVEX0NPTFVNTl9ERVNDID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuIHtcbiAgICAnbmFtZSc6IG5hbWUsXG4gICAgJ3R5cGUnOiAnZml4ZWQnLFxuICAgICdsZW5ndGgnOiA1LFxuICAgICdwcmVjaXNpb24nOiAwLFxuICAgICdzY2FsZSc6IDAsXG4gICAgJ251bGxhYmxlJzogZmFsc2VcbiAgfTtcbn07XG4vKipcbiAqIENyZWF0ZXMgYSBmaWxlIHRyYW5zZmVyIGFnZW50LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb250ZXh0XG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGaWxlVHJhbnNmZXJBZ2VudChjb250ZXh0KSB7XG4gIGNvbnN0IHJlbW90ZVN0b3JhZ2VVdGlsID0gbmV3IFNub3dmbGFrZVJlbW90ZVN0b3JhZ2VVdGlsKGNvbnRleHQuY29ubmVjdGlvbkNvbmZpZyk7XG4gIGNvbnN0IHJlc3BvbnNlID0gY29udGV4dC5maWxlTWV0YWRhdGE7XG4gIGNvbnN0IGNvbW1hbmQgPSBjb250ZXh0LnNxbFRleHQ7XG4gIGNvbnN0IGN3ZCA9IGNvbnRleHQuY3dkO1xuXG4gIGxldCBjb21tYW5kVHlwZTtcbiAgY29uc3QgZW5jcnlwdGlvbk1hdGVyaWFsID0gW107XG4gIGxldCBmaWxlTmFtZTtcbiAgY29uc3QgZmlsZVN0cmVhbSA9IGNvbnRleHQuZmlsZVN0cmVhbSA/IGNvbnRleHQuZmlsZVN0cmVhbSA6IG51bGw7XG5cbiAgbGV0IGF1dG9Db21wcmVzcztcbiAgbGV0IHNvdXJjZUNvbXByZXNzaW9uO1xuICBsZXQgcGFyYWxsZWw7XG4gIGxldCBzdGFnZUluZm87XG4gIGxldCBzdGFnZUxvY2F0aW9uVHlwZTtcbiAgbGV0IHByZXNpZ25lZFVybHM7XG4gIGxldCBvdmVyd3JpdGU7XG5cbiAgbGV0IHVzZUFjY2VsZXJhdGVFbmRwb2ludCA9IGZhbHNlO1xuXG4gIGxldCBzcmNGaWxlcztcbiAgY29uc3Qgc3JjRmlsZXNUb0VuY3J5cHRpb25NYXRlcmlhbCA9IHt9O1xuICBsZXQgbG9jYWxMb2NhdGlvbjtcblxuICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgLy8gU3RvcmUgaW5mbyBvZiBmaWxlcyByZXRyaWV2ZWRcbiAgY29uc3QgZmlsZXNUb1B1dCA9IFtdO1xuXG4gIC8vIFN0b3JlIG1ldGFkYXRhIG9mIGZpbGVzIHJldHJpZXZlZFxuICBjb25zdCBmaWxlTWV0YWRhdGEgPSBbXTtcbiAgY29uc3Qgc21hbGxGaWxlTWV0YXMgPSBbXTtcbiAgY29uc3QgbGFyZ2VGaWxlTWV0YXMgPSBbXTtcblxuICAvKipcbiAgKiBFeGVjdXRlIFBVVCBvciBHRVQgY29tbWFuZC5cbiAgKlxuICAqIEByZXR1cm5zIHtudWxsfVxuICAqL1xuICB0aGlzLmV4ZWN1dGUgPSBhc3luYyBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGZpbGVTdHJlYW0pIHtcbiAgICAgIGNvbnN0IGRhdGEgPSByZXNwb25zZVsnZGF0YSddO1xuICAgICAgY29tbWFuZFR5cGUgPSBkYXRhWydjb21tYW5kJ107XG4gICAgICBhdXRvQ29tcHJlc3MgPSBkYXRhWydhdXRvQ29tcHJlc3MnXTtcbiAgICAgIHNvdXJjZUNvbXByZXNzaW9uID0gZGF0YVsnc291cmNlQ29tcHJlc3Npb24nXTtcbiAgICAgIHBhcmFsbGVsID0gZGF0YVsncGFyYWxsZWwnXTtcbiAgICAgIHN0YWdlSW5mbyA9IGRhdGFbJ3N0YWdlSW5mbyddO1xuICAgICAgc3RhZ2VMb2NhdGlvblR5cGUgPSBzdGFnZUluZm9bJ2xvY2F0aW9uVHlwZSddO1xuICAgICAgcHJlc2lnbmVkVXJscyA9IGRhdGFbJ3ByZXNpZ25lZFVybHMnXTtcbiAgICAgIG92ZXJ3cml0ZSA9IGRhdGFbJ292ZXJ3cml0ZSddO1xuXG4gICAgICBpZiAoY29tbWFuZFR5cGUgIT09IENNRF9UWVBFX1VQTE9BRCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luY29ycmVjdCBVcGxvYWRGaWxlU3RyZWFtIGNvbW1hbmQnKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY3VyckZpbGVPYmogPSB7fTtcbiAgICAgIGN1cnJGaWxlT2JqWydzcmNGaWxlTmFtZSddID0gZGF0YS5zcmNfbG9jYXRpb25zWzBdO1xuICAgICAgY3VyckZpbGVPYmpbJ3NyY0ZpbGVQYXRoJ10gPSAnJztcbiAgICAgIGN1cnJGaWxlT2JqWydzcmNGaWxlU2l6ZSddID0gZmlsZVN0cmVhbS5sZW5ndGg7XG4gICAgICBmaWxlc1RvUHV0LnB1c2goY3VyckZpbGVPYmopO1xuXG4gICAgICBpbml0RW5jcnlwdGlvbk1hdGVyaWFsKCk7XG4gICAgICBpbml0RmlsZU1ldGFkYXRhKCk7XG5cbiAgICAgIGF3YWl0IHRyYW5zZmVyQWNjZWxlcmF0ZUNvbmZpZygpO1xuICAgICAgYXdhaXQgdXBkYXRlRmlsZU1ldGFzV2l0aFByZXNpZ25lZFVybCgpO1xuXG4gICAgICBpZiAoZmlsZU1ldGFkYXRhLmxlbmd0aCAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VwbG9hZEZpbGVTdHJlYW0gb25seSBhbGxvdyAxIGZpbGUnKTtcbiAgICAgIH1cblxuICAgICAgLy91cGxvYWQgXG4gICAgICBjb25zdCBzdG9yYWdlQ2xpZW50ID0gZ2V0U3RvcmFnZUNsaWVudChzdGFnZUxvY2F0aW9uVHlwZSk7XG4gICAgICBjb25zdCBjbGllbnQgPSBzdG9yYWdlQ2xpZW50LmNyZWF0ZUNsaWVudChzdGFnZUluZm8sIGZhbHNlKTtcbiAgICAgIGNvbnN0IG1ldGEgPSBmaWxlTWV0YWRhdGFbMF07XG4gICAgICBtZXRhWydwYXJhbGxlbCddID0gcGFyYWxsZWw7XG4gICAgICBtZXRhWydjbGllbnQnXSA9IGNsaWVudDtcbiAgICAgIG1ldGFbJ2ZpbGVTdHJlYW0nXSA9IGZpbGVTdHJlYW07XG5cbiAgICAgIC8vZm9yIGRpZ2VzdFxuICAgICAgY29uc3QgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKVxuICAgICAgICAudXBkYXRlKGZpbGVTdHJlYW0pXG4gICAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuICAgICAgbWV0YVsnU0hBMjU2X0RJR0VTVCddID0gaGFzaDtcbiAgICAgIG1ldGFbJ3VwbG9hZFNpemUnXSA9IGZpbGVTdHJlYW0ubGVuZ3RoO1xuICAgICAgbWV0YVsnZHN0Q29tcHJlc3Npb25UeXBlJ10gPSBmaWxlQ29tcHJlc3Npb25UeXBlLmxvb2t1cEJ5RW5jb2Rpbmcoc291cmNlQ29tcHJlc3Npb24pO1xuICAgICAgbWV0YVsncmVxdWlyZUNvbXByZXNzJ10gPSBmYWxzZTtcbiAgICAgIG1ldGFbJ2RzdEZpbGVOYW1lJ10gPSBtZXRhWydzcmNGaWxlTmFtZSddO1xuXG4gICAgICBhd2FpdCBzdG9yYWdlQ2xpZW50LnVwbG9hZE9uZUZpbGVTdHJlYW0obWV0YSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnNlQ29tbWFuZCgpO1xuICAgICAgaW5pdEZpbGVNZXRhZGF0YSgpO1xuXG4gICAgICBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX1VQTE9BRCkge1xuICAgICAgICBpZiAoZmlsZXNUb1B1dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGZpbGUgZm91bmQgZm9yOiAnICsgZmlsZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcHJvY2Vzc0ZpbGVDb21wcmVzc2lvblR5cGUoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9ET1dOTE9BRCkge1xuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMobG9jYWxMb2NhdGlvbikpIHtcbiAgICAgICAgICBmcy5ta2RpclN5bmMobG9jYWxMb2NhdGlvbik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHN0YWdlTG9jYXRpb25UeXBlID09PSBMT0NBTF9GUykge1xuICAgICAgICBwcm9jZXNzLnVtYXNrKDApO1xuICAgICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoc3RhZ2VJbmZvWydsb2NhdGlvbiddKSkge1xuICAgICAgICAgIGZzLm1rZGlyU3luYyhzdGFnZUluZm9bJ2xvY2F0aW9uJ10sIHsgbW9kZTogMG83NzcsIHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhd2FpdCB0cmFuc2ZlckFjY2VsZXJhdGVDb25maWcoKTtcbiAgICAgIGF3YWl0IHVwZGF0ZUZpbGVNZXRhc1dpdGhQcmVzaWduZWRVcmwoKTtcblxuICAgICAgZm9yIChjb25zdCBtZXRhIG9mIGZpbGVNZXRhZGF0YSkge1xuICAgICAgICBpZiAobWV0YVsnc3JjRmlsZVNpemUnXSA+IFNub3dmbGFrZVMzVXRpbC5EQVRBX1NJWkVfVEhSRVNIT0xEKSB7XG4gICAgICAgICAgLy8gQWRkIHRvIGxhcmdlIGZpbGUgbWV0YXNcbiAgICAgICAgICBtZXRhWydwYXJhbGxlbCddID0gcGFyYWxsZWw7XG4gICAgICAgICAgbGFyZ2VGaWxlTWV0YXMucHVzaChtZXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBBZGQgdG8gc21hbGwgZmlsZSBtZXRhcyBhbmQgc2V0IHBhcmFsbGVsIHRvIDFcbiAgICAgICAgICBtZXRhWydwYXJhbGxlbCddID0gMTtcbiAgICAgICAgICBzbWFsbEZpbGVNZXRhcy5wdXNoKG1ldGEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChjb21tYW5kVHlwZSA9PT0gQ01EX1RZUEVfVVBMT0FEKSB7XG4gICAgICAgIGF3YWl0IHVwbG9hZChsYXJnZUZpbGVNZXRhcywgc21hbGxGaWxlTWV0YXMpO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX0RPV05MT0FEKSB7XG4gICAgICAgIGF3YWl0IGRvd25sb2FkKGxhcmdlRmlsZU1ldGFzLCBzbWFsbEZpbGVNZXRhcyk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAqIEdlbmVyYXRlIHRoZSByb3dzZXQgYW5kIHJvd3NldCB0eXBlcyB1c2luZyB0aGUgZmlsZSBtZXRhZGF0YXMuXG4gICpcbiAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAqL1xuICB0aGlzLnJlc3VsdCA9IGZ1bmN0aW9uICgpIHtcbiAgICBjb25zdCByb3dzZXQgPSBbXTtcbiAgICBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX1VQTE9BRCkge1xuICAgICAgbGV0IHNyY0ZpbGVTaXplO1xuICAgICAgbGV0IGRzdEZpbGVTaXplO1xuICAgICAgbGV0IHNyY0NvbXByZXNzaW9uVHlwZTtcbiAgICAgIGxldCBkc3RDb21wcmVzc2lvblR5cGU7XG4gICAgICBsZXQgZXJyb3JEZXRhaWxzO1xuXG4gICAgICBpZiAocmVzdWx0cykge1xuICAgICAgICBmb3IgKGNvbnN0IG1ldGEgb2YgcmVzdWx0cykge1xuICAgICAgICAgIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gJ0VSUk9SJykge1xuICAgICAgICAgICAgZXJyb3JEZXRhaWxzID0gbWV0YVsnZXJyb3JEZXRhaWxzJ107XG4gICAgICAgICAgICBpZiAoIWVycm9yRGV0YWlscykge1xuICAgICAgICAgICAgICBlcnJvckRldGFpbHMgPSBgVW5rbm93biBlcnJvciBkdXJpbmcgUFVUIG9mIGZpbGU6ICR7bWV0YVsnc3JjRmlsZVBhdGgnXX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVycm9yRGV0YWlscyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXRhWydzcmNDb21wcmVzc2lvblR5cGUnXSkge1xuICAgICAgICAgICAgc3JjQ29tcHJlc3Npb25UeXBlID0gbWV0YVsnc3JjQ29tcHJlc3Npb25UeXBlJ11bJ25hbWUnXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgc3JjQ29tcHJlc3Npb25UeXBlID0gbnVsbDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobWV0YVsnZHN0Q29tcHJlc3Npb25UeXBlJ10pIHtcbiAgICAgICAgICAgIGRzdENvbXByZXNzaW9uVHlwZSA9IG1ldGFbJ2RzdENvbXByZXNzaW9uVHlwZSddWyduYW1lJ107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRzdENvbXByZXNzaW9uVHlwZSA9IG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3JEZXRhaWxzID0gbWV0YVsnZXJyb3JEZXRhaWxzJ107XG5cbiAgICAgICAgICBzcmNGaWxlU2l6ZSA9IG1ldGFbJ3NyY0ZpbGVTaXplJ10udG9TdHJpbmcoKTtcbiAgICAgICAgICBkc3RGaWxlU2l6ZSA9IG1ldGFbJ2RzdEZpbGVTaXplJ10udG9TdHJpbmcoKTtcblxuICAgICAgICAgIHJvd3NldC5wdXNoKFtcbiAgICAgICAgICAgIG1ldGFbJ3NyY0ZpbGVOYW1lJ10sXG4gICAgICAgICAgICBtZXRhWydkc3RGaWxlTmFtZSddLFxuICAgICAgICAgICAgc3JjRmlsZVNpemUsXG4gICAgICAgICAgICBkc3RGaWxlU2l6ZSxcbiAgICAgICAgICAgIHNyY0NvbXByZXNzaW9uVHlwZSxcbiAgICAgICAgICAgIGRzdENvbXByZXNzaW9uVHlwZSxcbiAgICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddLFxuICAgICAgICAgICAgZXJyb3JEZXRhaWxzXG4gICAgICAgICAgXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgICdyb3dzZXQnOiByb3dzZXQsXG4gICAgICAgICdyb3d0eXBlJzogW1xuICAgICAgICAgIFJFU1VMVF9URVhUX0NPTFVNTl9ERVNDKCdzb3VyY2UnKSxcbiAgICAgICAgICBSRVNVTFRfVEVYVF9DT0xVTU5fREVTQygndGFyZ2V0JyksXG4gICAgICAgICAgUkVTVUxUX0ZJWEVEX0NPTFVNTl9ERVNDKCdzb3VyY2VTaXplJyksXG4gICAgICAgICAgUkVTVUxUX0ZJWEVEX0NPTFVNTl9ERVNDKCd0YXJnZXRTaXplJyksXG4gICAgICAgICAgUkVTVUxUX1RFWFRfQ09MVU1OX0RFU0MoJ3NvdXJjZUNvbXByZXNzaW9uJyksXG4gICAgICAgICAgUkVTVUxUX1RFWFRfQ09MVU1OX0RFU0MoJ3RhcmdldENvbXByZXNzaW9uJyksXG4gICAgICAgICAgUkVTVUxUX1RFWFRfQ09MVU1OX0RFU0MoJ3N0YXR1cycpLFxuICAgICAgICAgIFJFU1VMVF9URVhUX0NPTFVNTl9ERVNDKCdtZXNzYWdlJyksXG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChjb21tYW5kVHlwZSA9PT0gQ01EX1RZUEVfRE9XTkxPQUQpIHtcbiAgICAgIGxldCBkc3RGaWxlU2l6ZTtcbiAgICAgIGxldCBlcnJvckRldGFpbHM7XG5cbiAgICAgIGlmIChyZXN1bHRzKSB7XG4gICAgICAgIGZvciAoY29uc3QgbWV0YSBvZiByZXN1bHRzKSB7XG4gICAgICAgICAgZXJyb3JEZXRhaWxzID0gbWV0YVsnZXJyb3JEZXRhaWxzJ107XG4gICAgICAgICAgZHN0RmlsZVNpemUgPSBtZXRhWydkc3RGaWxlU2l6ZSddO1xuXG4gICAgICAgICAgcm93c2V0LnB1c2goW1xuICAgICAgICAgICAgbWV0YVsnZHN0RmlsZU5hbWUnXSxcbiAgICAgICAgICAgIGRzdEZpbGVTaXplLFxuICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10sXG4gICAgICAgICAgICBlcnJvckRldGFpbHNcbiAgICAgICAgICBdKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4ge1xuICAgICAgICAncm93c2V0Jzogcm93c2V0LFxuICAgICAgICAncm93dHlwZSc6IFtcbiAgICAgICAgICBSRVNVTFRfVEVYVF9DT0xVTU5fREVTQygnZmlsZScpLFxuICAgICAgICAgIFJFU1VMVF9GSVhFRF9DT0xVTU5fREVTQygnc2l6ZScpLFxuICAgICAgICAgIFJFU1VMVF9URVhUX0NPTFVNTl9ERVNDKCdzdGF0dXMnKSxcbiAgICAgICAgICBSRVNVTFRfVEVYVF9DT0xVTU5fREVTQygnbWVzc2FnZScpXG4gICAgICAgIF1cbiAgICAgIH07XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAqIFVwbG9hZCBmaWxlcyBpbiB0aGUgbWV0YWRhdGEgbGlzdC5cbiAgKlxuICAqIEByZXR1cm5zIHtudWxsfVxuICAqL1xuICBhc3luYyBmdW5jdGlvbiB1cGxvYWQobGFyZ2VGaWxlTWV0YXMsIHNtYWxsRmlsZU1ldGFzKSB7XG4gICAgY29uc3Qgc3RvcmFnZUNsaWVudCA9IGdldFN0b3JhZ2VDbGllbnQoc3RhZ2VMb2NhdGlvblR5cGUpO1xuICAgIGNvbnN0IGNsaWVudCA9IHN0b3JhZ2VDbGllbnQuY3JlYXRlQ2xpZW50KHN0YWdlSW5mbywgZmFsc2UpO1xuXG4gICAgZm9yIChjb25zdCBtZXRhIG9mIHNtYWxsRmlsZU1ldGFzKSB7XG4gICAgICBtZXRhWydjbGllbnQnXSA9IGNsaWVudDtcbiAgICB9XG4gICAgZm9yIChjb25zdCBtZXRhIG9mIGxhcmdlRmlsZU1ldGFzKSB7XG4gICAgICBtZXRhWydjbGllbnQnXSA9IGNsaWVudDtcbiAgICB9XG5cbiAgICBpZiAoc21hbGxGaWxlTWV0YXMubGVuZ3RoID4gMCkge1xuICAgICAgLy9hd2FpdCB1cGxvYWRGaWxlc2luUGFyYWxsZWwoc21hbGxGaWxlTWV0YXMpO1xuICAgICAgYXdhaXQgdXBsb2FkRmlsZXNpblNlcXVlbnRpYWwoc21hbGxGaWxlTWV0YXMpO1xuICAgIH1cbiAgICBpZiAobGFyZ2VGaWxlTWV0YXMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgdXBsb2FkRmlsZXNpblNlcXVlbnRpYWwobGFyZ2VGaWxlTWV0YXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIFVwbG9hZCBhIGZpbGUgc2VxdWVudGlhbGx5LlxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IGZpbGVNZXRhXG4gICpcbiAgKiBAcmV0dXJucyB7bnVsbH1cbiAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gdXBsb2FkRmlsZXNpblNlcXVlbnRpYWwoZmlsZU1ldGEpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IGZpbGVNZXRhTGVuID0gZmlsZU1ldGEubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgZmlsZU1ldGFMZW4pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHVwbG9hZE9uZUZpbGUoZmlsZU1ldGFbaW5kZXhdKTtcbiAgICAgIGlmIChyZXN1bHRbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU4pIHtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gcmVuZXdFeHBpcmVkQ2xpZW50KCk7XG4gICAgICAgIGZvciAobGV0IGluZGV4MiA9IGluZGV4OyBpbmRleDIgPCBmaWxlTWV0YUxlbjsgaW5kZXgyKyspIHtcbiAgICAgICAgICBmaWxlTWV0YVtpbmRleDJdWydjbGllbnQnXSA9IGNsaWVudDtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gZWxzZSBpZiAocmVzdWx0WydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlJFTkVXX1BSRVNJR05FRF9VUkwpIHtcbiAgICAgICAgYXdhaXQgdXBkYXRlRmlsZU1ldGFzV2l0aFByZXNpZ25lZFVybCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdHMucHVzaChyZXN1bHQpO1xuICAgICAgaWYgKHJlc3VsdFsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5FUlJPUikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGluZGV4ICs9IDE7XG4gICAgICBpZiAoSU5KRUNUX1dBSVRfSU5fUFVUID4gMCkge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgSU5KRUNUX1dBSVRfSU5fUFVUKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICogR2VuZXJhdGUgYSB0ZW1wb3JhcnkgZGlyZWN0b3J5IGZvciB0aGUgZmlsZSB0aGVuIHVwbG9hZC5cbiAgKlxuICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICpcbiAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAqL1xuICBhc3luYyBmdW5jdGlvbiB1cGxvYWRPbmVGaWxlKG1ldGEpIHtcbiAgICBtZXRhWydyZWFsU3JjRmlsZVBhdGgnXSA9IG1ldGFbJ3NyY0ZpbGVQYXRoJ107XG4gICAgY29uc3QgdG1wRGlyID0gZnMubWtkdGVtcFN5bmMocGF0aC5qb2luKG9zLnRtcGRpcigpLCAndG1wJykpO1xuICAgIG1ldGFbJ3RtcERpciddID0gdG1wRGlyO1xuICAgIHRyeSB7XG4gICAgICBpZiAobWV0YVsncmVxdWlyZUNvbXByZXNzJ10pIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgU25vd2ZsYWtlRmlsZVV0aWwuY29tcHJlc3NGaWxlV2l0aEdaSVAobWV0YVsnc3JjRmlsZVBhdGgnXSwgbWV0YVsndG1wRGlyJ10pO1xuICAgICAgICBtZXRhWydyZWFsU3JjRmlsZVBhdGgnXSA9IHJlc3VsdC5uYW1lO1xuICAgICAgfVxuICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgU25vd2ZsYWtlRmlsZVV0aWwuZ2V0RGlnZXN0QW5kU2l6ZUZvckZpbGUobWV0YVsncmVhbFNyY0ZpbGVQYXRoJ10pO1xuICAgICAgY29uc3Qgc2hhMjU2RGlnZXN0ID0gcmVzdWx0LmRpZ2VzdDtcbiAgICAgIGNvbnN0IHVwbG9hZFNpemUgPSByZXN1bHQuc2l6ZTtcblxuICAgICAgbWV0YVsnU0hBMjU2X0RJR0VTVCddID0gc2hhMjU2RGlnZXN0O1xuICAgICAgbWV0YVsndXBsb2FkU2l6ZSddID0gdXBsb2FkU2l6ZTtcblxuICAgICAgY29uc3Qgc3RvcmFnZUNsaWVudCA9IGdldFN0b3JhZ2VDbGllbnQobWV0YVsnc3RhZ2VMb2NhdGlvblR5cGUnXSk7XG4gICAgICBhd2FpdCBzdG9yYWdlQ2xpZW50LnVwbG9hZE9uZUZpbGVXaXRoUmV0cnkobWV0YSk7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBtZXRhWydkc3RGaWxlU2l6ZSddID0gMDtcbiAgICAgIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSkge1xuICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5FUlJPUjtcblxuICAgICAgfVxuICAgICAgbWV0YVsnZXJyb3JEZXRhaWxzJ10gPSBlcnIudG9TdHJpbmcoKTtcbiAgICAgIG1ldGFbJ2Vycm9yRGV0YWlscyddICs9IGAgZmlsZT0ke21ldGFbJ3NyY0ZpbGVOYW1lJ119LCByZWFsIGZpbGU9JHttZXRhWydyZWFsU3JjRmlsZVBhdGgnXX1gO1xuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBSZW1vdmUgYWxsIGZpbGVzIGluc2lkZSB0bXAgZm9sZGVyXG4gICAgICBjb25zdCBtYXRjaGluZ0ZpbGVOYW1lcyA9IGdldE1hdGNoaW5nRmlsZVBhdGhzKG1ldGFbJ3RtcERpciddLCBtZXRhWydzcmNGaWxlTmFtZSddICsgJyonKTtcbiAgICAgIGZvciAoY29uc3QgbWF0Y2hpbmdGaWxlTmFtZSBvZiBtYXRjaGluZ0ZpbGVOYW1lcykge1xuICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgZnMudW5saW5rKG1hdGNoaW5nRmlsZU5hbWUsIGVyciA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIC8vIERlbGV0ZSB0bXAgZm9sZGVyXG4gICAgICBmcy5ybWRpcihtZXRhWyd0bXBEaXInXSwgKGVycikgPT4ge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgdGhyb3cgKGVycik7XG4gICAgICAgIH1cblxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGE7XG4gIH1cblxuICAvKipcbiAgKiBEb3dubG9hZCBmaWxlcyBpbiB0aGUgbWV0YWRhdGEgbGlzdC5cbiAgKlxuICAqIEByZXR1cm5zIHtudWxsfVxuICAqL1xuICBhc3luYyBmdW5jdGlvbiBkb3dubG9hZChsYXJnZUZpbGVNZXRhcywgc21hbGxGaWxlTWV0YXMpIHtcbiAgICBjb25zdCBzdG9yYWdlQ2xpZW50ID0gZ2V0U3RvcmFnZUNsaWVudChzdGFnZUxvY2F0aW9uVHlwZSk7XG4gICAgY29uc3QgY2xpZW50ID0gc3RvcmFnZUNsaWVudC5jcmVhdGVDbGllbnQoc3RhZ2VJbmZvLCBmYWxzZSk7XG5cbiAgICBmb3IgKGNvbnN0IG1ldGEgb2Ygc21hbGxGaWxlTWV0YXMpIHtcbiAgICAgIG1ldGFbJ2NsaWVudCddID0gY2xpZW50O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG1ldGEgb2YgbGFyZ2VGaWxlTWV0YXMpIHtcbiAgICAgIG1ldGFbJ2NsaWVudCddID0gY2xpZW50O1xuICAgIH1cblxuICAgIGlmIChzbWFsbEZpbGVNZXRhcy5sZW5ndGggPiAwKSB7XG4gICAgICAvL2F3YWl0IGRvd25sb2FkRmlsZXNpblBhcmFsbGVsKHNtYWxsRmlsZU1ldGFzKTtcbiAgICAgIGF3YWl0IGRvd25sb2FkRmlsZXNpblNlcXVlbnRpYWwoc21hbGxGaWxlTWV0YXMpO1xuICAgIH1cbiAgICBpZiAobGFyZ2VGaWxlTWV0YXMubGVuZ3RoID4gMCkge1xuICAgICAgYXdhaXQgZG93bmxvYWRGaWxlc2luU2VxdWVudGlhbChsYXJnZUZpbGVNZXRhcyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICogRG93bmxvYWQgYSBmaWxlIHNlcXVlbnRpYWxseS5cbiAgKlxuICAqIEBwYXJhbSB7T2JqZWN0fSBmaWxlTWV0YVxuICAqXG4gICogQHJldHVybnMge251bGx9XG4gICovXG4gIGFzeW5jIGZ1bmN0aW9uIGRvd25sb2FkRmlsZXNpblNlcXVlbnRpYWwoZmlsZU1ldGEpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IGZpbGVNZXRhTGVuID0gZmlsZU1ldGEubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4IDwgZmlsZU1ldGFMZW4pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGRvd25sb2FkT25lRmlsZShmaWxlTWV0YVtpbmRleF0pO1xuICAgICAgaWYgKHJlc3VsdFsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5SRU5FV19UT0tFTikge1xuICAgICAgICBjb25zdCBjbGllbnQgPSByZW5ld0V4cGlyZWRDbGllbnQoKTtcbiAgICAgICAgZm9yIChsZXQgaW5kZXgyID0gaW5kZXg7IGluZGV4MiA8IGZpbGVNZXRhTGVuOyBpbmRleDIrKykge1xuICAgICAgICAgIGZpbGVNZXRhW2luZGV4Ml1bJ2NsaWVudCddID0gY2xpZW50O1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHRbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuUkVORVdfUFJFU0lHTkVEX1VSTCkge1xuICAgICAgICBhd2FpdCB1cGRhdGVGaWxlTWV0YXNXaXRoUHJlc2lnbmVkVXJsKCk7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICBpbmRleCArPSAxO1xuICAgICAgaWYgKElOSkVDVF9XQUlUX0lOX1BVVCA+IDApIHtcbiAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIElOSkVDVF9XQUlUX0lOX1BVVCkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIERvd25sb2FkIGEgZmlsZSBhbmQgcGxhY2UgaW50byB0aGUgdGFyZ2V0IGRpcmVjdG9yeS5cbiAgKlxuICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICpcbiAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAqL1xuICBhc3luYyBmdW5jdGlvbiBkb3dubG9hZE9uZUZpbGUobWV0YSkge1xuICAgIG1ldGFbJ3RtcERpciddID0gYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZnMubWtkdGVtcChwYXRoLmpvaW4ob3MudG1wZGlyKCksICd0bXAnKSwgKGVyciwgZGlyKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKGRpcik7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0cnkge1xuICAgICAgY29uc3Qgc3RvcmFnZUNsaWVudCA9IGdldFN0b3JhZ2VDbGllbnQobWV0YVsnc3RhZ2VMb2NhdGlvblR5cGUnXSk7XG4gICAgICBhd2FpdCBzdG9yYWdlQ2xpZW50LmRvd25sb2FkT25lRmlsZShtZXRhKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIG1ldGFbJ2RzdEZpbGVTaXplJ10gPSAtMTtcbiAgICAgIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSkge1xuICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5FUlJPUjtcblxuICAgICAgfVxuICAgICAgbWV0YVsnZXJyb3JEZXRhaWxzJ10gPSBlcnIudG9TdHJpbmcoKTtcbiAgICAgIG1ldGFbJ2Vycm9yRGV0YWlscyddICs9IGAgZmlsZT0ke21ldGFbJ2RzdEZpbGVOYW1lJ119YDtcbiAgICB9XG5cbiAgICByZXR1cm4gbWV0YTtcbiAgfVxuXG4gIC8qKlxuICAqIERldGVybWluZSB3aGV0aGVyIHRvIGFjY2VsZXJhdGlvbiBjb25maWd1cmF0aW9uIGZvciBTMyBjbGllbnRzLlxuICAqXG4gICogQHJldHVybnMge251bGx9XG4gICovXG4gIGFzeW5jIGZ1bmN0aW9uIHRyYW5zZmVyQWNjZWxlcmF0ZUNvbmZpZygpIHtcbiAgICBpZiAoc3RhZ2VMb2NhdGlvblR5cGUgPT09IFMzX0ZTKSB7XG4gICAgICBjb25zdCBjbGllbnQgPSByZW1vdGVTdG9yYWdlVXRpbC5jcmVhdGVDbGllbnQoc3RhZ2VJbmZvLCBmYWxzZSk7XG4gICAgICBjb25zdCBzM2xvY2F0aW9uID0gU25vd2ZsYWtlUzNVdGlsLmV4dHJhY3RCdWNrZXROYW1lQW5kUGF0aChzdGFnZUluZm9bJ2xvY2F0aW9uJ10pO1xuXG4gICAgICBhd2FpdCBjbGllbnQuZ2V0QnVja2V0QWNjZWxlcmF0ZUNvbmZpZ3VyYXRpb24oeyBCdWNrZXQ6IHMzbG9jYXRpb24uYnVja2V0TmFtZSB9KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHVzZUFjY2VsZXJhdGVFbmRwb2ludCA9IGRhdGFbJ1N0YXR1cyddID09PSAnRW5hYmxlZCc7XG4gICAgICAgIH0pLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICBpZiAoZXJyWydjb2RlJ10gPT09ICdBY2Nlc3NEZW5pZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgKiBVcGRhdGUgcHJlc2lnbmVkIFVSTHMgb2YgZmlsZSBtZXRhZGF0YSB3aGVuIHVzaW5nIEdDUyBjbGllbnQuXG4gICpcbiAgKiBAcmV0dXJucyB7bnVsbH1cbiAgKi9cbiAgYXN5bmMgZnVuY3Rpb24gdXBkYXRlRmlsZU1ldGFzV2l0aFByZXNpZ25lZFVybCgpIHtcbiAgICBjb25zdCBzdG9yYWdlQ2xpZW50ID0gZ2V0U3RvcmFnZUNsaWVudChzdGFnZUxvY2F0aW9uVHlwZSk7XG5cbiAgICAvLyBwcmVzaWduZWQgdXJsIG9ubHkgYXBwbGllcyB0byByZW1vdGUgc3RvcmFnZVxuICAgIGlmIChzdG9yYWdlQ2xpZW50ID09PSByZW1vdGVTdG9yYWdlVXRpbCkge1xuICAgICAgLy8gcHJlc2lnbmVkIHVybCBvbmx5IGFwcGxpZXMgdG8gR0NTXG4gICAgICBpZiAoc3RhZ2VMb2NhdGlvblR5cGUgPT09IEdDU19GUykge1xuICAgICAgICBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX1VQTE9BRCkge1xuICAgICAgICAgIGNvbnN0IGZpbGVQYXRoVG9SZXBsYWNlID0gZ2V0RmlsZU5hbWVGcm9tUHV0Q29tbWFuZChjb21tYW5kKTtcblxuICAgICAgICAgIGZvciAoY29uc3QgbWV0YSBvZiBmaWxlTWV0YWRhdGEpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVOYW1lVG9SZXBsYWNlV2l0aCA9IG1ldGFbJ2RzdEZpbGVOYW1lJ107XG4gICAgICAgICAgICBsZXQgY29tbWFuZFdpdGhTaW5nbGVGaWxlID0gY29tbWFuZDtcbiAgICAgICAgICAgIGNvbW1hbmRXaXRoU2luZ2xlRmlsZSA9IGNvbW1hbmRXaXRoU2luZ2xlRmlsZS5yZXBsYWNlKGZpbGVQYXRoVG9SZXBsYWNlLCBmaWxlTmFtZVRvUmVwbGFjZVdpdGgpO1xuXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0geyBzcWxUZXh0OiBjb21tYW5kV2l0aFNpbmdsZUZpbGUgfTtcbiAgICAgICAgICAgIGNvbnN0IG5ld0NvbnRleHQgPSBzdGF0ZW1lbnQuY3JlYXRlQ29udGV4dChvcHRpb25zLCBjb250ZXh0LnNlcnZpY2VzLCBjb250ZXh0LmNvbm5lY3Rpb25Db25maWcpO1xuXG4gICAgICAgICAgICBjb25zdCByZXQgPSBhd2FpdCBzdGF0ZW1lbnQuc2VuZFJlcXVlc3QobmV3Q29udGV4dCk7XG4gICAgICAgICAgICBtZXRhWydzdGFnZUluZm8nXSA9IHJldFsnZGF0YSddWydkYXRhJ11bJ3N0YWdlSW5mbyddO1xuICAgICAgICAgICAgbWV0YVsncHJlc2lnbmVkVXJsJ10gPSBtZXRhWydzdGFnZUluZm8nXVsncHJlc2lnbmVkVXJsJ107XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9ET1dOTE9BRCkge1xuICAgICAgICAgIGZvciAobGV0IGluZGV4ID0gMDsgaW5kZXggPCBmaWxlTWV0YWRhdGEubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgICAgICBmaWxlTWV0YWRhdGFbaW5kZXhdWydwcmVzaWduZWRVcmwnXSA9IHByZXNpZ25lZFVybHNbaW5kZXhdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIFJldHVybnMgdGhlIGxvY2FsIGZpbGUgcGF0aC5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBjb21tYW5kXG4gICpcbiAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAqL1xuICBmdW5jdGlvbiBnZXRGaWxlTmFtZUZyb21QdXRDb21tYW5kKGNvbW1hbmQpIHtcbiAgICAvLyBFeHRyYWN0IGZpbGUgcGF0aCBmcm9tIFBVVCBjb21tYW5kOlxuICAgIC8vIEUuZy4gXCJQVVQgZmlsZTovL0M6PHBhdGgtdG8tZmlsZT4gQERCLlNDSEVNQS4lVEFCTEU7XCJcbiAgICBjb25zdCBzdGFydEluZGV4ID0gY29tbWFuZC5pbmRleE9mKEZJTEVfUFJPVE9DT0wpICsgRklMRV9QUk9UT0NPTC5sZW5ndGg7XG4gICAgY29uc3Qgc3BhY2VJbmRleCA9IGNvbW1hbmQuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpLmluZGV4T2YoJyAnKTtcbiAgICBjb25zdCBxdW90ZUluZGV4ID0gY29tbWFuZC5zdWJzdHJpbmcoc3RhcnRJbmRleCkuaW5kZXhPZignXFwnJyk7XG4gICAgbGV0IGVuZEluZGV4ID0gc3BhY2VJbmRleDtcbiAgICBpZiAocXVvdGVJbmRleCAhPT0gLTEgJiYgcXVvdGVJbmRleCA8IHNwYWNlSW5kZXgpIHtcbiAgICAgIGVuZEluZGV4ID0gcXVvdGVJbmRleDsgXG4gICAgfVxuICAgIGNvbnN0IGZpbGVQYXRoID0gY29tbWFuZC5zdWJzdHJpbmcoc3RhcnRJbmRleCwgc3RhcnRJbmRleCArIGVuZEluZGV4KTtcbiAgICByZXR1cm4gZmlsZVBhdGg7XG4gIH1cblxuICAvKipcbiAgKiBHZXQgdGhlIHN0b3JhZ2UgY2xpZW50IGJhc2VkIG9uIHN0YWdlIGxvY2F0aW9uIHR5cGUuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gc3RhZ2VMb2NhdGlvblR5cGVcbiAgKlxuICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICovXG4gIGZ1bmN0aW9uIGdldFN0b3JhZ2VDbGllbnQoc3RhZ2VMb2NhdGlvblR5cGUpIHtcbiAgICBpZiAoc3RhZ2VMb2NhdGlvblR5cGUgPT09IExPQ0FMX0ZTKSB7XG4gICAgICByZXR1cm4gU25vd2ZsYWtlTG9jYWxVdGlsO1xuICAgIH0gZWxzZSBpZiAoc3RhZ2VMb2NhdGlvblR5cGUgPT09IFMzX0ZTIHx8XG4gICAgICBzdGFnZUxvY2F0aW9uVHlwZSA9PT0gQVpVUkVfRlMgfHxcbiAgICAgIHN0YWdlTG9jYXRpb25UeXBlID09PSBHQ1NfRlMpIHtcbiAgICAgIHJldHVybiByZW1vdGVTdG9yYWdlVXRpbDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICogUGFyc2UgdGhlIGNvbW1hbmQgYW5kIGdldCBsaXN0IG9mIGZpbGVzIHRvIHVwbG9hZC9kb3dubG9hZC5cbiAgKlxuICAqIEByZXR1cm5zIHtudWxsfVxuICAqL1xuICBmdW5jdGlvbiBwYXJzZUNvbW1hbmQoKSB7XG4gICAgY29uc3QgZGF0YSA9IHJlc3BvbnNlWydkYXRhJ107XG4gICAgY29tbWFuZFR5cGUgPSBkYXRhWydjb21tYW5kJ107XG5cbiAgICBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX1VQTE9BRCkge1xuICAgICAgY29uc3Qgc3JjID0gZGF0YVsnc3JjX2xvY2F0aW9ucyddWzBdO1xuXG4gICAgICAvLyBHZXQgcm9vdCBkaXJlY3Rvcnkgb2YgZmlsZSBwYXRoXG4gICAgICBsZXQgcm9vdCA9IHBhdGguZGlybmFtZShzcmMpO1xuXG4gICAgICAvLyBJZiBjd2QgZXhpc3RzIGFuZCByb290IGlzIHJlbGF0aXZlIC4gdGhlbiByZXBsYWNlIHdpdGggY29udGV4dCdzIGN3ZFxuICAgICAgLy8gVXNlZCBmb3IgVlMgQ29kZSBleHRlbnNpb24gd2hlcmUgZXh0ZW5zaW9uIGN3ZCBkaWZmZXJzIGZyb20gdXNlciB3b3Jrc3BhY2UgZGlyICAgICAgXG4gICAgICBpZiAoY3dkICYmICFwYXRoLmlzQWJzb2x1dGUoc3JjKSkge1xuICAgICAgICBjb25zdCBhYnNvbHV0ZVBhdGggPSBwYXRoLnJlc29sdmUoY3dkLCBzcmMpO1xuICAgICAgICByb290ID0gcGF0aC5kaXJuYW1lKGFic29sdXRlUGF0aCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBkaXI7XG5cbiAgICAgIC8vIENoZWNrIHJvb3QgZGlyZWN0b3J5IGV4aXN0c1xuICAgICAgaWYgKGZzLmV4aXN0c1N5bmMocm9vdCkpIHtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIHJvb3QgcGF0aCBpcyBhIGRpcmVjdG9yeVxuICAgICAgICBkaXIgPSBmcy5zdGF0U3luYyhyb290KTtcblxuICAgICAgICBpZiAoZGlyLmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgICAgICAvLyBHZXQgZmlsZSBuYW1lIHRvIHVwbG9hZFxuICAgICAgICAgIGZpbGVOYW1lID0gcGF0aC5iYXNlbmFtZShzcmMpO1xuXG4gICAgICAgICAgLy8gRnVsbCBwYXRoIG5hbWUgb2YgdGhlIGZpbGVcbiAgICAgICAgICBjb25zdCBmaWxlTmFtZUZ1bGxQYXRoID0gcGF0aC5qb2luKHJvb3QsIGZpbGVOYW1lKTtcblxuICAgICAgICAgIC8vIElmIGZpbGUgbmFtZSBoYXMgYSB3aWxkY2FyZFxuICAgICAgICAgIGlmIChmaWxlTmFtZS5pbmNsdWRlcygnKicpKSB7XG4gICAgICAgICAgICAvLyBHZXQgYWxsIGZpbGUgbmFtZXMgdGhhdCBtYXRjaGVzIHRoZSB3aWxkY2FyZFxuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmdGaWxlTmFtZXMgPSBnZXRNYXRjaGluZ0ZpbGVQYXRocyhyb290LCBmaWxlTmFtZSk7XG5cbiAgICAgICAgICAgIGZvciAoY29uc3QgbWF0Y2hpbmdGaWxlTmFtZSBvZiBtYXRjaGluZ0ZpbGVOYW1lcykge1xuICAgICAgICAgICAgICBpbml0RW5jcnlwdGlvbk1hdGVyaWFsKCk7XG5cbiAgICAgICAgICAgICAgY29uc3QgZmlsZUluZm8gPSBmcy5zdGF0U3luYyhtYXRjaGluZ0ZpbGVOYW1lKTtcbiAgICAgICAgICAgICAgY29uc3QgY3VyckZpbGVPYmogPSB7fTtcbiAgICAgICAgICAgICAgY3VyckZpbGVPYmpbJ3NyY0ZpbGVOYW1lJ10gPSBwYXRoLmJhc2VuYW1lKG1hdGNoaW5nRmlsZU5hbWUpO1xuICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnc3JjRmlsZVBhdGgnXSA9IG1hdGNoaW5nRmlsZU5hbWU7XG4gICAgICAgICAgICAgIGN1cnJGaWxlT2JqWydzcmNGaWxlU2l6ZSddID0gZmlsZUluZm8uc2l6ZTtcblxuICAgICAgICAgICAgICBmaWxlc1RvUHV0LnB1c2goY3VyckZpbGVPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBObyB3aWxkY2FyZCwgZ2V0IHNpbmdsZSBmaWxlXG4gICAgICAgICAgICBpZiAoZnMuZXhpc3RzU3luYyhyb290KSkge1xuICAgICAgICAgICAgICBpbml0RW5jcnlwdGlvbk1hdGVyaWFsKCk7XG5cbiAgICAgICAgICAgICAgY29uc3QgZmlsZUluZm8gPSBmcy5zdGF0U3luYyhmaWxlTmFtZUZ1bGxQYXRoKTtcblxuICAgICAgICAgICAgICBjb25zdCBjdXJyRmlsZU9iaiA9IHt9O1xuICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnc3JjRmlsZU5hbWUnXSA9IGZpbGVOYW1lO1xuICAgICAgICAgICAgICBjdXJyRmlsZU9ialsnc3JjRmlsZVBhdGgnXSA9IGZpbGVOYW1lRnVsbFBhdGg7XG4gICAgICAgICAgICAgIGN1cnJGaWxlT2JqWydzcmNGaWxlU2l6ZSddID0gZmlsZUluZm8uc2l6ZTtcblxuICAgICAgICAgICAgICBmaWxlc1RvUHV0LnB1c2goY3VyckZpbGVPYmopO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGRpciArICcgaXMgbm90IGEgZGlyZWN0b3J5Jyk7XG4gICAgICB9XG5cbiAgICAgIGF1dG9Db21wcmVzcyA9IGRhdGFbJ2F1dG9Db21wcmVzcyddO1xuICAgICAgc291cmNlQ29tcHJlc3Npb24gPSBkYXRhWydzb3VyY2VDb21wcmVzc2lvbiddO1xuICAgIH0gZWxzZSBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX0RPV05MT0FEKSB7XG4gICAgICBpbml0RW5jcnlwdGlvbk1hdGVyaWFsKCk7XG4gICAgICBzcmNGaWxlcyA9IGRhdGFbJ3NyY19sb2NhdGlvbnMnXTtcblxuICAgICAgaWYgKHNyY0ZpbGVzLmxlbmd0aCA9PT0gZW5jcnlwdGlvbk1hdGVyaWFsLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGNvbnN0IGlkeCBpbiBzcmNGaWxlcykge1xuICAgICAgICAgIHNyY0ZpbGVzVG9FbmNyeXB0aW9uTWF0ZXJpYWxbc3JjRmlsZXNbaWR4XV0gPSBlbmNyeXB0aW9uTWF0ZXJpYWxbaWR4XTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChlbmNyeXB0aW9uTWF0ZXJpYWwubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIC8vIHNvbWUgZW5jcnlwdGlvbiBtYXRlcmlhbCBleGlzdHMuIFplcm8gbWVhbnMgbm8gZW5jcnlwdGlvblxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBudW1iZXIgb2YgZG93bmxvYWRpbmcgZmlsZXMgZG9lc25cXCd0IG1hdGNoJyk7XG4gICAgICB9XG4gICAgICBsb2NhbExvY2F0aW9uID0gZXhwYW5kVGlsZGUoZGF0YVsnbG9jYWxMb2NhdGlvbiddKTtcblxuICAgICAgLy8gSWYgY3dkIGV4aXN0cyBhbmQgcm9vdCBpcyByZWxhdGl2ZSAuIHRoZW4gcmVwbGFjZSB3aXRoIGNvbnRleHQncyBjd2RcbiAgICAgIC8vIFVzZWQgZm9yIFZTIENvZGUgZXh0ZW5zaW9uIHdoZXJlIGV4dGVuc2lvbiBjd2QgZGlmZmVycyBmcm9tIHVzZXIgd29ya3NwYWNlIGRpciAgICAgXG4gICAgICBpZiAoY3dkICYmICFwYXRoLmlzQWJzb2x1dGUobG9jYWxMb2NhdGlvbikpIHtcbiAgICAgICAgY29uc3QgYWJzb2x1dGVQYXRoID0gcGF0aC5yZXNvbHZlKGN3ZCwgbG9jYWxMb2NhdGlvbik7XG4gICAgICAgIGxvY2FsTG9jYXRpb24gPSBhYnNvbHV0ZVBhdGg7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRpciA9IGZzLnN0YXRTeW5jKGxvY2FsTG9jYXRpb24pO1xuICAgICAgaWYgKCFkaXIuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBsb2NhbCBwYXRoIGlzIG5vdCBhIGRpcmVjdG9yeTogJyArIGxvY2FsTG9jYXRpb24pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHBhcmFsbGVsID0gZGF0YVsncGFyYWxsZWwnXTtcbiAgICBzdGFnZUluZm8gPSBkYXRhWydzdGFnZUluZm8nXTtcbiAgICBzdGFnZUxvY2F0aW9uVHlwZSA9IHN0YWdlSW5mb1snbG9jYXRpb25UeXBlJ107XG4gICAgcHJlc2lnbmVkVXJscyA9IGRhdGFbJ3ByZXNpZ25lZFVybHMnXTtcbiAgICBvdmVyd3JpdGUgPSBkYXRhWydvdmVyd3JpdGUnXTtcbiAgfVxuXG4gIC8qKlxuICAqIEdlbmVyYXRlIGVuY3J5cHRpb24gbWF0ZXJpYWwgZm9yIGVhY2ggbWV0YWRhdGEuXG4gICpcbiAgKiBAcmV0dXJucyB7bnVsbH1cbiAgKi9cbiAgZnVuY3Rpb24gaW5pdEVuY3J5cHRpb25NYXRlcmlhbCgpIHtcbiAgICBpZiAocmVzcG9uc2VbJ2RhdGEnXSAmJiByZXNwb25zZVsnZGF0YSddWydlbmNyeXB0aW9uTWF0ZXJpYWwnXSkge1xuICAgICAgY29uc3Qgcm9vdE5vZGUgPSByZXNwb25zZVsnZGF0YSddWydlbmNyeXB0aW9uTWF0ZXJpYWwnXTtcblxuICAgICAgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9VUExPQUQpIHtcbiAgICAgICAgZW5jcnlwdGlvbk1hdGVyaWFsLnB1c2gobmV3IFNub3dmbGFrZUZpbGVFbmNyeXB0aW9uTWF0ZXJpYWwoXG4gICAgICAgICAgcm9vdE5vZGVbJ3F1ZXJ5U3RhZ2VNYXN0ZXJLZXknXSxcbiAgICAgICAgICByb290Tm9kZVsncXVlcnlJZCddLFxuICAgICAgICAgIHJvb3ROb2RlWydzbWtJZCddKSk7XG4gICAgICB9IGVsc2UgaWYgKGNvbW1hbmRUeXBlID09PSBDTURfVFlQRV9ET1dOTE9BRCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW0gaW4gcm9vdE5vZGUpIHtcbiAgICAgICAgICBlbmNyeXB0aW9uTWF0ZXJpYWwucHVzaChuZXcgU25vd2ZsYWtlRmlsZUVuY3J5cHRpb25NYXRlcmlhbChcbiAgICAgICAgICAgIHJvb3ROb2RlW2VsZW1dWydxdWVyeVN0YWdlTWFzdGVyS2V5J10sXG4gICAgICAgICAgICByb290Tm9kZVtlbGVtXVsncXVlcnlJZCddLFxuICAgICAgICAgICAgcm9vdE5vZGVbZWxlbV1bJ3Nta0lkJ10pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIEdlbmVyYXRlIG1ldGFkYXRhIGZvciBmaWxlcyB0byB1cGxvYWQvZG93bmxvYWQuXG4gICpcbiAgKiBAcmV0dXJucyB7bnVsbH1cbiAgKi9cbiAgZnVuY3Rpb24gaW5pdEZpbGVNZXRhZGF0YSgpIHtcbiAgICBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX1VQTE9BRCkge1xuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzVG9QdXQpIHtcbiAgICAgICAgY29uc3QgY3VyckZpbGVPYmogPSB7fTtcbiAgICAgICAgY3VyckZpbGVPYmpbJ3NyY0ZpbGVQYXRoJ10gPSBmaWxlWydzcmNGaWxlUGF0aCddO1xuICAgICAgICBjdXJyRmlsZU9ialsnc3JjRmlsZU5hbWUnXSA9IGZpbGVbJ3NyY0ZpbGVOYW1lJ107XG4gICAgICAgIGN1cnJGaWxlT2JqWydzcmNGaWxlU2l6ZSddID0gZmlsZVsnc3JjRmlsZVNpemUnXTtcbiAgICAgICAgY3VyckZpbGVPYmpbJ3N0YWdlTG9jYXRpb25UeXBlJ10gPSBzdGFnZUxvY2F0aW9uVHlwZTtcbiAgICAgICAgY3VyckZpbGVPYmpbJ3N0YWdlSW5mbyddID0gc3RhZ2VJbmZvO1xuICAgICAgICBjdXJyRmlsZU9ialsnb3ZlcndyaXRlJ10gPSBvdmVyd3JpdGU7XG5cbiAgICAgICAgZmlsZU1ldGFkYXRhLnB1c2goY3VyckZpbGVPYmopO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY29tbWFuZFR5cGUgPT09IENNRF9UWVBFX0RPV05MT0FEKSB7XG4gICAgICBmb3IgKGNvbnN0IGZpbGVOYW1lIG9mIHNyY0ZpbGVzKSB7XG4gICAgICAgIGNvbnN0IGN1cnJGaWxlT2JqID0ge307XG4gICAgICAgIGN1cnJGaWxlT2JqWydzcmNGaWxlTmFtZSddID0gZmlsZU5hbWU7XG4gICAgICAgIGN1cnJGaWxlT2JqWydkc3RGaWxlTmFtZSddID0gZmlsZU5hbWU7XG4gICAgICAgIGN1cnJGaWxlT2JqWydzdGFnZUxvY2F0aW9uVHlwZSddID0gc3RhZ2VMb2NhdGlvblR5cGU7XG4gICAgICAgIGN1cnJGaWxlT2JqWydzdGFnZUluZm8nXSA9IHN0YWdlSW5mbztcbiAgICAgICAgY3VyckZpbGVPYmpbJ3VzZUFjY2VsZXJhdGVFbmRwb2ludCddID0gdXNlQWNjZWxlcmF0ZUVuZHBvaW50O1xuICAgICAgICBjdXJyRmlsZU9ialsnbG9jYWxMb2NhdGlvbiddID0gbG9jYWxMb2NhdGlvbjtcbiAgICAgICAgY3VyckZpbGVPYmpbJ2VuY3J5cHRpb25NYXRlcmlhbCddID0gc3JjRmlsZXNUb0VuY3J5cHRpb25NYXRlcmlhbFtmaWxlTmFtZV07XG5cbiAgICAgICAgZmlsZU1ldGFkYXRhLnB1c2goY3VyckZpbGVPYmopO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbmNyeXB0aW9uTWF0ZXJpYWwubGVuZ3RoID4gMCkge1xuICAgICAgbGV0IGkgPSAwO1xuICAgICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVNZXRhZGF0YSkge1xuICAgICAgICBmaWxlWydlbmNyeXB0aW9uTWF0ZXJpYWwnXSA9IGVuY3J5cHRpb25NYXRlcmlhbFtpXTtcbiAgICAgICAgaSsrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAqIEdldCB0aGUgY29tcHJlc3Npb24gdHlwZSBvZiB0aGUgZmlsZS5cbiAgKlxuICAqIEByZXR1cm5zIHtudWxsfVxuICAqL1xuICBmdW5jdGlvbiBwcm9jZXNzRmlsZUNvbXByZXNzaW9uVHlwZSgpIHtcbiAgICBsZXQgdXNlclNwZWNpZmllZFNvdXJjZUNvbXByZXNzaW9uO1xuICAgIGxldCBhdXRvRGV0ZWN0O1xuICAgIGlmIChzb3VyY2VDb21wcmVzc2lvbiA9PT0gJ2F1dG9fZGV0ZWN0Jykge1xuICAgICAgYXV0b0RldGVjdCA9IHRydWU7XG5cbiAgICB9IGVsc2UgaWYgKHNvdXJjZUNvbXByZXNzaW9uID09PSB0eXBlb2YoJ3VuZGVmaW5lZCcpKSB7XG4gICAgICBhdXRvRGV0ZWN0ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHVzZXJTcGVjaWZpZWRTb3VyY2VDb21wcmVzc2lvbiA9IGZpbGVDb21wcmVzc2lvblR5cGUubG9va3VwQnlNaW1lU3ViVHlwZShzb3VyY2VDb21wcmVzc2lvbik7XG4gICAgICBpZiAodXNlclNwZWNpZmllZFNvdXJjZUNvbXByZXNzaW9uID09PSB0eXBlb2YgKCd1bmRlZmluZWQnKSB8fCAhdXNlclNwZWNpZmllZFNvdXJjZUNvbXByZXNzaW9uWydpc19zdXBwb3J0ZWQnXSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3Ioc291cmNlQ29tcHJlc3Npb24gKyAnIGlzIG5vdCBhIHN1cHBvcnRlZCBjb21wcmVzc2lvbiB0eXBlJyk7XG4gICAgICB9XG4gICAgICBhdXRvRGV0ZWN0ID0gZmFsc2U7XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBtZXRhIG9mIGZpbGVNZXRhZGF0YSkge1xuICAgICAgY29uc3QgZmlsZU5hbWUgPSBtZXRhWydzcmNGaWxlTmFtZSddO1xuICAgICAgY29uc3QgZmlsZVBhdGggPSBtZXRhWydzcmNGaWxlUGF0aCddO1xuXG4gICAgICBsZXQgY3VycmVudEZpbGVDb21wcmVzc2lvblR5cGU7XG4gICAgICBsZXQgZW5jb2Rpbmc7XG5cbiAgICAgIGlmIChhdXRvRGV0ZWN0KSB7XG4gICAgICAgIGVuY29kaW5nID0gbWltZS5sb29rdXAoZmlsZU5hbWUpO1xuXG4gICAgICAgIGlmICghZW5jb2RpbmcpIHtcbiAgICAgICAgICBjb25zdCB0ZXN0ID0gQnVmZmVyLmFsbG9jKDQpO1xuICAgICAgICAgIGNvbnN0IGZkID0gZnMub3BlblN5bmMoZmlsZVBhdGgsICdyKycpO1xuICAgICAgICAgIGZzLnJlYWRTeW5jKGZkLCB0ZXN0LCAwLCA0LCAwKTtcbiAgICAgICAgICBmcy5jbG9zZVN5bmMoZmQpO1xuXG4gICAgICAgICAgaWYgKGZpbGVOYW1lLnN1YnN0cmluZyhmaWxlTmFtZS5sYXN0SW5kZXhPZignLicpKSA9PT0gJy5icicpIHtcbiAgICAgICAgICAgIGVuY29kaW5nID0gJ2JyJztcbiAgICAgICAgICB9IGVsc2UgaWYgKGZpbGVOYW1lLnN1YnN0cmluZyhmaWxlTmFtZS5sYXN0SW5kZXhPZignLicpKSA9PT0gJy5kZWZsYXRlJykge1xuICAgICAgICAgICAgZW5jb2RpbmcgPSAnZGVmbGF0ZSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChmaWxlTmFtZS5zdWJzdHJpbmcoZmlsZU5hbWUubGFzdEluZGV4T2YoJy4nKSkgPT09ICcucmF3X2RlZmxhdGUnKSB7XG4gICAgICAgICAgICBlbmNvZGluZyA9ICdyYXdfZGVmbGF0ZSc7XG4gICAgICAgICAgfSBlbHNlIGlmIChCdWZmZXIuZnJvbSh0ZXN0LnRvU3RyaW5nKCkpLnNsaWNlKDAsIDMpID09PSBCdWZmZXIuZnJvbSgnT1JDJykpIHtcbiAgICAgICAgICAgIGVuY29kaW5nID0gJ29yYyc7XG4gICAgICAgICAgfSBlbHNlIGlmIChCdWZmZXIuZnJvbSh0ZXN0LnRvU3RyaW5nKCkpID09PSBCdWZmZXIuZnJvbSgnUEFSMScpKSB7XG4gICAgICAgICAgICBlbmNvZGluZyA9ICdwYXJxdWV0JztcbiAgICAgICAgICB9IGVsc2UgaWYgKGJpbmFzY2lpLmhleGxpZnkodGVzdC50b1N0cmluZygpKSA9PT0gJzI4ZmQyZmZkJyB8fFxuICAgICAgICAgICAgZmlsZU5hbWUuc3Vic3RyaW5nKGZpbGVOYW1lLmxhc3RJbmRleE9mKCcuJykpID09PSAnLnpzdCcpIHtcbiAgICAgICAgICAgIGVuY29kaW5nID0gJ3pzdGQnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICAgIGN1cnJlbnRGaWxlQ29tcHJlc3Npb25UeXBlID0gZmlsZUNvbXByZXNzaW9uVHlwZS5sb29rdXBCeUVuY29kaW5nKGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbHNlIHt9IE5vIGZpbGUgZW5jb2RpbmcgZGV0ZWN0ZWRcblxuICAgICAgICBpZiAoY3VycmVudEZpbGVDb21wcmVzc2lvblR5cGUgJiYgIWN1cnJlbnRGaWxlQ29tcHJlc3Npb25UeXBlWydpc19zdXBwb3J0ZWQnXSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlbmNvZGluZyArICcgaXMgbm90IGEgYSBzdXBwb3J0ZWQgY29tcHJlc3Npb24gdHlwZScpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50RmlsZUNvbXByZXNzaW9uVHlwZSA9IHVzZXJTcGVjaWZpZWRTb3VyY2VDb21wcmVzc2lvbjtcbiAgICAgIH1cblxuICAgICAgaWYgKGN1cnJlbnRGaWxlQ29tcHJlc3Npb25UeXBlKSB7XG4gICAgICAgIGlmIChjdXJyZW50RmlsZUNvbXByZXNzaW9uVHlwZVsnaXNfc3VwcG9ydGVkJ10pIHtcbiAgICAgICAgICBtZXRhWydkc3RDb21wcmVzc2lvblR5cGUnXSA9IGN1cnJlbnRGaWxlQ29tcHJlc3Npb25UeXBlO1xuICAgICAgICAgIG1ldGFbJ3JlcXVpcmVDb21wcmVzcyddID0gZmFsc2U7XG4gICAgICAgICAgbWV0YVsnZHN0RmlsZU5hbWUnXSA9IG1ldGFbJ3NyY0ZpbGVOYW1lJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGVuY29kaW5nICsgJyBpcyBub3QgYSBhIHN1cHBvcnRlZCBjb21wcmVzc2lvbiB0eXBlJyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGFbJ3JlcXVpcmVDb21wcmVzcyddID0gYXV0b0NvbXByZXNzO1xuICAgICAgICBtZXRhWydzcmNDb21wcmVzc2lvblR5cGUnXSA9IG51bGw7XG5cbiAgICAgICAgLy8gSWYgcmVxdWlyZUNvbXByZXNzIGlzIHRydWUsIGRlc3RpbmF0aW9uIGZpbGUgZXh0ZW5zaW9uIGlzIGNoYW5nZWQgdG8gemlwXG4gICAgICAgIGlmIChhdXRvQ29tcHJlc3MpIHtcbiAgICAgICAgICAvLyBDb21wcmVzcyB3aXRoIGd6aXBcbiAgICAgICAgICBtZXRhWydkc3RDb21wcmVzc2lvblR5cGUnXSA9IGZpbGVDb21wcmVzc2lvblR5cGUubG9va3VwQnlNaW1lU3ViVHlwZSgnR1pJUCcpO1xuICAgICAgICAgIG1ldGFbJ2RzdEZpbGVOYW1lJ10gPSBtZXRhWydzcmNGaWxlTmFtZSddICsgbWV0YVsnZHN0Q29tcHJlc3Npb25UeXBlJ11bJ2ZpbGVfZXh0ZW5zaW9uJ107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWV0YVsnZHN0RmlsZU5hbWUnXSA9IG1ldGFbJ3NyY0ZpbGVOYW1lJ107XG4gICAgICAgICAgbWV0YVsnZHN0Q29tcHJlc3Npb25UeXBlJ10gPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vVE9ETyBTTk9XLTk5MjM4NzogQ3JlYXRlIGEgZnVuY3Rpb24gdG8gcmVuZXcgZXhwaXJlZCBjbGllbnRcbmZ1bmN0aW9uIHJlbmV3RXhwaXJlZENsaWVudCgpIHt9XG5cbm1vZHVsZS5leHBvcnRzID0gRmlsZVRyYW5zZmVyQWdlbnQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/file_transfer_agent.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/gcs_util.js":
/*!************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/file_transfer_agent/gcs_util.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const EncryptionMetadata = (__webpack_require__(/*! ./encrypt_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/encrypt_util.js\").EncryptionMetadata);\nconst FileHeader = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\").FileHeader);\nconst getProxyAgent = (__webpack_require__(/*! ../http/node */ \"(rsc)/./node_modules/snowflake-sdk/lib/http/node.js\").getProxyAgent);\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/proxy_util.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst { shouldPerformGCPBucket, lstrip } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\n\nconst GCS_METADATA_PREFIX = 'x-goog-meta-';\nconst SFC_DIGEST = 'sfc-digest';\nconst MATDESC_KEY = 'matdesc';\nconst ENCRYPTIONDATAPROP = 'encryptiondata';\nconst GCS_METADATA_SFC_DIGEST = GCS_METADATA_PREFIX + SFC_DIGEST;\nconst GCS_METADATA_MATDESC_KEY = GCS_METADATA_PREFIX + MATDESC_KEY;\nconst GCS_METADATA_ENCRYPTIONDATAPROP = GCS_METADATA_PREFIX + ENCRYPTIONDATAPROP;\nconst GCS_FILE_HEADER_DIGEST = 'gcs-file-header-digest';\nconst GCS_FILE_HEADER_CONTENT_LENGTH = 'gcs-file-header-content-length';\nconst GCS_FILE_HEADER_ENCRYPTION_METADATA = 'gcs-file-header-encryption-metadata';\n\nconst HTTP_HEADER_CONTENT_ENCODING = 'Content-Encoding';\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\").resultStatus);\n\nconst { Storage } = __webpack_require__(/*! @google-cloud/storage */ \"(rsc)/./node_modules/@google-cloud/storage/build/cjs/src/index.js\");\n\nconst EXPIRED_TOKEN = 'ExpiredToken';\n\nconst ERRORNO_WSAECONNABORTED = 10053;  // network connection was aborted\n\n/** \n * @typedef {object} GCSLocation\n * @property {string} bucketName\n * @property {string} path \n */\nfunction GCSLocation(bucketName, path) {\n  return {\n    'bucketName': bucketName,\n    'path': path\n  };\n}\n\n/**\n * Creates an GCS utility object.\n * @param {module} connectionConfig\n * @param {module} httpClient\n * @param {module} fileStream\n *\n * @returns {Object}\n * @constructor\n */\nfunction GCSUtil(connectionConfig, httpClient, fileStream) {\n  let axios = httpClient;\n  const fs = typeof fileStream !== 'undefined' ? fileStream : __webpack_require__(/*! fs */ \"fs\");\n  let isProxyEnabled = false;\n\n  /**\n  * Retrieve the GCS token from the stage info metadata.\n  *\n  * @param {Object} stageInfo\n  *\n  * @returns {String}\n  */\n  this.createClient = function (stageInfo) {\n    const stageCredentials = stageInfo['creds'];\n    const gcsToken = stageCredentials['GCS_ACCESS_TOKEN'];\n    //TODO: SNOW-1789759 the value is hardcoded now, but it should be server driven\n    const isRegionalUrlEnabled = (stageInfo.region).toLowerCase() === 'me-central2' || stageInfo.useRegionalUrl;\n    let endPoint = null;\n    if (stageInfo['endPoint']) {\n      endPoint = stageInfo['endPoint'];\n    } else if (isRegionalUrlEnabled) {\n      endPoint = `storage.${stageInfo.region.toLowerCase()}.rep.googleapis.com`;\n    }\n\n    let client;\n    if (gcsToken) {\n      const interceptors = [];\n      interceptors.push({\n        request: (requestConfig) => {\n          requestConfig.headers = requestConfig.headers || {};\n          Object.assign(requestConfig.headers, { Authorization: `Bearer ${gcsToken}` });\n          return requestConfig;\n        }\n      });\n\n      const storage = Util.exists(endPoint) ? new Storage({ interceptors_: interceptors, apiEndpoint: endPoint }) : new Storage({ interceptors_: interceptors });\n      client = { gcsToken: gcsToken, gcsClient: storage };\n    } else {\n      client = null;\n    }\n\n    process.nextTick(() => this.setupHttpClient(endPoint));\n\n    return client;\n  };\n\n  /**\n  * Extract the bucket name and path from the metadata's stage location.\n  *\n  * @param {String} stageLocation\n  *\n  * @returns {GCSLocation}\n  */\n  this.extractBucketNameAndPath = function (stageLocation) {\n    let containerName = stageLocation;\n    let path = '';\n\n    // split stage location as bucket name and path\n    if (stageLocation.includes('/')) {\n      containerName = stageLocation.substring(0, stageLocation.indexOf('/'));\n\n      path = stageLocation.substring(stageLocation.indexOf('/') + 1, stageLocation.length);\n      if (path && !path.endsWith('/')) {\n        path += '/';\n      }\n    }\n\n    return GCSLocation(containerName, path);\n  };\n\n  /**\n  * Create file header based on file being uploaded or not.\n  *\n  * @param {Object} meta\n  * @param {String} filename\n  *\n  * @returns {Object}\n  */\n  this.getFileHeader = async function (meta, filename) {\n    if (meta['resultStatus'] === resultStatus.UPLOADED ||\n      meta['resultStatus'] === resultStatus.DOWNLOADED) {\n      return FileHeader(\n        meta[GCS_FILE_HEADER_DIGEST],\n        meta[GCS_FILE_HEADER_CONTENT_LENGTH],\n        meta[GCS_FILE_HEADER_ENCRYPTION_METADATA]\n      );\n    } else {\n      if (meta['presignedUrl']) {\n        await axios.get(meta['presignedUrl'])\n          .catch(err => {\n            if ([401, 403, 404].includes(err.response.status)) {\n              meta['resultStatus'] = resultStatus.NOT_FOUND_FILE;\n            }\n          });\n      } else {\n        const url = this.generateFileURL(meta.stageInfo, lstrip(filename, '/'));\n        const accessToken = meta['client'].gcsToken;\n        const gcsHeaders = { 'Authorization': `Bearer ${accessToken}` };\n        let encryptionMetadata;\n        let digest;\n        let contentLength;\n        let encryptionDataProp;\n        let matDescKey;\n\n        try {\n          if (shouldPerformGCPBucket(accessToken) && !isProxyEnabled) {\n            const gcsLocation = this.extractBucketNameAndPath(meta['stageInfo']['location']);\n            const metadata = await meta['client'].gcsClient\n              .bucket(gcsLocation.bucketName)\n              .file(gcsLocation.path + filename)\n              .getMetadata();\n\n            digest = metadata[0].metadata[SFC_DIGEST];\n            contentLength = metadata[0].size;\n            encryptionDataProp = metadata[0].metadata[ENCRYPTIONDATAPROP];\n            matDescKey = metadata[0].metadata[MATDESC_KEY];\n          } else {\n            const response = await axios.head(url, { headers: gcsHeaders });\n\n            digest = response.headers[GCS_METADATA_SFC_DIGEST];\n            contentLength = response.headers['content-length'];\n            encryptionDataProp = response.headers[GCS_METADATA_ENCRYPTIONDATAPROP];\n            matDescKey = response.headers[GCS_METADATA_MATDESC_KEY];\n          }\n\n          if (encryptionDataProp) {\n            const encryptionData = JSON.parse(encryptionDataProp);\n            if (encryptionData) {\n              encryptionMetadata = EncryptionMetadata(\n                encryptionData['WrappedContentKey']['EncryptedKey'],\n                encryptionData['ContentEncryptionIV'],\n                matDescKey ? matDescKey : null\n              );\n            }\n          }\n\n          meta['resultStatus'] = resultStatus.UPLOADED;\n\n          return FileHeader(\n            digest,\n            contentLength,\n            encryptionMetadata\n          );\n        } catch (err) {\n          const errCode = !isNaN(err['code']) && !isNaN(parseInt(err['code'])) ? err['code'] : err.response.status;\n\n          if ([403, 408, 429, 500, 503].includes(errCode)) {\n            meta['lastError'] = err;\n            meta['resultStatus'] = resultStatus.NEED_RETRY;\n            return;\n          }\n          if (errCode === 404) {\n            meta['resultStatus'] = resultStatus.NOT_FOUND_FILE;\n          } else if (errCode === 401) {\n            meta['lastError'] = err;\n            meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n          } else {\n            meta['lastError'] = err;\n            meta['resultStatus'] = resultStatus.ERROR;\n            throw err;\n          }\n        }\n      }\n    }\n    return FileHeader(null, null, null);\n  };\n\n  /**\n  * Create the file metadata then upload the file.\n  *\n  * @param {String} dataFile\n  * @param {Object} meta\n  * @param {Object} encryptionMetadata\n  * @param {Number} maxConcurrency\n  *\n  * @returns {null}\n  */\n  this.uploadFile = async function (dataFile, meta, encryptionMetadata, maxConcurrency) {\n    const fileStream = fs.readFileSync(dataFile);\n    await this.uploadFileStream(fileStream, meta, encryptionMetadata, maxConcurrency);\n  };\n\n  /**\n    * Create the file metadata then upload the file stream.\n    *\n    * @param {String} fileStream\n    * @param {Object} meta\n    * @param {Object} encryptionMetadata\n    *\n    * @returns {null}\n    */\n  this.uploadFileStream = async function (fileStream, meta, encryptionMetadata) {\n    let uploadUrl = meta['presignedUrl'];\n    let accessToken = null;\n\n    if (!uploadUrl) {\n      const tempFilename = meta['dstFileName'].substring(meta['dstFileName'].indexOf('/') + 1, meta['dstFileName'].length);\n\n      uploadUrl = this.generateFileURL(meta.stageInfo, tempFilename);\n      accessToken = meta['client'].gcsToken;\n    }\n    let contentEncoding = '';\n\n    if (meta['dstCompressionType']) {\n      contentEncoding = meta['dstCompressionType']['name'];\n      contentEncoding = contentEncoding.toLowerCase();\n    }\n\n    // We set the contentEncoding to blank for the following file types\n    if (['gzip', 'bzip2', 'brotli', 'deflate', 'raw_deflate', 'zstd'].includes(contentEncoding)) {\n      contentEncoding = '';\n    }\n\n    const gcsHeaders = {\n      [HTTP_HEADER_CONTENT_ENCODING]: contentEncoding,\n      [GCS_METADATA_SFC_DIGEST]: meta['SHA256_DIGEST'],\n    };\n\n    if (accessToken) {\n      gcsHeaders['Authorization'] = `Bearer ${accessToken}`;\n    }\n\n    if (encryptionMetadata) {\n      gcsHeaders[GCS_METADATA_ENCRYPTIONDATAPROP] =\n        JSON.stringify({\n          'EncryptionMode': 'FullBlob',\n          'WrappedContentKey': {\n            'KeyId': 'symmKey1',\n            'EncryptedKey': encryptionMetadata.key,\n            'Algorithm': 'AES_CBC_256'\n          },\n          'EncryptionAgent': {\n            'Protocol': '1.0',\n            'EncryptionAlgorithm': 'AES_CBC_256',\n          },\n          'ContentEncryptionIV': encryptionMetadata.iv,\n          'KeyWrappingMetadata': {\n            'EncryptionLibrary': 'Java 5.3.0'\n          }\n        });\n      gcsHeaders[GCS_METADATA_MATDESC_KEY] = encryptionMetadata.matDesc;\n    }\n\n    try {\n      if (shouldPerformGCPBucket(accessToken) && !isProxyEnabled) {\n        const gcsLocation = this.extractBucketNameAndPath(meta['stageInfo']['location']);\n\n        await meta['client'].gcsClient\n          .bucket(gcsLocation.bucketName)\n          .file(gcsLocation.path + meta['dstFileName'])\n          .save(fileStream, {\n            resumable: false,\n            metadata: {\n              metadata: {\n                [ENCRYPTIONDATAPROP]: gcsHeaders[GCS_METADATA_ENCRYPTIONDATAPROP],\n                [MATDESC_KEY]: gcsHeaders[GCS_METADATA_MATDESC_KEY],\n                [SFC_DIGEST]: gcsHeaders[GCS_METADATA_SFC_DIGEST]\n              }\n            }\n          });\n      } else {\n        // Set maxBodyLength to allow large file uploading\n        await axios.put(uploadUrl, fileStream, { maxBodyLength: Infinity, headers: gcsHeaders });\n      }\n    } catch (err) {\n      if ([403, 408, 429, 500, 503].includes(err['code'])) {\n        meta['lastError'] = err;\n        meta['resultStatus'] = resultStatus.NEED_RETRY;\n      } else if (!accessToken && err['code'] === 400 &&\n        (!meta['lastError'] || meta['lastError']['code'] !== 400)) {\n        // Only attempt to renew urls if this isn't the second time this happens\n        meta['lastError'] = err;\n        meta['resultStatus'] = resultStatus.RENEW_PRESIGNED_URL;\n      } else if (accessToken && err['code'] === 401) {\n\n        meta['lastError'] = err;\n        meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n      }\n      return;\n    }\n\n    meta['dstFileSize'] = meta['uploadSize'];\n    meta['resultStatus'] = resultStatus.UPLOADED;\n\n    meta[GCS_FILE_HEADER_DIGEST] = gcsHeaders[GCS_METADATA_SFC_DIGEST];\n    meta[GCS_FILE_HEADER_CONTENT_LENGTH] = meta['uploadSize'];\n    meta[GCS_FILE_HEADER_ENCRYPTION_METADATA] = gcsHeaders[GCS_METADATA_ENCRYPTIONDATAPROP];\n  };\n\n\n  /**\n   * Download the file.\n   *\n   * @param {Object} meta\n   * @param fullDstPath\n   *\n   * @returns {null}\n   */\n  this.nativeDownloadFile = async function (meta, fullDstPath) {\n    let downloadUrl = meta['presignedUrl'];\n    let accessToken = null;\n    let gcsHeaders = {};\n\n    if (!downloadUrl) {\n      downloadUrl = this.generateFileURL(\n        meta.stageInfo, lstrip(meta['srcFileName'], '/')\n      );\n      accessToken = meta['client'].gcsToken;\n      gcsHeaders = { 'Authorization': `Bearer ${accessToken}` };\n    }\n\n    let encryptionDataprop;\n    let matDescKey;\n    let sfcDigest;\n    let size;\n\n    try {\n      if (shouldPerformGCPBucket(accessToken) && !isProxyEnabled) {\n        const gcsLocation = this.extractBucketNameAndPath(meta['stageInfo']['location']);\n        await meta['client'].gcsClient\n          .bucket(gcsLocation.bucketName)\n          .file(gcsLocation.path + meta['srcFileName'])\n          .download({\n            destination: fullDstPath\n          });\n\n        const metadata = await meta['client'].gcsClient\n          .bucket(gcsLocation.bucketName)\n          .file(gcsLocation.path + meta['srcFileName'])\n          .getMetadata();\n\n        encryptionDataprop = metadata[0].metadata[ENCRYPTIONDATAPROP];\n        matDescKey = metadata[0].metadata[MATDESC_KEY];\n        sfcDigest = metadata[0].metadata[SFC_DIGEST];\n        size = metadata[0].size;\n      } else {\n        let response;\n        await axios.get(downloadUrl, {\n          headers: gcsHeaders,\n          responseType: 'stream'\n        }).then(async (res) => {\n          response = res;\n          await new Promise((resolve, reject) => {\n            const writer = fs.createWriteStream(fullDstPath);\n            response.data.pipe(writer);\n            writer.on('error', err => {\n              writer.close();\n              reject(err);\n            });\n            writer.on('close', () => {\n              resolve();\n            });\n          });\n        });\n\n        encryptionDataprop = response.headers[GCS_METADATA_ENCRYPTIONDATAPROP];\n        matDescKey = response.headers[GCS_METADATA_MATDESC_KEY];\n        sfcDigest = response.headers[GCS_METADATA_SFC_DIGEST];\n        size = response.headers['content-length'];\n      }\n    } catch (err) {\n      if (err['code'] === EXPIRED_TOKEN) {\n        meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n      } else {\n        meta['lastError'] = err;\n        if (err['code'] === ERRORNO_WSAECONNABORTED) {\n          meta['resultStatus'] = resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY;\n        } else {\n          meta['resultStatus'] = resultStatus.NEED_RETRY;\n        }\n      }\n      return;\n    }\n\n    let encryptionData;\n    if (encryptionDataprop) {\n      encryptionData = JSON.parse(encryptionDataprop);\n    }\n\n    let encryptionMetadata;\n    if (encryptionData) {\n      encryptionMetadata = EncryptionMetadata(\n        encryptionData['WrappedContentKey']['EncryptedKey'],\n        encryptionData['ContentEncryptionIV'],\n        matDescKey\n      );\n    }\n\n    const fileInfo = fs.statSync(fullDstPath);\n    meta['srcFileSize'] = fileInfo.size;\n\n    meta['resultStatus'] = resultStatus.DOWNLOADED;\n\n    meta[GCS_FILE_HEADER_DIGEST] = sfcDigest;\n    meta[GCS_FILE_HEADER_CONTENT_LENGTH] = size;\n    meta[GCS_FILE_HEADER_ENCRYPTION_METADATA] = encryptionMetadata;\n  };\n\n  /**\n  * Generate file URL based on bucket.\n  *\n  * @param {Object} stageInfo\n  * @param {String} filename\n  *\n  * @returns {String}\n  */\n  this.generateFileURL = function (stageInfo, filename) {\n    const gcsLocation = this.extractBucketNameAndPath(stageInfo.location);\n    const fullFilePath = `${gcsLocation.path}${filename}`;\n    const endPoint = this.getGCSCustomEndPoint(stageInfo);\n    const link = `${endPoint != null ? endPoint : 'https://storage.googleapis.com'}/${gcsLocation.bucketName}/${fullFilePath}`;\n    return link.startsWith('https://') ? link : `https://${link}`;\n  };\n\n  this.getGCSCustomEndPoint = function (stageInfo) {\n    //TODO: SNOW-1789759 hardcoded region will be replaced in the future\n    const isRegionalUrlEnabled = (stageInfo.region).toLowerCase() === 'me-central2' || stageInfo.useRegionalUrl;\n    let endPoint = null;\n    if (stageInfo['endPoint']) {\n      endPoint = stageInfo['endPoint'];\n    } else if (isRegionalUrlEnabled) {\n      endPoint = `storage.${stageInfo.region.toLowerCase()}.rep.googleapis.com`;\n    }\n    return endPoint;\n  };\n\n  this.setupHttpClient = function (endPoint) {\n    if (typeof httpClient === 'undefined') {\n      const proxy = ProxyUtil.getProxy(connectionConfig.getProxy(), 'GCS Util');\n\n      //When http_proxy is enabled, the driver should use Axios for HTTPS requests to avoid relying on HTTP_PROXY in GCS.\n      if (proxy || Util.getEnvVar('http_proxy')) {\n        isProxyEnabled = true;\n        const proxyAgent = getProxyAgent(proxy, new URL(connectionConfig.accessUrl), endPoint || 'storage.googleapis.com');\n        axios = (__webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\").create)({\n          proxy: false,\n          httpAgent: proxyAgent,\n          httpsAgent: proxyAgent,\n        });\n      } else {\n        axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\n      }\n    }\n  };\n}\n\nmodule.exports = GCSUtil;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9nY3NfdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSwyQkFBMkIsNElBQTRDO0FBQ3ZFLG1CQUFtQiwyR0FBa0M7QUFDckQsc0JBQXNCLDhHQUFxQztBQUMzRCxrQkFBa0IsbUJBQU8sQ0FBQywyRUFBZTtBQUN6QyxhQUFhLG1CQUFPLENBQUMsK0RBQVM7QUFDOUIsUUFBUSxpQ0FBaUMsRUFBRSxtQkFBTyxDQUFDLCtEQUFTOztBQUU1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQiw2R0FBb0M7O0FBRXpELFFBQVEsVUFBVSxFQUFFLG1CQUFPLENBQUMsZ0dBQXVCOztBQUVuRDs7QUFFQSx3Q0FBd0M7O0FBRXhDO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELG1CQUFPLENBQUMsY0FBSTtBQUMxRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRCQUE0QiwrQkFBK0I7QUFDM0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHlCQUF5QixTQUFTLEdBQUc7QUFDdEY7QUFDQTtBQUNBLE9BQU87O0FBRVAsNERBQTRELG9EQUFvRCxrQkFBa0IsNkJBQTZCO0FBQy9KLGlCQUFpQjtBQUNqQixNQUFNO0FBQ047QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxRQUFRO0FBQ1I7QUFDQTtBQUNBLDZCQUE2QiwyQkFBMkIsWUFBWTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaLHFEQUFxRCxxQkFBcUI7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDLFlBQVk7QUFDMUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFFBQVE7QUFDUjtBQUNBLGlEQUFpRCw4Q0FBOEM7QUFDL0Y7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiwyQkFBMkIsWUFBWTtBQUM1RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsaUJBQWlCLEVBQUUsU0FBUztBQUN4RDtBQUNBLG9CQUFvQiwrREFBK0QsR0FBRyx1QkFBdUIsR0FBRyxhQUFhO0FBQzdILDJEQUEyRCxLQUFLO0FBQ2hFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0QkFBNEIsK0JBQStCO0FBQzNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMkZBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1IsZ0JBQWdCLG1CQUFPLENBQUMsNkRBQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9nY3NfdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBFbmNyeXB0aW9uTWV0YWRhdGEgPSByZXF1aXJlKCcuL2VuY3J5cHRfdXRpbCcpLkVuY3J5cHRpb25NZXRhZGF0YTtcbmNvbnN0IEZpbGVIZWFkZXIgPSByZXF1aXJlKCcuLi9maWxlX3V0aWwnKS5GaWxlSGVhZGVyO1xuY29uc3QgZ2V0UHJveHlBZ2VudCA9IHJlcXVpcmUoJy4uL2h0dHAvbm9kZScpLmdldFByb3h5QWdlbnQ7XG5jb25zdCBQcm94eVV0aWwgPSByZXF1aXJlKCcuLi9wcm94eV91dGlsJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgeyBzaG91bGRQZXJmb3JtR0NQQnVja2V0LCBsc3RyaXAgfSA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuY29uc3QgR0NTX01FVEFEQVRBX1BSRUZJWCA9ICd4LWdvb2ctbWV0YS0nO1xuY29uc3QgU0ZDX0RJR0VTVCA9ICdzZmMtZGlnZXN0JztcbmNvbnN0IE1BVERFU0NfS0VZID0gJ21hdGRlc2MnO1xuY29uc3QgRU5DUllQVElPTkRBVEFQUk9QID0gJ2VuY3J5cHRpb25kYXRhJztcbmNvbnN0IEdDU19NRVRBREFUQV9TRkNfRElHRVNUID0gR0NTX01FVEFEQVRBX1BSRUZJWCArIFNGQ19ESUdFU1Q7XG5jb25zdCBHQ1NfTUVUQURBVEFfTUFUREVTQ19LRVkgPSBHQ1NfTUVUQURBVEFfUFJFRklYICsgTUFUREVTQ19LRVk7XG5jb25zdCBHQ1NfTUVUQURBVEFfRU5DUllQVElPTkRBVEFQUk9QID0gR0NTX01FVEFEQVRBX1BSRUZJWCArIEVOQ1JZUFRJT05EQVRBUFJPUDtcbmNvbnN0IEdDU19GSUxFX0hFQURFUl9ESUdFU1QgPSAnZ2NzLWZpbGUtaGVhZGVyLWRpZ2VzdCc7XG5jb25zdCBHQ1NfRklMRV9IRUFERVJfQ09OVEVOVF9MRU5HVEggPSAnZ2NzLWZpbGUtaGVhZGVyLWNvbnRlbnQtbGVuZ3RoJztcbmNvbnN0IEdDU19GSUxFX0hFQURFUl9FTkNSWVBUSU9OX01FVEFEQVRBID0gJ2djcy1maWxlLWhlYWRlci1lbmNyeXB0aW9uLW1ldGFkYXRhJztcblxuY29uc3QgSFRUUF9IRUFERVJfQ09OVEVOVF9FTkNPRElORyA9ICdDb250ZW50LUVuY29kaW5nJztcbmNvbnN0IHJlc3VsdFN0YXR1cyA9IHJlcXVpcmUoJy4uL2ZpbGVfdXRpbCcpLnJlc3VsdFN0YXR1cztcblxuY29uc3QgeyBTdG9yYWdlIH0gPSByZXF1aXJlKCdAZ29vZ2xlLWNsb3VkL3N0b3JhZ2UnKTtcblxuY29uc3QgRVhQSVJFRF9UT0tFTiA9ICdFeHBpcmVkVG9rZW4nO1xuXG5jb25zdCBFUlJPUk5PX1dTQUVDT05OQUJPUlRFRCA9IDEwMDUzOyAgLy8gbmV0d29yayBjb25uZWN0aW9uIHdhcyBhYm9ydGVkXG5cbi8qKiBcbiAqIEB0eXBlZGVmIHtvYmplY3R9IEdDU0xvY2F0aW9uXG4gKiBAcHJvcGVydHkge3N0cmluZ30gYnVja2V0TmFtZVxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBhdGggXG4gKi9cbmZ1bmN0aW9uIEdDU0xvY2F0aW9uKGJ1Y2tldE5hbWUsIHBhdGgpIHtcbiAgcmV0dXJuIHtcbiAgICAnYnVja2V0TmFtZSc6IGJ1Y2tldE5hbWUsXG4gICAgJ3BhdGgnOiBwYXRoXG4gIH07XG59XG5cbi8qKlxuICogQ3JlYXRlcyBhbiBHQ1MgdXRpbGl0eSBvYmplY3QuXG4gKiBAcGFyYW0ge21vZHVsZX0gY29ubmVjdGlvbkNvbmZpZ1xuICogQHBhcmFtIHttb2R1bGV9IGh0dHBDbGllbnRcbiAqIEBwYXJhbSB7bW9kdWxlfSBmaWxlU3RyZWFtXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBHQ1NVdGlsKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQsIGZpbGVTdHJlYW0pIHtcbiAgbGV0IGF4aW9zID0gaHR0cENsaWVudDtcbiAgY29uc3QgZnMgPSB0eXBlb2YgZmlsZVN0cmVhbSAhPT0gJ3VuZGVmaW5lZCcgPyBmaWxlU3RyZWFtIDogcmVxdWlyZSgnZnMnKTtcbiAgbGV0IGlzUHJveHlFbmFibGVkID0gZmFsc2U7XG5cbiAgLyoqXG4gICogUmV0cmlldmUgdGhlIEdDUyB0b2tlbiBmcm9tIHRoZSBzdGFnZSBpbmZvIG1ldGFkYXRhLlxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IHN0YWdlSW5mb1xuICAqXG4gICogQHJldHVybnMge1N0cmluZ31cbiAgKi9cbiAgdGhpcy5jcmVhdGVDbGllbnQgPSBmdW5jdGlvbiAoc3RhZ2VJbmZvKSB7XG4gICAgY29uc3Qgc3RhZ2VDcmVkZW50aWFscyA9IHN0YWdlSW5mb1snY3JlZHMnXTtcbiAgICBjb25zdCBnY3NUb2tlbiA9IHN0YWdlQ3JlZGVudGlhbHNbJ0dDU19BQ0NFU1NfVE9LRU4nXTtcbiAgICAvL1RPRE86IFNOT1ctMTc4OTc1OSB0aGUgdmFsdWUgaXMgaGFyZGNvZGVkIG5vdywgYnV0IGl0IHNob3VsZCBiZSBzZXJ2ZXIgZHJpdmVuXG4gICAgY29uc3QgaXNSZWdpb25hbFVybEVuYWJsZWQgPSAoc3RhZ2VJbmZvLnJlZ2lvbikudG9Mb3dlckNhc2UoKSA9PT0gJ21lLWNlbnRyYWwyJyB8fCBzdGFnZUluZm8udXNlUmVnaW9uYWxVcmw7XG4gICAgbGV0IGVuZFBvaW50ID0gbnVsbDtcbiAgICBpZiAoc3RhZ2VJbmZvWydlbmRQb2ludCddKSB7XG4gICAgICBlbmRQb2ludCA9IHN0YWdlSW5mb1snZW5kUG9pbnQnXTtcbiAgICB9IGVsc2UgaWYgKGlzUmVnaW9uYWxVcmxFbmFibGVkKSB7XG4gICAgICBlbmRQb2ludCA9IGBzdG9yYWdlLiR7c3RhZ2VJbmZvLnJlZ2lvbi50b0xvd2VyQ2FzZSgpfS5yZXAuZ29vZ2xlYXBpcy5jb21gO1xuICAgIH1cblxuICAgIGxldCBjbGllbnQ7XG4gICAgaWYgKGdjc1Rva2VuKSB7XG4gICAgICBjb25zdCBpbnRlcmNlcHRvcnMgPSBbXTtcbiAgICAgIGludGVyY2VwdG9ycy5wdXNoKHtcbiAgICAgICAgcmVxdWVzdDogKHJlcXVlc3RDb25maWcpID0+IHtcbiAgICAgICAgICByZXF1ZXN0Q29uZmlnLmhlYWRlcnMgPSByZXF1ZXN0Q29uZmlnLmhlYWRlcnMgfHwge307XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihyZXF1ZXN0Q29uZmlnLmhlYWRlcnMsIHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke2djc1Rva2VufWAgfSk7XG4gICAgICAgICAgcmV0dXJuIHJlcXVlc3RDb25maWc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBjb25zdCBzdG9yYWdlID0gVXRpbC5leGlzdHMoZW5kUG9pbnQpID8gbmV3IFN0b3JhZ2UoeyBpbnRlcmNlcHRvcnNfOiBpbnRlcmNlcHRvcnMsIGFwaUVuZHBvaW50OiBlbmRQb2ludCB9KSA6IG5ldyBTdG9yYWdlKHsgaW50ZXJjZXB0b3JzXzogaW50ZXJjZXB0b3JzIH0pO1xuICAgICAgY2xpZW50ID0geyBnY3NUb2tlbjogZ2NzVG9rZW4sIGdjc0NsaWVudDogc3RvcmFnZSB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGllbnQgPSBudWxsO1xuICAgIH1cblxuICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gdGhpcy5zZXR1cEh0dHBDbGllbnQoZW5kUG9pbnQpKTtcblxuICAgIHJldHVybiBjbGllbnQ7XG4gIH07XG5cbiAgLyoqXG4gICogRXh0cmFjdCB0aGUgYnVja2V0IG5hbWUgYW5kIHBhdGggZnJvbSB0aGUgbWV0YWRhdGEncyBzdGFnZSBsb2NhdGlvbi5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBzdGFnZUxvY2F0aW9uXG4gICpcbiAgKiBAcmV0dXJucyB7R0NTTG9jYXRpb259XG4gICovXG4gIHRoaXMuZXh0cmFjdEJ1Y2tldE5hbWVBbmRQYXRoID0gZnVuY3Rpb24gKHN0YWdlTG9jYXRpb24pIHtcbiAgICBsZXQgY29udGFpbmVyTmFtZSA9IHN0YWdlTG9jYXRpb247XG4gICAgbGV0IHBhdGggPSAnJztcblxuICAgIC8vIHNwbGl0IHN0YWdlIGxvY2F0aW9uIGFzIGJ1Y2tldCBuYW1lIGFuZCBwYXRoXG4gICAgaWYgKHN0YWdlTG9jYXRpb24uaW5jbHVkZXMoJy8nKSkge1xuICAgICAgY29udGFpbmVyTmFtZSA9IHN0YWdlTG9jYXRpb24uc3Vic3RyaW5nKDAsIHN0YWdlTG9jYXRpb24uaW5kZXhPZignLycpKTtcblxuICAgICAgcGF0aCA9IHN0YWdlTG9jYXRpb24uc3Vic3RyaW5nKHN0YWdlTG9jYXRpb24uaW5kZXhPZignLycpICsgMSwgc3RhZ2VMb2NhdGlvbi5sZW5ndGgpO1xuICAgICAgaWYgKHBhdGggJiYgIXBhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgICAgICBwYXRoICs9ICcvJztcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gR0NTTG9jYXRpb24oY29udGFpbmVyTmFtZSwgcGF0aCk7XG4gIH07XG5cbiAgLyoqXG4gICogQ3JlYXRlIGZpbGUgaGVhZGVyIGJhc2VkIG9uIGZpbGUgYmVpbmcgdXBsb2FkZWQgb3Igbm90LlxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAgKlxuICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICovXG4gIHRoaXMuZ2V0RmlsZUhlYWRlciA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhLCBmaWxlbmFtZSkge1xuICAgIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlVQTE9BREVEIHx8XG4gICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLkRPV05MT0FERUQpIHtcbiAgICAgIHJldHVybiBGaWxlSGVhZGVyKFxuICAgICAgICBtZXRhW0dDU19GSUxFX0hFQURFUl9ESUdFU1RdLFxuICAgICAgICBtZXRhW0dDU19GSUxFX0hFQURFUl9DT05URU5UX0xFTkdUSF0sXG4gICAgICAgIG1ldGFbR0NTX0ZJTEVfSEVBREVSX0VOQ1JZUFRJT05fTUVUQURBVEFdXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobWV0YVsncHJlc2lnbmVkVXJsJ10pIHtcbiAgICAgICAgYXdhaXQgYXhpb3MuZ2V0KG1ldGFbJ3ByZXNpZ25lZFVybCddKVxuICAgICAgICAgIC5jYXRjaChlcnIgPT4ge1xuICAgICAgICAgICAgaWYgKFs0MDEsIDQwMywgNDA0XS5pbmNsdWRlcyhlcnIucmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgICAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5OT1RfRk9VTkRfRklMRTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHVybCA9IHRoaXMuZ2VuZXJhdGVGaWxlVVJMKG1ldGEuc3RhZ2VJbmZvLCBsc3RyaXAoZmlsZW5hbWUsICcvJykpO1xuICAgICAgICBjb25zdCBhY2Nlc3NUb2tlbiA9IG1ldGFbJ2NsaWVudCddLmdjc1Rva2VuO1xuICAgICAgICBjb25zdCBnY3NIZWFkZXJzID0geyAnQXV0aG9yaXphdGlvbic6IGBCZWFyZXIgJHthY2Nlc3NUb2tlbn1gIH07XG4gICAgICAgIGxldCBlbmNyeXB0aW9uTWV0YWRhdGE7XG4gICAgICAgIGxldCBkaWdlc3Q7XG4gICAgICAgIGxldCBjb250ZW50TGVuZ3RoO1xuICAgICAgICBsZXQgZW5jcnlwdGlvbkRhdGFQcm9wO1xuICAgICAgICBsZXQgbWF0RGVzY0tleTtcblxuICAgICAgICB0cnkge1xuICAgICAgICAgIGlmIChzaG91bGRQZXJmb3JtR0NQQnVja2V0KGFjY2Vzc1Rva2VuKSAmJiAhaXNQcm94eUVuYWJsZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGdjc0xvY2F0aW9uID0gdGhpcy5leHRyYWN0QnVja2V0TmFtZUFuZFBhdGgobWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uJ10pO1xuICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBtZXRhWydjbGllbnQnXS5nY3NDbGllbnRcbiAgICAgICAgICAgICAgLmJ1Y2tldChnY3NMb2NhdGlvbi5idWNrZXROYW1lKVxuICAgICAgICAgICAgICAuZmlsZShnY3NMb2NhdGlvbi5wYXRoICsgZmlsZW5hbWUpXG4gICAgICAgICAgICAgIC5nZXRNZXRhZGF0YSgpO1xuXG4gICAgICAgICAgICBkaWdlc3QgPSBtZXRhZGF0YVswXS5tZXRhZGF0YVtTRkNfRElHRVNUXTtcbiAgICAgICAgICAgIGNvbnRlbnRMZW5ndGggPSBtZXRhZGF0YVswXS5zaXplO1xuICAgICAgICAgICAgZW5jcnlwdGlvbkRhdGFQcm9wID0gbWV0YWRhdGFbMF0ubWV0YWRhdGFbRU5DUllQVElPTkRBVEFQUk9QXTtcbiAgICAgICAgICAgIG1hdERlc2NLZXkgPSBtZXRhZGF0YVswXS5tZXRhZGF0YVtNQVRERVNDX0tFWV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgYXhpb3MuaGVhZCh1cmwsIHsgaGVhZGVyczogZ2NzSGVhZGVycyB9KTtcblxuICAgICAgICAgICAgZGlnZXN0ID0gcmVzcG9uc2UuaGVhZGVyc1tHQ1NfTUVUQURBVEFfU0ZDX0RJR0VTVF07XG4gICAgICAgICAgICBjb250ZW50TGVuZ3RoID0gcmVzcG9uc2UuaGVhZGVyc1snY29udGVudC1sZW5ndGgnXTtcbiAgICAgICAgICAgIGVuY3J5cHRpb25EYXRhUHJvcCA9IHJlc3BvbnNlLmhlYWRlcnNbR0NTX01FVEFEQVRBX0VOQ1JZUFRJT05EQVRBUFJPUF07XG4gICAgICAgICAgICBtYXREZXNjS2V5ID0gcmVzcG9uc2UuaGVhZGVyc1tHQ1NfTUVUQURBVEFfTUFUREVTQ19LRVldO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChlbmNyeXB0aW9uRGF0YVByb3ApIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY3J5cHRpb25EYXRhID0gSlNPTi5wYXJzZShlbmNyeXB0aW9uRGF0YVByb3ApO1xuICAgICAgICAgICAgaWYgKGVuY3J5cHRpb25EYXRhKSB7XG4gICAgICAgICAgICAgIGVuY3J5cHRpb25NZXRhZGF0YSA9IEVuY3J5cHRpb25NZXRhZGF0YShcbiAgICAgICAgICAgICAgICBlbmNyeXB0aW9uRGF0YVsnV3JhcHBlZENvbnRlbnRLZXknXVsnRW5jcnlwdGVkS2V5J10sXG4gICAgICAgICAgICAgICAgZW5jcnlwdGlvbkRhdGFbJ0NvbnRlbnRFbmNyeXB0aW9uSVYnXSxcbiAgICAgICAgICAgICAgICBtYXREZXNjS2V5ID8gbWF0RGVzY0tleSA6IG51bGxcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5VUExPQURFRDtcblxuICAgICAgICAgIHJldHVybiBGaWxlSGVhZGVyKFxuICAgICAgICAgICAgZGlnZXN0LFxuICAgICAgICAgICAgY29udGVudExlbmd0aCxcbiAgICAgICAgICAgIGVuY3J5cHRpb25NZXRhZGF0YVxuICAgICAgICAgICk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGNvbnN0IGVyckNvZGUgPSAhaXNOYU4oZXJyWydjb2RlJ10pICYmICFpc05hTihwYXJzZUludChlcnJbJ2NvZGUnXSkpID8gZXJyWydjb2RlJ10gOiBlcnIucmVzcG9uc2Uuc3RhdHVzO1xuXG4gICAgICAgICAgaWYgKFs0MDMsIDQwOCwgNDI5LCA1MDAsIDUwM10uaW5jbHVkZXMoZXJyQ29kZSkpIHtcbiAgICAgICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVyckNvZGUgPT09IDQwNCkge1xuICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTk9UX0ZPVU5EX0ZJTEU7XG4gICAgICAgICAgfSBlbHNlIGlmIChlcnJDb2RlID09PSA0MDEpIHtcbiAgICAgICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuRVJST1I7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBGaWxlSGVhZGVyKG51bGwsIG51bGwsIG51bGwpO1xuICB9O1xuXG4gIC8qKlxuICAqIENyZWF0ZSB0aGUgZmlsZSBtZXRhZGF0YSB0aGVuIHVwbG9hZCB0aGUgZmlsZS5cbiAgKlxuICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhRmlsZVxuICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICogQHBhcmFtIHtPYmplY3R9IGVuY3J5cHRpb25NZXRhZGF0YVxuICAqIEBwYXJhbSB7TnVtYmVyfSBtYXhDb25jdXJyZW5jeVxuICAqXG4gICogQHJldHVybnMge251bGx9XG4gICovXG4gIHRoaXMudXBsb2FkRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhRmlsZSwgbWV0YSwgZW5jcnlwdGlvbk1ldGFkYXRhLCBtYXhDb25jdXJyZW5jeSkge1xuICAgIGNvbnN0IGZpbGVTdHJlYW0gPSBmcy5yZWFkRmlsZVN5bmMoZGF0YUZpbGUpO1xuICAgIGF3YWl0IHRoaXMudXBsb2FkRmlsZVN0cmVhbShmaWxlU3RyZWFtLCBtZXRhLCBlbmNyeXB0aW9uTWV0YWRhdGEsIG1heENvbmN1cnJlbmN5KTtcbiAgfTtcblxuICAvKipcbiAgICAqIENyZWF0ZSB0aGUgZmlsZSBtZXRhZGF0YSB0aGVuIHVwbG9hZCB0aGUgZmlsZSBzdHJlYW0uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IGZpbGVTdHJlYW1cbiAgICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAgKiBAcGFyYW0ge09iamVjdH0gZW5jcnlwdGlvbk1ldGFkYXRhXG4gICAgKlxuICAgICogQHJldHVybnMge251bGx9XG4gICAgKi9cbiAgdGhpcy51cGxvYWRGaWxlU3RyZWFtID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVTdHJlYW0sIG1ldGEsIGVuY3J5cHRpb25NZXRhZGF0YSkge1xuICAgIGxldCB1cGxvYWRVcmwgPSBtZXRhWydwcmVzaWduZWRVcmwnXTtcbiAgICBsZXQgYWNjZXNzVG9rZW4gPSBudWxsO1xuXG4gICAgaWYgKCF1cGxvYWRVcmwpIHtcbiAgICAgIGNvbnN0IHRlbXBGaWxlbmFtZSA9IG1ldGFbJ2RzdEZpbGVOYW1lJ10uc3Vic3RyaW5nKG1ldGFbJ2RzdEZpbGVOYW1lJ10uaW5kZXhPZignLycpICsgMSwgbWV0YVsnZHN0RmlsZU5hbWUnXS5sZW5ndGgpO1xuXG4gICAgICB1cGxvYWRVcmwgPSB0aGlzLmdlbmVyYXRlRmlsZVVSTChtZXRhLnN0YWdlSW5mbywgdGVtcEZpbGVuYW1lKTtcbiAgICAgIGFjY2Vzc1Rva2VuID0gbWV0YVsnY2xpZW50J10uZ2NzVG9rZW47XG4gICAgfVxuICAgIGxldCBjb250ZW50RW5jb2RpbmcgPSAnJztcblxuICAgIGlmIChtZXRhWydkc3RDb21wcmVzc2lvblR5cGUnXSkge1xuICAgICAgY29udGVudEVuY29kaW5nID0gbWV0YVsnZHN0Q29tcHJlc3Npb25UeXBlJ11bJ25hbWUnXTtcbiAgICAgIGNvbnRlbnRFbmNvZGluZyA9IGNvbnRlbnRFbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIFdlIHNldCB0aGUgY29udGVudEVuY29kaW5nIHRvIGJsYW5rIGZvciB0aGUgZm9sbG93aW5nIGZpbGUgdHlwZXNcbiAgICBpZiAoWydnemlwJywgJ2J6aXAyJywgJ2Jyb3RsaScsICdkZWZsYXRlJywgJ3Jhd19kZWZsYXRlJywgJ3pzdGQnXS5pbmNsdWRlcyhjb250ZW50RW5jb2RpbmcpKSB7XG4gICAgICBjb250ZW50RW5jb2RpbmcgPSAnJztcbiAgICB9XG5cbiAgICBjb25zdCBnY3NIZWFkZXJzID0ge1xuICAgICAgW0hUVFBfSEVBREVSX0NPTlRFTlRfRU5DT0RJTkddOiBjb250ZW50RW5jb2RpbmcsXG4gICAgICBbR0NTX01FVEFEQVRBX1NGQ19ESUdFU1RdOiBtZXRhWydTSEEyNTZfRElHRVNUJ10sXG4gICAgfTtcblxuICAgIGlmIChhY2Nlc3NUb2tlbikge1xuICAgICAgZ2NzSGVhZGVyc1snQXV0aG9yaXphdGlvbiddID0gYEJlYXJlciAke2FjY2Vzc1Rva2VufWA7XG4gICAgfVxuXG4gICAgaWYgKGVuY3J5cHRpb25NZXRhZGF0YSkge1xuICAgICAgZ2NzSGVhZGVyc1tHQ1NfTUVUQURBVEFfRU5DUllQVElPTkRBVEFQUk9QXSA9XG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAnRW5jcnlwdGlvbk1vZGUnOiAnRnVsbEJsb2InLFxuICAgICAgICAgICdXcmFwcGVkQ29udGVudEtleSc6IHtcbiAgICAgICAgICAgICdLZXlJZCc6ICdzeW1tS2V5MScsXG4gICAgICAgICAgICAnRW5jcnlwdGVkS2V5JzogZW5jcnlwdGlvbk1ldGFkYXRhLmtleSxcbiAgICAgICAgICAgICdBbGdvcml0aG0nOiAnQUVTX0NCQ18yNTYnXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnRW5jcnlwdGlvbkFnZW50Jzoge1xuICAgICAgICAgICAgJ1Byb3RvY29sJzogJzEuMCcsXG4gICAgICAgICAgICAnRW5jcnlwdGlvbkFsZ29yaXRobSc6ICdBRVNfQ0JDXzI1NicsXG4gICAgICAgICAgfSxcbiAgICAgICAgICAnQ29udGVudEVuY3J5cHRpb25JVic6IGVuY3J5cHRpb25NZXRhZGF0YS5pdixcbiAgICAgICAgICAnS2V5V3JhcHBpbmdNZXRhZGF0YSc6IHtcbiAgICAgICAgICAgICdFbmNyeXB0aW9uTGlicmFyeSc6ICdKYXZhIDUuMy4wJ1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICBnY3NIZWFkZXJzW0dDU19NRVRBREFUQV9NQVRERVNDX0tFWV0gPSBlbmNyeXB0aW9uTWV0YWRhdGEubWF0RGVzYztcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHNob3VsZFBlcmZvcm1HQ1BCdWNrZXQoYWNjZXNzVG9rZW4pICYmICFpc1Byb3h5RW5hYmxlZCkge1xuICAgICAgICBjb25zdCBnY3NMb2NhdGlvbiA9IHRoaXMuZXh0cmFjdEJ1Y2tldE5hbWVBbmRQYXRoKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvbiddKTtcblxuICAgICAgICBhd2FpdCBtZXRhWydjbGllbnQnXS5nY3NDbGllbnRcbiAgICAgICAgICAuYnVja2V0KGdjc0xvY2F0aW9uLmJ1Y2tldE5hbWUpXG4gICAgICAgICAgLmZpbGUoZ2NzTG9jYXRpb24ucGF0aCArIG1ldGFbJ2RzdEZpbGVOYW1lJ10pXG4gICAgICAgICAgLnNhdmUoZmlsZVN0cmVhbSwge1xuICAgICAgICAgICAgcmVzdW1hYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgIG1ldGFkYXRhOiB7XG4gICAgICAgICAgICAgICAgW0VOQ1JZUFRJT05EQVRBUFJPUF06IGdjc0hlYWRlcnNbR0NTX01FVEFEQVRBX0VOQ1JZUFRJT05EQVRBUFJPUF0sXG4gICAgICAgICAgICAgICAgW01BVERFU0NfS0VZXTogZ2NzSGVhZGVyc1tHQ1NfTUVUQURBVEFfTUFUREVTQ19LRVldLFxuICAgICAgICAgICAgICAgIFtTRkNfRElHRVNUXTogZ2NzSGVhZGVyc1tHQ1NfTUVUQURBVEFfU0ZDX0RJR0VTVF1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gU2V0IG1heEJvZHlMZW5ndGggdG8gYWxsb3cgbGFyZ2UgZmlsZSB1cGxvYWRpbmdcbiAgICAgICAgYXdhaXQgYXhpb3MucHV0KHVwbG9hZFVybCwgZmlsZVN0cmVhbSwgeyBtYXhCb2R5TGVuZ3RoOiBJbmZpbml0eSwgaGVhZGVyczogZ2NzSGVhZGVycyB9KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChbNDAzLCA0MDgsIDQyOSwgNTAwLCA1MDNdLmluY2x1ZGVzKGVyclsnY29kZSddKSkge1xuICAgICAgICBtZXRhWydsYXN0RXJyb3InXSA9IGVycjtcbiAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWTtcbiAgICAgIH0gZWxzZSBpZiAoIWFjY2Vzc1Rva2VuICYmIGVyclsnY29kZSddID09PSA0MDAgJiZcbiAgICAgICAgKCFtZXRhWydsYXN0RXJyb3InXSB8fCBtZXRhWydsYXN0RXJyb3InXVsnY29kZSddICE9PSA0MDApKSB7XG4gICAgICAgIC8vIE9ubHkgYXR0ZW1wdCB0byByZW5ldyB1cmxzIGlmIHRoaXMgaXNuJ3QgdGhlIHNlY29uZCB0aW1lIHRoaXMgaGFwcGVuc1xuICAgICAgICBtZXRhWydsYXN0RXJyb3InXSA9IGVycjtcbiAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfUFJFU0lHTkVEX1VSTDtcbiAgICAgIH0gZWxzZSBpZiAoYWNjZXNzVG9rZW4gJiYgZXJyWydjb2RlJ10gPT09IDQwMSkge1xuXG4gICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5SRU5FV19UT0tFTjtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBtZXRhWydkc3RGaWxlU2l6ZSddID0gbWV0YVsndXBsb2FkU2l6ZSddO1xuICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlVQTE9BREVEO1xuXG4gICAgbWV0YVtHQ1NfRklMRV9IRUFERVJfRElHRVNUXSA9IGdjc0hlYWRlcnNbR0NTX01FVEFEQVRBX1NGQ19ESUdFU1RdO1xuICAgIG1ldGFbR0NTX0ZJTEVfSEVBREVSX0NPTlRFTlRfTEVOR1RIXSA9IG1ldGFbJ3VwbG9hZFNpemUnXTtcbiAgICBtZXRhW0dDU19GSUxFX0hFQURFUl9FTkNSWVBUSU9OX01FVEFEQVRBXSA9IGdjc0hlYWRlcnNbR0NTX01FVEFEQVRBX0VOQ1JZUFRJT05EQVRBUFJPUF07XG4gIH07XG5cblxuICAvKipcbiAgICogRG93bmxvYWQgdGhlIGZpbGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAqIEBwYXJhbSBmdWxsRHN0UGF0aFxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICovXG4gIHRoaXMubmF0aXZlRG93bmxvYWRGaWxlID0gYXN5bmMgZnVuY3Rpb24gKG1ldGEsIGZ1bGxEc3RQYXRoKSB7XG4gICAgbGV0IGRvd25sb2FkVXJsID0gbWV0YVsncHJlc2lnbmVkVXJsJ107XG4gICAgbGV0IGFjY2Vzc1Rva2VuID0gbnVsbDtcbiAgICBsZXQgZ2NzSGVhZGVycyA9IHt9O1xuXG4gICAgaWYgKCFkb3dubG9hZFVybCkge1xuICAgICAgZG93bmxvYWRVcmwgPSB0aGlzLmdlbmVyYXRlRmlsZVVSTChcbiAgICAgICAgbWV0YS5zdGFnZUluZm8sIGxzdHJpcChtZXRhWydzcmNGaWxlTmFtZSddLCAnLycpXG4gICAgICApO1xuICAgICAgYWNjZXNzVG9rZW4gPSBtZXRhWydjbGllbnQnXS5nY3NUb2tlbjtcbiAgICAgIGdjc0hlYWRlcnMgPSB7ICdBdXRob3JpemF0aW9uJzogYEJlYXJlciAke2FjY2Vzc1Rva2VufWAgfTtcbiAgICB9XG5cbiAgICBsZXQgZW5jcnlwdGlvbkRhdGFwcm9wO1xuICAgIGxldCBtYXREZXNjS2V5O1xuICAgIGxldCBzZmNEaWdlc3Q7XG4gICAgbGV0IHNpemU7XG5cbiAgICB0cnkge1xuICAgICAgaWYgKHNob3VsZFBlcmZvcm1HQ1BCdWNrZXQoYWNjZXNzVG9rZW4pICYmICFpc1Byb3h5RW5hYmxlZCkge1xuICAgICAgICBjb25zdCBnY3NMb2NhdGlvbiA9IHRoaXMuZXh0cmFjdEJ1Y2tldE5hbWVBbmRQYXRoKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvbiddKTtcbiAgICAgICAgYXdhaXQgbWV0YVsnY2xpZW50J10uZ2NzQ2xpZW50XG4gICAgICAgICAgLmJ1Y2tldChnY3NMb2NhdGlvbi5idWNrZXROYW1lKVxuICAgICAgICAgIC5maWxlKGdjc0xvY2F0aW9uLnBhdGggKyBtZXRhWydzcmNGaWxlTmFtZSddKVxuICAgICAgICAgIC5kb3dubG9hZCh7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbjogZnVsbERzdFBhdGhcbiAgICAgICAgICB9KTtcblxuICAgICAgICBjb25zdCBtZXRhZGF0YSA9IGF3YWl0IG1ldGFbJ2NsaWVudCddLmdjc0NsaWVudFxuICAgICAgICAgIC5idWNrZXQoZ2NzTG9jYXRpb24uYnVja2V0TmFtZSlcbiAgICAgICAgICAuZmlsZShnY3NMb2NhdGlvbi5wYXRoICsgbWV0YVsnc3JjRmlsZU5hbWUnXSlcbiAgICAgICAgICAuZ2V0TWV0YWRhdGEoKTtcblxuICAgICAgICBlbmNyeXB0aW9uRGF0YXByb3AgPSBtZXRhZGF0YVswXS5tZXRhZGF0YVtFTkNSWVBUSU9OREFUQVBST1BdO1xuICAgICAgICBtYXREZXNjS2V5ID0gbWV0YWRhdGFbMF0ubWV0YWRhdGFbTUFUREVTQ19LRVldO1xuICAgICAgICBzZmNEaWdlc3QgPSBtZXRhZGF0YVswXS5tZXRhZGF0YVtTRkNfRElHRVNUXTtcbiAgICAgICAgc2l6ZSA9IG1ldGFkYXRhWzBdLnNpemU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICAgIGF3YWl0IGF4aW9zLmdldChkb3dubG9hZFVybCwge1xuICAgICAgICAgIGhlYWRlcnM6IGdjc0hlYWRlcnMsXG4gICAgICAgICAgcmVzcG9uc2VUeXBlOiAnc3RyZWFtJ1xuICAgICAgICB9KS50aGVuKGFzeW5jIChyZXMpID0+IHtcbiAgICAgICAgICByZXNwb25zZSA9IHJlcztcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB3cml0ZXIgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShmdWxsRHN0UGF0aCk7XG4gICAgICAgICAgICByZXNwb25zZS5kYXRhLnBpcGUod3JpdGVyKTtcbiAgICAgICAgICAgIHdyaXRlci5vbignZXJyb3InLCBlcnIgPT4ge1xuICAgICAgICAgICAgICB3cml0ZXIuY2xvc2UoKTtcbiAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHdyaXRlci5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBlbmNyeXB0aW9uRGF0YXByb3AgPSByZXNwb25zZS5oZWFkZXJzW0dDU19NRVRBREFUQV9FTkNSWVBUSU9OREFUQVBST1BdO1xuICAgICAgICBtYXREZXNjS2V5ID0gcmVzcG9uc2UuaGVhZGVyc1tHQ1NfTUVUQURBVEFfTUFUREVTQ19LRVldO1xuICAgICAgICBzZmNEaWdlc3QgPSByZXNwb25zZS5oZWFkZXJzW0dDU19NRVRBREFUQV9TRkNfRElHRVNUXTtcbiAgICAgICAgc2l6ZSA9IHJlc3BvbnNlLmhlYWRlcnNbJ2NvbnRlbnQtbGVuZ3RoJ107XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoZXJyWydjb2RlJ10gPT09IEVYUElSRURfVE9LRU4pIHtcbiAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuUkVORVdfVE9LRU47XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXRhWydsYXN0RXJyb3InXSA9IGVycjtcbiAgICAgICAgaWYgKGVyclsnY29kZSddID09PSBFUlJPUk5PX1dTQUVDT05OQUJPUlRFRCkge1xuICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLk5FRURfUkVUUllfV0lUSF9MT1dFUl9DT05DVVJSRU5DWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGVuY3J5cHRpb25EYXRhO1xuICAgIGlmIChlbmNyeXB0aW9uRGF0YXByb3ApIHtcbiAgICAgIGVuY3J5cHRpb25EYXRhID0gSlNPTi5wYXJzZShlbmNyeXB0aW9uRGF0YXByb3ApO1xuICAgIH1cblxuICAgIGxldCBlbmNyeXB0aW9uTWV0YWRhdGE7XG4gICAgaWYgKGVuY3J5cHRpb25EYXRhKSB7XG4gICAgICBlbmNyeXB0aW9uTWV0YWRhdGEgPSBFbmNyeXB0aW9uTWV0YWRhdGEoXG4gICAgICAgIGVuY3J5cHRpb25EYXRhWydXcmFwcGVkQ29udGVudEtleSddWydFbmNyeXB0ZWRLZXknXSxcbiAgICAgICAgZW5jcnlwdGlvbkRhdGFbJ0NvbnRlbnRFbmNyeXB0aW9uSVYnXSxcbiAgICAgICAgbWF0RGVzY0tleVxuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlSW5mbyA9IGZzLnN0YXRTeW5jKGZ1bGxEc3RQYXRoKTtcbiAgICBtZXRhWydzcmNGaWxlU2l6ZSddID0gZmlsZUluZm8uc2l6ZTtcblxuICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLkRPV05MT0FERUQ7XG5cbiAgICBtZXRhW0dDU19GSUxFX0hFQURFUl9ESUdFU1RdID0gc2ZjRGlnZXN0O1xuICAgIG1ldGFbR0NTX0ZJTEVfSEVBREVSX0NPTlRFTlRfTEVOR1RIXSA9IHNpemU7XG4gICAgbWV0YVtHQ1NfRklMRV9IRUFERVJfRU5DUllQVElPTl9NRVRBREFUQV0gPSBlbmNyeXB0aW9uTWV0YWRhdGE7XG4gIH07XG5cbiAgLyoqXG4gICogR2VuZXJhdGUgZmlsZSBVUkwgYmFzZWQgb24gYnVja2V0LlxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IHN0YWdlSW5mb1xuICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlbmFtZVxuICAqXG4gICogQHJldHVybnMge1N0cmluZ31cbiAgKi9cbiAgdGhpcy5nZW5lcmF0ZUZpbGVVUkwgPSBmdW5jdGlvbiAoc3RhZ2VJbmZvLCBmaWxlbmFtZSkge1xuICAgIGNvbnN0IGdjc0xvY2F0aW9uID0gdGhpcy5leHRyYWN0QnVja2V0TmFtZUFuZFBhdGgoc3RhZ2VJbmZvLmxvY2F0aW9uKTtcbiAgICBjb25zdCBmdWxsRmlsZVBhdGggPSBgJHtnY3NMb2NhdGlvbi5wYXRofSR7ZmlsZW5hbWV9YDtcbiAgICBjb25zdCBlbmRQb2ludCA9IHRoaXMuZ2V0R0NTQ3VzdG9tRW5kUG9pbnQoc3RhZ2VJbmZvKTtcbiAgICBjb25zdCBsaW5rID0gYCR7ZW5kUG9pbnQgIT0gbnVsbCA/IGVuZFBvaW50IDogJ2h0dHBzOi8vc3RvcmFnZS5nb29nbGVhcGlzLmNvbSd9LyR7Z2NzTG9jYXRpb24uYnVja2V0TmFtZX0vJHtmdWxsRmlsZVBhdGh9YDtcbiAgICByZXR1cm4gbGluay5zdGFydHNXaXRoKCdodHRwczovLycpID8gbGluayA6IGBodHRwczovLyR7bGlua31gO1xuICB9O1xuXG4gIHRoaXMuZ2V0R0NTQ3VzdG9tRW5kUG9pbnQgPSBmdW5jdGlvbiAoc3RhZ2VJbmZvKSB7XG4gICAgLy9UT0RPOiBTTk9XLTE3ODk3NTkgaGFyZGNvZGVkIHJlZ2lvbiB3aWxsIGJlIHJlcGxhY2VkIGluIHRoZSBmdXR1cmVcbiAgICBjb25zdCBpc1JlZ2lvbmFsVXJsRW5hYmxlZCA9IChzdGFnZUluZm8ucmVnaW9uKS50b0xvd2VyQ2FzZSgpID09PSAnbWUtY2VudHJhbDInIHx8IHN0YWdlSW5mby51c2VSZWdpb25hbFVybDtcbiAgICBsZXQgZW5kUG9pbnQgPSBudWxsO1xuICAgIGlmIChzdGFnZUluZm9bJ2VuZFBvaW50J10pIHtcbiAgICAgIGVuZFBvaW50ID0gc3RhZ2VJbmZvWydlbmRQb2ludCddO1xuICAgIH0gZWxzZSBpZiAoaXNSZWdpb25hbFVybEVuYWJsZWQpIHtcbiAgICAgIGVuZFBvaW50ID0gYHN0b3JhZ2UuJHtzdGFnZUluZm8ucmVnaW9uLnRvTG93ZXJDYXNlKCl9LnJlcC5nb29nbGVhcGlzLmNvbWA7XG4gICAgfVxuICAgIHJldHVybiBlbmRQb2ludDtcbiAgfTtcblxuICB0aGlzLnNldHVwSHR0cENsaWVudCA9IGZ1bmN0aW9uIChlbmRQb2ludCkge1xuICAgIGlmICh0eXBlb2YgaHR0cENsaWVudCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnN0IHByb3h5ID0gUHJveHlVdGlsLmdldFByb3h5KGNvbm5lY3Rpb25Db25maWcuZ2V0UHJveHkoKSwgJ0dDUyBVdGlsJyk7XG5cbiAgICAgIC8vV2hlbiBodHRwX3Byb3h5IGlzIGVuYWJsZWQsIHRoZSBkcml2ZXIgc2hvdWxkIHVzZSBBeGlvcyBmb3IgSFRUUFMgcmVxdWVzdHMgdG8gYXZvaWQgcmVseWluZyBvbiBIVFRQX1BST1hZIGluIEdDUy5cbiAgICAgIGlmIChwcm94eSB8fCBVdGlsLmdldEVudlZhcignaHR0cF9wcm94eScpKSB7XG4gICAgICAgIGlzUHJveHlFbmFibGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgcHJveHlBZ2VudCA9IGdldFByb3h5QWdlbnQocHJveHksIG5ldyBVUkwoY29ubmVjdGlvbkNvbmZpZy5hY2Nlc3NVcmwpLCBlbmRQb2ludCB8fCAnc3RvcmFnZS5nb29nbGVhcGlzLmNvbScpO1xuICAgICAgICBheGlvcyA9IHJlcXVpcmUoJ2F4aW9zJykuY3JlYXRlKHtcbiAgICAgICAgICBwcm94eTogZmFsc2UsXG4gICAgICAgICAgaHR0cEFnZW50OiBwcm94eUFnZW50LFxuICAgICAgICAgIGh0dHBzQWdlbnQ6IHByb3h5QWdlbnQsXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXhpb3MgPSByZXF1aXJlKCdheGlvcycpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBHQ1NVdGlsO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/gcs_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/local_util.js":
/*!**************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/file_transfer_agent/local_util.js ***!
  \**************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst expandTilde = __webpack_require__(/*! expand-tilde */ \"(rsc)/./node_modules/expand-tilde/index.js\");\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\").resultStatus);\n\n/**\n * Creates a local utility object.\n *\n * @returns {Object}\n * @constructor\n */\nfunction LocalUtil() {\n  this.createClient = function () {\n    return null;\n  };\n\n  /**\n  * Write file to upload.\n  *\n  * @param {Object} meta\n  *\n  * @returns {null}\n  */\n  this.uploadOneFileWithRetry = async function (meta) {\n    await new Promise(function (resolve) {\n      // Create stream object for reader and writer\n      const reader = fs.createReadStream(meta['realSrcFilePath']);\n      // Create directory if doesn't exist\n      if (!fs.existsSync(meta['stageInfo']['location'])) {\n        fs.mkdirSync(meta['stageInfo']['location'], { recursive: true });\n      }\n\n      let output = path.join(meta['stageInfo']['location'], meta['dstFileName']);\n\n      // expand '~' and '~user' expressions\n      if (process.platform !== 'win32') {\n        output = expandTilde(output);\n      }\n\n      const writer = fs.createWriteStream(output);\n      // Write file\n      const result = reader.pipe(writer);\n      result.on('finish', function () {\n        resolve();\n      });\n    });\n\n    meta['dstFileSize'] = meta['uploadSize'];\n    meta['resultStatus'] = resultStatus.UPLOADED;\n  };\n\n  /**\n  * Write file to download.\n  *\n  * @param {Object} meta\n  *\n  * @returns {null}\n  */\n  this.downloadOneFile = async function (meta) {\n    let output;\n    await new Promise(function (resolve) {\n      const srcFilePath = expandTilde(meta['stageInfo']['location']);\n\n      // Create stream object for reader and writer\n      const realSrcFilePath = path.join(srcFilePath, meta['srcFileName']);\n      const reader = fs.createReadStream(realSrcFilePath);\n\n      // Create directory if doesn't exist\n      if (!fs.existsSync(meta['localLocation'])) {\n        fs.mkdirSync(meta['localLocation'], { recursive: true });\n      }\n\n      output = path.join(meta['localLocation'], meta['dstFileName']);\n\n      const writer = fs.createWriteStream(output);\n      // Write file\n      const result = reader.pipe(writer);\n      result.on('finish', function () {\n        resolve();\n      });\n    });\n\n    const fileStat = fs.statSync(output);\n    meta['dstFileSize'] = fileStat.size;\n    meta['resultStatus'] = resultStatus.DOWNLOADED;\n  };\n}\n\nexports.LocalUtil = LocalUtil;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9sb2NhbF91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixvQkFBb0IsbUJBQU8sQ0FBQyxnRUFBYztBQUMxQyxxQkFBcUIsNkdBQW9DOztBQUV6RDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxpQkFBaUI7QUFDdkU7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDhDQUE4QyxpQkFBaUI7QUFDL0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2ZpbGVfdHJhbnNmZXJfYWdlbnQvbG9jYWxfdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZXhwYW5kVGlsZGUgPSByZXF1aXJlKCdleHBhbmQtdGlsZGUnKTtcbmNvbnN0IHJlc3VsdFN0YXR1cyA9IHJlcXVpcmUoJy4uL2ZpbGVfdXRpbCcpLnJlc3VsdFN0YXR1cztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbG9jYWwgdXRpbGl0eSBvYmplY3QuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBMb2NhbFV0aWwoKSB7XG4gIHRoaXMuY3JlYXRlQ2xpZW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuXG4gIC8qKlxuICAqIFdyaXRlIGZpbGUgdG8gdXBsb2FkLlxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgKlxuICAqIEByZXR1cm5zIHtudWxsfVxuICAqL1xuICB0aGlzLnVwbG9hZE9uZUZpbGVXaXRoUmV0cnkgPSBhc3luYyBmdW5jdGlvbiAobWV0YSkge1xuICAgIGF3YWl0IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAvLyBDcmVhdGUgc3RyZWFtIG9iamVjdCBmb3IgcmVhZGVyIGFuZCB3cml0ZXJcbiAgICAgIGNvbnN0IHJlYWRlciA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0obWV0YVsncmVhbFNyY0ZpbGVQYXRoJ10pO1xuICAgICAgLy8gQ3JlYXRlIGRpcmVjdG9yeSBpZiBkb2Vzbid0IGV4aXN0XG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMobWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uJ10pKSB7XG4gICAgICAgIGZzLm1rZGlyU3luYyhtZXRhWydzdGFnZUluZm8nXVsnbG9jYXRpb24nXSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBvdXRwdXQgPSBwYXRoLmpvaW4obWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uJ10sIG1ldGFbJ2RzdEZpbGVOYW1lJ10pO1xuXG4gICAgICAvLyBleHBhbmQgJ34nIGFuZCAnfnVzZXInIGV4cHJlc3Npb25zXG4gICAgICBpZiAocHJvY2Vzcy5wbGF0Zm9ybSAhPT0gJ3dpbjMyJykge1xuICAgICAgICBvdXRwdXQgPSBleHBhbmRUaWxkZShvdXRwdXQpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB3cml0ZXIgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShvdXRwdXQpO1xuICAgICAgLy8gV3JpdGUgZmlsZVxuICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZGVyLnBpcGUod3JpdGVyKTtcbiAgICAgIHJlc3VsdC5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIG1ldGFbJ2RzdEZpbGVTaXplJ10gPSBtZXRhWyd1cGxvYWRTaXplJ107XG4gICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuVVBMT0FERUQ7XG4gIH07XG5cbiAgLyoqXG4gICogV3JpdGUgZmlsZSB0byBkb3dubG9hZC5cbiAgKlxuICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICpcbiAgKiBAcmV0dXJucyB7bnVsbH1cbiAgKi9cbiAgdGhpcy5kb3dubG9hZE9uZUZpbGUgPSBhc3luYyBmdW5jdGlvbiAobWV0YSkge1xuICAgIGxldCBvdXRwdXQ7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIGNvbnN0IHNyY0ZpbGVQYXRoID0gZXhwYW5kVGlsZGUobWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uJ10pO1xuXG4gICAgICAvLyBDcmVhdGUgc3RyZWFtIG9iamVjdCBmb3IgcmVhZGVyIGFuZCB3cml0ZXJcbiAgICAgIGNvbnN0IHJlYWxTcmNGaWxlUGF0aCA9IHBhdGguam9pbihzcmNGaWxlUGF0aCwgbWV0YVsnc3JjRmlsZU5hbWUnXSk7XG4gICAgICBjb25zdCByZWFkZXIgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKHJlYWxTcmNGaWxlUGF0aCk7XG5cbiAgICAgIC8vIENyZWF0ZSBkaXJlY3RvcnkgaWYgZG9lc24ndCBleGlzdFxuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKG1ldGFbJ2xvY2FsTG9jYXRpb24nXSkpIHtcbiAgICAgICAgZnMubWtkaXJTeW5jKG1ldGFbJ2xvY2FsTG9jYXRpb24nXSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICB9XG5cbiAgICAgIG91dHB1dCA9IHBhdGguam9pbihtZXRhWydsb2NhbExvY2F0aW9uJ10sIG1ldGFbJ2RzdEZpbGVOYW1lJ10pO1xuXG4gICAgICBjb25zdCB3cml0ZXIgPSBmcy5jcmVhdGVXcml0ZVN0cmVhbShvdXRwdXQpO1xuICAgICAgLy8gV3JpdGUgZmlsZVxuICAgICAgY29uc3QgcmVzdWx0ID0gcmVhZGVyLnBpcGUod3JpdGVyKTtcbiAgICAgIHJlc3VsdC5vbignZmluaXNoJywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IGZpbGVTdGF0ID0gZnMuc3RhdFN5bmMob3V0cHV0KTtcbiAgICBtZXRhWydkc3RGaWxlU2l6ZSddID0gZmlsZVN0YXQuc2l6ZTtcbiAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5ET1dOTE9BREVEO1xuICB9O1xufVxuXG5leHBvcnRzLkxvY2FsVXRpbCA9IExvY2FsVXRpbDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/local_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/remote_storage_util.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/file_transfer_agent/remote_storage_util.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst SnowflakeS3Util = (__webpack_require__(/*! ./s3_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/s3_util.js\").S3Util);\nconst SnowflakeAzureUtil = __webpack_require__(/*! ./azure_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/azure_util.js\");\nconst SnowflakeGCSUtil = __webpack_require__(/*! ./gcs_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/gcs_util.js\");\n\nconst SnowflakeEncryptionUtil = new ((__webpack_require__(/*! ./encrypt_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/encrypt_util.js\").EncryptUtil))();\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\").resultStatus);\n\nconst DEFAULT_CONCURRENCY = 1;\nconst DEFAULT_MAX_RETRY = 5;\n\n// File Encryption Material\nfunction SnowflakeFileEncryptionMaterial(key, qid, smkid) {\n  const smkidString = '' + smkid;\n  return {\n    'queryStageMasterKey': key, // query stage master key\n    'queryId': qid, // query id\n    'smkId': smkidString  // SMK id\n  };\n}\n\nexports.SnowflakeFileEncryptionMaterial = SnowflakeFileEncryptionMaterial;\n\n/**\n * Creates a remote storage utility object.\n *\n * @returns {Object}\n * @constructor\n */\nfunction RemoteStorageUtil(connectionConfig) {\n  let client = null;\n\n  /**\n  * Get storage type based on location type.\n  *\n  * @param {String} type\n  *\n  * @returns {Object}\n  */\n  this.getForStorageType = function (type) {\n    if (client) {\n      return client;\n    }\n    if (type === 'S3') {\n      client = new SnowflakeS3Util(connectionConfig);\n    } else if (type === 'AZURE') {\n      client = new SnowflakeAzureUtil(connectionConfig);\n    } else if (type === 'GCS') {\n      client = new SnowflakeGCSUtil(connectionConfig);\n    }\n    return client;\n  };\n\n  /**\n  * Create the client based on the location type.\n  */\n  this.createClient = function (stageInfo, useAccelerateEndpoint = false) {\n    const utilClass = this.getForStorageType(stageInfo['locationType']);\n    return utilClass.createClient(stageInfo, useAccelerateEndpoint);\n  };\n\n  /**\n   * Encrypt then upload one file stream.\n   *\n   * @param {Object} meta\n   *\n   * @returns {null}\n   */\n  this.uploadOneFileStream = async function (meta) {\n    let encryptionMetadata;\n    let dataFileStream = meta['fileStream'];\n    \n    if (meta['encryptionMaterial']) {\n      const result = await SnowflakeEncryptionUtil.encryptFileStream(\n        meta['encryptionMaterial'],\n        meta['fileStream']);\n      encryptionMetadata = result.encryptionMetadata;\n      dataFileStream = result.dataStream;\n    }\n\n    const utilClass = this.getForStorageType(meta['stageInfo']['locationType']);\n\n    let maxConcurrency = meta['parallel'];\n    let lastErr;\n    const maxRetry = DEFAULT_MAX_RETRY;\n\n    for (let retry = 0; retry < maxRetry; retry++) {\n      if (!meta['overwrite']) {\n        const fileHeader = await utilClass.getFileHeader(meta, meta['dstFileName']);\n\n        if (fileHeader && meta['resultStatus'] === resultStatus.UPLOADED) {\n          // File already exists\n          meta['dstFileSize'] = 0;\n          meta['resultStatus'] = resultStatus.SKIPPED;\n          return;\n        }\n      }\n      if (meta['overwrite'] || meta['resultStatus'] === resultStatus.NOT_FOUND_FILE) {\n        await utilClass.uploadFileStream(\n          dataFileStream,\n          meta,\n          encryptionMetadata,\n          maxConcurrency);\n      }\n\n      if (meta['resultStatus'] === resultStatus.UPLOADED) {\n        return;\n      } else if (meta['resultStatus'] === resultStatus.RENEW_TOKEN) {\n        return;\n      } else if (meta['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n        return;\n      } else if (meta['resultStatus'] === resultStatus.NEED_RETRY) {\n        lastErr = meta['lastError'];\n        // Failed to upload file, retrying\n        if (!meta['noSleepingTime']) {\n          const sleepingTime = Math.min(Math.pow(2, retry), 16);\n          await new Promise(resolve => setTimeout(resolve, sleepingTime));\n        }\n      } else if (meta['resultStatus'] === resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY) {\n        lastErr = meta['lastError'];\n        // Failed to upload file, retrying with max concurrency\n        maxConcurrency = meta['parallel'] - parseInt(retry * meta['parallel'] / maxRetry);\n        maxConcurrency = Math.max(DEFAULT_CONCURRENCY, maxConcurrency);\n        meta['lastMaxConcurrency'] = maxConcurrency;\n\n        if (!meta['noSleepingTime']) {\n          const sleepingTime = Math.min(Math.pow(2, retry), 16);\n          await new Promise(resolve => setTimeout(resolve, sleepingTime));\n        }\n      }\n    }\n    if (lastErr) {\n      throw new Error(lastErr);\n    } else {\n      const msg = 'Unknown Error in uploading a file: ' + meta['srcFileName'];\n      throw new Error(msg);\n    }\n  };\n\n  /**\n  * Encrypt then upload one file.\n  *\n  * @param {Object} meta\n  *\n  * @returns {null}\n  */\n  this.uploadOneFile = async function (meta) {\n    let encryptionMetadata;\n    let dataFile;\n\n    if (meta['encryptionMaterial']) {\n      const result = await SnowflakeEncryptionUtil.encryptFile(\n        meta['encryptionMaterial'],\n        meta['realSrcFilePath'],\n        meta['tmpDir']);\n      encryptionMetadata = result.encryptionMetadata;\n      dataFile = result.dataFile;\n    } else {\n      dataFile = meta['realSrcFilePath'];\n    }\n\n    const utilClass = this.getForStorageType(meta['stageInfo']['locationType']);\n\n    let maxConcurrency = meta['parallel'];\n    let lastErr;\n    const maxRetry = DEFAULT_MAX_RETRY;\n\n    for (let retry = 0; retry < maxRetry; retry++) {\n      if (!meta['overwrite']) {\n        const fileHeader = await utilClass.getFileHeader(meta, meta['dstFileName']);\n\n        if (fileHeader && meta['resultStatus'] === resultStatus.UPLOADED) {\n          // File already exists\n          meta['dstFileSize'] = 0;\n          meta['resultStatus'] = resultStatus.SKIPPED;\n          return;\n        }\n      }\n      if (meta['overwrite'] || meta['resultStatus'] === resultStatus.NOT_FOUND_FILE) {\n        await utilClass.uploadFile(\n          dataFile,\n          meta,\n          encryptionMetadata,\n          maxConcurrency);\n      }\n\n      if (meta['resultStatus'] === resultStatus.UPLOADED) {\n        return;\n      } else if (meta['resultStatus'] === resultStatus.RENEW_TOKEN) {\n        return;\n      } else if (meta['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n        return;\n      } else if (meta['resultStatus'] === resultStatus.NEED_RETRY) {\n        lastErr = meta['lastError'];\n        // Failed to upload file, retrying\n        if (!meta['noSleepingTime']) {\n          const sleepingTime = Math.min(Math.pow(2, retry), 16);\n          await new Promise(resolve => setTimeout(resolve, sleepingTime));\n        }\n      } else if (meta['resultStatus'] === resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY) {\n        lastErr = meta['lastError'];\n        // Failed to upload file, retrying with max concurrency\n        maxConcurrency = meta['parallel'] - parseInt(retry * meta['parallel'] / maxRetry);\n        maxConcurrency = Math.max(DEFAULT_CONCURRENCY, maxConcurrency);\n        meta['lastMaxConcurrency'] = maxConcurrency;\n\n        if (!meta['noSleepingTime']) {\n          const sleepingTime = Math.min(Math.pow(2, retry), 16);\n          await new Promise(resolve => setTimeout(resolve, sleepingTime));\n        }\n      }\n    }\n    if (lastErr) {\n      throw new Error(lastErr);\n    } else {\n      const msg = 'Unknown Error in uploading a file: ' + dataFile;\n      throw new Error(msg);\n    }\n  };\n\n  /**\n  * Attempt upload of a file and retry if fails.\n  *\n  * @param {Object} meta\n  *\n  * @returns {null}\n  */\n  this.uploadOneFileWithRetry = async function (meta) {\n    const utilClass = this.getForStorageType(meta['stageInfo']['locationType']);\n\n    let breakFlag = false;\n    for (let x = 0; x < 10; x++) {\n      await this.uploadOneFile(meta);\n\n      if (meta['resultStatus'] === resultStatus.UPLOADED) {\n        for (let y = 0; y < 10; y++) {\n          await utilClass.getFileHeader(meta, meta['dstFileName']);\n          if (meta['resultStatus'] === resultStatus.NOT_FOUND_FILE) {\n            // Wait 1 second\n            await new Promise(resolve => setTimeout(resolve, 1000));\n            continue;\n          }\n          break;\n        }\n      }\n      breakFlag = true;\n      break;\n    }\n    if (!breakFlag) {\n      // Could not upload a file even after retry\n      meta['resultStatus'] = resultStatus.ERROR;\n    }\n  };\n\n  /**\n  * Download a file.\n  *\n  * @param {Object} meta\n  *\n  * @returns {null}\n  */\n  this.downloadOneFile = async function (meta) {\n    // Downloads a file from S3\n    let fullDstPath = meta['localLocation'];\n    await new Promise((resolve, reject) => {\n      fs.realpath(fullDstPath, (err, basePath) => {\n        if (err) {\n          reject(err); \n        }\n        fullDstPath = path.join(basePath, path.basename(meta['dstFileName']));\n        resolve();\n      });\n    });\n\n    // TODO: validate fullDstPath is under the writable directory\n    const baseDir = path.dirname(fullDstPath);\n    await new Promise((resolve) => {\n      fs.exists(baseDir, (exists) => {\n        if (!exists) {\n          fs.mkdir(baseDir, () => {\n            resolve();\n          });\n        } else {\n          resolve();\n        }\n      });\n    });\n\n    const utilClass = this.getForStorageType(meta['stageInfo']['locationType']);\n    let fileHeader = await utilClass.getFileHeader(meta, meta['srcFileName']);\n\n    if (fileHeader) {\n      meta['srcFileSize'] = fileHeader.contentLength;\n    }\n\n    let maxConcurrency = meta['parallel'];\n    let lastErr;\n    const maxRetry = DEFAULT_MAX_RETRY;\n\n    for (let retry = 0; retry < maxRetry; retry++) {\n      // Download the file\n      await utilClass.nativeDownloadFile(meta, fullDstPath, maxConcurrency);\n\n      if (meta['resultStatus'] === resultStatus.DOWNLOADED) {\n        if (meta['encryptionMaterial']) {\n          /**\n            * For storage utils that do not have the privilege of\n            * getting the metadata early, both object and metadata\n            * are downloaded at once.In which case, the file meta will\n            * be updated with all the metadata that we need and\n            * then we can call getFileHeader to get just that and also\n            * preserve the idea of getting metadata in the first place.\n            * One example of this is the utils that use presigned url\n            * for upload / download and not the storage client library.\n            **/\n          if (meta['presignedUrl']) {\n            fileHeader = await utilClass.getFileHeader(meta, meta['srcFilePath']);\n          }\n\n          const tmpDstName = await SnowflakeEncryptionUtil.decryptFile(\n            fileHeader.encryptionMetadata,\n            meta['encryptionMaterial'],\n            fullDstPath,\n            meta['tmpDir']);\n\n          // Copy decrypted tmp file to target destination path\n          await new Promise((resolve, reject) => {\n            fs.copyFile(tmpDstName, fullDstPath, async (err) => {\n              if (err) {\n                reject(err); \n              }\n              resolve();\n            });\n          });\n\n          // Delete tmp file\n          await new Promise((resolve, reject) => {\n            fs.unlink(tmpDstName, (err) => {\n              if (err) {\n                reject(err); \n              }\n              resolve();\n            });\n          });\n\n          // Delete tmp folder\n          await new Promise((resolve, reject) => {\n            fs.rmdir(meta['tmpDir'], (err) => {\n              if (err) {\n                reject(err);\n              }\n              resolve();\n            });\n          });\n        }\n        await new Promise((resolve) => {\n          fs.stat(fullDstPath, (err, stat) => {\n            meta['dstFileSize'] = stat.size;\n            resolve();\n          });\n        });\n\n        return;\n      } else if (meta['resultStatus'] === resultStatus.RENEW_TOKEN) {\n        return;\n      } else if (meta['resultStatus'] === resultStatus.RENEW_PRESIGNED_URL) {\n        return;\n      } else if (meta['resultStatus'] === resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY) {\n        lastErr = meta['lastError'];\n        // Failed to download file, retrying with max concurrency\n        maxConcurrency = meta['parallel'] - parseInt(retry * meta['parallel'] / maxRetry);\n        maxConcurrency = Math.max(DEFAULT_CONCURRENCY, maxConcurrency);\n        meta['lastMaxConcurrency'] = maxConcurrency;\n\n        if (!meta['noSleepingTime']) {\n          const sleepingTime = Math.min(Math.pow(2, retry), 16);\n          await new Promise(resolve => setTimeout(resolve, sleepingTime));\n        }\n      } else if (meta['resultStatus'] === resultStatus.NEED_RETRY) {\n        lastErr = meta['lastError'];\n        // Failed to download file, retrying\n        if (!meta['noSleepingTime']) {\n          const sleepingTime = Math.min(Math.pow(2, retry), 16);\n          await new Promise(resolve => setTimeout(resolve, sleepingTime));\n        }\n      }        \n    }\n    if (lastErr) {\n      throw new Error(lastErr);\n    } else {\n      const msg = 'Unknown Error in uploading a file: ' + meta['srcFileName'];\n      throw new Error(msg);\n    }\n  };  \n}\n\nexports.RemoteStorageUtil = RemoteStorageUtil;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9yZW1vdGVfc3RvcmFnZV91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQix3QkFBd0Isc0hBQTJCO0FBQ25ELDJCQUEyQixtQkFBTyxDQUFDLDhGQUFjO0FBQ2pELHlCQUF5QixtQkFBTyxDQUFDLDBGQUFZOztBQUU3QyxxQ0FBcUMscUlBQXFDO0FBQzFFLHFCQUFxQiw2R0FBb0M7O0FBRXpEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVDQUF1Qzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QixrQkFBa0I7QUFDMUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7O0FBRUE7QUFDQSx3QkFBd0IsUUFBUTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLGtCQUFrQjtBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVzs7QUFFWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTOztBQUVUO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9yZW1vdGVfc3RvcmFnZV91dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XG5jb25zdCBTbm93Zmxha2VTM1V0aWwgPSByZXF1aXJlKCcuL3MzX3V0aWwnKS5TM1V0aWw7XG5jb25zdCBTbm93Zmxha2VBenVyZVV0aWwgPSByZXF1aXJlKCcuL2F6dXJlX3V0aWwnKTtcbmNvbnN0IFNub3dmbGFrZUdDU1V0aWwgPSByZXF1aXJlKCcuL2djc191dGlsJyk7XG5cbmNvbnN0IFNub3dmbGFrZUVuY3J5cHRpb25VdGlsID0gbmV3IChyZXF1aXJlKCcuL2VuY3J5cHRfdXRpbCcpLkVuY3J5cHRVdGlsKSgpO1xuY29uc3QgcmVzdWx0U3RhdHVzID0gcmVxdWlyZSgnLi4vZmlsZV91dGlsJykucmVzdWx0U3RhdHVzO1xuXG5jb25zdCBERUZBVUxUX0NPTkNVUlJFTkNZID0gMTtcbmNvbnN0IERFRkFVTFRfTUFYX1JFVFJZID0gNTtcblxuLy8gRmlsZSBFbmNyeXB0aW9uIE1hdGVyaWFsXG5mdW5jdGlvbiBTbm93Zmxha2VGaWxlRW5jcnlwdGlvbk1hdGVyaWFsKGtleSwgcWlkLCBzbWtpZCkge1xuICBjb25zdCBzbWtpZFN0cmluZyA9ICcnICsgc21raWQ7XG4gIHJldHVybiB7XG4gICAgJ3F1ZXJ5U3RhZ2VNYXN0ZXJLZXknOiBrZXksIC8vIHF1ZXJ5IHN0YWdlIG1hc3RlciBrZXlcbiAgICAncXVlcnlJZCc6IHFpZCwgLy8gcXVlcnkgaWRcbiAgICAnc21rSWQnOiBzbWtpZFN0cmluZyAgLy8gU01LIGlkXG4gIH07XG59XG5cbmV4cG9ydHMuU25vd2ZsYWtlRmlsZUVuY3J5cHRpb25NYXRlcmlhbCA9IFNub3dmbGFrZUZpbGVFbmNyeXB0aW9uTWF0ZXJpYWw7XG5cbi8qKlxuICogQ3JlYXRlcyBhIHJlbW90ZSBzdG9yYWdlIHV0aWxpdHkgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gUmVtb3RlU3RvcmFnZVV0aWwoY29ubmVjdGlvbkNvbmZpZykge1xuICBsZXQgY2xpZW50ID0gbnVsbDtcblxuICAvKipcbiAgKiBHZXQgc3RvcmFnZSB0eXBlIGJhc2VkIG9uIGxvY2F0aW9uIHR5cGUuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICAqXG4gICogQHJldHVybnMge09iamVjdH1cbiAgKi9cbiAgdGhpcy5nZXRGb3JTdG9yYWdlVHlwZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgaWYgKGNsaWVudCkge1xuICAgICAgcmV0dXJuIGNsaWVudDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09ICdTMycpIHtcbiAgICAgIGNsaWVudCA9IG5ldyBTbm93Zmxha2VTM1V0aWwoY29ubmVjdGlvbkNvbmZpZyk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnQVpVUkUnKSB7XG4gICAgICBjbGllbnQgPSBuZXcgU25vd2ZsYWtlQXp1cmVVdGlsKGNvbm5lY3Rpb25Db25maWcpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ0dDUycpIHtcbiAgICAgIGNsaWVudCA9IG5ldyBTbm93Zmxha2VHQ1NVdGlsKGNvbm5lY3Rpb25Db25maWcpO1xuICAgIH1cbiAgICByZXR1cm4gY2xpZW50O1xuICB9O1xuXG4gIC8qKlxuICAqIENyZWF0ZSB0aGUgY2xpZW50IGJhc2VkIG9uIHRoZSBsb2NhdGlvbiB0eXBlLlxuICAqL1xuICB0aGlzLmNyZWF0ZUNsaWVudCA9IGZ1bmN0aW9uIChzdGFnZUluZm8sIHVzZUFjY2VsZXJhdGVFbmRwb2ludCA9IGZhbHNlKSB7XG4gICAgY29uc3QgdXRpbENsYXNzID0gdGhpcy5nZXRGb3JTdG9yYWdlVHlwZShzdGFnZUluZm9bJ2xvY2F0aW9uVHlwZSddKTtcbiAgICByZXR1cm4gdXRpbENsYXNzLmNyZWF0ZUNsaWVudChzdGFnZUluZm8sIHVzZUFjY2VsZXJhdGVFbmRwb2ludCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEVuY3J5cHQgdGhlbiB1cGxvYWQgb25lIGZpbGUgc3RyZWFtLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVsbH1cbiAgICovXG4gIHRoaXMudXBsb2FkT25lRmlsZVN0cmVhbSA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhKSB7XG4gICAgbGV0IGVuY3J5cHRpb25NZXRhZGF0YTtcbiAgICBsZXQgZGF0YUZpbGVTdHJlYW0gPSBtZXRhWydmaWxlU3RyZWFtJ107XG4gICAgXG4gICAgaWYgKG1ldGFbJ2VuY3J5cHRpb25NYXRlcmlhbCddKSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBTbm93Zmxha2VFbmNyeXB0aW9uVXRpbC5lbmNyeXB0RmlsZVN0cmVhbShcbiAgICAgICAgbWV0YVsnZW5jcnlwdGlvbk1hdGVyaWFsJ10sXG4gICAgICAgIG1ldGFbJ2ZpbGVTdHJlYW0nXSk7XG4gICAgICBlbmNyeXB0aW9uTWV0YWRhdGEgPSByZXN1bHQuZW5jcnlwdGlvbk1ldGFkYXRhO1xuICAgICAgZGF0YUZpbGVTdHJlYW0gPSByZXN1bHQuZGF0YVN0cmVhbTtcbiAgICB9XG5cbiAgICBjb25zdCB1dGlsQ2xhc3MgPSB0aGlzLmdldEZvclN0b3JhZ2VUeXBlKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvblR5cGUnXSk7XG5cbiAgICBsZXQgbWF4Q29uY3VycmVuY3kgPSBtZXRhWydwYXJhbGxlbCddO1xuICAgIGxldCBsYXN0RXJyO1xuICAgIGNvbnN0IG1heFJldHJ5ID0gREVGQVVMVF9NQVhfUkVUUlk7XG5cbiAgICBmb3IgKGxldCByZXRyeSA9IDA7IHJldHJ5IDwgbWF4UmV0cnk7IHJldHJ5KyspIHtcbiAgICAgIGlmICghbWV0YVsnb3ZlcndyaXRlJ10pIHtcbiAgICAgICAgY29uc3QgZmlsZUhlYWRlciA9IGF3YWl0IHV0aWxDbGFzcy5nZXRGaWxlSGVhZGVyKG1ldGEsIG1ldGFbJ2RzdEZpbGVOYW1lJ10pO1xuXG4gICAgICAgIGlmIChmaWxlSGVhZGVyICYmIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuVVBMT0FERUQpIHtcbiAgICAgICAgICAvLyBGaWxlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgbWV0YVsnZHN0RmlsZVNpemUnXSA9IDA7XG4gICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuU0tJUFBFRDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXRhWydvdmVyd3JpdGUnXSB8fCBtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLk5PVF9GT1VORF9GSUxFKSB7XG4gICAgICAgIGF3YWl0IHV0aWxDbGFzcy51cGxvYWRGaWxlU3RyZWFtKFxuICAgICAgICAgIGRhdGFGaWxlU3RyZWFtLFxuICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgZW5jcnlwdGlvbk1ldGFkYXRhLFxuICAgICAgICAgIG1heENvbmN1cnJlbmN5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuVVBMT0FERUQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5SRU5FV19QUkVTSUdORURfVVJMKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZKSB7XG4gICAgICAgIGxhc3RFcnIgPSBtZXRhWydsYXN0RXJyb3InXTtcbiAgICAgICAgLy8gRmFpbGVkIHRvIHVwbG9hZCBmaWxlLCByZXRyeWluZ1xuICAgICAgICBpZiAoIW1ldGFbJ25vU2xlZXBpbmdUaW1lJ10pIHtcbiAgICAgICAgICBjb25zdCBzbGVlcGluZ1RpbWUgPSBNYXRoLm1pbihNYXRoLnBvdygyLCByZXRyeSksIDE2KTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgc2xlZXBpbmdUaW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZX1dJVEhfTE9XRVJfQ09OQ1VSUkVOQ1kpIHtcbiAgICAgICAgbGFzdEVyciA9IG1ldGFbJ2xhc3RFcnJvciddO1xuICAgICAgICAvLyBGYWlsZWQgdG8gdXBsb2FkIGZpbGUsIHJldHJ5aW5nIHdpdGggbWF4IGNvbmN1cnJlbmN5XG4gICAgICAgIG1heENvbmN1cnJlbmN5ID0gbWV0YVsncGFyYWxsZWwnXSAtIHBhcnNlSW50KHJldHJ5ICogbWV0YVsncGFyYWxsZWwnXSAvIG1heFJldHJ5KTtcbiAgICAgICAgbWF4Q29uY3VycmVuY3kgPSBNYXRoLm1heChERUZBVUxUX0NPTkNVUlJFTkNZLCBtYXhDb25jdXJyZW5jeSk7XG4gICAgICAgIG1ldGFbJ2xhc3RNYXhDb25jdXJyZW5jeSddID0gbWF4Q29uY3VycmVuY3k7XG5cbiAgICAgICAgaWYgKCFtZXRhWydub1NsZWVwaW5nVGltZSddKSB7XG4gICAgICAgICAgY29uc3Qgc2xlZXBpbmdUaW1lID0gTWF0aC5taW4oTWF0aC5wb3coMiwgcmV0cnkpLCAxNik7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHNsZWVwaW5nVGltZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0RXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobGFzdEVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdVbmtub3duIEVycm9yIGluIHVwbG9hZGluZyBhIGZpbGU6ICcgKyBtZXRhWydzcmNGaWxlTmFtZSddO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAqIEVuY3J5cHQgdGhlbiB1cGxvYWQgb25lIGZpbGUuXG4gICpcbiAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAqXG4gICogQHJldHVybnMge251bGx9XG4gICovXG4gIHRoaXMudXBsb2FkT25lRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhKSB7XG4gICAgbGV0IGVuY3J5cHRpb25NZXRhZGF0YTtcbiAgICBsZXQgZGF0YUZpbGU7XG5cbiAgICBpZiAobWV0YVsnZW5jcnlwdGlvbk1hdGVyaWFsJ10pIHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IFNub3dmbGFrZUVuY3J5cHRpb25VdGlsLmVuY3J5cHRGaWxlKFxuICAgICAgICBtZXRhWydlbmNyeXB0aW9uTWF0ZXJpYWwnXSxcbiAgICAgICAgbWV0YVsncmVhbFNyY0ZpbGVQYXRoJ10sXG4gICAgICAgIG1ldGFbJ3RtcERpciddKTtcbiAgICAgIGVuY3J5cHRpb25NZXRhZGF0YSA9IHJlc3VsdC5lbmNyeXB0aW9uTWV0YWRhdGE7XG4gICAgICBkYXRhRmlsZSA9IHJlc3VsdC5kYXRhRmlsZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YUZpbGUgPSBtZXRhWydyZWFsU3JjRmlsZVBhdGgnXTtcbiAgICB9XG5cbiAgICBjb25zdCB1dGlsQ2xhc3MgPSB0aGlzLmdldEZvclN0b3JhZ2VUeXBlKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvblR5cGUnXSk7XG5cbiAgICBsZXQgbWF4Q29uY3VycmVuY3kgPSBtZXRhWydwYXJhbGxlbCddO1xuICAgIGxldCBsYXN0RXJyO1xuICAgIGNvbnN0IG1heFJldHJ5ID0gREVGQVVMVF9NQVhfUkVUUlk7XG5cbiAgICBmb3IgKGxldCByZXRyeSA9IDA7IHJldHJ5IDwgbWF4UmV0cnk7IHJldHJ5KyspIHtcbiAgICAgIGlmICghbWV0YVsnb3ZlcndyaXRlJ10pIHtcbiAgICAgICAgY29uc3QgZmlsZUhlYWRlciA9IGF3YWl0IHV0aWxDbGFzcy5nZXRGaWxlSGVhZGVyKG1ldGEsIG1ldGFbJ2RzdEZpbGVOYW1lJ10pO1xuXG4gICAgICAgIGlmIChmaWxlSGVhZGVyICYmIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuVVBMT0FERUQpIHtcbiAgICAgICAgICAvLyBGaWxlIGFscmVhZHkgZXhpc3RzXG4gICAgICAgICAgbWV0YVsnZHN0RmlsZVNpemUnXSA9IDA7XG4gICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuU0tJUFBFRDtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtZXRhWydvdmVyd3JpdGUnXSB8fCBtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLk5PVF9GT1VORF9GSUxFKSB7XG4gICAgICAgIGF3YWl0IHV0aWxDbGFzcy51cGxvYWRGaWxlKFxuICAgICAgICAgIGRhdGFGaWxlLFxuICAgICAgICAgIG1ldGEsXG4gICAgICAgICAgZW5jcnlwdGlvbk1ldGFkYXRhLFxuICAgICAgICAgIG1heENvbmN1cnJlbmN5KTtcbiAgICAgIH1cblxuICAgICAgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuVVBMT0FERUQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5SRU5FV19QUkVTSUdORURfVVJMKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZKSB7XG4gICAgICAgIGxhc3RFcnIgPSBtZXRhWydsYXN0RXJyb3InXTtcbiAgICAgICAgLy8gRmFpbGVkIHRvIHVwbG9hZCBmaWxlLCByZXRyeWluZ1xuICAgICAgICBpZiAoIW1ldGFbJ25vU2xlZXBpbmdUaW1lJ10pIHtcbiAgICAgICAgICBjb25zdCBzbGVlcGluZ1RpbWUgPSBNYXRoLm1pbihNYXRoLnBvdygyLCByZXRyeSksIDE2KTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgc2xlZXBpbmdUaW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZX1dJVEhfTE9XRVJfQ09OQ1VSUkVOQ1kpIHtcbiAgICAgICAgbGFzdEVyciA9IG1ldGFbJ2xhc3RFcnJvciddO1xuICAgICAgICAvLyBGYWlsZWQgdG8gdXBsb2FkIGZpbGUsIHJldHJ5aW5nIHdpdGggbWF4IGNvbmN1cnJlbmN5XG4gICAgICAgIG1heENvbmN1cnJlbmN5ID0gbWV0YVsncGFyYWxsZWwnXSAtIHBhcnNlSW50KHJldHJ5ICogbWV0YVsncGFyYWxsZWwnXSAvIG1heFJldHJ5KTtcbiAgICAgICAgbWF4Q29uY3VycmVuY3kgPSBNYXRoLm1heChERUZBVUxUX0NPTkNVUlJFTkNZLCBtYXhDb25jdXJyZW5jeSk7XG4gICAgICAgIG1ldGFbJ2xhc3RNYXhDb25jdXJyZW5jeSddID0gbWF4Q29uY3VycmVuY3k7XG5cbiAgICAgICAgaWYgKCFtZXRhWydub1NsZWVwaW5nVGltZSddKSB7XG4gICAgICAgICAgY29uc3Qgc2xlZXBpbmdUaW1lID0gTWF0aC5taW4oTWF0aC5wb3coMiwgcmV0cnkpLCAxNik7XG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIHNsZWVwaW5nVGltZSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChsYXN0RXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobGFzdEVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdVbmtub3duIEVycm9yIGluIHVwbG9hZGluZyBhIGZpbGU6ICcgKyBkYXRhRmlsZTtcbiAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgKiBBdHRlbXB0IHVwbG9hZCBvZiBhIGZpbGUgYW5kIHJldHJ5IGlmIGZhaWxzLlxuICAqXG4gICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgKlxuICAqIEByZXR1cm5zIHtudWxsfVxuICAqL1xuICB0aGlzLnVwbG9hZE9uZUZpbGVXaXRoUmV0cnkgPSBhc3luYyBmdW5jdGlvbiAobWV0YSkge1xuICAgIGNvbnN0IHV0aWxDbGFzcyA9IHRoaXMuZ2V0Rm9yU3RvcmFnZVR5cGUobWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uVHlwZSddKTtcblxuICAgIGxldCBicmVha0ZsYWcgPSBmYWxzZTtcbiAgICBmb3IgKGxldCB4ID0gMDsgeCA8IDEwOyB4KyspIHtcbiAgICAgIGF3YWl0IHRoaXMudXBsb2FkT25lRmlsZShtZXRhKTtcblxuICAgICAgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuVVBMT0FERUQpIHtcbiAgICAgICAgZm9yIChsZXQgeSA9IDA7IHkgPCAxMDsgeSsrKSB7XG4gICAgICAgICAgYXdhaXQgdXRpbENsYXNzLmdldEZpbGVIZWFkZXIobWV0YSwgbWV0YVsnZHN0RmlsZU5hbWUnXSk7XG4gICAgICAgICAgaWYgKG1ldGFbJ3Jlc3VsdFN0YXR1cyddID09PSByZXN1bHRTdGF0dXMuTk9UX0ZPVU5EX0ZJTEUpIHtcbiAgICAgICAgICAgIC8vIFdhaXQgMSBzZWNvbmRcbiAgICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxMDAwKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrRmxhZyA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKCFicmVha0ZsYWcpIHtcbiAgICAgIC8vIENvdWxkIG5vdCB1cGxvYWQgYSBmaWxlIGV2ZW4gYWZ0ZXIgcmV0cnlcbiAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLkVSUk9SO1xuICAgIH1cbiAgfTtcblxuICAvKipcbiAgKiBEb3dubG9hZCBhIGZpbGUuXG4gICpcbiAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAqXG4gICogQHJldHVybnMge251bGx9XG4gICovXG4gIHRoaXMuZG93bmxvYWRPbmVGaWxlID0gYXN5bmMgZnVuY3Rpb24gKG1ldGEpIHtcbiAgICAvLyBEb3dubG9hZHMgYSBmaWxlIGZyb20gUzNcbiAgICBsZXQgZnVsbERzdFBhdGggPSBtZXRhWydsb2NhbExvY2F0aW9uJ107XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgZnMucmVhbHBhdGgoZnVsbERzdFBhdGgsIChlcnIsIGJhc2VQYXRoKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICByZWplY3QoZXJyKTsgXG4gICAgICAgIH1cbiAgICAgICAgZnVsbERzdFBhdGggPSBwYXRoLmpvaW4oYmFzZVBhdGgsIHBhdGguYmFzZW5hbWUobWV0YVsnZHN0RmlsZU5hbWUnXSkpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8vIFRPRE86IHZhbGlkYXRlIGZ1bGxEc3RQYXRoIGlzIHVuZGVyIHRoZSB3cml0YWJsZSBkaXJlY3RvcnlcbiAgICBjb25zdCBiYXNlRGlyID0gcGF0aC5kaXJuYW1lKGZ1bGxEc3RQYXRoKTtcbiAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgZnMuZXhpc3RzKGJhc2VEaXIsIChleGlzdHMpID0+IHtcbiAgICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgICBmcy5ta2RpcihiYXNlRGlyLCAoKSA9PiB7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGNvbnN0IHV0aWxDbGFzcyA9IHRoaXMuZ2V0Rm9yU3RvcmFnZVR5cGUobWV0YVsnc3RhZ2VJbmZvJ11bJ2xvY2F0aW9uVHlwZSddKTtcbiAgICBsZXQgZmlsZUhlYWRlciA9IGF3YWl0IHV0aWxDbGFzcy5nZXRGaWxlSGVhZGVyKG1ldGEsIG1ldGFbJ3NyY0ZpbGVOYW1lJ10pO1xuXG4gICAgaWYgKGZpbGVIZWFkZXIpIHtcbiAgICAgIG1ldGFbJ3NyY0ZpbGVTaXplJ10gPSBmaWxlSGVhZGVyLmNvbnRlbnRMZW5ndGg7XG4gICAgfVxuXG4gICAgbGV0IG1heENvbmN1cnJlbmN5ID0gbWV0YVsncGFyYWxsZWwnXTtcbiAgICBsZXQgbGFzdEVycjtcbiAgICBjb25zdCBtYXhSZXRyeSA9IERFRkFVTFRfTUFYX1JFVFJZO1xuXG4gICAgZm9yIChsZXQgcmV0cnkgPSAwOyByZXRyeSA8IG1heFJldHJ5OyByZXRyeSsrKSB7XG4gICAgICAvLyBEb3dubG9hZCB0aGUgZmlsZVxuICAgICAgYXdhaXQgdXRpbENsYXNzLm5hdGl2ZURvd25sb2FkRmlsZShtZXRhLCBmdWxsRHN0UGF0aCwgbWF4Q29uY3VycmVuY3kpO1xuXG4gICAgICBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5ET1dOTE9BREVEKSB7XG4gICAgICAgIGlmIChtZXRhWydlbmNyeXB0aW9uTWF0ZXJpYWwnXSkge1xuICAgICAgICAgIC8qKlxuICAgICAgICAgICAgKiBGb3Igc3RvcmFnZSB1dGlscyB0aGF0IGRvIG5vdCBoYXZlIHRoZSBwcml2aWxlZ2Ugb2ZcbiAgICAgICAgICAgICogZ2V0dGluZyB0aGUgbWV0YWRhdGEgZWFybHksIGJvdGggb2JqZWN0IGFuZCBtZXRhZGF0YVxuICAgICAgICAgICAgKiBhcmUgZG93bmxvYWRlZCBhdCBvbmNlLkluIHdoaWNoIGNhc2UsIHRoZSBmaWxlIG1ldGEgd2lsbFxuICAgICAgICAgICAgKiBiZSB1cGRhdGVkIHdpdGggYWxsIHRoZSBtZXRhZGF0YSB0aGF0IHdlIG5lZWQgYW5kXG4gICAgICAgICAgICAqIHRoZW4gd2UgY2FuIGNhbGwgZ2V0RmlsZUhlYWRlciB0byBnZXQganVzdCB0aGF0IGFuZCBhbHNvXG4gICAgICAgICAgICAqIHByZXNlcnZlIHRoZSBpZGVhIG9mIGdldHRpbmcgbWV0YWRhdGEgaW4gdGhlIGZpcnN0IHBsYWNlLlxuICAgICAgICAgICAgKiBPbmUgZXhhbXBsZSBvZiB0aGlzIGlzIHRoZSB1dGlscyB0aGF0IHVzZSBwcmVzaWduZWQgdXJsXG4gICAgICAgICAgICAqIGZvciB1cGxvYWQgLyBkb3dubG9hZCBhbmQgbm90IHRoZSBzdG9yYWdlIGNsaWVudCBsaWJyYXJ5LlxuICAgICAgICAgICAgKiovXG4gICAgICAgICAgaWYgKG1ldGFbJ3ByZXNpZ25lZFVybCddKSB7XG4gICAgICAgICAgICBmaWxlSGVhZGVyID0gYXdhaXQgdXRpbENsYXNzLmdldEZpbGVIZWFkZXIobWV0YSwgbWV0YVsnc3JjRmlsZVBhdGgnXSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgdG1wRHN0TmFtZSA9IGF3YWl0IFNub3dmbGFrZUVuY3J5cHRpb25VdGlsLmRlY3J5cHRGaWxlKFxuICAgICAgICAgICAgZmlsZUhlYWRlci5lbmNyeXB0aW9uTWV0YWRhdGEsXG4gICAgICAgICAgICBtZXRhWydlbmNyeXB0aW9uTWF0ZXJpYWwnXSxcbiAgICAgICAgICAgIGZ1bGxEc3RQYXRoLFxuICAgICAgICAgICAgbWV0YVsndG1wRGlyJ10pO1xuXG4gICAgICAgICAgLy8gQ29weSBkZWNyeXB0ZWQgdG1wIGZpbGUgdG8gdGFyZ2V0IGRlc3RpbmF0aW9uIHBhdGhcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBmcy5jb3B5RmlsZSh0bXBEc3ROYW1lLCBmdWxsRHN0UGF0aCwgYXN5bmMgKGVycikgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7IFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgLy8gRGVsZXRlIHRtcCBmaWxlXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZnMudW5saW5rKHRtcERzdE5hbWUsIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpOyBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIC8vIERlbGV0ZSB0bXAgZm9sZGVyXG4gICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZnMucm1kaXIobWV0YVsndG1wRGlyJ10sIChlcnIpID0+IHtcbiAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiB7XG4gICAgICAgICAgZnMuc3RhdChmdWxsRHN0UGF0aCwgKGVyciwgc3RhdCkgPT4ge1xuICAgICAgICAgICAgbWV0YVsnZHN0RmlsZVNpemUnXSA9IHN0YXQuc2l6ZTtcbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChtZXRhWydyZXN1bHRTdGF0dXMnXSA9PT0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5SRU5FV19QUkVTSUdORURfVVJMKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZX1dJVEhfTE9XRVJfQ09OQ1VSUkVOQ1kpIHtcbiAgICAgICAgbGFzdEVyciA9IG1ldGFbJ2xhc3RFcnJvciddO1xuICAgICAgICAvLyBGYWlsZWQgdG8gZG93bmxvYWQgZmlsZSwgcmV0cnlpbmcgd2l0aCBtYXggY29uY3VycmVuY3lcbiAgICAgICAgbWF4Q29uY3VycmVuY3kgPSBtZXRhWydwYXJhbGxlbCddIC0gcGFyc2VJbnQocmV0cnkgKiBtZXRhWydwYXJhbGxlbCddIC8gbWF4UmV0cnkpO1xuICAgICAgICBtYXhDb25jdXJyZW5jeSA9IE1hdGgubWF4KERFRkFVTFRfQ09OQ1VSUkVOQ1ksIG1heENvbmN1cnJlbmN5KTtcbiAgICAgICAgbWV0YVsnbGFzdE1heENvbmN1cnJlbmN5J10gPSBtYXhDb25jdXJyZW5jeTtcblxuICAgICAgICBpZiAoIW1ldGFbJ25vU2xlZXBpbmdUaW1lJ10pIHtcbiAgICAgICAgICBjb25zdCBzbGVlcGluZ1RpbWUgPSBNYXRoLm1pbihNYXRoLnBvdygyLCByZXRyeSksIDE2KTtcbiAgICAgICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgc2xlZXBpbmdUaW1lKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAobWV0YVsncmVzdWx0U3RhdHVzJ10gPT09IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZKSB7XG4gICAgICAgIGxhc3RFcnIgPSBtZXRhWydsYXN0RXJyb3InXTtcbiAgICAgICAgLy8gRmFpbGVkIHRvIGRvd25sb2FkIGZpbGUsIHJldHJ5aW5nXG4gICAgICAgIGlmICghbWV0YVsnbm9TbGVlcGluZ1RpbWUnXSkge1xuICAgICAgICAgIGNvbnN0IHNsZWVwaW5nVGltZSA9IE1hdGgubWluKE1hdGgucG93KDIsIHJldHJ5KSwgMTYpO1xuICAgICAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBzbGVlcGluZ1RpbWUpKTtcbiAgICAgICAgfVxuICAgICAgfSAgICAgICAgXG4gICAgfVxuICAgIGlmIChsYXN0RXJyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IobGFzdEVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1zZyA9ICdVbmtub3duIEVycm9yIGluIHVwbG9hZGluZyBhIGZpbGU6ICcgKyBtZXRhWydzcmNGaWxlTmFtZSddO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxuICB9OyAgXG59XG5cbmV4cG9ydHMuUmVtb3RlU3RvcmFnZVV0aWwgPSBSZW1vdGVTdG9yYWdlVXRpbDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/remote_storage_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/s3_util.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/file_transfer_agent/s3_util.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { NodeHttpHandler } = __webpack_require__(/*! @smithy/node-http-handler */ \"(rsc)/./node_modules/@smithy/node-http-handler/dist-es/index.js\");\nconst EncryptionMetadata = (__webpack_require__(/*! ./encrypt_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/encrypt_util.js\").EncryptionMetadata);\nconst FileHeader = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\").FileHeader);\nconst expandTilde = __webpack_require__(/*! expand-tilde */ \"(rsc)/./node_modules/expand-tilde/index.js\");\nconst getProxyAgent = (__webpack_require__(/*! ../http/node */ \"(rsc)/./node_modules/snowflake-sdk/lib/http/node.js\").getProxyAgent);\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/proxy_util.js\");\n\nconst AMZ_IV = 'x-amz-iv';\nconst AMZ_KEY = 'x-amz-key';\nconst AMZ_MATDESC = 'x-amz-matdesc';\nconst SFC_DIGEST = 'sfc-digest';\n\nconst EXPIRED_TOKEN = 'ExpiredToken';\nconst NO_SUCH_KEY = 'NoSuchKey';\nconst SNOWFLAKE_S3_DESTINATION = 's3.amazonaws.com';\n\nconst ERRORNO_WSAECONNABORTED = 10053;  // network connection was aborted\nconst DATA_SIZE_THRESHOLD = 67108864; // magic number, given from  error message.\n\nconst resultStatus = (__webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\").resultStatus);\n\nconst HTTP_HEADER_VALUE_OCTET_STREAM = 'application/octet-stream';\n\n// S3 Location: S3 bucket name + path\nfunction S3Location(bucketName, s3path) {\n  return {\n    'bucketName': bucketName, // S3 bucket name\n    's3path': s3path // S3 path name\n  };\n}\n\n/**\n * Creates an S3 utility object.\n *\n * @param connectionConfig\n *\n * @param s3 - used for tests, mock can be supplied\n * @param filestream - used for tests, mock can be supplied\n * @returns {Object}\n * @constructor\n */\nfunction S3Util(connectionConfig, s3, filestream) {\n  const AWS = typeof s3 !== 'undefined' ? s3 : __webpack_require__(/*! @aws-sdk/client-s3 */ \"@aws-sdk/client-s3\");\n  const fs = typeof filestream !== 'undefined' ? filestream : __webpack_require__(/*! fs */ \"fs\");\n  /**\n   * Create an AWS S3 client using an AWS token.\n   */\n  this.createClient = function (stageInfo, useAccelerateEndpoint) {\n    const stageCredentials = stageInfo['creds'];\n    const securityToken = stageCredentials['AWS_TOKEN'];\n    const isRegionalUrlEnabled = stageInfo.useRegionalUrl || stageInfo.useS3RegionalUrl;\n    \n    // if GS sends us an endpoint, it's likely for FIPS. Use it.\n    let endPoint = null;\n    if (stageInfo['endPoint']) {\n      endPoint = `https://${stageInfo['endPoint']}`;\n    } else {\n      if (stageInfo.region && isRegionalUrlEnabled) {\n        const domainSuffixForRegionalUrl = (stageInfo.region).toLowerCase().startsWith('cn-') ? 'amazonaws.com.cn' : 'amazonaws.com';\n        endPoint = `https://s3.${stageInfo.region}.${domainSuffixForRegionalUrl}`;\n      }\n    }\n  \n    const config = {\n      apiVersion: '2006-03-01',\n      region: stageInfo['region'],\n      credentials: {\n        accessKeyId: stageCredentials['AWS_KEY_ID'],\n        secretAccessKey: stageCredentials['AWS_SECRET_KEY'],\n        sessionToken: securityToken,\n      },\n      endpoint: endPoint,\n      useAccelerateEndpoint: useAccelerateEndpoint\n    };\n\n    const proxy = ProxyUtil.getProxy(connectionConfig.getProxy(), 'S3 Util');\n    if (proxy) {\n      const proxyAgent = getProxyAgent(proxy, new URL(connectionConfig.accessUrl), endPoint || SNOWFLAKE_S3_DESTINATION);\n      config.requestHandler = new NodeHttpHandler({\n        httpAgent: proxyAgent,\n        httpsAgent: proxyAgent\n      });\n    }\n\n    return new AWS.S3(config);\n  };\n\n  /**\n   * Get file header based on file being uploaded or not.\n   *\n   * @param {Object} meta\n   * @param {String} filename\n   *\n   * @returns {Object}\n   */\n  this.getFileHeader = async function (meta, filename) {\n    const stageInfo = meta['stageInfo'];\n    const client = this.createClient(stageInfo);\n    const s3location = extractBucketNameAndPath(stageInfo['location']);\n\n    const params = {\n      Bucket: s3location.bucketName,\n      Key: s3location.s3path + filename\n    };\n\n    let akey;\n\n    try {\n      await client.getObject(params)\n        .then(function (data) {\n          akey = data;\n        });\n    } catch (err) {\n      if (err['Code'] === EXPIRED_TOKEN) {\n        meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n        return null;\n      } else if (err['Code'] === NO_SUCH_KEY) {\n        meta['resultStatus'] = resultStatus.NOT_FOUND_FILE;\n        return FileHeader(null, null, null);\n      } else if (err['Code'] === '400') {\n        meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n        return null;\n      } else {\n        meta['resultStatus'] = resultStatus.ERROR;\n        return null;\n      }\n    }\n\n    meta['resultStatus'] = resultStatus.UPLOADED;\n\n    let encryptionMetadata;\n    if (akey && akey.Metadata[AMZ_KEY]) {\n      encryptionMetadata = EncryptionMetadata(\n        akey.Metadata[AMZ_KEY],\n        akey.Metadata[AMZ_IV],\n        akey.Metadata[AMZ_MATDESC]\n      );\n    }\n\n    return FileHeader(\n      akey.Metadata[SFC_DIGEST],\n      akey.ContentLength,\n      encryptionMetadata\n    );\n  };\n\n  /**\n   * Create the file metadata then upload the file.\n   *\n   * @param {String} dataFile\n   * @param {Object} meta\n   * @param {Object} encryptionMetadata\n   */\n  this.uploadFile = async function (dataFile, meta, encryptionMetadata) {\n    const fileStream = fs.readFileSync(dataFile);\n    await this.uploadFileStream(fileStream, meta, encryptionMetadata);\n  };\n\n  /**\n   * Create the file metadata then upload the file stream.\n   *\n   * @param {String} fileStream\n   * @param {Object} meta\n   * @param {Object} encryptionMetadata\n   */\n  this.uploadFileStream = async function (fileStream, meta, encryptionMetadata) {\n    const s3Metadata = {\n      HTTP_HEADER_CONTENT_TYPE: HTTP_HEADER_VALUE_OCTET_STREAM,\n      SFC_DIGEST: meta['SHA256_DIGEST']\n    };\n\n    if (encryptionMetadata) {\n      s3Metadata[AMZ_IV] = encryptionMetadata.iv;\n      s3Metadata[AMZ_KEY] = encryptionMetadata.key;\n      s3Metadata[AMZ_MATDESC] = encryptionMetadata.matDesc;\n    }\n\n    const stageInfo = meta['stageInfo'];\n    const client = this.createClient(stageInfo);\n\n    const s3location = extractBucketNameAndPath(meta['stageInfo']['location']);\n\n    const params = {\n      Bucket: s3location.bucketName,\n      Body: fileStream,\n      Key: s3location.s3path + meta['dstFileName'],\n      Metadata: s3Metadata\n    };\n\n    // call S3 to upload file to specified bucket\n    try {\n      await client.putObject(params);\n    } catch (err) {\n      if (err['Code'] === EXPIRED_TOKEN) {\n        meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n      } else {\n        meta['lastError'] = err;\n        if (err['Code'] === ERRORNO_WSAECONNABORTED.toString()) {\n          meta['resultStatus'] = resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY;\n        } else {\n          meta['resultStatus'] = resultStatus.NEED_RETRY;\n        }\n      }\n      return;\n    }\n\n    meta['dstFileSize'] = meta['uploadSize'];\n    meta['resultStatus'] = resultStatus.UPLOADED;\n  };\n\n  /**\n   * Download the file.\n   *\n   * @param {String} dataFile\n   * @param {Object} meta\n   * @param {Object} encryptionMetadata\n   */\n  this.nativeDownloadFile = async function (meta, fullDstPath) {\n    const stageInfo = meta['stageInfo'];\n    const client = this.createClient(stageInfo);\n\n    const s3location = extractBucketNameAndPath(meta['stageInfo']['location']);\n\n    const params = {\n      Bucket: s3location.bucketName,\n      Key: s3location.s3path + meta['dstFileName'],\n    };\n\n    // call S3 to download file to specified bucket\n    try {\n      await client.getObject(params)\n        .then(data => data.Body.transformToByteArray())\n        .then((data) => {\n          return new Promise((resolve, reject) => {\n            fs.writeFile(fullDstPath, data, 'binary', (err) => {\n              if (err) {\n                reject(err);\n              }\n              resolve();\n            });\n          });\n        });\n    } catch (err) {\n      if (err['Code'] === EXPIRED_TOKEN) {\n        meta['resultStatus'] = resultStatus.RENEW_TOKEN;\n      } else {\n        meta['lastError'] = err;\n        if (err['Code'] === ERRORNO_WSAECONNABORTED.toString()) {\n          meta['resultStatus'] = resultStatus.NEED_RETRY_WITH_LOWER_CONCURRENCY;\n        } else {\n          meta['resultStatus'] = resultStatus.NEED_RETRY;\n        }\n      }\n      return;\n    }\n    meta['resultStatus'] = resultStatus.DOWNLOADED;\n  };\n}\n\n/**\n * Extract the bucket name and path from the metadata's stage location.\n *\n * @param {String} stageLocation\n *\n * @returns {Object}\n */\nfunction extractBucketNameAndPath(stageLocation) {\n  // expand '~' and '~user' expressions\n  if (process.platform !== 'win32') {\n    stageLocation = expandTilde(stageLocation);\n  }\n\n  let bucketName = stageLocation;\n  let s3path;\n\n  // split stage location as bucket name and path\n  if (stageLocation.includes('/')) {\n    bucketName = stageLocation.substring(0, stageLocation.indexOf('/'));\n\n    s3path = stageLocation.substring(stageLocation.indexOf('/') + 1, stageLocation.length);\n    if (s3path && !s3path.endsWith('/')) {\n      s3path += '/';\n    }\n  }\n  return S3Location(bucketName, s3path);\n}\n\nmodule.exports = { S3Util, SNOWFLAKE_S3_DESTINATION, DATA_SIZE_THRESHOLD, extractBucketNameAndPath };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9zM191dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBLFFBQVEsa0JBQWtCLEVBQUUsbUJBQU8sQ0FBQyxrR0FBMkI7QUFDL0QsMkJBQTJCLDRJQUE0QztBQUN2RSxtQkFBbUIsMkdBQWtDO0FBQ3JELG9CQUFvQixtQkFBTyxDQUFDLGdFQUFjO0FBQzFDLHNCQUFzQiw4R0FBcUM7QUFDM0Qsa0JBQWtCLG1CQUFPLENBQUMsMkVBQWU7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0M7QUFDeEMsc0NBQXNDOztBQUV0QyxxQkFBcUIsNkdBQW9DOztBQUV6RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsbUJBQU8sQ0FBQyw4Q0FBb0I7QUFDM0UsOERBQThELG1CQUFPLENBQUMsY0FBSTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRCxNQUFNO0FBQ047QUFDQTtBQUNBLGlDQUFpQyxpQkFBaUIsR0FBRywyQkFBMkI7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxTQUFTO0FBQ1QsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZmlsZV90cmFuc2Zlcl9hZ2VudC9zM191dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHsgTm9kZUh0dHBIYW5kbGVyIH0gPSByZXF1aXJlKCdAc21pdGh5L25vZGUtaHR0cC1oYW5kbGVyJyk7XG5jb25zdCBFbmNyeXB0aW9uTWV0YWRhdGEgPSByZXF1aXJlKCcuL2VuY3J5cHRfdXRpbCcpLkVuY3J5cHRpb25NZXRhZGF0YTtcbmNvbnN0IEZpbGVIZWFkZXIgPSByZXF1aXJlKCcuLi9maWxlX3V0aWwnKS5GaWxlSGVhZGVyO1xuY29uc3QgZXhwYW5kVGlsZGUgPSByZXF1aXJlKCdleHBhbmQtdGlsZGUnKTtcbmNvbnN0IGdldFByb3h5QWdlbnQgPSByZXF1aXJlKCcuLi9odHRwL25vZGUnKS5nZXRQcm94eUFnZW50O1xuY29uc3QgUHJveHlVdGlsID0gcmVxdWlyZSgnLi4vcHJveHlfdXRpbCcpO1xuXG5jb25zdCBBTVpfSVYgPSAneC1hbXotaXYnO1xuY29uc3QgQU1aX0tFWSA9ICd4LWFtei1rZXknO1xuY29uc3QgQU1aX01BVERFU0MgPSAneC1hbXotbWF0ZGVzYyc7XG5jb25zdCBTRkNfRElHRVNUID0gJ3NmYy1kaWdlc3QnO1xuXG5jb25zdCBFWFBJUkVEX1RPS0VOID0gJ0V4cGlyZWRUb2tlbic7XG5jb25zdCBOT19TVUNIX0tFWSA9ICdOb1N1Y2hLZXknO1xuY29uc3QgU05PV0ZMQUtFX1MzX0RFU1RJTkFUSU9OID0gJ3MzLmFtYXpvbmF3cy5jb20nO1xuXG5jb25zdCBFUlJPUk5PX1dTQUVDT05OQUJPUlRFRCA9IDEwMDUzOyAgLy8gbmV0d29yayBjb25uZWN0aW9uIHdhcyBhYm9ydGVkXG5jb25zdCBEQVRBX1NJWkVfVEhSRVNIT0xEID0gNjcxMDg4NjQ7IC8vIG1hZ2ljIG51bWJlciwgZ2l2ZW4gZnJvbSAgZXJyb3IgbWVzc2FnZS5cblxuY29uc3QgcmVzdWx0U3RhdHVzID0gcmVxdWlyZSgnLi4vZmlsZV91dGlsJykucmVzdWx0U3RhdHVzO1xuXG5jb25zdCBIVFRQX0hFQURFUl9WQUxVRV9PQ1RFVF9TVFJFQU0gPSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJztcblxuLy8gUzMgTG9jYXRpb246IFMzIGJ1Y2tldCBuYW1lICsgcGF0aFxuZnVuY3Rpb24gUzNMb2NhdGlvbihidWNrZXROYW1lLCBzM3BhdGgpIHtcbiAgcmV0dXJuIHtcbiAgICAnYnVja2V0TmFtZSc6IGJ1Y2tldE5hbWUsIC8vIFMzIGJ1Y2tldCBuYW1lXG4gICAgJ3MzcGF0aCc6IHMzcGF0aCAvLyBTMyBwYXRoIG5hbWVcbiAgfTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGFuIFMzIHV0aWxpdHkgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBjb25uZWN0aW9uQ29uZmlnXG4gKlxuICogQHBhcmFtIHMzIC0gdXNlZCBmb3IgdGVzdHMsIG1vY2sgY2FuIGJlIHN1cHBsaWVkXG4gKiBAcGFyYW0gZmlsZXN0cmVhbSAtIHVzZWQgZm9yIHRlc3RzLCBtb2NrIGNhbiBiZSBzdXBwbGllZFxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTM1V0aWwoY29ubmVjdGlvbkNvbmZpZywgczMsIGZpbGVzdHJlYW0pIHtcbiAgY29uc3QgQVdTID0gdHlwZW9mIHMzICE9PSAndW5kZWZpbmVkJyA/IHMzIDogcmVxdWlyZSgnQGF3cy1zZGsvY2xpZW50LXMzJyk7XG4gIGNvbnN0IGZzID0gdHlwZW9mIGZpbGVzdHJlYW0gIT09ICd1bmRlZmluZWQnID8gZmlsZXN0cmVhbSA6IHJlcXVpcmUoJ2ZzJyk7XG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gQVdTIFMzIGNsaWVudCB1c2luZyBhbiBBV1MgdG9rZW4uXG4gICAqL1xuICB0aGlzLmNyZWF0ZUNsaWVudCA9IGZ1bmN0aW9uIChzdGFnZUluZm8sIHVzZUFjY2VsZXJhdGVFbmRwb2ludCkge1xuICAgIGNvbnN0IHN0YWdlQ3JlZGVudGlhbHMgPSBzdGFnZUluZm9bJ2NyZWRzJ107XG4gICAgY29uc3Qgc2VjdXJpdHlUb2tlbiA9IHN0YWdlQ3JlZGVudGlhbHNbJ0FXU19UT0tFTiddO1xuICAgIGNvbnN0IGlzUmVnaW9uYWxVcmxFbmFibGVkID0gc3RhZ2VJbmZvLnVzZVJlZ2lvbmFsVXJsIHx8IHN0YWdlSW5mby51c2VTM1JlZ2lvbmFsVXJsO1xuICAgIFxuICAgIC8vIGlmIEdTIHNlbmRzIHVzIGFuIGVuZHBvaW50LCBpdCdzIGxpa2VseSBmb3IgRklQUy4gVXNlIGl0LlxuICAgIGxldCBlbmRQb2ludCA9IG51bGw7XG4gICAgaWYgKHN0YWdlSW5mb1snZW5kUG9pbnQnXSkge1xuICAgICAgZW5kUG9pbnQgPSBgaHR0cHM6Ly8ke3N0YWdlSW5mb1snZW5kUG9pbnQnXX1gO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc3RhZ2VJbmZvLnJlZ2lvbiAmJiBpc1JlZ2lvbmFsVXJsRW5hYmxlZCkge1xuICAgICAgICBjb25zdCBkb21haW5TdWZmaXhGb3JSZWdpb25hbFVybCA9IChzdGFnZUluZm8ucmVnaW9uKS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2NuLScpID8gJ2FtYXpvbmF3cy5jb20uY24nIDogJ2FtYXpvbmF3cy5jb20nO1xuICAgICAgICBlbmRQb2ludCA9IGBodHRwczovL3MzLiR7c3RhZ2VJbmZvLnJlZ2lvbn0uJHtkb21haW5TdWZmaXhGb3JSZWdpb25hbFVybH1gO1xuICAgICAgfVxuICAgIH1cbiAgXG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgYXBpVmVyc2lvbjogJzIwMDYtMDMtMDEnLFxuICAgICAgcmVnaW9uOiBzdGFnZUluZm9bJ3JlZ2lvbiddLFxuICAgICAgY3JlZGVudGlhbHM6IHtcbiAgICAgICAgYWNjZXNzS2V5SWQ6IHN0YWdlQ3JlZGVudGlhbHNbJ0FXU19LRVlfSUQnXSxcbiAgICAgICAgc2VjcmV0QWNjZXNzS2V5OiBzdGFnZUNyZWRlbnRpYWxzWydBV1NfU0VDUkVUX0tFWSddLFxuICAgICAgICBzZXNzaW9uVG9rZW46IHNlY3VyaXR5VG9rZW4sXG4gICAgICB9LFxuICAgICAgZW5kcG9pbnQ6IGVuZFBvaW50LFxuICAgICAgdXNlQWNjZWxlcmF0ZUVuZHBvaW50OiB1c2VBY2NlbGVyYXRlRW5kcG9pbnRcbiAgICB9O1xuXG4gICAgY29uc3QgcHJveHkgPSBQcm94eVV0aWwuZ2V0UHJveHkoY29ubmVjdGlvbkNvbmZpZy5nZXRQcm94eSgpLCAnUzMgVXRpbCcpO1xuICAgIGlmIChwcm94eSkge1xuICAgICAgY29uc3QgcHJveHlBZ2VudCA9IGdldFByb3h5QWdlbnQocHJveHksIG5ldyBVUkwoY29ubmVjdGlvbkNvbmZpZy5hY2Nlc3NVcmwpLCBlbmRQb2ludCB8fCBTTk9XRkxBS0VfUzNfREVTVElOQVRJT04pO1xuICAgICAgY29uZmlnLnJlcXVlc3RIYW5kbGVyID0gbmV3IE5vZGVIdHRwSGFuZGxlcih7XG4gICAgICAgIGh0dHBBZ2VudDogcHJveHlBZ2VudCxcbiAgICAgICAgaHR0cHNBZ2VudDogcHJveHlBZ2VudFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBBV1MuUzMoY29uZmlnKTtcbiAgfTtcblxuICAvKipcbiAgICogR2V0IGZpbGUgaGVhZGVyIGJhc2VkIG9uIGZpbGUgYmVpbmcgdXBsb2FkZWQgb3Igbm90LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gbWV0YVxuICAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZW5hbWVcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHRoaXMuZ2V0RmlsZUhlYWRlciA9IGFzeW5jIGZ1bmN0aW9uIChtZXRhLCBmaWxlbmFtZSkge1xuICAgIGNvbnN0IHN0YWdlSW5mbyA9IG1ldGFbJ3N0YWdlSW5mbyddO1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY3JlYXRlQ2xpZW50KHN0YWdlSW5mbyk7XG4gICAgY29uc3QgczNsb2NhdGlvbiA9IGV4dHJhY3RCdWNrZXROYW1lQW5kUGF0aChzdGFnZUluZm9bJ2xvY2F0aW9uJ10pO1xuXG4gICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgQnVja2V0OiBzM2xvY2F0aW9uLmJ1Y2tldE5hbWUsXG4gICAgICBLZXk6IHMzbG9jYXRpb24uczNwYXRoICsgZmlsZW5hbWVcbiAgICB9O1xuXG4gICAgbGV0IGFrZXk7XG5cbiAgICB0cnkge1xuICAgICAgYXdhaXQgY2xpZW50LmdldE9iamVjdChwYXJhbXMpXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgYWtleSA9IGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyclsnQ29kZSddID09PSBFWFBJUkVEX1RPS0VOKSB7XG4gICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoZXJyWydDb2RlJ10gPT09IE5PX1NVQ0hfS0VZKSB7XG4gICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLk5PVF9GT1VORF9GSUxFO1xuICAgICAgICByZXR1cm4gRmlsZUhlYWRlcihudWxsLCBudWxsLCBudWxsKTtcbiAgICAgIH0gZWxzZSBpZiAoZXJyWydDb2RlJ10gPT09ICc0MDAnKSB7XG4gICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLkVSUk9SO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5VUExPQURFRDtcblxuICAgIGxldCBlbmNyeXB0aW9uTWV0YWRhdGE7XG4gICAgaWYgKGFrZXkgJiYgYWtleS5NZXRhZGF0YVtBTVpfS0VZXSkge1xuICAgICAgZW5jcnlwdGlvbk1ldGFkYXRhID0gRW5jcnlwdGlvbk1ldGFkYXRhKFxuICAgICAgICBha2V5Lk1ldGFkYXRhW0FNWl9LRVldLFxuICAgICAgICBha2V5Lk1ldGFkYXRhW0FNWl9JVl0sXG4gICAgICAgIGFrZXkuTWV0YWRhdGFbQU1aX01BVERFU0NdXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBGaWxlSGVhZGVyKFxuICAgICAgYWtleS5NZXRhZGF0YVtTRkNfRElHRVNUXSxcbiAgICAgIGFrZXkuQ29udGVudExlbmd0aCxcbiAgICAgIGVuY3J5cHRpb25NZXRhZGF0YVxuICAgICk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgZmlsZSBtZXRhZGF0YSB0aGVuIHVwbG9hZCB0aGUgZmlsZS5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFGaWxlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbmNyeXB0aW9uTWV0YWRhdGFcbiAgICovXG4gIHRoaXMudXBsb2FkRmlsZSA9IGFzeW5jIGZ1bmN0aW9uIChkYXRhRmlsZSwgbWV0YSwgZW5jcnlwdGlvbk1ldGFkYXRhKSB7XG4gICAgY29uc3QgZmlsZVN0cmVhbSA9IGZzLnJlYWRGaWxlU3luYyhkYXRhRmlsZSk7XG4gICAgYXdhaXQgdGhpcy51cGxvYWRGaWxlU3RyZWFtKGZpbGVTdHJlYW0sIG1ldGEsIGVuY3J5cHRpb25NZXRhZGF0YSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZSB0aGUgZmlsZSBtZXRhZGF0YSB0aGVuIHVwbG9hZCB0aGUgZmlsZSBzdHJlYW0uXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBmaWxlU3RyZWFtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtZXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBlbmNyeXB0aW9uTWV0YWRhdGFcbiAgICovXG4gIHRoaXMudXBsb2FkRmlsZVN0cmVhbSA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlU3RyZWFtLCBtZXRhLCBlbmNyeXB0aW9uTWV0YWRhdGEpIHtcbiAgICBjb25zdCBzM01ldGFkYXRhID0ge1xuICAgICAgSFRUUF9IRUFERVJfQ09OVEVOVF9UWVBFOiBIVFRQX0hFQURFUl9WQUxVRV9PQ1RFVF9TVFJFQU0sXG4gICAgICBTRkNfRElHRVNUOiBtZXRhWydTSEEyNTZfRElHRVNUJ11cbiAgICB9O1xuXG4gICAgaWYgKGVuY3J5cHRpb25NZXRhZGF0YSkge1xuICAgICAgczNNZXRhZGF0YVtBTVpfSVZdID0gZW5jcnlwdGlvbk1ldGFkYXRhLml2O1xuICAgICAgczNNZXRhZGF0YVtBTVpfS0VZXSA9IGVuY3J5cHRpb25NZXRhZGF0YS5rZXk7XG4gICAgICBzM01ldGFkYXRhW0FNWl9NQVRERVNDXSA9IGVuY3J5cHRpb25NZXRhZGF0YS5tYXREZXNjO1xuICAgIH1cblxuICAgIGNvbnN0IHN0YWdlSW5mbyA9IG1ldGFbJ3N0YWdlSW5mbyddO1xuICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY3JlYXRlQ2xpZW50KHN0YWdlSW5mbyk7XG5cbiAgICBjb25zdCBzM2xvY2F0aW9uID0gZXh0cmFjdEJ1Y2tldE5hbWVBbmRQYXRoKG1ldGFbJ3N0YWdlSW5mbyddWydsb2NhdGlvbiddKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIEJ1Y2tldDogczNsb2NhdGlvbi5idWNrZXROYW1lLFxuICAgICAgQm9keTogZmlsZVN0cmVhbSxcbiAgICAgIEtleTogczNsb2NhdGlvbi5zM3BhdGggKyBtZXRhWydkc3RGaWxlTmFtZSddLFxuICAgICAgTWV0YWRhdGE6IHMzTWV0YWRhdGFcbiAgICB9O1xuXG4gICAgLy8gY2FsbCBTMyB0byB1cGxvYWQgZmlsZSB0byBzcGVjaWZpZWQgYnVja2V0XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IGNsaWVudC5wdXRPYmplY3QocGFyYW1zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChlcnJbJ0NvZGUnXSA9PT0gRVhQSVJFRF9UT0tFTikge1xuICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5SRU5FV19UT0tFTjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1ldGFbJ2xhc3RFcnJvciddID0gZXJyO1xuICAgICAgICBpZiAoZXJyWydDb2RlJ10gPT09IEVSUk9STk9fV1NBRUNPTk5BQk9SVEVELnRvU3RyaW5nKCkpIHtcbiAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZX1dJVEhfTE9XRVJfQ09OQ1VSUkVOQ1k7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuTkVFRF9SRVRSWTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG1ldGFbJ2RzdEZpbGVTaXplJ10gPSBtZXRhWyd1cGxvYWRTaXplJ107XG4gICAgbWV0YVsncmVzdWx0U3RhdHVzJ10gPSByZXN1bHRTdGF0dXMuVVBMT0FERUQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIERvd25sb2FkIHRoZSBmaWxlLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YUZpbGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG1ldGFcbiAgICogQHBhcmFtIHtPYmplY3R9IGVuY3J5cHRpb25NZXRhZGF0YVxuICAgKi9cbiAgdGhpcy5uYXRpdmVEb3dubG9hZEZpbGUgPSBhc3luYyBmdW5jdGlvbiAobWV0YSwgZnVsbERzdFBhdGgpIHtcbiAgICBjb25zdCBzdGFnZUluZm8gPSBtZXRhWydzdGFnZUluZm8nXTtcbiAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNyZWF0ZUNsaWVudChzdGFnZUluZm8pO1xuXG4gICAgY29uc3QgczNsb2NhdGlvbiA9IGV4dHJhY3RCdWNrZXROYW1lQW5kUGF0aChtZXRhWydzdGFnZUluZm8nXVsnbG9jYXRpb24nXSk7XG5cbiAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICBCdWNrZXQ6IHMzbG9jYXRpb24uYnVja2V0TmFtZSxcbiAgICAgIEtleTogczNsb2NhdGlvbi5zM3BhdGggKyBtZXRhWydkc3RGaWxlTmFtZSddLFxuICAgIH07XG5cbiAgICAvLyBjYWxsIFMzIHRvIGRvd25sb2FkIGZpbGUgdG8gc3BlY2lmaWVkIGJ1Y2tldFxuICAgIHRyeSB7XG4gICAgICBhd2FpdCBjbGllbnQuZ2V0T2JqZWN0KHBhcmFtcylcbiAgICAgICAgLnRoZW4oZGF0YSA9PiBkYXRhLkJvZHkudHJhbnNmb3JtVG9CeXRlQXJyYXkoKSlcbiAgICAgICAgLnRoZW4oKGRhdGEpID0+IHtcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgZnMud3JpdGVGaWxlKGZ1bGxEc3RQYXRoLCBkYXRhLCAnYmluYXJ5JywgKGVycikgPT4ge1xuICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaWYgKGVyclsnQ29kZSddID09PSBFWFBJUkVEX1RPS0VOKSB7XG4gICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLlJFTkVXX1RPS0VOO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWV0YVsnbGFzdEVycm9yJ10gPSBlcnI7XG4gICAgICAgIGlmIChlcnJbJ0NvZGUnXSA9PT0gRVJST1JOT19XU0FFQ09OTkFCT1JURUQudG9TdHJpbmcoKSkge1xuICAgICAgICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLk5FRURfUkVUUllfV0lUSF9MT1dFUl9DT05DVVJSRU5DWTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtZXRhWydyZXN1bHRTdGF0dXMnXSA9IHJlc3VsdFN0YXR1cy5ORUVEX1JFVFJZO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIG1ldGFbJ3Jlc3VsdFN0YXR1cyddID0gcmVzdWx0U3RhdHVzLkRPV05MT0FERUQ7XG4gIH07XG59XG5cbi8qKlxuICogRXh0cmFjdCB0aGUgYnVja2V0IG5hbWUgYW5kIHBhdGggZnJvbSB0aGUgbWV0YWRhdGEncyBzdGFnZSBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RhZ2VMb2NhdGlvblxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RCdWNrZXROYW1lQW5kUGF0aChzdGFnZUxvY2F0aW9uKSB7XG4gIC8vIGV4cGFuZCAnficgYW5kICd+dXNlcicgZXhwcmVzc2lvbnNcbiAgaWYgKHByb2Nlc3MucGxhdGZvcm0gIT09ICd3aW4zMicpIHtcbiAgICBzdGFnZUxvY2F0aW9uID0gZXhwYW5kVGlsZGUoc3RhZ2VMb2NhdGlvbik7XG4gIH1cblxuICBsZXQgYnVja2V0TmFtZSA9IHN0YWdlTG9jYXRpb247XG4gIGxldCBzM3BhdGg7XG5cbiAgLy8gc3BsaXQgc3RhZ2UgbG9jYXRpb24gYXMgYnVja2V0IG5hbWUgYW5kIHBhdGhcbiAgaWYgKHN0YWdlTG9jYXRpb24uaW5jbHVkZXMoJy8nKSkge1xuICAgIGJ1Y2tldE5hbWUgPSBzdGFnZUxvY2F0aW9uLnN1YnN0cmluZygwLCBzdGFnZUxvY2F0aW9uLmluZGV4T2YoJy8nKSk7XG5cbiAgICBzM3BhdGggPSBzdGFnZUxvY2F0aW9uLnN1YnN0cmluZyhzdGFnZUxvY2F0aW9uLmluZGV4T2YoJy8nKSArIDEsIHN0YWdlTG9jYXRpb24ubGVuZ3RoKTtcbiAgICBpZiAoczNwYXRoICYmICFzM3BhdGguZW5kc1dpdGgoJy8nKSkge1xuICAgICAgczNwYXRoICs9ICcvJztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFMzTG9jYXRpb24oYnVja2V0TmFtZSwgczNwYXRoKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IFMzVXRpbCwgU05PV0ZMQUtFX1MzX0RFU1RJTkFUSU9OLCBEQVRBX1NJWkVfVEhSRVNIT0xELCBleHRyYWN0QnVja2V0TmFtZUFuZFBhdGggfTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/file_transfer_agent/s3_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/file_util.js":
/*!*****************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/file_util.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const crypto = __webpack_require__(/*! crypto */ \"crypto\");\nconst fs =  __webpack_require__(/*! fs */ \"fs\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst struct = __webpack_require__(/*! python-struct */ \"(rsc)/./node_modules/python-struct/src/node_adapter.js\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst glob = __webpack_require__(/*! glob */ \"(rsc)/./node_modules/glob/dist/commonjs/index.js\");\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\n\nconst resultStatus = {\n  ERROR: 'ERROR',\n  UPLOADED: 'UPLOADED',\n  DOWNLOADED: 'DOWNLOADED',\n  COLLISION: 'COLLISION',\n  SKIPPED: 'SKIPPED',\n  RENEW_TOKEN: 'RENEW_TOKEN',\n  RENEW_PRESIGNED_URL: 'RENEW_PRESIGNED_URL',\n  NOT_FOUND_FILE: 'NOT_FOUND_FILE',\n  NEED_RETRY: 'NEED_RETRY',\n  NEED_RETRY_WITH_LOWER_CONCURRENCY: 'NEED_RETRY_WITH_LOWER_CONCURRENCY'\n};\n\nexports.resultStatus = resultStatus;\n\n// File Header\nfunction FileHeader(digest, contentLength, encryptionMetadata) {\n  return {\n    'digest': digest,\n    'contentLength': contentLength,\n    'encryptionMetadata': encryptionMetadata\n  };\n}\n\nexports.FileHeader = FileHeader;\n\n/**\n * Creates a file utility object.\n *\n * @returns {Object}\n * @constructor\n */\nfunction FileUtil() {\n  /**\n  * Compress file with GZIP.\n  *\n  * @param {String} fileName\n  * @param {String} tmpDir\n  *\n  * @returns {Object}\n  */\n  this.compressFileWithGZIP = async function (fileName, tmpDir) {\n    // Set file name and path for compressed file\n    const baseName = path.basename(fileName);\n    const gzipFileName = path.join(tmpDir, baseName + '_c.gz');\n\n    await new Promise(function (resolve) {\n      // Create gzip object\n      const gzip = zlib.createGzip();\n      // Create stream object for reader and writer\n      const reader = fs.createReadStream(fileName);\n      const writer = fs.createWriteStream(gzipFileName);\n      // Write and compress file\n      const result = reader.pipe(gzip).pipe(writer);\n      result.on('finish', function () {\n        resolve();\n      });\n    });\n\n    await this.normalizeGzipHeader(gzipFileName);\n\n    const fileInfo = fs.statSync(gzipFileName);\n\n    return {\n      name: gzipFileName,\n      size: fileInfo.size\n    };\n  };\n\n  /**\n  * Normalize the header by removing the timestamp.\n  * Note: GZIP in python includes the file name when compressing but\n  * nodejs does not so there is no need to remove it here.\n  * \n  * @param {String} gzipFileName\n  *\n  * @returns {null}\n  */\n  this.normalizeGzipHeader = async function (gzipFileName) {\n    const fd = fs.openSync(gzipFileName, 'rs+');\n\n    // Reset the timestamp in gzip header\n    // Write at position 4\n    fs.writeSync(fd, struct.pack('<L', 0), 0, 1, 4);\n\n    fs.closeSync(fd);\n  };\n\n  /**\n  * Get file digest and size.\n  *\n  * @param {String} fileName\n  *\n  * @returns {Object}\n  */\n  this.getDigestAndSizeForFile = async function (fileName) {\n    const chunkSize = 16 * 4 * 1024;\n\n    const fileInfo = fs.statSync(fileName);\n    const bufferSize = fileInfo.size;\n\n    let buffer = [];\n    await new Promise(function (resolve) {\n      // Create reader stream and set maximum chunk size\n      const infile = fs.createReadStream(fileName, { highWaterMark: chunkSize });\n      infile.on('data', function (chunk) {\n        buffer.push(chunk);\n      });\n      infile.on('close', function () {\n        buffer = Buffer.concat(buffer);\n        resolve();\n      });\n    });\n\n    const hash = crypto.createHash('sha256')\n      .update(buffer)\n      .digest('base64');\n\n    return {\n      digest: hash,\n      size: bufferSize\n    };\n  };\n}\nexports.FileUtil = FileUtil;\n\nexports.getMatchingFilePaths = function (dir, fileName) {\n  const pathWithWildcard = path.join(dir, fileName);\n  const pathWithWildcardDependsOnPlatform = os.platform() === 'win32'\n    ? pathWithWildcard.replace(/\\\\/g, '/')\n    : pathWithWildcard;\n  return glob.sync(pathWithWildcardDependsOnPlatform);\n};\n\n\n/**\n * Checks if the provided file or directory is writable only by the user and os tha file owner is the same as os user. FsPromises can be provided.\n * @param filePath\n * @param expectedMode\n * @param fsPromises\n * @returns {Promise<boolean>} resolves always to true for Windows\n */\nexports.validateOnlyUserReadWritePermissionAndOwner = async function (filePath, fsPromises) {\n  const fsp = fsPromises ? fsPromises : __webpack_require__(/*! fs/promises */ \"fs/promises\");\n  if (os.platform() === 'win32') {\n    return;\n  }\n  try {\n    const stats = await fsp.stat(filePath);\n    const mode = stats.mode;\n    const permission = mode & 0o777;\n\n    //This should be 600 permission, which means the file permission has not been changed by others.\n    const octalPermissions = permission.toString(8);\n    if (octalPermissions === '600') {\n      Logger.getInstance().debug(`Validated that the user has only read and write permission for file: ${filePath}, Permission: ${permission}`);\n    } else {\n      throw new Error(`Invalid file permissions (${octalPermissions} for file ${filePath}). Make sure you have read and write permissions and other users do not have access to it. Please remove the file and re-run the driver.`);\n    }\n\n    const userInfo = os.userInfo();\n    if (stats.uid === userInfo.uid) {\n      Logger.getInstance().debug('Validated file owner');\n    } else {\n      throw new Error(`Invalid file owner for file ${filePath}). Make sure the system user are the owner of the file otherwise please remove the file and re-run the driver.`);\n    }\n  } catch (err) {\n    //When file doesn't exist - return\n    if (err.code === 'ENOENT') {\n      return;\n    } else {\n      throw err;\n    }\n  }\n};\n\n/**\n * Checks if the provided file or directory permissions are correct.\n * @param filePath\n * @param expectedMode\n * @param fsPromises\n * @returns {Promise<boolean>} resolves always to true for Windows\n */\nexports.isFileModeCorrect = async function (filePath, expectedMode, fsPromises) {\n  if (os.platform() === 'win32') {\n    return true;\n  }\n  return await fsPromises.stat(filePath).then((stats) => {\n    // we have to limit the number of LSB bits to 9 with the mask, as the stats.mode starts with the file type,\n    // e.g. the directory with permissions 755 will have stats.mask of 40755.\n    const mask = (1 << 9) - 1;\n    return (stats.mode & mask) === expectedMode;\n  });\n};\n\n/**\n * Checks if the provided file or directory is writable only by the user.\n * @param configFilePath\n * @param fsPromises\n * @returns {Promise<boolean>} resolves always to true for Windows\n */\nexports.isFileNotWritableByGroupOrOthers = async function (configFilePath, fsPromises) {\n  if (os.platform() === 'win32') {\n    return true;\n  }\n  const stats = await fsPromises.stat(configFilePath);\n  return (stats.mode & (1 << 4)) === 0 && (stats.mode & (1 << 1)) === 0;\n};\n\n/**\n * Generate checksum for given text. The algorithm and encoding can be provided.\n * @param text\n * @param algorithm\n * @param encoding\n * @returns {Promise<String>} resolves always to true for Windows\n */\nexports.generateChecksum = function (text, algorithm, encoding) {\n  return crypto\n    .createHash(algorithm || 'sha256')\n    .update(text, 'utf8')\n    .digest(encoding || 'hex')\n    .substring(0, 32); \n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZmlsZV91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixZQUFZLG1CQUFPLENBQUMsY0FBSTtBQUN4QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsZUFBZSxtQkFBTyxDQUFDLDZFQUFlO0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsOERBQU07QUFDM0IsZUFBZSxtQkFBTyxDQUFDLGtFQUFVOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLOztBQUVMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCwwQkFBMEI7QUFDL0U7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCOztBQUVoQiw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxtREFBbUQ7QUFDbkQsd0NBQXdDLG1CQUFPLENBQUMsZ0NBQWE7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EseUdBQXlHLFNBQVMsZ0JBQWdCLFdBQVc7QUFDN0ksTUFBTTtBQUNOLG1EQUFtRCxrQkFBa0IsV0FBVyxTQUFTO0FBQ3pGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxREFBcUQsU0FBUztBQUM5RDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLHdDQUF3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsaUJBQWlCO0FBQzlCO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9maWxlX3V0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCBmcyA9ICByZXF1aXJlKCdmcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IHN0cnVjdCA9IHJlcXVpcmUoJ3B5dGhvbi1zdHJ1Y3QnKTtcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBnbG9iID0gcmVxdWlyZSgnZ2xvYicpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi9sb2dnZXInKTtcblxuY29uc3QgcmVzdWx0U3RhdHVzID0ge1xuICBFUlJPUjogJ0VSUk9SJyxcbiAgVVBMT0FERUQ6ICdVUExPQURFRCcsXG4gIERPV05MT0FERUQ6ICdET1dOTE9BREVEJyxcbiAgQ09MTElTSU9OOiAnQ09MTElTSU9OJyxcbiAgU0tJUFBFRDogJ1NLSVBQRUQnLFxuICBSRU5FV19UT0tFTjogJ1JFTkVXX1RPS0VOJyxcbiAgUkVORVdfUFJFU0lHTkVEX1VSTDogJ1JFTkVXX1BSRVNJR05FRF9VUkwnLFxuICBOT1RfRk9VTkRfRklMRTogJ05PVF9GT1VORF9GSUxFJyxcbiAgTkVFRF9SRVRSWTogJ05FRURfUkVUUlknLFxuICBORUVEX1JFVFJZX1dJVEhfTE9XRVJfQ09OQ1VSUkVOQ1k6ICdORUVEX1JFVFJZX1dJVEhfTE9XRVJfQ09OQ1VSUkVOQ1knXG59O1xuXG5leHBvcnRzLnJlc3VsdFN0YXR1cyA9IHJlc3VsdFN0YXR1cztcblxuLy8gRmlsZSBIZWFkZXJcbmZ1bmN0aW9uIEZpbGVIZWFkZXIoZGlnZXN0LCBjb250ZW50TGVuZ3RoLCBlbmNyeXB0aW9uTWV0YWRhdGEpIHtcbiAgcmV0dXJuIHtcbiAgICAnZGlnZXN0JzogZGlnZXN0LFxuICAgICdjb250ZW50TGVuZ3RoJzogY29udGVudExlbmd0aCxcbiAgICAnZW5jcnlwdGlvbk1ldGFkYXRhJzogZW5jcnlwdGlvbk1ldGFkYXRhXG4gIH07XG59XG5cbmV4cG9ydHMuRmlsZUhlYWRlciA9IEZpbGVIZWFkZXI7XG5cbi8qKlxuICogQ3JlYXRlcyBhIGZpbGUgdXRpbGl0eSBvYmplY3QuXG4gKlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBGaWxlVXRpbCgpIHtcbiAgLyoqXG4gICogQ29tcHJlc3MgZmlsZSB3aXRoIEdaSVAuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZU5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gdG1wRGlyXG4gICpcbiAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAqL1xuICB0aGlzLmNvbXByZXNzRmlsZVdpdGhHWklQID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVOYW1lLCB0bXBEaXIpIHtcbiAgICAvLyBTZXQgZmlsZSBuYW1lIGFuZCBwYXRoIGZvciBjb21wcmVzc2VkIGZpbGVcbiAgICBjb25zdCBiYXNlTmFtZSA9IHBhdGguYmFzZW5hbWUoZmlsZU5hbWUpO1xuICAgIGNvbnN0IGd6aXBGaWxlTmFtZSA9IHBhdGguam9pbih0bXBEaXIsIGJhc2VOYW1lICsgJ19jLmd6Jyk7XG5cbiAgICBhd2FpdCBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgLy8gQ3JlYXRlIGd6aXAgb2JqZWN0XG4gICAgICBjb25zdCBnemlwID0gemxpYi5jcmVhdGVHemlwKCk7XG4gICAgICAvLyBDcmVhdGUgc3RyZWFtIG9iamVjdCBmb3IgcmVhZGVyIGFuZCB3cml0ZXJcbiAgICAgIGNvbnN0IHJlYWRlciA9IGZzLmNyZWF0ZVJlYWRTdHJlYW0oZmlsZU5hbWUpO1xuICAgICAgY29uc3Qgd3JpdGVyID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0oZ3ppcEZpbGVOYW1lKTtcbiAgICAgIC8vIFdyaXRlIGFuZCBjb21wcmVzcyBmaWxlXG4gICAgICBjb25zdCByZXN1bHQgPSByZWFkZXIucGlwZShnemlwKS5waXBlKHdyaXRlcik7XG4gICAgICByZXN1bHQub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBhd2FpdCB0aGlzLm5vcm1hbGl6ZUd6aXBIZWFkZXIoZ3ppcEZpbGVOYW1lKTtcblxuICAgIGNvbnN0IGZpbGVJbmZvID0gZnMuc3RhdFN5bmMoZ3ppcEZpbGVOYW1lKTtcblxuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiBnemlwRmlsZU5hbWUsXG4gICAgICBzaXplOiBmaWxlSW5mby5zaXplXG4gICAgfTtcbiAgfTtcblxuICAvKipcbiAgKiBOb3JtYWxpemUgdGhlIGhlYWRlciBieSByZW1vdmluZyB0aGUgdGltZXN0YW1wLlxuICAqIE5vdGU6IEdaSVAgaW4gcHl0aG9uIGluY2x1ZGVzIHRoZSBmaWxlIG5hbWUgd2hlbiBjb21wcmVzc2luZyBidXRcbiAgKiBub2RlanMgZG9lcyBub3Qgc28gdGhlcmUgaXMgbm8gbmVlZCB0byByZW1vdmUgaXQgaGVyZS5cbiAgKiBcbiAgKiBAcGFyYW0ge1N0cmluZ30gZ3ppcEZpbGVOYW1lXG4gICpcbiAgKiBAcmV0dXJucyB7bnVsbH1cbiAgKi9cbiAgdGhpcy5ub3JtYWxpemVHemlwSGVhZGVyID0gYXN5bmMgZnVuY3Rpb24gKGd6aXBGaWxlTmFtZSkge1xuICAgIGNvbnN0IGZkID0gZnMub3BlblN5bmMoZ3ppcEZpbGVOYW1lLCAncnMrJyk7XG5cbiAgICAvLyBSZXNldCB0aGUgdGltZXN0YW1wIGluIGd6aXAgaGVhZGVyXG4gICAgLy8gV3JpdGUgYXQgcG9zaXRpb24gNFxuICAgIGZzLndyaXRlU3luYyhmZCwgc3RydWN0LnBhY2soJzxMJywgMCksIDAsIDEsIDQpO1xuXG4gICAgZnMuY2xvc2VTeW5jKGZkKTtcbiAgfTtcblxuICAvKipcbiAgKiBHZXQgZmlsZSBkaWdlc3QgYW5kIHNpemUuXG4gICpcbiAgKiBAcGFyYW0ge1N0cmluZ30gZmlsZU5hbWVcbiAgKlxuICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICovXG4gIHRoaXMuZ2V0RGlnZXN0QW5kU2l6ZUZvckZpbGUgPSBhc3luYyBmdW5jdGlvbiAoZmlsZU5hbWUpIHtcbiAgICBjb25zdCBjaHVua1NpemUgPSAxNiAqIDQgKiAxMDI0O1xuXG4gICAgY29uc3QgZmlsZUluZm8gPSBmcy5zdGF0U3luYyhmaWxlTmFtZSk7XG4gICAgY29uc3QgYnVmZmVyU2l6ZSA9IGZpbGVJbmZvLnNpemU7XG5cbiAgICBsZXQgYnVmZmVyID0gW107XG4gICAgYXdhaXQgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgIC8vIENyZWF0ZSByZWFkZXIgc3RyZWFtIGFuZCBzZXQgbWF4aW11bSBjaHVuayBzaXplXG4gICAgICBjb25zdCBpbmZpbGUgPSBmcy5jcmVhdGVSZWFkU3RyZWFtKGZpbGVOYW1lLCB7IGhpZ2hXYXRlck1hcms6IGNodW5rU2l6ZSB9KTtcbiAgICAgIGluZmlsZS5vbignZGF0YScsIGZ1bmN0aW9uIChjaHVuaykge1xuICAgICAgICBidWZmZXIucHVzaChjaHVuayk7XG4gICAgICB9KTtcbiAgICAgIGluZmlsZS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5jb25jYXQoYnVmZmVyKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBjb25zdCBoYXNoID0gY3J5cHRvLmNyZWF0ZUhhc2goJ3NoYTI1NicpXG4gICAgICAudXBkYXRlKGJ1ZmZlcilcbiAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpZ2VzdDogaGFzaCxcbiAgICAgIHNpemU6IGJ1ZmZlclNpemVcbiAgICB9O1xuICB9O1xufVxuZXhwb3J0cy5GaWxlVXRpbCA9IEZpbGVVdGlsO1xuXG5leHBvcnRzLmdldE1hdGNoaW5nRmlsZVBhdGhzID0gZnVuY3Rpb24gKGRpciwgZmlsZU5hbWUpIHtcbiAgY29uc3QgcGF0aFdpdGhXaWxkY2FyZCA9IHBhdGguam9pbihkaXIsIGZpbGVOYW1lKTtcbiAgY29uc3QgcGF0aFdpdGhXaWxkY2FyZERlcGVuZHNPblBsYXRmb3JtID0gb3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJ1xuICAgID8gcGF0aFdpdGhXaWxkY2FyZC5yZXBsYWNlKC9cXFxcL2csICcvJylcbiAgICA6IHBhdGhXaXRoV2lsZGNhcmQ7XG4gIHJldHVybiBnbG9iLnN5bmMocGF0aFdpdGhXaWxkY2FyZERlcGVuZHNPblBsYXRmb3JtKTtcbn07XG5cblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGZpbGUgb3IgZGlyZWN0b3J5IGlzIHdyaXRhYmxlIG9ubHkgYnkgdGhlIHVzZXIgYW5kIG9zIHRoYSBmaWxlIG93bmVyIGlzIHRoZSBzYW1lIGFzIG9zIHVzZXIuIEZzUHJvbWlzZXMgY2FuIGJlIHByb3ZpZGVkLlxuICogQHBhcmFtIGZpbGVQYXRoXG4gKiBAcGFyYW0gZXhwZWN0ZWRNb2RlXG4gKiBAcGFyYW0gZnNQcm9taXNlc1xuICogQHJldHVybnMge1Byb21pc2U8Ym9vbGVhbj59IHJlc29sdmVzIGFsd2F5cyB0byB0cnVlIGZvciBXaW5kb3dzXG4gKi9cbmV4cG9ydHMudmFsaWRhdGVPbmx5VXNlclJlYWRXcml0ZVBlcm1pc3Npb25BbmRPd25lciA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlUGF0aCwgZnNQcm9taXNlcykge1xuICBjb25zdCBmc3AgPSBmc1Byb21pc2VzID8gZnNQcm9taXNlcyA6IHJlcXVpcmUoJ2ZzL3Byb21pc2VzJyk7XG4gIGlmIChvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdHMgPSBhd2FpdCBmc3Auc3RhdChmaWxlUGF0aCk7XG4gICAgY29uc3QgbW9kZSA9IHN0YXRzLm1vZGU7XG4gICAgY29uc3QgcGVybWlzc2lvbiA9IG1vZGUgJiAwbzc3NztcblxuICAgIC8vVGhpcyBzaG91bGQgYmUgNjAwIHBlcm1pc3Npb24sIHdoaWNoIG1lYW5zIHRoZSBmaWxlIHBlcm1pc3Npb24gaGFzIG5vdCBiZWVuIGNoYW5nZWQgYnkgb3RoZXJzLlxuICAgIGNvbnN0IG9jdGFsUGVybWlzc2lvbnMgPSBwZXJtaXNzaW9uLnRvU3RyaW5nKDgpO1xuICAgIGlmIChvY3RhbFBlcm1pc3Npb25zID09PSAnNjAwJykge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFZhbGlkYXRlZCB0aGF0IHRoZSB1c2VyIGhhcyBvbmx5IHJlYWQgYW5kIHdyaXRlIHBlcm1pc3Npb24gZm9yIGZpbGU6ICR7ZmlsZVBhdGh9LCBQZXJtaXNzaW9uOiAke3Blcm1pc3Npb259YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBmaWxlIHBlcm1pc3Npb25zICgke29jdGFsUGVybWlzc2lvbnN9IGZvciBmaWxlICR7ZmlsZVBhdGh9KS4gTWFrZSBzdXJlIHlvdSBoYXZlIHJlYWQgYW5kIHdyaXRlIHBlcm1pc3Npb25zIGFuZCBvdGhlciB1c2VycyBkbyBub3QgaGF2ZSBhY2Nlc3MgdG8gaXQuIFBsZWFzZSByZW1vdmUgdGhlIGZpbGUgYW5kIHJlLXJ1biB0aGUgZHJpdmVyLmApO1xuICAgIH1cblxuICAgIGNvbnN0IHVzZXJJbmZvID0gb3MudXNlckluZm8oKTtcbiAgICBpZiAoc3RhdHMudWlkID09PSB1c2VySW5mby51aWQpIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdWYWxpZGF0ZWQgZmlsZSBvd25lcicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgZmlsZSBvd25lciBmb3IgZmlsZSAke2ZpbGVQYXRofSkuIE1ha2Ugc3VyZSB0aGUgc3lzdGVtIHVzZXIgYXJlIHRoZSBvd25lciBvZiB0aGUgZmlsZSBvdGhlcndpc2UgcGxlYXNlIHJlbW92ZSB0aGUgZmlsZSBhbmQgcmUtcnVuIHRoZSBkcml2ZXIuYCk7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvL1doZW4gZmlsZSBkb2Vzbid0IGV4aXN0IC0gcmV0dXJuXG4gICAgaWYgKGVyci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgZmlsZSBvciBkaXJlY3RvcnkgcGVybWlzc2lvbnMgYXJlIGNvcnJlY3QuXG4gKiBAcGFyYW0gZmlsZVBhdGhcbiAqIEBwYXJhbSBleHBlY3RlZE1vZGVcbiAqIEBwYXJhbSBmc1Byb21pc2VzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gcmVzb2x2ZXMgYWx3YXlzIHRvIHRydWUgZm9yIFdpbmRvd3NcbiAqL1xuZXhwb3J0cy5pc0ZpbGVNb2RlQ29ycmVjdCA9IGFzeW5jIGZ1bmN0aW9uIChmaWxlUGF0aCwgZXhwZWN0ZWRNb2RlLCBmc1Byb21pc2VzKSB7XG4gIGlmIChvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGF3YWl0IGZzUHJvbWlzZXMuc3RhdChmaWxlUGF0aCkudGhlbigoc3RhdHMpID0+IHtcbiAgICAvLyB3ZSBoYXZlIHRvIGxpbWl0IHRoZSBudW1iZXIgb2YgTFNCIGJpdHMgdG8gOSB3aXRoIHRoZSBtYXNrLCBhcyB0aGUgc3RhdHMubW9kZSBzdGFydHMgd2l0aCB0aGUgZmlsZSB0eXBlLFxuICAgIC8vIGUuZy4gdGhlIGRpcmVjdG9yeSB3aXRoIHBlcm1pc3Npb25zIDc1NSB3aWxsIGhhdmUgc3RhdHMubWFzayBvZiA0MDc1NS5cbiAgICBjb25zdCBtYXNrID0gKDEgPDwgOSkgLSAxO1xuICAgIHJldHVybiAoc3RhdHMubW9kZSAmIG1hc2spID09PSBleHBlY3RlZE1vZGU7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIHByb3ZpZGVkIGZpbGUgb3IgZGlyZWN0b3J5IGlzIHdyaXRhYmxlIG9ubHkgYnkgdGhlIHVzZXIuXG4gKiBAcGFyYW0gY29uZmlnRmlsZVBhdGhcbiAqIEBwYXJhbSBmc1Byb21pc2VzXG4gKiBAcmV0dXJucyB7UHJvbWlzZTxib29sZWFuPn0gcmVzb2x2ZXMgYWx3YXlzIHRvIHRydWUgZm9yIFdpbmRvd3NcbiAqL1xuZXhwb3J0cy5pc0ZpbGVOb3RXcml0YWJsZUJ5R3JvdXBPck90aGVycyA9IGFzeW5jIGZ1bmN0aW9uIChjb25maWdGaWxlUGF0aCwgZnNQcm9taXNlcykge1xuICBpZiAob3MucGxhdGZvcm0oKSA9PT0gJ3dpbjMyJykge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGNvbnN0IHN0YXRzID0gYXdhaXQgZnNQcm9taXNlcy5zdGF0KGNvbmZpZ0ZpbGVQYXRoKTtcbiAgcmV0dXJuIChzdGF0cy5tb2RlICYgKDEgPDwgNCkpID09PSAwICYmIChzdGF0cy5tb2RlICYgKDEgPDwgMSkpID09PSAwO1xufTtcblxuLyoqXG4gKiBHZW5lcmF0ZSBjaGVja3N1bSBmb3IgZ2l2ZW4gdGV4dC4gVGhlIGFsZ29yaXRobSBhbmQgZW5jb2RpbmcgY2FuIGJlIHByb3ZpZGVkLlxuICogQHBhcmFtIHRleHRcbiAqIEBwYXJhbSBhbGdvcml0aG1cbiAqIEBwYXJhbSBlbmNvZGluZ1xuICogQHJldHVybnMge1Byb21pc2U8U3RyaW5nPn0gcmVzb2x2ZXMgYWx3YXlzIHRvIHRydWUgZm9yIFdpbmRvd3NcbiAqL1xuZXhwb3J0cy5nZW5lcmF0ZUNoZWNrc3VtID0gZnVuY3Rpb24gKHRleHQsIGFsZ29yaXRobSwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGNyeXB0b1xuICAgIC5jcmVhdGVIYXNoKGFsZ29yaXRobSB8fCAnc2hhMjU2JylcbiAgICAudXBkYXRlKHRleHQsICd1dGY4JylcbiAgICAuZGlnZXN0KGVuY29kaW5nIHx8ICdoZXgnKVxuICAgIC5zdWJzdHJpbmcoMCwgMzIpOyBcbn07XG5cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/global_config.js":
/*!*********************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/global_config.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst mkdirp = __webpack_require__(/*! mkdirp */ \"(rsc)/./node_modules/mkdirp/index.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst { XMLParser, XMLValidator } = __webpack_require__(/*! fast-xml-parser */ \"(rsc)/./node_modules/fast-xml-parser/src/fxp.js\");\n\nlet disableOCSPChecks = false;\n\n/**\n * Updates the value of the 'disableOCSPChecks' parameter.\n *\n * @param {boolean} value\n */\nexports.setDisableOCSPChecks = function (value) {\n  // validate input\n  Errors.assertInternal(Util.isBoolean(value));\n\n  disableOCSPChecks = value;\n};\n\n/**\n * Returns the value of the 'disableOCSPChecks' parameter.\n *\n * @returns {boolean}\n */\nexports.isOCSPChecksDisabled = function () {\n  return disableOCSPChecks;\n};\n\nlet ocspFailOpen = true;\nexports.ocspFailOpen = ocspFailOpen;\n\n/**\n * Updates the value of the 'ocspFailOpen' parameter.\n *\n * @param {boolean} value\n */\nexports.setOcspFailOpen = function (value) {\n  // validate input\n  Errors.assertInternal(Util.isBoolean(value));\n\n  ocspFailOpen = value;\n};\n\n/**\n * Returns the value of the 'ocspFailOpen' parameter.\n *\n * @param {boolean} value\n */\nexports.getOcspFailOpen = function () {\n  return ocspFailOpen;\n};\n\nconst ocspModes = {\n  FAIL_CLOSED: 'FAIL_CLOSED',\n  FAIL_OPEN: 'FAIL_OPEN',\n  INSECURE: 'INSECURE'\n};\nexports.ocspModes = ocspModes;\n\n/**\n * Returns the OCSP mode\n *\n * @returns {string}\n */\nexports.getOcspMode = function () {\n  if (disableOCSPChecks) {\n    return ocspModes.INSECURE;\n  } else if (!ocspFailOpen) {\n    return ocspModes.FAIL_CLOSED;\n  }\n  return ocspModes.FAIL_OPEN;\n};\n\n/**\n * Returns the upper limit for number of entries we can have in the OCSP response cache.\n *\n * @returns {number}\n */\nexports.getOcspResponseCacheSizeLimit = function () {\n  return 1000;\n};\n\n/**\n * Returns the maximum time in seconds that entries can live in the OCSP\n * response cache.\n *\n * @returns {number}\n */\nexports.getOcspResponseCacheMaxAge = function () {\n  // 24 hours, in seconds\n  // It was in millionseconds before but the timestamp we save in\n  // cache file was in seconds. Compare that with max age in millionseconds\n  // would makes the cache never expire.\n  // change max age here because customer would have local cache file exist\n  // already and we need to keep that valid with new version of the driver.\n  // use small value for test only\n  let maxage = Number(process.env.SF_OCSP_TEST_CACHE_MAXAGE) || 86400;\n  if ((maxage > 86400) || (maxage <= 0)) {\n    maxage = 86400;\n  }\n  return maxage;\n};\n\n/**\n * Creates a cache directory.\n *\n * @returns {string}\n */\nexports.mkdirCacheDir = function () {\n  let cacheRootDir = process.env.SF_OCSP_RESPONSE_CACHE_DIR;\n  if (!Util.exists(cacheRootDir)) {\n    cacheRootDir = os.homedir();\n  }\n  if (!Util.exists(cacheRootDir)) {\n    cacheRootDir = os.tmpdir(); // fallback to TMP if user home doesn't exist.\n  }\n\n  let cacheDir;\n  const platform = os.platform();\n  if (platform === 'darwin') {\n    cacheDir = path.join(cacheRootDir, 'Library', 'Caches', 'Snowflake');\n  } else if (platform === 'win32') {\n    cacheDir = path.join(cacheRootDir, 'AppData', 'Local', 'Snowflake', 'Caches');\n  } else {\n    // linux\n    cacheDir = path.join(cacheRootDir, '.cache', 'snowflake');\n  }\n  try {\n    mkdirp.sync(cacheDir);\n  } catch (e) {\n    Logger.getInstance().debug('Failed to create a cache directory %s, err: %s', cacheDir, e);\n  }\n  return cacheDir;\n};\n\nconst rest = {\n  HTTPS_PORT: 443,\n  HTTPS_PROTOCOL: 'https'\n};\nexports.rest = rest;\n\n// The default JSON parser\nexports.jsonColumnVariantParser = rawColumnValue => new Function(`return (${rawColumnValue});`)();\n\n/**\n * Updates the value of the 'jsonColumnVariantParser' parameter.\n *\n * @param {function: (rawColumnValue: string) => any} value\n */\nexports.setJsonColumnVariantParser = function (value){\n  // validate input\n  Errors.assertInternal(Util.isFunction(value));\n\n  exports.jsonColumnVariantParser = value;\n};\n\n/**\n * As a default we set parameters values identical like in fast-xml-parser lib defaults\n * thus preserving backward compatibility if customer doesn't set custom configuration\n * and give possibility to set only part of parameters\n */\nconst defaultXmlParserConfiguration = {\n  ignoreAttributes: true,\n  alwaysCreateTextNode: false,\n  attributeNamePrefix: '@_',\n  attributesGroupName: false\n};\n\n// The default XML parser\nexports.xmlColumnVariantParser = createXmlColumnVariantParser(defaultXmlParserConfiguration);\n\n/**\n * Updates the value of the 'xmlColumnVariantParser' parameter.\n * Return fucntion with custom XmlParser configuration or default if not set.\n *\n * @param {function: (rawColumnValue: string) => any} value\n */\nexports.setXmlColumnVariantParser = function (value){\n  // validate input\n  Errors.assertInternal(Util.isFunction(value));\n\n  exports.xmlColumnVariantParser = value;\n};\n/**\n * Create and update the 'xmlColumnVariantParser' parameter using custom parser configuration.\n *\n * @param {function: (rawColumnValue: string) => any} params\n */\nexports.createXmlColumnVariantParserWithParameters = function (params){\n  exports.xmlColumnVariantParser = createXmlColumnVariantParser(params);\n};\n\n/**\n * Create function to parse XML using XMlParser with custom configuration.\n * Parametrs that you can override:\n *  ignoreAttributes: true,\n *  attributeNamePrefix: '@_',\n *  attributesGroupName: false,\n *  alwaysCreateTextNode: false\n *\n * @param {object} config\n */\nfunction createXmlColumnVariantParser(config) {\n  let parserConfiguration;\n  if (!Util.isObject(config)) {\n    parserConfiguration = defaultXmlParserConfiguration;\n  } else {\n    parserConfiguration = {\n      ignoreAttributes: Util.exists(config.ignoreAttributes) ? config.ignoreAttributes : defaultXmlParserConfiguration.ignoreAttributes,\n      attributeNamePrefix: Util.exists(config.attributeNamePrefix) ? config.attributeNamePrefix : defaultXmlParserConfiguration.attributeNamePrefix,\n      //For attributesGroupName null value is acceptable and mean no grouping\n      attributesGroupName: config.attributesGroupName !== undefined ? config.attributesGroupName : defaultXmlParserConfiguration.attributesGroupName,\n      alwaysCreateTextNode: Util.exists(config.alwaysCreateTextNode) ? config.alwaysCreateTextNode : defaultXmlParserConfiguration.alwaysCreateTextNode,\n    };\n  }\n  return rawColumnValue => {\n    // check if raw string is in XML format\n    // ensure each tag is enclosed and all attributes and elements are valid\n    // XMLValidator.validate returns true if valid, returns an error if invalid\n    const validateResult = XMLValidator.validate(rawColumnValue);\n    if (validateResult === true) {\n      // use XML parser\n      return new XMLParser(parserConfiguration).parse(rawColumnValue);\n    } else {\n      throw new Error(validateResult.err.msg);\n    }\n  };\n}\n\nlet keepAlive = true;\n\n/**\n * Updates the value of the 'keepAlive' parameter.\n *\n * @param {boolean} value\n */\nexports.setKeepAlive = function (value) {\n  Errors.assertInternal(Util.isBoolean(value));\n  keepAlive = value;\n};\n\n/**\n * Returns the overriden value of 'keepAlive' or default if not set. Default value is true\n *\n * @param {boolean} value\n */\nexports.getKeepAlive = function () {\n  return keepAlive;\n};\n\nlet credentialManager = null;\n\nexports.setCustomCredentialManager = function (customCredentialManager) {\n  Errors.checkArgumentValid(Util.checkValidCustomCredentialManager(customCredentialManager),\n    ErrorCodes.ERR_GLOBAL_CONFIGURE_INVALID_CUSTOM_CREDENTIAL_MANAGER);\n  \n  credentialManager =  customCredentialManager;\n  Logger.getInstance().info('Custom credential manager is set by a user.');\n};\n\nexports.getCredentialManager = function () { \n  return credentialManager;  \n};\n\nlet envProxy = true;\nexports.setEnvProxy = function (value) {\n  Errors.assertInternal(Util.isBoolean(value));\n  envProxy = value;\n};\n\nexports.isEnvProxyActive = function () {\n  return envProxy;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvZ2xvYmFsX2NvbmZpZy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsZUFBZSxtQkFBTyxDQUFDLG9EQUFRO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxrRUFBVTtBQUNqQztBQUNBLGFBQWEsbUJBQU8sQ0FBQyw4REFBUTtBQUM3QixlQUFlLG1CQUFPLENBQUMsa0VBQVU7QUFDakMsUUFBUSwwQkFBMEIsRUFBRSxtQkFBTyxDQUFDLHdFQUFpQjs7QUFFN0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjs7QUFFcEI7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTs7QUFFWjtBQUNBLCtCQUErQiw2Q0FBNkMsZUFBZSxFQUFFOztBQUU3RjtBQUNBO0FBQ0E7QUFDQSxXQUFXLDJDQUEyQztBQUN0RDtBQUNBLGtDQUFrQztBQUNsQztBQUNBOztBQUVBLEVBQUUsK0JBQStCO0FBQ2pDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4QkFBOEI7O0FBRTlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVywyQ0FBMkM7QUFDdEQ7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTs7QUFFQSxFQUFFLDhCQUE4QjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsMkNBQTJDO0FBQ3REO0FBQ0Esa0RBQWtEO0FBQ2xELEVBQUUsOEJBQThCO0FBQ2hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBOztBQUVBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4QjtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2dsb2JhbF9jb25maWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgb3MgPSByZXF1aXJlKCdvcycpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcbmNvbnN0IG1rZGlycCA9IHJlcXVpcmUoJ21rZGlycCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSBFcnJvcnMuY29kZXM7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuY29uc3QgeyBYTUxQYXJzZXIsIFhNTFZhbGlkYXRvciB9ID0gcmVxdWlyZSgnZmFzdC14bWwtcGFyc2VyJyk7XG5cbmxldCBkaXNhYmxlT0NTUENoZWNrcyA9IGZhbHNlO1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSAnZGlzYWJsZU9DU1BDaGVja3MnIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gKi9cbmV4cG9ydHMuc2V0RGlzYWJsZU9DU1BDaGVja3MgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgLy8gdmFsaWRhdGUgaW5wdXRcbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNCb29sZWFuKHZhbHVlKSk7XG5cbiAgZGlzYWJsZU9DU1BDaGVja3MgPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlICdkaXNhYmxlT0NTUENoZWNrcycgcGFyYW1ldGVyLlxuICpcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzT0NTUENoZWNrc0Rpc2FibGVkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZGlzYWJsZU9DU1BDaGVja3M7XG59O1xuXG5sZXQgb2NzcEZhaWxPcGVuID0gdHJ1ZTtcbmV4cG9ydHMub2NzcEZhaWxPcGVuID0gb2NzcEZhaWxPcGVuO1xuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHZhbHVlIG9mIHRoZSAnb2NzcEZhaWxPcGVuJyBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICovXG5leHBvcnRzLnNldE9jc3BGYWlsT3BlbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAvLyB2YWxpZGF0ZSBpbnB1dFxuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc0Jvb2xlYW4odmFsdWUpKTtcblxuICBvY3NwRmFpbE9wZW4gPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlICdvY3NwRmFpbE9wZW4nIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gKi9cbmV4cG9ydHMuZ2V0T2NzcEZhaWxPcGVuID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gb2NzcEZhaWxPcGVuO1xufTtcblxuY29uc3Qgb2NzcE1vZGVzID0ge1xuICBGQUlMX0NMT1NFRDogJ0ZBSUxfQ0xPU0VEJyxcbiAgRkFJTF9PUEVOOiAnRkFJTF9PUEVOJyxcbiAgSU5TRUNVUkU6ICdJTlNFQ1VSRSdcbn07XG5leHBvcnRzLm9jc3BNb2RlcyA9IG9jc3BNb2RlcztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBPQ1NQIG1vZGVcbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5leHBvcnRzLmdldE9jc3BNb2RlID0gZnVuY3Rpb24gKCkge1xuICBpZiAoZGlzYWJsZU9DU1BDaGVja3MpIHtcbiAgICByZXR1cm4gb2NzcE1vZGVzLklOU0VDVVJFO1xuICB9IGVsc2UgaWYgKCFvY3NwRmFpbE9wZW4pIHtcbiAgICByZXR1cm4gb2NzcE1vZGVzLkZBSUxfQ0xPU0VEO1xuICB9XG4gIHJldHVybiBvY3NwTW9kZXMuRkFJTF9PUEVOO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB1cHBlciBsaW1pdCBmb3IgbnVtYmVyIG9mIGVudHJpZXMgd2UgY2FuIGhhdmUgaW4gdGhlIE9DU1AgcmVzcG9uc2UgY2FjaGUuXG4gKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5nZXRPY3NwUmVzcG9uc2VDYWNoZVNpemVMaW1pdCA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIDEwMDA7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG1heGltdW0gdGltZSBpbiBzZWNvbmRzIHRoYXQgZW50cmllcyBjYW4gbGl2ZSBpbiB0aGUgT0NTUFxuICogcmVzcG9uc2UgY2FjaGUuXG4gKlxuICogQHJldHVybnMge251bWJlcn1cbiAqL1xuZXhwb3J0cy5nZXRPY3NwUmVzcG9uc2VDYWNoZU1heEFnZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gMjQgaG91cnMsIGluIHNlY29uZHNcbiAgLy8gSXQgd2FzIGluIG1pbGxpb25zZWNvbmRzIGJlZm9yZSBidXQgdGhlIHRpbWVzdGFtcCB3ZSBzYXZlIGluXG4gIC8vIGNhY2hlIGZpbGUgd2FzIGluIHNlY29uZHMuIENvbXBhcmUgdGhhdCB3aXRoIG1heCBhZ2UgaW4gbWlsbGlvbnNlY29uZHNcbiAgLy8gd291bGQgbWFrZXMgdGhlIGNhY2hlIG5ldmVyIGV4cGlyZS5cbiAgLy8gY2hhbmdlIG1heCBhZ2UgaGVyZSBiZWNhdXNlIGN1c3RvbWVyIHdvdWxkIGhhdmUgbG9jYWwgY2FjaGUgZmlsZSBleGlzdFxuICAvLyBhbHJlYWR5IGFuZCB3ZSBuZWVkIHRvIGtlZXAgdGhhdCB2YWxpZCB3aXRoIG5ldyB2ZXJzaW9uIG9mIHRoZSBkcml2ZXIuXG4gIC8vIHVzZSBzbWFsbCB2YWx1ZSBmb3IgdGVzdCBvbmx5XG4gIGxldCBtYXhhZ2UgPSBOdW1iZXIocHJvY2Vzcy5lbnYuU0ZfT0NTUF9URVNUX0NBQ0hFX01BWEFHRSkgfHwgODY0MDA7XG4gIGlmICgobWF4YWdlID4gODY0MDApIHx8IChtYXhhZ2UgPD0gMCkpIHtcbiAgICBtYXhhZ2UgPSA4NjQwMDtcbiAgfVxuICByZXR1cm4gbWF4YWdlO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEgY2FjaGUgZGlyZWN0b3J5LlxuICpcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbmV4cG9ydHMubWtkaXJDYWNoZURpciA9IGZ1bmN0aW9uICgpIHtcbiAgbGV0IGNhY2hlUm9vdERpciA9IHByb2Nlc3MuZW52LlNGX09DU1BfUkVTUE9OU0VfQ0FDSEVfRElSO1xuICBpZiAoIVV0aWwuZXhpc3RzKGNhY2hlUm9vdERpcikpIHtcbiAgICBjYWNoZVJvb3REaXIgPSBvcy5ob21lZGlyKCk7XG4gIH1cbiAgaWYgKCFVdGlsLmV4aXN0cyhjYWNoZVJvb3REaXIpKSB7XG4gICAgY2FjaGVSb290RGlyID0gb3MudG1wZGlyKCk7IC8vIGZhbGxiYWNrIHRvIFRNUCBpZiB1c2VyIGhvbWUgZG9lc24ndCBleGlzdC5cbiAgfVxuXG4gIGxldCBjYWNoZURpcjtcbiAgY29uc3QgcGxhdGZvcm0gPSBvcy5wbGF0Zm9ybSgpO1xuICBpZiAocGxhdGZvcm0gPT09ICdkYXJ3aW4nKSB7XG4gICAgY2FjaGVEaXIgPSBwYXRoLmpvaW4oY2FjaGVSb290RGlyLCAnTGlicmFyeScsICdDYWNoZXMnLCAnU25vd2ZsYWtlJyk7XG4gIH0gZWxzZSBpZiAocGxhdGZvcm0gPT09ICd3aW4zMicpIHtcbiAgICBjYWNoZURpciA9IHBhdGguam9pbihjYWNoZVJvb3REaXIsICdBcHBEYXRhJywgJ0xvY2FsJywgJ1Nub3dmbGFrZScsICdDYWNoZXMnKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBsaW51eFxuICAgIGNhY2hlRGlyID0gcGF0aC5qb2luKGNhY2hlUm9vdERpciwgJy5jYWNoZScsICdzbm93Zmxha2UnKTtcbiAgfVxuICB0cnkge1xuICAgIG1rZGlycC5zeW5jKGNhY2hlRGlyKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdGYWlsZWQgdG8gY3JlYXRlIGEgY2FjaGUgZGlyZWN0b3J5ICVzLCBlcnI6ICVzJywgY2FjaGVEaXIsIGUpO1xuICB9XG4gIHJldHVybiBjYWNoZURpcjtcbn07XG5cbmNvbnN0IHJlc3QgPSB7XG4gIEhUVFBTX1BPUlQ6IDQ0MyxcbiAgSFRUUFNfUFJPVE9DT0w6ICdodHRwcydcbn07XG5leHBvcnRzLnJlc3QgPSByZXN0O1xuXG4vLyBUaGUgZGVmYXVsdCBKU09OIHBhcnNlclxuZXhwb3J0cy5qc29uQ29sdW1uVmFyaWFudFBhcnNlciA9IHJhd0NvbHVtblZhbHVlID0+IG5ldyBGdW5jdGlvbihgcmV0dXJuICgke3Jhd0NvbHVtblZhbHVlfSk7YCkoKTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSB2YWx1ZSBvZiB0aGUgJ2pzb25Db2x1bW5WYXJpYW50UGFyc2VyJyBwYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbjogKHJhd0NvbHVtblZhbHVlOiBzdHJpbmcpID0+IGFueX0gdmFsdWVcbiAqL1xuZXhwb3J0cy5zZXRKc29uQ29sdW1uVmFyaWFudFBhcnNlciA9IGZ1bmN0aW9uICh2YWx1ZSl7XG4gIC8vIHZhbGlkYXRlIGlucHV0XG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzRnVuY3Rpb24odmFsdWUpKTtcblxuICBleHBvcnRzLmpzb25Db2x1bW5WYXJpYW50UGFyc2VyID0gdmFsdWU7XG59O1xuXG4vKipcbiAqIEFzIGEgZGVmYXVsdCB3ZSBzZXQgcGFyYW1ldGVycyB2YWx1ZXMgaWRlbnRpY2FsIGxpa2UgaW4gZmFzdC14bWwtcGFyc2VyIGxpYiBkZWZhdWx0c1xuICogdGh1cyBwcmVzZXJ2aW5nIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgaWYgY3VzdG9tZXIgZG9lc24ndCBzZXQgY3VzdG9tIGNvbmZpZ3VyYXRpb25cbiAqIGFuZCBnaXZlIHBvc3NpYmlsaXR5IHRvIHNldCBvbmx5IHBhcnQgb2YgcGFyYW1ldGVyc1xuICovXG5jb25zdCBkZWZhdWx0WG1sUGFyc2VyQ29uZmlndXJhdGlvbiA9IHtcbiAgaWdub3JlQXR0cmlidXRlczogdHJ1ZSxcbiAgYWx3YXlzQ3JlYXRlVGV4dE5vZGU6IGZhbHNlLFxuICBhdHRyaWJ1dGVOYW1lUHJlZml4OiAnQF8nLFxuICBhdHRyaWJ1dGVzR3JvdXBOYW1lOiBmYWxzZVxufTtcblxuLy8gVGhlIGRlZmF1bHQgWE1MIHBhcnNlclxuZXhwb3J0cy54bWxDb2x1bW5WYXJpYW50UGFyc2VyID0gY3JlYXRlWG1sQ29sdW1uVmFyaWFudFBhcnNlcihkZWZhdWx0WG1sUGFyc2VyQ29uZmlndXJhdGlvbik7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlICd4bWxDb2x1bW5WYXJpYW50UGFyc2VyJyBwYXJhbWV0ZXIuXG4gKiBSZXR1cm4gZnVjbnRpb24gd2l0aCBjdXN0b20gWG1sUGFyc2VyIGNvbmZpZ3VyYXRpb24gb3IgZGVmYXVsdCBpZiBub3Qgc2V0LlxuICpcbiAqIEBwYXJhbSB7ZnVuY3Rpb246IChyYXdDb2x1bW5WYWx1ZTogc3RyaW5nKSA9PiBhbnl9IHZhbHVlXG4gKi9cbmV4cG9ydHMuc2V0WG1sQ29sdW1uVmFyaWFudFBhcnNlciA9IGZ1bmN0aW9uICh2YWx1ZSl7XG4gIC8vIHZhbGlkYXRlIGlucHV0XG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzRnVuY3Rpb24odmFsdWUpKTtcblxuICBleHBvcnRzLnhtbENvbHVtblZhcmlhbnRQYXJzZXIgPSB2YWx1ZTtcbn07XG4vKipcbiAqIENyZWF0ZSBhbmQgdXBkYXRlIHRoZSAneG1sQ29sdW1uVmFyaWFudFBhcnNlcicgcGFyYW1ldGVyIHVzaW5nIGN1c3RvbSBwYXJzZXIgY29uZmlndXJhdGlvbi5cbiAqXG4gKiBAcGFyYW0ge2Z1bmN0aW9uOiAocmF3Q29sdW1uVmFsdWU6IHN0cmluZykgPT4gYW55fSBwYXJhbXNcbiAqL1xuZXhwb3J0cy5jcmVhdGVYbWxDb2x1bW5WYXJpYW50UGFyc2VyV2l0aFBhcmFtZXRlcnMgPSBmdW5jdGlvbiAocGFyYW1zKXtcbiAgZXhwb3J0cy54bWxDb2x1bW5WYXJpYW50UGFyc2VyID0gY3JlYXRlWG1sQ29sdW1uVmFyaWFudFBhcnNlcihwYXJhbXMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGUgZnVuY3Rpb24gdG8gcGFyc2UgWE1MIHVzaW5nIFhNbFBhcnNlciB3aXRoIGN1c3RvbSBjb25maWd1cmF0aW9uLlxuICogUGFyYW1ldHJzIHRoYXQgeW91IGNhbiBvdmVycmlkZTpcbiAqICBpZ25vcmVBdHRyaWJ1dGVzOiB0cnVlLFxuICogIGF0dHJpYnV0ZU5hbWVQcmVmaXg6ICdAXycsXG4gKiAgYXR0cmlidXRlc0dyb3VwTmFtZTogZmFsc2UsXG4gKiAgYWx3YXlzQ3JlYXRlVGV4dE5vZGU6IGZhbHNlXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZ1xuICovXG5mdW5jdGlvbiBjcmVhdGVYbWxDb2x1bW5WYXJpYW50UGFyc2VyKGNvbmZpZykge1xuICBsZXQgcGFyc2VyQ29uZmlndXJhdGlvbjtcbiAgaWYgKCFVdGlsLmlzT2JqZWN0KGNvbmZpZykpIHtcbiAgICBwYXJzZXJDb25maWd1cmF0aW9uID0gZGVmYXVsdFhtbFBhcnNlckNvbmZpZ3VyYXRpb247XG4gIH0gZWxzZSB7XG4gICAgcGFyc2VyQ29uZmlndXJhdGlvbiA9IHtcbiAgICAgIGlnbm9yZUF0dHJpYnV0ZXM6IFV0aWwuZXhpc3RzKGNvbmZpZy5pZ25vcmVBdHRyaWJ1dGVzKSA/IGNvbmZpZy5pZ25vcmVBdHRyaWJ1dGVzIDogZGVmYXVsdFhtbFBhcnNlckNvbmZpZ3VyYXRpb24uaWdub3JlQXR0cmlidXRlcyxcbiAgICAgIGF0dHJpYnV0ZU5hbWVQcmVmaXg6IFV0aWwuZXhpc3RzKGNvbmZpZy5hdHRyaWJ1dGVOYW1lUHJlZml4KSA/IGNvbmZpZy5hdHRyaWJ1dGVOYW1lUHJlZml4IDogZGVmYXVsdFhtbFBhcnNlckNvbmZpZ3VyYXRpb24uYXR0cmlidXRlTmFtZVByZWZpeCxcbiAgICAgIC8vRm9yIGF0dHJpYnV0ZXNHcm91cE5hbWUgbnVsbCB2YWx1ZSBpcyBhY2NlcHRhYmxlIGFuZCBtZWFuIG5vIGdyb3VwaW5nXG4gICAgICBhdHRyaWJ1dGVzR3JvdXBOYW1lOiBjb25maWcuYXR0cmlidXRlc0dyb3VwTmFtZSAhPT0gdW5kZWZpbmVkID8gY29uZmlnLmF0dHJpYnV0ZXNHcm91cE5hbWUgOiBkZWZhdWx0WG1sUGFyc2VyQ29uZmlndXJhdGlvbi5hdHRyaWJ1dGVzR3JvdXBOYW1lLFxuICAgICAgYWx3YXlzQ3JlYXRlVGV4dE5vZGU6IFV0aWwuZXhpc3RzKGNvbmZpZy5hbHdheXNDcmVhdGVUZXh0Tm9kZSkgPyBjb25maWcuYWx3YXlzQ3JlYXRlVGV4dE5vZGUgOiBkZWZhdWx0WG1sUGFyc2VyQ29uZmlndXJhdGlvbi5hbHdheXNDcmVhdGVUZXh0Tm9kZSxcbiAgICB9O1xuICB9XG4gIHJldHVybiByYXdDb2x1bW5WYWx1ZSA9PiB7XG4gICAgLy8gY2hlY2sgaWYgcmF3IHN0cmluZyBpcyBpbiBYTUwgZm9ybWF0XG4gICAgLy8gZW5zdXJlIGVhY2ggdGFnIGlzIGVuY2xvc2VkIGFuZCBhbGwgYXR0cmlidXRlcyBhbmQgZWxlbWVudHMgYXJlIHZhbGlkXG4gICAgLy8gWE1MVmFsaWRhdG9yLnZhbGlkYXRlIHJldHVybnMgdHJ1ZSBpZiB2YWxpZCwgcmV0dXJucyBhbiBlcnJvciBpZiBpbnZhbGlkXG4gICAgY29uc3QgdmFsaWRhdGVSZXN1bHQgPSBYTUxWYWxpZGF0b3IudmFsaWRhdGUocmF3Q29sdW1uVmFsdWUpO1xuICAgIGlmICh2YWxpZGF0ZVJlc3VsdCA9PT0gdHJ1ZSkge1xuICAgICAgLy8gdXNlIFhNTCBwYXJzZXJcbiAgICAgIHJldHVybiBuZXcgWE1MUGFyc2VyKHBhcnNlckNvbmZpZ3VyYXRpb24pLnBhcnNlKHJhd0NvbHVtblZhbHVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbGlkYXRlUmVzdWx0LmVyci5tc2cpO1xuICAgIH1cbiAgfTtcbn1cblxubGV0IGtlZXBBbGl2ZSA9IHRydWU7XG5cbi8qKlxuICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlICdrZWVwQWxpdmUnIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHZhbHVlXG4gKi9cbmV4cG9ydHMuc2V0S2VlcEFsaXZlID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzQm9vbGVhbih2YWx1ZSkpO1xuICBrZWVwQWxpdmUgPSB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgb3ZlcnJpZGVuIHZhbHVlIG9mICdrZWVwQWxpdmUnIG9yIGRlZmF1bHQgaWYgbm90IHNldC4gRGVmYXVsdCB2YWx1ZSBpcyB0cnVlXG4gKlxuICogQHBhcmFtIHtib29sZWFufSB2YWx1ZVxuICovXG5leHBvcnRzLmdldEtlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGtlZXBBbGl2ZTtcbn07XG5cbmxldCBjcmVkZW50aWFsTWFuYWdlciA9IG51bGw7XG5cbmV4cG9ydHMuc2V0Q3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIgPSBmdW5jdGlvbiAoY3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIpIHtcbiAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmNoZWNrVmFsaWRDdXN0b21DcmVkZW50aWFsTWFuYWdlcihjdXN0b21DcmVkZW50aWFsTWFuYWdlciksXG4gICAgRXJyb3JDb2Rlcy5FUlJfR0xPQkFMX0NPTkZJR1VSRV9JTlZBTElEX0NVU1RPTV9DUkVERU5USUFMX01BTkFHRVIpO1xuICBcbiAgY3JlZGVudGlhbE1hbmFnZXIgPSAgY3VzdG9tQ3JlZGVudGlhbE1hbmFnZXI7XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ0N1c3RvbSBjcmVkZW50aWFsIG1hbmFnZXIgaXMgc2V0IGJ5IGEgdXNlci4nKTtcbn07XG5cbmV4cG9ydHMuZ2V0Q3JlZGVudGlhbE1hbmFnZXIgPSBmdW5jdGlvbiAoKSB7IFxuICByZXR1cm4gY3JlZGVudGlhbE1hbmFnZXI7ICBcbn07XG5cbmxldCBlbnZQcm94eSA9IHRydWU7XG5leHBvcnRzLnNldEVudlByb3h5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzQm9vbGVhbih2YWx1ZSkpO1xuICBlbnZQcm94eSA9IHZhbHVlO1xufTtcblxuZXhwb3J0cy5pc0VudlByb3h5QWN0aXZlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gZW52UHJveHk7XG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/global_config.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/http/base.js":
/*!*****************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/http/base.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst ExecutionTimer = __webpack_require__(/*! ../logger/execution_timer */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger/execution_timer.js\");\nconst axios = __webpack_require__(/*! axios */ \"(rsc)/./node_modules/axios/dist/node/axios.cjs\");\nconst URL = (__webpack_require__(/*! node:url */ \"node:url\").URL);\nconst requestUtil = __webpack_require__(/*! ./request_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/http/request_util.js\");\n\nconst DEFAULT_REQUEST_TIMEOUT = 360000;\n\n/**\n * Creates a new HTTP client.\n *\n * @param connectionConfig\n * @constructor\n */\nfunction HttpClient(connectionConfig) {\n  // save the connection config\n  Logger.getInstance().trace('Initializing base HttpClient with Connection Config[%s]',\n    connectionConfig.describeIdentityAttributes());\n  this._connectionConfig = connectionConfig;\n}\n\n/**\n * Issues an HTTP request.\n *\n * @param {Object} options\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.request = function (options) {\n  Logger.getInstance().trace('Request%s - preparing for sending.', requestUtil.describeRequestFromOptions(options));\n\n  const requestObject = {};\n  const requestAbortController = new AbortController();\n  const requestHandlers = { signal: requestAbortController.signal };\n  const requestOptions = prepareRequestOptions.call(this, options, requestHandlers);\n\n  let sendRequest = async function sendRequest() {\n    Logger.getInstance().trace('Request%s - sending.', requestUtil.describeRequestFromOptions(requestOptions));\n    const timer = new ExecutionTimer().start();\n    requestObject.requestPromise = axios.request(requestOptions).then(response => {\n      const httpResponseTime = timer.getDuration();\n      Logger.getInstance().debug('Request%s - response received after %s milliseconds with status %s.', requestUtil.describeRequestFromOptions(requestOptions), httpResponseTime, response.status);\n      sanitizeAxiosResponse(response);\n      if (Util.isFunction(options.callback)) {\n        Logger.getInstance().trace('Request%s - calling callback function.', requestUtil.describeRequestFromOptions(requestOptions));\n        return options.callback(null, normalizeResponse(response), response.data);\n      } else {\n        Logger.getInstance().trace('Request%s - callback function was not provided.', requestUtil.describeRequestFromOptions(requestOptions));\n        return null;\n      }\n    }).catch(err => {\n      const httpResponseTime = timer.getDuration();\n      Logger.getInstance().debug('Request%s - failed after %s milliseconds.', requestUtil.describeRequestFromOptions(requestOptions), httpResponseTime);\n      sanitizeAxiosError(err);\n      if (Util.isFunction(options.callback)) {\n        if (err.response) { // axios returns error for not 2xx responses - let's unwrap it\n          Logger.getInstance().trace('Request%s - calling callback function for error from response. Received code: ', requestUtil.describeRequestFromOptions(requestOptions), err.response.status);\n          options.callback(null, normalizeResponse(err.response), err.response.data);\n        } else {\n          Logger.getInstance().trace('Request%s - calling callback function for error without response.', requestUtil.describeRequestFromOptions(requestOptions));\n          options.callback(err, normalizeResponse(null), null);\n        }\n        return null;\n      } else {\n        Logger.getInstance().warn('Request%s - callback function was not provided. Error will be re-raised.', requestUtil.describeRequestFromOptions(requestOptions));\n        throw err;\n      }\n    });\n  };\n  sendRequest = sendRequest.bind(this);\n\n  Logger.getInstance().trace('Request%s - issued for the next tick.', requestUtil.describeRequestFromOptions(requestOptions));\n  process.nextTick(sendRequest);\n\n  // return an externalized request object that only contains\n  // methods we're comfortable exposing to the outside world\n  requestObject.abort = function () {\n    if (requestAbortController) {\n      Logger.getInstance().trace('Request%s - aborting.', requestUtil.describeRequestFromOptions(requestOptions));\n      requestAbortController.abort();\n      Logger.getInstance().debug('Request%s - aborted.', requestUtil.describeRequestFromOptions(requestOptions));\n    }\n  };\n\n  return requestObject;\n};\n\n/**\n * Issues an HTTP request.\n *\n * @param {Object} options\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.requestAsync = async function (options) {\n  Logger.getInstance().trace('Request%s - preparing for async sending.', requestUtil.describeRequestFromOptions(options));\n  const timer = new ExecutionTimer();\n  try {\n    const requestOptions = prepareRequestOptions.call(this, options);\n\n    timer.start();\n    const response = await axios.request(requestOptions);\n    const httpResponseTime = timer.getDuration();\n    Logger.getInstance().debug('Request%s - response received after %s milliseconds with status %s.', requestUtil.describeRequestFromOptions(requestOptions), httpResponseTime, response.status);\n    parseResponseData(response);\n    sanitizeAxiosResponse(response);\n    return normalizeResponse(response);\n  } catch (err) {\n    const httpResponseTime = timer.getDuration();\n    Logger.getInstance().debug('Request%s - failed after %s milliseconds. Error will be re-raised.', requestUtil.describeRequestFromOptions(options), httpResponseTime);\n    sanitizeAxiosError(err);\n    throw err;\n  }\n};\n\nfunction parseResponseData(response) {\n  Logger.getInstance().trace('Request%s - parsing response data.', requestUtil.describeRequestFromResponse(response));\n  parseIfJSONData(response);\n}\n\nfunction parseIfJSONData(response) {\n  if (Util.isString(response['data']) &&\n      response['headers']['content-type'] === 'application/json') {\n    response['data'] = JSON.parse(response['data']);\n  }\n}\n\n/**\n * Issues an HTTP POST request.\n *\n * @param {String} url\n * @param {String} body\n * @param {Object} options\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.post = async function (url, body, options) {\n  return this.requestAsync({\n    url: url,\n    method: 'POST',\n    data: body,\n    ...options\n  });\n};\n\n/**\n * Issues an HTTP GET request.\n *\n * @param {String} url\n * @param {Object} params\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.get = async function (url, params) {\n  return this.requestAsync({\n    url: url,\n    method: 'GET',\n    ...params,\n  });\n};\n\n/**\n * Issues an HTTP HEAD request.\n *\n * @param {String} url\n * @param {Object} config\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.head = async function (url, config) {\n  return this.requestAsync({\n    url: url,\n    method: 'HEAD',\n    ...config\n  });\n};\n\n/**\n * Issues an HTTP PUT request.\n *\n * @param {String} url\n * @param {Object} data\n * @param {Object} config\n *\n * @returns {Object} an object representing the request that was issued.\n */\nHttpClient.prototype.put = async function (url, data, config) {\n  return this.requestAsync({\n    url: url,\n    method: 'PUT',\n    data: data,\n    ...config\n  });\n};\n\n/**\n * @abstract\n * Returns the module to use when making HTTP requests. Subclasses must override\n * and provide their own implementations.\n *\n * @returns {*}\n */\nHttpClient.prototype.getRequestModule = function () {\n  return null;\n};\n\n/**\n * Returns the agent and proxy options.\n *\n * @returns {*}\n */\nHttpClient.prototype.getAgent = function () {\n  return null;\n};\n\nmodule.exports = HttpClient;\n\nfunction sanitizeAxiosResponse(response) {\n  Logger.getInstance().trace('Request%s - sanitizing response data.', requestUtil.describeRequestFromResponse(response));\n  response.request = undefined;\n  if (response.config) {\n    response.config.data = undefined;\n    response.config.headers = undefined;\n  }\n}\n\nfunction sanitizeAxiosError(error) {\n  error.request = undefined;\n  error.config = undefined;\n  if (error.response) {\n    Logger.getInstance().trace('Request%s - sanitizing response error data.', requestUtil.describeRequestFromResponse(error.response));\n    sanitizeAxiosResponse(error.response);\n  }\n}\n\nfunction prepareRequestOptions(options, requestHandlers = {}) {\n  Logger.getInstance().trace('Request%s - constructing options.', requestUtil.describeRequestFromOptions(options));\n  const headers = normalizeHeaders(options.headers) || {};\n\n  const timeout = options.timeout ||\n    this._connectionConfig.getTimeout() ||\n    DEFAULT_REQUEST_TIMEOUT;\n\n  let data = options.data || options.json;\n\n  if (data) {\n    const bufferUncompressed = Buffer.from(JSON.stringify(data), 'utf8');\n    zlib.gzip(bufferUncompressed, null, function (err, bufferCompressed) {\n      // if the compression was successful\n      if (!err) {\n        data = bufferCompressed;\n        headers['Content-Encoding'] = 'gzip';\n        Logger.getInstance().debug('Request%s - original buffer length: %d bytes. Compressed buffer length: %d bytes.', requestUtil.describeRequestFromOptions(options), bufferUncompressed.buffer.byteLength, bufferCompressed.buffer.byteLength);\n      } else {\n        // Logging 'err' variable value should not be done, since it may contain compressed customer's data.\n        // It can be added only for debugging purposes.\n        Logger.getInstance().warn('Request%s - could not compress request data.', requestUtil.describeRequestFromOptions(options));\n      }\n    });\n  }\n\n  const params = options.params;\n\n  let mock;\n  if (this._connectionConfig.agentClass) {\n    mock = {\n      agentClass: this._connectionConfig.agentClass\n    };\n  }\n  const backoffStrategy = this.constructExponentialBackoffStrategy();\n  const requestOptions =  {\n    method: options.method,\n    url: options.url,\n    headers: headers,\n    data: data,\n    params: params,\n    timeout: timeout,\n    requestOCSP: true,\n    retryDelay: backoffStrategy,\n    rejectUnauthorized: true,\n    // we manually parse jsons or other structures from the server so they need to be text\n    responseType: options.responseType || 'text',\n    proxy: false,\n    ...requestHandlers\n  };\n\n  const url = new URL(options.url);\n  const isHttps = url.protocol === 'https:';\n  const agent = this.getAgent(url, this._connectionConfig.getProxy(), mock);\n  if (isHttps) {\n    requestOptions.httpsAgent = agent;\n  } else {\n    requestOptions.httpAgent = agent;\n  }\n\n  Logger.getInstance().debug('Request%s - options - timeout: %s, retryDelay: %s, responseType: %s', requestUtil.describeRequestFromOptions(options), requestOptions.timeout, requestOptions.retryDelay, requestOptions.responseType);\n  return requestOptions;\n}\n\n/**\n * Normalizes a request headers object so that we get the same behavior\n * regardless of whether we're using request.js or browser-request.js.\n *\n * @param {Object} headers\n *\n * @returns {Object}\n */\nfunction normalizeHeaders(headers) {\n  Logger.getInstance().trace('Normalizing headers');\n  if (Util.isObject(headers)) {\n    const normalizedHeaders = {\n      'user-agent': Util.userAgent\n    };\n\n    // shallow copy the headers object and convert some headers like 'Accept'\n    // and 'Content-Type' to lower case while copying; this is necessary\n    // because the browser-request module, which we use to make http requests in\n    // the browser, does not do case-insensitive checks when deciding whether to\n    // insert default values for the 'accept' and 'content-type' headers; in\n    // otherwise, if someone specifies an 'Accept': 'application/json' header,\n    // browser-request will inject its own 'accept': 'application/json' header\n    // and the browser XMLHttpRequest object will concatenate the two values and\n    // send 'Accept': 'application/json, application/json' with the request\n    let headerNameLowerCase;\n    for (const headerName in headers) {\n      if (Object.prototype.hasOwnProperty.call(headers, headerName)) {\n        headerNameLowerCase = headerName.toLowerCase();\n        if ((headerNameLowerCase === 'accept') ||\n          (headerNameLowerCase === 'content-type')) {\n          normalizedHeaders[headerNameLowerCase] = headers[headerName];\n        } else {\n          normalizedHeaders[headerName] = headers[headerName];\n        }\n      }\n    }\n    Logger.getInstance().trace('Headers were normalized');\n    return normalizedHeaders;\n  } else {\n    Logger.getInstance().trace('Headers were not an object. Original value will be returned.');\n    return headers;\n  }\n\n}\n\n/**\n * Normalizes the response object so that we can extract response headers from\n * it in a uniform way regardless of whether we're using request.js or\n * browser-request.js.\n *\n * @param {Object} response\n *\n * @return {Object}\n */\nfunction normalizeResponse(response) {\n  // if the response doesn't already have a getResponseHeader() method, add one\n  if (response && !response.getResponseHeader) {\n    Logger.getInstance().trace('Request%s - normalizing.', requestUtil.describeRequestFromResponse(response));\n    response.getResponseHeader = function (header) {\n      return response.headers && response.headers[\n        Util.isString(header) ? header.toLowerCase() : header];\n    };\n  }\n\n  if (response) {\n    response.body = response.data; // converting axios response body to old expected body attribute\n    response.statusCode = response.status; // converting axios status to old expected statusCode\n  }\n\n  return response;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvaHR0cC9iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixhQUFhLG1CQUFPLENBQUMsK0RBQVM7QUFDOUIsZUFBZSxtQkFBTyxDQUFDLG1FQUFXO0FBQ2xDLHVCQUF1QixtQkFBTyxDQUFDLG1HQUEyQjtBQUMxRCxjQUFjLG1CQUFPLENBQUMsNkRBQU87QUFDN0IsWUFBWSxxREFBdUI7QUFDbkMsb0JBQW9CLG1CQUFPLENBQUMsbUZBQWdCOztBQUU1Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw0REFBNEQ7QUFDNUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQSwwRUFBMEU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQ0FBbUM7QUFDbkMsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvaHR0cC9iYXNlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBFeGVjdXRpb25UaW1lciA9IHJlcXVpcmUoJy4uL2xvZ2dlci9leGVjdXRpb25fdGltZXInKTtcbmNvbnN0IGF4aW9zID0gcmVxdWlyZSgnYXhpb3MnKTtcbmNvbnN0IFVSTCA9IHJlcXVpcmUoJ25vZGU6dXJsJykuVVJMO1xuY29uc3QgcmVxdWVzdFV0aWwgPSByZXF1aXJlKCcuL3JlcXVlc3RfdXRpbCcpO1xuXG5jb25zdCBERUZBVUxUX1JFUVVFU1RfVElNRU9VVCA9IDM2MDAwMDtcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEhUVFAgY2xpZW50LlxuICpcbiAqIEBwYXJhbSBjb25uZWN0aW9uQ29uZmlnXG4gKiBAY29uc3RydWN0b3JcbiAqL1xuZnVuY3Rpb24gSHR0cENsaWVudChjb25uZWN0aW9uQ29uZmlnKSB7XG4gIC8vIHNhdmUgdGhlIGNvbm5lY3Rpb24gY29uZmlnXG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdJbml0aWFsaXppbmcgYmFzZSBIdHRwQ2xpZW50IHdpdGggQ29ubmVjdGlvbiBDb25maWdbJXNdJyxcbiAgICBjb25uZWN0aW9uQ29uZmlnLmRlc2NyaWJlSWRlbnRpdHlBdHRyaWJ1dGVzKCkpO1xuICB0aGlzLl9jb25uZWN0aW9uQ29uZmlnID0gY29ubmVjdGlvbkNvbmZpZztcbn1cblxuLyoqXG4gKiBJc3N1ZXMgYW4gSFRUUCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gKlxuICogQHJldHVybnMge09iamVjdH0gYW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgcmVxdWVzdCB0aGF0IHdhcyBpc3N1ZWQuXG4gKi9cbkh0dHBDbGllbnQucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gcHJlcGFyaW5nIGZvciBzZW5kaW5nLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKG9wdGlvbnMpKTtcblxuICBjb25zdCByZXF1ZXN0T2JqZWN0ID0ge307XG4gIGNvbnN0IHJlcXVlc3RBYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gIGNvbnN0IHJlcXVlc3RIYW5kbGVycyA9IHsgc2lnbmFsOiByZXF1ZXN0QWJvcnRDb250cm9sbGVyLnNpZ25hbCB9O1xuICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHByZXBhcmVSZXF1ZXN0T3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMsIHJlcXVlc3RIYW5kbGVycyk7XG5cbiAgbGV0IHNlbmRSZXF1ZXN0ID0gYXN5bmMgZnVuY3Rpb24gc2VuZFJlcXVlc3QoKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ1JlcXVlc3QlcyAtIHNlbmRpbmcuJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMocmVxdWVzdE9wdGlvbnMpKTtcbiAgICBjb25zdCB0aW1lciA9IG5ldyBFeGVjdXRpb25UaW1lcigpLnN0YXJ0KCk7XG4gICAgcmVxdWVzdE9iamVjdC5yZXF1ZXN0UHJvbWlzZSA9IGF4aW9zLnJlcXVlc3QocmVxdWVzdE9wdGlvbnMpLnRoZW4ocmVzcG9uc2UgPT4ge1xuICAgICAgY29uc3QgaHR0cFJlc3BvbnNlVGltZSA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUmVxdWVzdCVzIC0gcmVzcG9uc2UgcmVjZWl2ZWQgYWZ0ZXIgJXMgbWlsbGlzZWNvbmRzIHdpdGggc3RhdHVzICVzLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zKSwgaHR0cFJlc3BvbnNlVGltZSwgcmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgIHNhbml0aXplQXhpb3NSZXNwb25zZShyZXNwb25zZSk7XG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKG9wdGlvbnMuY2FsbGJhY2spKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0JXMgLSBjYWxsaW5nIGNhbGxiYWNrIGZ1bmN0aW9uLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zKSk7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmNhbGxiYWNrKG51bGwsIG5vcm1hbGl6ZVJlc3BvbnNlKHJlc3BvbnNlKSwgcmVzcG9uc2UuZGF0YSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gY2FsbGJhY2sgZnVuY3Rpb24gd2FzIG5vdCBwcm92aWRlZC4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhyZXF1ZXN0T3B0aW9ucykpO1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9KS5jYXRjaChlcnIgPT4ge1xuICAgICAgY29uc3QgaHR0cFJlc3BvbnNlVGltZSA9IHRpbWVyLmdldER1cmF0aW9uKCk7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUmVxdWVzdCVzIC0gZmFpbGVkIGFmdGVyICVzIG1pbGxpc2Vjb25kcy4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhyZXF1ZXN0T3B0aW9ucyksIGh0dHBSZXNwb25zZVRpbWUpO1xuICAgICAgc2FuaXRpemVBeGlvc0Vycm9yKGVycik7XG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKG9wdGlvbnMuY2FsbGJhY2spKSB7XG4gICAgICAgIGlmIChlcnIucmVzcG9uc2UpIHsgLy8gYXhpb3MgcmV0dXJucyBlcnJvciBmb3Igbm90IDJ4eCByZXNwb25zZXMgLSBsZXQncyB1bndyYXAgaXRcbiAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gY2FsbGluZyBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZXJyb3IgZnJvbSByZXNwb25zZS4gUmVjZWl2ZWQgY29kZTogJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMocmVxdWVzdE9wdGlvbnMpLCBlcnIucmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICBvcHRpb25zLmNhbGxiYWNrKG51bGwsIG5vcm1hbGl6ZVJlc3BvbnNlKGVyci5yZXNwb25zZSksIGVyci5yZXNwb25zZS5kYXRhKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gY2FsbGluZyBjYWxsYmFjayBmdW5jdGlvbiBmb3IgZXJyb3Igd2l0aG91dCByZXNwb25zZS4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhyZXF1ZXN0T3B0aW9ucykpO1xuICAgICAgICAgIG9wdGlvbnMuY2FsbGJhY2soZXJyLCBub3JtYWxpemVSZXNwb25zZShudWxsKSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdSZXF1ZXN0JXMgLSBjYWxsYmFjayBmdW5jdGlvbiB3YXMgbm90IHByb3ZpZGVkLiBFcnJvciB3aWxsIGJlIHJlLXJhaXNlZC4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhyZXF1ZXN0T3B0aW9ucykpO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIHNlbmRSZXF1ZXN0ID0gc2VuZFJlcXVlc3QuYmluZCh0aGlzKTtcblxuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gaXNzdWVkIGZvciB0aGUgbmV4dCB0aWNrLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zKSk7XG4gIHByb2Nlc3MubmV4dFRpY2soc2VuZFJlcXVlc3QpO1xuXG4gIC8vIHJldHVybiBhbiBleHRlcm5hbGl6ZWQgcmVxdWVzdCBvYmplY3QgdGhhdCBvbmx5IGNvbnRhaW5zXG4gIC8vIG1ldGhvZHMgd2UncmUgY29tZm9ydGFibGUgZXhwb3NpbmcgdG8gdGhlIG91dHNpZGUgd29ybGRcbiAgcmVxdWVzdE9iamVjdC5hYm9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAocmVxdWVzdEFib3J0Q29udHJvbGxlcikge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ1JlcXVlc3QlcyAtIGFib3J0aW5nLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKHJlcXVlc3RPcHRpb25zKSk7XG4gICAgICByZXF1ZXN0QWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUmVxdWVzdCVzIC0gYWJvcnRlZC4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhyZXF1ZXN0T3B0aW9ucykpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gcmVxdWVzdE9iamVjdDtcbn07XG5cbi8qKlxuICogSXNzdWVzIGFuIEhUVFAgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlcXVlc3QgdGhhdCB3YXMgaXNzdWVkLlxuICovXG5IdHRwQ2xpZW50LnByb3RvdHlwZS5yZXF1ZXN0QXN5bmMgPSBhc3luYyBmdW5jdGlvbiAob3B0aW9ucykge1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gcHJlcGFyaW5nIGZvciBhc3luYyBzZW5kaW5nLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKG9wdGlvbnMpKTtcbiAgY29uc3QgdGltZXIgPSBuZXcgRXhlY3V0aW9uVGltZXIoKTtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHByZXBhcmVSZXF1ZXN0T3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgdGltZXIuc3RhcnQoKTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGF4aW9zLnJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgIGNvbnN0IGh0dHBSZXNwb25zZVRpbWUgPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdSZXF1ZXN0JXMgLSByZXNwb25zZSByZWNlaXZlZCBhZnRlciAlcyBtaWxsaXNlY29uZHMgd2l0aCBzdGF0dXMgJXMuJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMocmVxdWVzdE9wdGlvbnMpLCBodHRwUmVzcG9uc2VUaW1lLCByZXNwb25zZS5zdGF0dXMpO1xuICAgIHBhcnNlUmVzcG9uc2VEYXRhKHJlc3BvbnNlKTtcbiAgICBzYW5pdGl6ZUF4aW9zUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIHJldHVybiBub3JtYWxpemVSZXNwb25zZShyZXNwb25zZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnN0IGh0dHBSZXNwb25zZVRpbWUgPSB0aW1lci5nZXREdXJhdGlvbigpO1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdSZXF1ZXN0JXMgLSBmYWlsZWQgYWZ0ZXIgJXMgbWlsbGlzZWNvbmRzLiBFcnJvciB3aWxsIGJlIHJlLXJhaXNlZC4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhvcHRpb25zKSwgaHR0cFJlc3BvbnNlVGltZSk7XG4gICAgc2FuaXRpemVBeGlvc0Vycm9yKGVycik7XG4gICAgdGhyb3cgZXJyO1xuICB9XG59O1xuXG5mdW5jdGlvbiBwYXJzZVJlc3BvbnNlRGF0YShyZXNwb25zZSkge1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gcGFyc2luZyByZXNwb25zZSBkYXRhLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21SZXNwb25zZShyZXNwb25zZSkpO1xuICBwYXJzZUlmSlNPTkRhdGEocmVzcG9uc2UpO1xufVxuXG5mdW5jdGlvbiBwYXJzZUlmSlNPTkRhdGEocmVzcG9uc2UpIHtcbiAgaWYgKFV0aWwuaXNTdHJpbmcocmVzcG9uc2VbJ2RhdGEnXSkgJiZcbiAgICAgIHJlc3BvbnNlWydoZWFkZXJzJ11bJ2NvbnRlbnQtdHlwZSddID09PSAnYXBwbGljYXRpb24vanNvbicpIHtcbiAgICByZXNwb25zZVsnZGF0YSddID0gSlNPTi5wYXJzZShyZXNwb25zZVsnZGF0YSddKTtcbiAgfVxufVxuXG4vKipcbiAqIElzc3VlcyBhbiBIVFRQIFBPU1QgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge1N0cmluZ30gYm9keVxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByZXF1ZXN0IHRoYXQgd2FzIGlzc3VlZC5cbiAqL1xuSHR0cENsaWVudC5wcm90b3R5cGUucG9zdCA9IGFzeW5jIGZ1bmN0aW9uICh1cmwsIGJvZHksIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMucmVxdWVzdEFzeW5jKHtcbiAgICB1cmw6IHVybCxcbiAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICBkYXRhOiBib2R5LFxuICAgIC4uLm9wdGlvbnNcbiAgfSk7XG59O1xuXG4vKipcbiAqIElzc3VlcyBhbiBIVFRQIEdFVCByZXF1ZXN0LlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXNcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBhbiBvYmplY3QgcmVwcmVzZW50aW5nIHRoZSByZXF1ZXN0IHRoYXQgd2FzIGlzc3VlZC5cbiAqL1xuSHR0cENsaWVudC5wcm90b3R5cGUuZ2V0ID0gYXN5bmMgZnVuY3Rpb24gKHVybCwgcGFyYW1zKSB7XG4gIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyh7XG4gICAgdXJsOiB1cmwsXG4gICAgbWV0aG9kOiAnR0VUJyxcbiAgICAuLi5wYXJhbXMsXG4gIH0pO1xufTtcblxuLyoqXG4gKiBJc3N1ZXMgYW4gSFRUUCBIRUFEIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHVybFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlcXVlc3QgdGhhdCB3YXMgaXNzdWVkLlxuICovXG5IdHRwQ2xpZW50LnByb3RvdHlwZS5oZWFkID0gYXN5bmMgZnVuY3Rpb24gKHVybCwgY29uZmlnKSB7XG4gIHJldHVybiB0aGlzLnJlcXVlc3RBc3luYyh7XG4gICAgdXJsOiB1cmwsXG4gICAgbWV0aG9kOiAnSEVBRCcsXG4gICAgLi4uY29uZmlnXG4gIH0pO1xufTtcblxuLyoqXG4gKiBJc3N1ZXMgYW4gSFRUUCBQVVQgcmVxdWVzdC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsXG4gKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZ1xuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9IGFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlcXVlc3QgdGhhdCB3YXMgaXNzdWVkLlxuICovXG5IdHRwQ2xpZW50LnByb3RvdHlwZS5wdXQgPSBhc3luYyBmdW5jdGlvbiAodXJsLCBkYXRhLCBjb25maWcpIHtcbiAgcmV0dXJuIHRoaXMucmVxdWVzdEFzeW5jKHtcbiAgICB1cmw6IHVybCxcbiAgICBtZXRob2Q6ICdQVVQnLFxuICAgIGRhdGE6IGRhdGEsXG4gICAgLi4uY29uZmlnXG4gIH0pO1xufTtcblxuLyoqXG4gKiBAYWJzdHJhY3RcbiAqIFJldHVybnMgdGhlIG1vZHVsZSB0byB1c2Ugd2hlbiBtYWtpbmcgSFRUUCByZXF1ZXN0cy4gU3ViY2xhc3NlcyBtdXN0IG92ZXJyaWRlXG4gKiBhbmQgcHJvdmlkZSB0aGVpciBvd24gaW1wbGVtZW50YXRpb25zLlxuICpcbiAqIEByZXR1cm5zIHsqfVxuICovXG5IdHRwQ2xpZW50LnByb3RvdHlwZS5nZXRSZXF1ZXN0TW9kdWxlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgYWdlbnQgYW5kIHByb3h5IG9wdGlvbnMuXG4gKlxuICogQHJldHVybnMgeyp9XG4gKi9cbkh0dHBDbGllbnQucHJvdG90eXBlLmdldEFnZW50ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gbnVsbDtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gSHR0cENsaWVudDtcblxuZnVuY3Rpb24gc2FuaXRpemVBeGlvc1Jlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0JXMgLSBzYW5pdGl6aW5nIHJlc3BvbnNlIGRhdGEuJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbVJlc3BvbnNlKHJlc3BvbnNlKSk7XG4gIHJlc3BvbnNlLnJlcXVlc3QgPSB1bmRlZmluZWQ7XG4gIGlmIChyZXNwb25zZS5jb25maWcpIHtcbiAgICByZXNwb25zZS5jb25maWcuZGF0YSA9IHVuZGVmaW5lZDtcbiAgICByZXNwb25zZS5jb25maWcuaGVhZGVycyA9IHVuZGVmaW5lZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBzYW5pdGl6ZUF4aW9zRXJyb3IoZXJyb3IpIHtcbiAgZXJyb3IucmVxdWVzdCA9IHVuZGVmaW5lZDtcbiAgZXJyb3IuY29uZmlnID0gdW5kZWZpbmVkO1xuICBpZiAoZXJyb3IucmVzcG9uc2UpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gc2FuaXRpemluZyByZXNwb25zZSBlcnJvciBkYXRhLicsIHJlcXVlc3RVdGlsLmRlc2NyaWJlUmVxdWVzdEZyb21SZXNwb25zZShlcnJvci5yZXNwb25zZSkpO1xuICAgIHNhbml0aXplQXhpb3NSZXNwb25zZShlcnJvci5yZXNwb25zZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJlcGFyZVJlcXVlc3RPcHRpb25zKG9wdGlvbnMsIHJlcXVlc3RIYW5kbGVycyA9IHt9KSB7XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0JXMgLSBjb25zdHJ1Y3Rpbmcgb3B0aW9ucy4nLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhvcHRpb25zKSk7XG4gIGNvbnN0IGhlYWRlcnMgPSBub3JtYWxpemVIZWFkZXJzKG9wdGlvbnMuaGVhZGVycykgfHwge307XG5cbiAgY29uc3QgdGltZW91dCA9IG9wdGlvbnMudGltZW91dCB8fFxuICAgIHRoaXMuX2Nvbm5lY3Rpb25Db25maWcuZ2V0VGltZW91dCgpIHx8XG4gICAgREVGQVVMVF9SRVFVRVNUX1RJTUVPVVQ7XG5cbiAgbGV0IGRhdGEgPSBvcHRpb25zLmRhdGEgfHwgb3B0aW9ucy5qc29uO1xuXG4gIGlmIChkYXRhKSB7XG4gICAgY29uc3QgYnVmZmVyVW5jb21wcmVzc2VkID0gQnVmZmVyLmZyb20oSlNPTi5zdHJpbmdpZnkoZGF0YSksICd1dGY4Jyk7XG4gICAgemxpYi5nemlwKGJ1ZmZlclVuY29tcHJlc3NlZCwgbnVsbCwgZnVuY3Rpb24gKGVyciwgYnVmZmVyQ29tcHJlc3NlZCkge1xuICAgICAgLy8gaWYgdGhlIGNvbXByZXNzaW9uIHdhcyBzdWNjZXNzZnVsXG4gICAgICBpZiAoIWVycikge1xuICAgICAgICBkYXRhID0gYnVmZmVyQ29tcHJlc3NlZDtcbiAgICAgICAgaGVhZGVyc1snQ29udGVudC1FbmNvZGluZyddID0gJ2d6aXAnO1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnUmVxdWVzdCVzIC0gb3JpZ2luYWwgYnVmZmVyIGxlbmd0aDogJWQgYnl0ZXMuIENvbXByZXNzZWQgYnVmZmVyIGxlbmd0aDogJWQgYnl0ZXMuJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMob3B0aW9ucyksIGJ1ZmZlclVuY29tcHJlc3NlZC5idWZmZXIuYnl0ZUxlbmd0aCwgYnVmZmVyQ29tcHJlc3NlZC5idWZmZXIuYnl0ZUxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBMb2dnaW5nICdlcnInIHZhcmlhYmxlIHZhbHVlIHNob3VsZCBub3QgYmUgZG9uZSwgc2luY2UgaXQgbWF5IGNvbnRhaW4gY29tcHJlc3NlZCBjdXN0b21lcidzIGRhdGEuXG4gICAgICAgIC8vIEl0IGNhbiBiZSBhZGRlZCBvbmx5IGZvciBkZWJ1Z2dpbmcgcHVycG9zZXMuXG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ1JlcXVlc3QlcyAtIGNvdWxkIG5vdCBjb21wcmVzcyByZXF1ZXN0IGRhdGEuJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbU9wdGlvbnMob3B0aW9ucykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgY29uc3QgcGFyYW1zID0gb3B0aW9ucy5wYXJhbXM7XG5cbiAgbGV0IG1vY2s7XG4gIGlmICh0aGlzLl9jb25uZWN0aW9uQ29uZmlnLmFnZW50Q2xhc3MpIHtcbiAgICBtb2NrID0ge1xuICAgICAgYWdlbnRDbGFzczogdGhpcy5fY29ubmVjdGlvbkNvbmZpZy5hZ2VudENsYXNzXG4gICAgfTtcbiAgfVxuICBjb25zdCBiYWNrb2ZmU3RyYXRlZ3kgPSB0aGlzLmNvbnN0cnVjdEV4cG9uZW50aWFsQmFja29mZlN0cmF0ZWd5KCk7XG4gIGNvbnN0IHJlcXVlc3RPcHRpb25zID0gIHtcbiAgICBtZXRob2Q6IG9wdGlvbnMubWV0aG9kLFxuICAgIHVybDogb3B0aW9ucy51cmwsXG4gICAgaGVhZGVyczogaGVhZGVycyxcbiAgICBkYXRhOiBkYXRhLFxuICAgIHBhcmFtczogcGFyYW1zLFxuICAgIHRpbWVvdXQ6IHRpbWVvdXQsXG4gICAgcmVxdWVzdE9DU1A6IHRydWUsXG4gICAgcmV0cnlEZWxheTogYmFja29mZlN0cmF0ZWd5LFxuICAgIHJlamVjdFVuYXV0aG9yaXplZDogdHJ1ZSxcbiAgICAvLyB3ZSBtYW51YWxseSBwYXJzZSBqc29ucyBvciBvdGhlciBzdHJ1Y3R1cmVzIGZyb20gdGhlIHNlcnZlciBzbyB0aGV5IG5lZWQgdG8gYmUgdGV4dFxuICAgIHJlc3BvbnNlVHlwZTogb3B0aW9ucy5yZXNwb25zZVR5cGUgfHwgJ3RleHQnLFxuICAgIHByb3h5OiBmYWxzZSxcbiAgICAuLi5yZXF1ZXN0SGFuZGxlcnNcbiAgfTtcblxuICBjb25zdCB1cmwgPSBuZXcgVVJMKG9wdGlvbnMudXJsKTtcbiAgY29uc3QgaXNIdHRwcyA9IHVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gIGNvbnN0IGFnZW50ID0gdGhpcy5nZXRBZ2VudCh1cmwsIHRoaXMuX2Nvbm5lY3Rpb25Db25maWcuZ2V0UHJveHkoKSwgbW9jayk7XG4gIGlmIChpc0h0dHBzKSB7XG4gICAgcmVxdWVzdE9wdGlvbnMuaHR0cHNBZ2VudCA9IGFnZW50O1xuICB9IGVsc2Uge1xuICAgIHJlcXVlc3RPcHRpb25zLmh0dHBBZ2VudCA9IGFnZW50O1xuICB9XG5cbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1JlcXVlc3QlcyAtIG9wdGlvbnMgLSB0aW1lb3V0OiAlcywgcmV0cnlEZWxheTogJXMsIHJlc3BvbnNlVHlwZTogJXMnLCByZXF1ZXN0VXRpbC5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyhvcHRpb25zKSwgcmVxdWVzdE9wdGlvbnMudGltZW91dCwgcmVxdWVzdE9wdGlvbnMucmV0cnlEZWxheSwgcmVxdWVzdE9wdGlvbnMucmVzcG9uc2VUeXBlKTtcbiAgcmV0dXJuIHJlcXVlc3RPcHRpb25zO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYSByZXF1ZXN0IGhlYWRlcnMgb2JqZWN0IHNvIHRoYXQgd2UgZ2V0IHRoZSBzYW1lIGJlaGF2aW9yXG4gKiByZWdhcmRsZXNzIG9mIHdoZXRoZXIgd2UncmUgdXNpbmcgcmVxdWVzdC5qcyBvciBicm93c2VyLXJlcXVlc3QuanMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGhlYWRlcnNcbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBub3JtYWxpemVIZWFkZXJzKGhlYWRlcnMpIHtcbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ05vcm1hbGl6aW5nIGhlYWRlcnMnKTtcbiAgaWYgKFV0aWwuaXNPYmplY3QoaGVhZGVycykpIHtcbiAgICBjb25zdCBub3JtYWxpemVkSGVhZGVycyA9IHtcbiAgICAgICd1c2VyLWFnZW50JzogVXRpbC51c2VyQWdlbnRcbiAgICB9O1xuXG4gICAgLy8gc2hhbGxvdyBjb3B5IHRoZSBoZWFkZXJzIG9iamVjdCBhbmQgY29udmVydCBzb21lIGhlYWRlcnMgbGlrZSAnQWNjZXB0J1xuICAgIC8vIGFuZCAnQ29udGVudC1UeXBlJyB0byBsb3dlciBjYXNlIHdoaWxlIGNvcHlpbmc7IHRoaXMgaXMgbmVjZXNzYXJ5XG4gICAgLy8gYmVjYXVzZSB0aGUgYnJvd3Nlci1yZXF1ZXN0IG1vZHVsZSwgd2hpY2ggd2UgdXNlIHRvIG1ha2UgaHR0cCByZXF1ZXN0cyBpblxuICAgIC8vIHRoZSBicm93c2VyLCBkb2VzIG5vdCBkbyBjYXNlLWluc2Vuc2l0aXZlIGNoZWNrcyB3aGVuIGRlY2lkaW5nIHdoZXRoZXIgdG9cbiAgICAvLyBpbnNlcnQgZGVmYXVsdCB2YWx1ZXMgZm9yIHRoZSAnYWNjZXB0JyBhbmQgJ2NvbnRlbnQtdHlwZScgaGVhZGVyczsgaW5cbiAgICAvLyBvdGhlcndpc2UsIGlmIHNvbWVvbmUgc3BlY2lmaWVzIGFuICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicgaGVhZGVyLFxuICAgIC8vIGJyb3dzZXItcmVxdWVzdCB3aWxsIGluamVjdCBpdHMgb3duICdhY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbicgaGVhZGVyXG4gICAgLy8gYW5kIHRoZSBicm93c2VyIFhNTEh0dHBSZXF1ZXN0IG9iamVjdCB3aWxsIGNvbmNhdGVuYXRlIHRoZSB0d28gdmFsdWVzIGFuZFxuICAgIC8vIHNlbmQgJ0FjY2VwdCc6ICdhcHBsaWNhdGlvbi9qc29uLCBhcHBsaWNhdGlvbi9qc29uJyB3aXRoIHRoZSByZXF1ZXN0XG4gICAgbGV0IGhlYWRlck5hbWVMb3dlckNhc2U7XG4gICAgZm9yIChjb25zdCBoZWFkZXJOYW1lIGluIGhlYWRlcnMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaGVhZGVycywgaGVhZGVyTmFtZSkpIHtcbiAgICAgICAgaGVhZGVyTmFtZUxvd2VyQ2FzZSA9IGhlYWRlck5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKChoZWFkZXJOYW1lTG93ZXJDYXNlID09PSAnYWNjZXB0JykgfHxcbiAgICAgICAgICAoaGVhZGVyTmFtZUxvd2VyQ2FzZSA9PT0gJ2NvbnRlbnQtdHlwZScpKSB7XG4gICAgICAgICAgbm9ybWFsaXplZEhlYWRlcnNbaGVhZGVyTmFtZUxvd2VyQ2FzZV0gPSBoZWFkZXJzW2hlYWRlck5hbWVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5vcm1hbGl6ZWRIZWFkZXJzW2hlYWRlck5hbWVdID0gaGVhZGVyc1toZWFkZXJOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnSGVhZGVycyB3ZXJlIG5vcm1hbGl6ZWQnKTtcbiAgICByZXR1cm4gbm9ybWFsaXplZEhlYWRlcnM7XG4gIH0gZWxzZSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0hlYWRlcnMgd2VyZSBub3QgYW4gb2JqZWN0LiBPcmlnaW5hbCB2YWx1ZSB3aWxsIGJlIHJldHVybmVkLicpO1xuICAgIHJldHVybiBoZWFkZXJzO1xuICB9XG5cbn1cblxuLyoqXG4gKiBOb3JtYWxpemVzIHRoZSByZXNwb25zZSBvYmplY3Qgc28gdGhhdCB3ZSBjYW4gZXh0cmFjdCByZXNwb25zZSBoZWFkZXJzIGZyb21cbiAqIGl0IGluIGEgdW5pZm9ybSB3YXkgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIHdlJ3JlIHVzaW5nIHJlcXVlc3QuanMgb3JcbiAqIGJyb3dzZXItcmVxdWVzdC5qcy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcmVzcG9uc2VcbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZVJlc3BvbnNlKHJlc3BvbnNlKSB7XG4gIC8vIGlmIHRoZSByZXNwb25zZSBkb2Vzbid0IGFscmVhZHkgaGF2ZSBhIGdldFJlc3BvbnNlSGVhZGVyKCkgbWV0aG9kLCBhZGQgb25lXG4gIGlmIChyZXNwb25zZSAmJiAhcmVzcG9uc2UuZ2V0UmVzcG9uc2VIZWFkZXIpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnUmVxdWVzdCVzIC0gbm9ybWFsaXppbmcuJywgcmVxdWVzdFV0aWwuZGVzY3JpYmVSZXF1ZXN0RnJvbVJlc3BvbnNlKHJlc3BvbnNlKSk7XG4gICAgcmVzcG9uc2UuZ2V0UmVzcG9uc2VIZWFkZXIgPSBmdW5jdGlvbiAoaGVhZGVyKSB7XG4gICAgICByZXR1cm4gcmVzcG9uc2UuaGVhZGVycyAmJiByZXNwb25zZS5oZWFkZXJzW1xuICAgICAgICBVdGlsLmlzU3RyaW5nKGhlYWRlcikgPyBoZWFkZXIudG9Mb3dlckNhc2UoKSA6IGhlYWRlcl07XG4gICAgfTtcbiAgfVxuXG4gIGlmIChyZXNwb25zZSkge1xuICAgIHJlc3BvbnNlLmJvZHkgPSByZXNwb25zZS5kYXRhOyAvLyBjb252ZXJ0aW5nIGF4aW9zIHJlc3BvbnNlIGJvZHkgdG8gb2xkIGV4cGVjdGVkIGJvZHkgYXR0cmlidXRlXG4gICAgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1czsgLy8gY29udmVydGluZyBheGlvcyBzdGF0dXMgdG8gb2xkIGV4cGVjdGVkIHN0YXR1c0NvZGVcbiAgfVxuXG4gIHJldHVybiByZXNwb25zZTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/http/base.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/http/node.js":
/*!*****************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/http/node.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst ProxyUtil = __webpack_require__(/*! ../proxy_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/proxy_util.js\");\nconst Base = __webpack_require__(/*! ./base */ \"(rsc)/./node_modules/snowflake-sdk/lib/http/base.js\");\nconst HttpsAgent = __webpack_require__(/*! ../agent/https_ocsp_agent */ \"(rsc)/./node_modules/snowflake-sdk/lib/agent/https_ocsp_agent.js\");\nconst HttpsProxyAgent = __webpack_require__(/*! ../agent/https_proxy_agent */ \"(rsc)/./node_modules/snowflake-sdk/lib/agent/https_proxy_agent.js\");\nconst HttpAgent = (__webpack_require__(/*! http */ \"http\").Agent);\nconst GlobalConfig = __webpack_require__(/*! ../../lib/global_config */ \"(rsc)/./node_modules/snowflake-sdk/lib/global_config.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst RequestUtil = __webpack_require__(/*! ../http/request_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/http/request_util.js\");\n\n/**\n * Returns the delay time calculated by exponential backoff with\n * decorrelated jitter. For more details, check out:\n * http://www.awsarchitectureblog.com/2015/03/backoff.html\n * @return  {Number} number of milliseconds to wait before retrying again the request.\n */\nNodeHttpClient.prototype.constructExponentialBackoffStrategy = function () {\n  Logger.getInstance().trace('Calculating exponential backoff strategy');\n\n  const previousSleepTime = this._connectionConfig.getRetrySfStartingSleepTime();\n  // maximum seconds\n  const cap = this._connectionConfig.getRetrySfMaxSleepTime();\n  // minimum seconds\n  const base = 1;\n  const nextSleepTime = Util.nextSleepTime(base, cap, previousSleepTime);\n  const nextSleepTimeInMilliseconds = nextSleepTime * 1000;\n  Logger.getInstance().trace('Calculated exponential backoff strategy sleep time: %d', nextSleepTimeInMilliseconds);\n  return nextSleepTimeInMilliseconds;\n};\n\n/**\n * Creates a client that can be used to make requests in Node.js.\n *\n * @param {ConnectionConfig} connectionConfig\n * @constructor\n */\nfunction NodeHttpClient(connectionConfig) {\n  Logger.getInstance().trace('Initializing NodeHttpClient with Connection Config[%s]',\n    connectionConfig.describeIdentityAttributes());\n  Base.apply(this, [connectionConfig]);\n}\n\nUtil.inherits(NodeHttpClient, Base);\n\nconst httpsAgentCache = new Map();\n\nfunction getFromCacheOrCreate(agentClass, options, agentId) {\n  Logger.getInstance().trace('Agent[id: %s] - trying to retrieve from cache or create.', agentId);\n  let agent = {};\n  function createAgent(agentClass, agentOptions, agentId) {\n    Logger.getInstance().trace('Agent[id: %s] - creating a new agent instance.', agentId);\n    const agent = agentClass(agentOptions);\n    httpsAgentCache.set(agentId, agent);\n    Logger.getInstance().trace('Agent[id: %s] - new instance stored in cache.', agentId);\n\n    // detect and log PROXY envvar + agent proxy settings\n    const compareAndLogEnvAndAgentProxies = ProxyUtil.getCompareAndLogEnvAndAgentProxies(agentOptions);\n    Logger.getInstance().debug('Agent[id: %s] - proxy settings used in requests: %s', agentId, compareAndLogEnvAndAgentProxies.messages);\n    // if there's anything to warn on (e.g. both envvar + agent proxy used, and they are different)\n    // log warnings on them\n    if (compareAndLogEnvAndAgentProxies.warnings) {\n      Logger.getInstance().warn('Agent[id: %s] - %s', agentId, compareAndLogEnvAndAgentProxies.warnings);\n    }\n\n    return agent;\n  }\n\n  if (httpsAgentCache.has(agentId)) {\n    Logger.getInstance().trace('Agent[id: %s] - retrieving an agent instance from cache.', agentId);\n    agent = httpsAgentCache.get(agentId);\n  } else {\n    agent = createAgent(agentClass, options, agentId);\n  }\n  return agent;\n}\n\nfunction enrichAgentOptionsWithProxyConfig(agentOptions, proxy) {\n  agentOptions.host = proxy.host;\n  agentOptions.port = proxy.port;\n  agentOptions.protocol = proxy.protocol;\n  if (proxy.user && proxy.password) {\n    agentOptions.user = proxy.user;\n    agentOptions.password = proxy.password;\n  }\n}\n\nfunction isBypassProxy(proxy, destination, agentId) {\n  if (proxy && proxy.noProxy) {\n    const bypassList = proxy.noProxy.split('|');\n    for (let i = 0; i < bypassList.length; i++) {\n      let host = bypassList[i].trim();\n      host = host.replace('*', '.*?');\n      const matches = destination.match(host);\n      if (matches) {\n        Logger.getInstance().debug('Agent[id: %s] - bypassing proxy allowed for destination: %s', agentId, destination);\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * @inheritDoc\n */\nNodeHttpClient.prototype.getAgent = function (parsedUrl, proxy, mock) {\n  Logger.getInstance().trace('Agent[url: %s] - getting an agent instance.', RequestUtil.describeURL(parsedUrl.href));\n  if (!proxy && GlobalConfig.isEnvProxyActive()) {\n    const isHttps = parsedUrl.protocol === 'https:';\n    proxy = ProxyUtil.getProxyFromEnv(isHttps);\n    if (proxy) {\n      Logger.getInstance().debug('Agent[url: %s] - proxy info loaded from the environment variable. Proxy host: %s', RequestUtil.describeURL(parsedUrl.href), proxy.host);\n    }\n  }\n  return getProxyAgent(proxy, parsedUrl, parsedUrl.href, mock);\n};\n\nfunction getProxyAgent(proxyOptions, parsedUrl, destination, mock) {\n  Logger.getInstance().trace('Agent[url: %s] - getting a proxy agent instance.', RequestUtil.describeURL(parsedUrl.href));\n  const agentOptions = {\n    protocol: parsedUrl.protocol,\n    hostname: parsedUrl.hostname,\n    keepAlive: GlobalConfig.getKeepAlive()\n  };\n\n  if (mock) {\n    const mockAgent = mock.agentClass(agentOptions);\n    if (mockAgent.protocol === parsedUrl.protocol) {\n      Logger.getInstance().debug('Agent[url: %s] - the mock agent will be used.', RequestUtil.describeURL(parsedUrl.href));\n      return mockAgent;\n    }\n  }\n\n  const destHost = ProxyUtil.getHostFromURL(destination);\n  const agentId = createAgentId(agentOptions.protocol, agentOptions.hostname, destHost, agentOptions.keepAlive);\n  Logger.getInstance().debug('Agent[id: %s] - the destination host is: %s.', agentId, destHost);\n\n  const bypassProxy = isBypassProxy(proxyOptions, destination, agentId);\n  let agent;\n  const isHttps = agentOptions.protocol === 'https:';\n\n  if (isHttps) {\n    if (proxyOptions && !bypassProxy) {\n      Logger.getInstance().trace('Agent[id: %s] - using HTTPS agent enriched with proxy options.', agentId);\n      enrichAgentOptionsWithProxyConfig(agentOptions, proxyOptions);\n      agent = getFromCacheOrCreate(HttpsProxyAgent, agentOptions, agentId);\n    } else {\n      Logger.getInstance().trace('Agent[id: %s] - using HTTPS agent without proxy.', agentId);\n      agent = getFromCacheOrCreate(HttpsAgent, agentOptions, agentId);\n    }\n  } else if (proxyOptions && !bypassProxy) {\n    Logger.getInstance().trace('Agent[id: %s] - using HTTP agent enriched with proxy options.', agentId);\n    enrichAgentOptionsWithProxyConfig(agentOptions, proxyOptions);\n    agent = getFromCacheOrCreate(HttpAgent, agentOptions, agentId);\n  } else {\n    Logger.getInstance().trace('Agent[id: %s] - using HTTP agent without proxy.', agentId);\n    agent = getFromCacheOrCreate(HttpAgent, agentOptions, agentId);\n  }\n  return agent;\n}\n\nfunction createAgentId(protocol, hostname, destination, keepAlive) {\n  return `${protocol}//${hostname}-${destination}-${keepAlive ? 'keepAlive' : 'noKeepAlive'}`;\n}\n\n//This is for the testing purpose.\nfunction getAgentCacheSize() {\n  return httpsAgentCache.size;\n}\n\nmodule.exports = { NodeHttpClient, getProxyAgent, getAgentCacheSize, isBypassProxy };//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvaHR0cC9ub2RlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQywrREFBUztBQUM5QixrQkFBa0IsbUJBQU8sQ0FBQywyRUFBZTtBQUN6QyxhQUFhLG1CQUFPLENBQUMsbUVBQVE7QUFDN0IsbUJBQW1CLG1CQUFPLENBQUMsbUdBQTJCO0FBQ3RELHdCQUF3QixtQkFBTyxDQUFDLHFHQUE0QjtBQUM1RCxrQkFBa0IsK0NBQXFCO0FBQ3ZDLHFCQUFxQixtQkFBTyxDQUFDLHdGQUF5QjtBQUN0RCxlQUFlLG1CQUFPLENBQUMsbUVBQVc7QUFDbEMsb0JBQW9CLG1CQUFPLENBQUMseUZBQXNCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxTQUFTLElBQUksU0FBUyxHQUFHLFlBQVksR0FBRyx3Q0FBd0M7QUFDNUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2h0dHAvbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgUHJveHlVdGlsID0gcmVxdWlyZSgnLi4vcHJveHlfdXRpbCcpO1xuY29uc3QgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xuY29uc3QgSHR0cHNBZ2VudCA9IHJlcXVpcmUoJy4uL2FnZW50L2h0dHBzX29jc3BfYWdlbnQnKTtcbmNvbnN0IEh0dHBzUHJveHlBZ2VudCA9IHJlcXVpcmUoJy4uL2FnZW50L2h0dHBzX3Byb3h5X2FnZW50Jyk7XG5jb25zdCBIdHRwQWdlbnQgPSByZXF1aXJlKCdodHRwJykuQWdlbnQ7XG5jb25zdCBHbG9iYWxDb25maWcgPSByZXF1aXJlKCcuLi8uLi9saWIvZ2xvYmFsX2NvbmZpZycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBSZXF1ZXN0VXRpbCA9IHJlcXVpcmUoJy4uL2h0dHAvcmVxdWVzdF91dGlsJyk7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVsYXkgdGltZSBjYWxjdWxhdGVkIGJ5IGV4cG9uZW50aWFsIGJhY2tvZmYgd2l0aFxuICogZGVjb3JyZWxhdGVkIGppdHRlci4gRm9yIG1vcmUgZGV0YWlscywgY2hlY2sgb3V0OlxuICogaHR0cDovL3d3dy5hd3NhcmNoaXRlY3R1cmVibG9nLmNvbS8yMDE1LzAzL2JhY2tvZmYuaHRtbFxuICogQHJldHVybiAge051bWJlcn0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSByZXRyeWluZyBhZ2FpbiB0aGUgcmVxdWVzdC5cbiAqL1xuTm9kZUh0dHBDbGllbnQucHJvdG90eXBlLmNvbnN0cnVjdEV4cG9uZW50aWFsQmFja29mZlN0cmF0ZWd5ID0gZnVuY3Rpb24gKCkge1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ2FsY3VsYXRpbmcgZXhwb25lbnRpYWwgYmFja29mZiBzdHJhdGVneScpO1xuXG4gIGNvbnN0IHByZXZpb3VzU2xlZXBUaW1lID0gdGhpcy5fY29ubmVjdGlvbkNvbmZpZy5nZXRSZXRyeVNmU3RhcnRpbmdTbGVlcFRpbWUoKTtcbiAgLy8gbWF4aW11bSBzZWNvbmRzXG4gIGNvbnN0IGNhcCA9IHRoaXMuX2Nvbm5lY3Rpb25Db25maWcuZ2V0UmV0cnlTZk1heFNsZWVwVGltZSgpO1xuICAvLyBtaW5pbXVtIHNlY29uZHNcbiAgY29uc3QgYmFzZSA9IDE7XG4gIGNvbnN0IG5leHRTbGVlcFRpbWUgPSBVdGlsLm5leHRTbGVlcFRpbWUoYmFzZSwgY2FwLCBwcmV2aW91c1NsZWVwVGltZSk7XG4gIGNvbnN0IG5leHRTbGVlcFRpbWVJbk1pbGxpc2Vjb25kcyA9IG5leHRTbGVlcFRpbWUgKiAxMDAwO1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQ2FsY3VsYXRlZCBleHBvbmVudGlhbCBiYWNrb2ZmIHN0cmF0ZWd5IHNsZWVwIHRpbWU6ICVkJywgbmV4dFNsZWVwVGltZUluTWlsbGlzZWNvbmRzKTtcbiAgcmV0dXJuIG5leHRTbGVlcFRpbWVJbk1pbGxpc2Vjb25kcztcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIGNsaWVudCB0aGF0IGNhbiBiZSB1c2VkIHRvIG1ha2UgcmVxdWVzdHMgaW4gTm9kZS5qcy5cbiAqXG4gKiBAcGFyYW0ge0Nvbm5lY3Rpb25Db25maWd9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBOb2RlSHR0cENsaWVudChjb25uZWN0aW9uQ29uZmlnKSB7XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdJbml0aWFsaXppbmcgTm9kZUh0dHBDbGllbnQgd2l0aCBDb25uZWN0aW9uIENvbmZpZ1slc10nLFxuICAgIGNvbm5lY3Rpb25Db25maWcuZGVzY3JpYmVJZGVudGl0eUF0dHJpYnV0ZXMoKSk7XG4gIEJhc2UuYXBwbHkodGhpcywgW2Nvbm5lY3Rpb25Db25maWddKTtcbn1cblxuVXRpbC5pbmhlcml0cyhOb2RlSHR0cENsaWVudCwgQmFzZSk7XG5cbmNvbnN0IGh0dHBzQWdlbnRDYWNoZSA9IG5ldyBNYXAoKTtcblxuZnVuY3Rpb24gZ2V0RnJvbUNhY2hlT3JDcmVhdGUoYWdlbnRDbGFzcywgb3B0aW9ucywgYWdlbnRJZCkge1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQWdlbnRbaWQ6ICVzXSAtIHRyeWluZyB0byByZXRyaWV2ZSBmcm9tIGNhY2hlIG9yIGNyZWF0ZS4nLCBhZ2VudElkKTtcbiAgbGV0IGFnZW50ID0ge307XG4gIGZ1bmN0aW9uIGNyZWF0ZUFnZW50KGFnZW50Q2xhc3MsIGFnZW50T3B0aW9ucywgYWdlbnRJZCkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdBZ2VudFtpZDogJXNdIC0gY3JlYXRpbmcgYSBuZXcgYWdlbnQgaW5zdGFuY2UuJywgYWdlbnRJZCk7XG4gICAgY29uc3QgYWdlbnQgPSBhZ2VudENsYXNzKGFnZW50T3B0aW9ucyk7XG4gICAgaHR0cHNBZ2VudENhY2hlLnNldChhZ2VudElkLCBhZ2VudCk7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0FnZW50W2lkOiAlc10gLSBuZXcgaW5zdGFuY2Ugc3RvcmVkIGluIGNhY2hlLicsIGFnZW50SWQpO1xuXG4gICAgLy8gZGV0ZWN0IGFuZCBsb2cgUFJPWFkgZW52dmFyICsgYWdlbnQgcHJveHkgc2V0dGluZ3NcbiAgICBjb25zdCBjb21wYXJlQW5kTG9nRW52QW5kQWdlbnRQcm94aWVzID0gUHJveHlVdGlsLmdldENvbXBhcmVBbmRMb2dFbnZBbmRBZ2VudFByb3hpZXMoYWdlbnRPcHRpb25zKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQWdlbnRbaWQ6ICVzXSAtIHByb3h5IHNldHRpbmdzIHVzZWQgaW4gcmVxdWVzdHM6ICVzJywgYWdlbnRJZCwgY29tcGFyZUFuZExvZ0VudkFuZEFnZW50UHJveGllcy5tZXNzYWdlcyk7XG4gICAgLy8gaWYgdGhlcmUncyBhbnl0aGluZyB0byB3YXJuIG9uIChlLmcuIGJvdGggZW52dmFyICsgYWdlbnQgcHJveHkgdXNlZCwgYW5kIHRoZXkgYXJlIGRpZmZlcmVudClcbiAgICAvLyBsb2cgd2FybmluZ3Mgb24gdGhlbVxuICAgIGlmIChjb21wYXJlQW5kTG9nRW52QW5kQWdlbnRQcm94aWVzLndhcm5pbmdzKSB7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdBZ2VudFtpZDogJXNdIC0gJXMnLCBhZ2VudElkLCBjb21wYXJlQW5kTG9nRW52QW5kQWdlbnRQcm94aWVzLndhcm5pbmdzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYWdlbnQ7XG4gIH1cblxuICBpZiAoaHR0cHNBZ2VudENhY2hlLmhhcyhhZ2VudElkKSkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdBZ2VudFtpZDogJXNdIC0gcmV0cmlldmluZyBhbiBhZ2VudCBpbnN0YW5jZSBmcm9tIGNhY2hlLicsIGFnZW50SWQpO1xuICAgIGFnZW50ID0gaHR0cHNBZ2VudENhY2hlLmdldChhZ2VudElkKTtcbiAgfSBlbHNlIHtcbiAgICBhZ2VudCA9IGNyZWF0ZUFnZW50KGFnZW50Q2xhc3MsIG9wdGlvbnMsIGFnZW50SWQpO1xuICB9XG4gIHJldHVybiBhZ2VudDtcbn1cblxuZnVuY3Rpb24gZW5yaWNoQWdlbnRPcHRpb25zV2l0aFByb3h5Q29uZmlnKGFnZW50T3B0aW9ucywgcHJveHkpIHtcbiAgYWdlbnRPcHRpb25zLmhvc3QgPSBwcm94eS5ob3N0O1xuICBhZ2VudE9wdGlvbnMucG9ydCA9IHByb3h5LnBvcnQ7XG4gIGFnZW50T3B0aW9ucy5wcm90b2NvbCA9IHByb3h5LnByb3RvY29sO1xuICBpZiAocHJveHkudXNlciAmJiBwcm94eS5wYXNzd29yZCkge1xuICAgIGFnZW50T3B0aW9ucy51c2VyID0gcHJveHkudXNlcjtcbiAgICBhZ2VudE9wdGlvbnMucGFzc3dvcmQgPSBwcm94eS5wYXNzd29yZDtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc0J5cGFzc1Byb3h5KHByb3h5LCBkZXN0aW5hdGlvbiwgYWdlbnRJZCkge1xuICBpZiAocHJveHkgJiYgcHJveHkubm9Qcm94eSkge1xuICAgIGNvbnN0IGJ5cGFzc0xpc3QgPSBwcm94eS5ub1Byb3h5LnNwbGl0KCd8Jyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBieXBhc3NMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgaG9zdCA9IGJ5cGFzc0xpc3RbaV0udHJpbSgpO1xuICAgICAgaG9zdCA9IGhvc3QucmVwbGFjZSgnKicsICcuKj8nKTtcbiAgICAgIGNvbnN0IG1hdGNoZXMgPSBkZXN0aW5hdGlvbi5tYXRjaChob3N0KTtcbiAgICAgIGlmIChtYXRjaGVzKSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdBZ2VudFtpZDogJXNdIC0gYnlwYXNzaW5nIHByb3h5IGFsbG93ZWQgZm9yIGRlc3RpbmF0aW9uOiAlcycsIGFnZW50SWQsIGRlc3RpbmF0aW9uKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5Ob2RlSHR0cENsaWVudC5wcm90b3R5cGUuZ2V0QWdlbnQgPSBmdW5jdGlvbiAocGFyc2VkVXJsLCBwcm94eSwgbW9jaykge1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQWdlbnRbdXJsOiAlc10gLSBnZXR0aW5nIGFuIGFnZW50IGluc3RhbmNlLicsIFJlcXVlc3RVdGlsLmRlc2NyaWJlVVJMKHBhcnNlZFVybC5ocmVmKSk7XG4gIGlmICghcHJveHkgJiYgR2xvYmFsQ29uZmlnLmlzRW52UHJveHlBY3RpdmUoKSkge1xuICAgIGNvbnN0IGlzSHR0cHMgPSBwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonO1xuICAgIHByb3h5ID0gUHJveHlVdGlsLmdldFByb3h5RnJvbUVudihpc0h0dHBzKTtcbiAgICBpZiAocHJveHkpIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdBZ2VudFt1cmw6ICVzXSAtIHByb3h5IGluZm8gbG9hZGVkIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlLiBQcm94eSBob3N0OiAlcycsIFJlcXVlc3RVdGlsLmRlc2NyaWJlVVJMKHBhcnNlZFVybC5ocmVmKSwgcHJveHkuaG9zdCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBnZXRQcm94eUFnZW50KHByb3h5LCBwYXJzZWRVcmwsIHBhcnNlZFVybC5ocmVmLCBtb2NrKTtcbn07XG5cbmZ1bmN0aW9uIGdldFByb3h5QWdlbnQocHJveHlPcHRpb25zLCBwYXJzZWRVcmwsIGRlc3RpbmF0aW9uLCBtb2NrKSB7XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdBZ2VudFt1cmw6ICVzXSAtIGdldHRpbmcgYSBwcm94eSBhZ2VudCBpbnN0YW5jZS4nLCBSZXF1ZXN0VXRpbC5kZXNjcmliZVVSTChwYXJzZWRVcmwuaHJlZikpO1xuICBjb25zdCBhZ2VudE9wdGlvbnMgPSB7XG4gICAgcHJvdG9jb2w6IHBhcnNlZFVybC5wcm90b2NvbCxcbiAgICBob3N0bmFtZTogcGFyc2VkVXJsLmhvc3RuYW1lLFxuICAgIGtlZXBBbGl2ZTogR2xvYmFsQ29uZmlnLmdldEtlZXBBbGl2ZSgpXG4gIH07XG5cbiAgaWYgKG1vY2spIHtcbiAgICBjb25zdCBtb2NrQWdlbnQgPSBtb2NrLmFnZW50Q2xhc3MoYWdlbnRPcHRpb25zKTtcbiAgICBpZiAobW9ja0FnZW50LnByb3RvY29sID09PSBwYXJzZWRVcmwucHJvdG9jb2wpIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdBZ2VudFt1cmw6ICVzXSAtIHRoZSBtb2NrIGFnZW50IHdpbGwgYmUgdXNlZC4nLCBSZXF1ZXN0VXRpbC5kZXNjcmliZVVSTChwYXJzZWRVcmwuaHJlZikpO1xuICAgICAgcmV0dXJuIG1vY2tBZ2VudDtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZXN0SG9zdCA9IFByb3h5VXRpbC5nZXRIb3N0RnJvbVVSTChkZXN0aW5hdGlvbik7XG4gIGNvbnN0IGFnZW50SWQgPSBjcmVhdGVBZ2VudElkKGFnZW50T3B0aW9ucy5wcm90b2NvbCwgYWdlbnRPcHRpb25zLmhvc3RuYW1lLCBkZXN0SG9zdCwgYWdlbnRPcHRpb25zLmtlZXBBbGl2ZSk7XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdBZ2VudFtpZDogJXNdIC0gdGhlIGRlc3RpbmF0aW9uIGhvc3QgaXM6ICVzLicsIGFnZW50SWQsIGRlc3RIb3N0KTtcblxuICBjb25zdCBieXBhc3NQcm94eSA9IGlzQnlwYXNzUHJveHkocHJveHlPcHRpb25zLCBkZXN0aW5hdGlvbiwgYWdlbnRJZCk7XG4gIGxldCBhZ2VudDtcbiAgY29uc3QgaXNIdHRwcyA9IGFnZW50T3B0aW9ucy5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG5cbiAgaWYgKGlzSHR0cHMpIHtcbiAgICBpZiAocHJveHlPcHRpb25zICYmICFieXBhc3NQcm94eSkge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ0FnZW50W2lkOiAlc10gLSB1c2luZyBIVFRQUyBhZ2VudCBlbnJpY2hlZCB3aXRoIHByb3h5IG9wdGlvbnMuJywgYWdlbnRJZCk7XG4gICAgICBlbnJpY2hBZ2VudE9wdGlvbnNXaXRoUHJveHlDb25maWcoYWdlbnRPcHRpb25zLCBwcm94eU9wdGlvbnMpO1xuICAgICAgYWdlbnQgPSBnZXRGcm9tQ2FjaGVPckNyZWF0ZShIdHRwc1Byb3h5QWdlbnQsIGFnZW50T3B0aW9ucywgYWdlbnRJZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdBZ2VudFtpZDogJXNdIC0gdXNpbmcgSFRUUFMgYWdlbnQgd2l0aG91dCBwcm94eS4nLCBhZ2VudElkKTtcbiAgICAgIGFnZW50ID0gZ2V0RnJvbUNhY2hlT3JDcmVhdGUoSHR0cHNBZ2VudCwgYWdlbnRPcHRpb25zLCBhZ2VudElkKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAocHJveHlPcHRpb25zICYmICFieXBhc3NQcm94eSkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdBZ2VudFtpZDogJXNdIC0gdXNpbmcgSFRUUCBhZ2VudCBlbnJpY2hlZCB3aXRoIHByb3h5IG9wdGlvbnMuJywgYWdlbnRJZCk7XG4gICAgZW5yaWNoQWdlbnRPcHRpb25zV2l0aFByb3h5Q29uZmlnKGFnZW50T3B0aW9ucywgcHJveHlPcHRpb25zKTtcbiAgICBhZ2VudCA9IGdldEZyb21DYWNoZU9yQ3JlYXRlKEh0dHBBZ2VudCwgYWdlbnRPcHRpb25zLCBhZ2VudElkKTtcbiAgfSBlbHNlIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZSgnQWdlbnRbaWQ6ICVzXSAtIHVzaW5nIEhUVFAgYWdlbnQgd2l0aG91dCBwcm94eS4nLCBhZ2VudElkKTtcbiAgICBhZ2VudCA9IGdldEZyb21DYWNoZU9yQ3JlYXRlKEh0dHBBZ2VudCwgYWdlbnRPcHRpb25zLCBhZ2VudElkKTtcbiAgfVxuICByZXR1cm4gYWdlbnQ7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUFnZW50SWQocHJvdG9jb2wsIGhvc3RuYW1lLCBkZXN0aW5hdGlvbiwga2VlcEFsaXZlKSB7XG4gIHJldHVybiBgJHtwcm90b2NvbH0vLyR7aG9zdG5hbWV9LSR7ZGVzdGluYXRpb259LSR7a2VlcEFsaXZlID8gJ2tlZXBBbGl2ZScgOiAnbm9LZWVwQWxpdmUnfWA7XG59XG5cbi8vVGhpcyBpcyBmb3IgdGhlIHRlc3RpbmcgcHVycG9zZS5cbmZ1bmN0aW9uIGdldEFnZW50Q2FjaGVTaXplKCkge1xuICByZXR1cm4gaHR0cHNBZ2VudENhY2hlLnNpemU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBOb2RlSHR0cENsaWVudCwgZ2V0UHJveHlBZ2VudCwgZ2V0QWdlbnRDYWNoZVNpemUsIGlzQnlwYXNzUHJveHkgfTsiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/http/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/http/request_util.js":
/*!*************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/http/request_util.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const LoggingUtil = __webpack_require__(/*! ../logger/logging_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger/logging_util.js\");\nconst sfParams = __webpack_require__(/*! ../constants/sf_params */ \"(rsc)/./node_modules/snowflake-sdk/lib/constants/sf_params.js\");\n\n// Initial whitelist for attributes - they will be described with values\nconst DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES = [\n  'baseUrl',\n  'path',\n  'method',\n  sfParams.paramsNames.SF_REQUEST_ID,\n  sfParams.paramsNames.SF_REQUEST_GUID,\n  sfParams.paramsNames.SF_WAREHOUSE_NAME,\n  sfParams.paramsNames.SF_DB_NAME,\n  sfParams.paramsNames.SF_SCHEMA_NAME,\n];\n\n// Initial blacklist for attributes - described as present/not present only\nconst DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES = [\n  sfParams.paramsNames.SF_TOKEN\n];\n\n// Helper function to resolve attributes arrays given defaults and overrides.\nfunction resolveAttributeList(defaultAttrs, overrideAttrs) {\n  return overrideAttrs || defaultAttrs;\n}\n\n/**\n * Describes a request based on its options.\n * Should work with not-yet-parsed options as well (before calling prepareRequestOptions method).\n *\n * @param {Object} requestOptions - Object representing the request data with top-level keys.\n * @param {Object} [options] - Options for describing attributes.\n * @param {Array<string>} [options.overrideAttributesDescribedWithValues]\n * @param {Array<string>} [options.overrideAttributesDescribedWithoutValues]\n * @returns {string} A string representation of the request data.\n */\nfunction describeRequestFromOptions(\n  requestOptions,\n  {\n    overrideAttributesDescribedWithValues,\n    overrideAttributesDescribedWithoutValues\n  } = {}\n) {\n  const describingAttributesWithValues = resolveAttributeList(\n    DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES,\n    overrideAttributesDescribedWithValues\n  );\n\n  const describingAttributesWithoutValues = resolveAttributeList(\n    DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES,\n    overrideAttributesDescribedWithoutValues\n  );\n\n  const { method, url, params } = requestOptions || {};\n\n  return describeRequestData(\n    { method, url, params },\n    describingAttributesWithValues,\n    describingAttributesWithoutValues\n  );\n}\n\n/**\n * Creates a string that represents request data from a response.\n * Helps to identify the request that was the source of the response.\n *\n * @param {Object} response - Axios response object.\n * @param {Object} [options] - Options for describing attributes.\n * @param {Array<string>} [options.overrideAttributesDescribedWithValues]\n * @param {Array<string>} [options.overrideAttributesDescribedWithoutValues]\n * @returns {string} A string representation of the request data.\n */\nfunction describeRequestFromResponse(\n  response,\n  {\n    overrideAttributesDescribedWithValues,\n    overrideAttributesDescribedWithoutValues\n  } = {}\n) {\n  let method;\n  let url;\n  let params;\n  const responseConfig = response?.config;\n\n  const describingAttributesWithValues = resolveAttributeList(\n    DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES,\n    overrideAttributesDescribedWithValues\n  );\n\n  const describingAttributesWithoutValues = resolveAttributeList(\n    DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES,\n    overrideAttributesDescribedWithoutValues\n  );\n\n  if (responseConfig) {\n    method = responseConfig.method;\n    url = responseConfig.url;\n    params = responseConfig.params;\n  }\n\n  return describeRequestData(\n    { method, url, params },\n    describingAttributesWithValues,\n    describingAttributesWithoutValues\n  );\n}\n\n/**\n * Constructs a string representation of request data.\n *\n * @param {Object} requestData - Object containing the method, url, and parameters.\n * @param {string} requestData.method - HTTP method.\n * @param {string} requestData.url - Request URL.\n * @param {Object} [requestData.params] - Additional query parameters.\n * @param {Array<string>} attributesWithValues - Attributes to describe with values.\n * @param {Array<string>} attributesWithoutValues - Attributes to describe without values.\n * @returns {string} A string describing the request data.\n */\nfunction describeRequestData(\n  { method, url, params } = {},\n  attributesWithValues,\n  attributesWithoutValues\n) {\n  const requestObject = {\n    // Ensure consistent casing for methods to match request-response pairs in logs.\n    method: method?.toUpperCase(),\n    ...constructURLData(url, params),\n  };\n\n  return LoggingUtil.describeAttributes(\n    requestObject,\n    attributesWithValues,\n    attributesWithoutValues\n  );\n}\n\n/**\n * Constructs an object representing URL data including the base URL, path, and query parameters.\n *\n * @param {string} url - The full URL.\n * @param {Object} [params] - Additional query parameters.\n * @returns {Object} Contains baseUrl, path, and merged query parameters.\n */\nfunction constructURLData(url, params = {}) {\n  if (!url) {\n    return { baseUrl: undefined, path: undefined, queryParams: {} };\n  }\n\n  const urlObj = new URL(url);\n  const queryParams = { ...params };\n\n  urlObj.searchParams.forEach((value, key) => {\n    queryParams[key] = value;\n  });\n\n  const baseUrl = `${urlObj.protocol}//${urlObj.hostname}${urlObj.port ? `:${urlObj.port}` : ''}`;\n\n  return {\n    baseUrl: baseUrl,\n    path: urlObj.pathname,\n    ...queryParams,\n  };\n}\n\n/**\n * @param {string} url - The URL to describe.\n * @param {Object} [options] - Options for describing attributes.\n * @param {Array<string>} [options.overrideAttributesDescribedWithValues]\n * @param {Array<string>} [options.overrideAttributesDescribedWithoutValues]\n * @returns {string} A string describing the URL.\n */\nfunction describeURL(\n  url,\n  {\n    overrideAttributesDescribedWithValues,\n    overrideAttributesDescribedWithoutValues\n  } = {}\n) {\n  const describingAttributesWithValues = resolveAttributeList(\n    DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES,\n    overrideAttributesDescribedWithValues\n  );\n\n  const describingAttributesWithoutValues = resolveAttributeList(\n    DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES,\n    overrideAttributesDescribedWithoutValues\n  );\n\n  const urlData = constructURLData(url);\n\n  return LoggingUtil.describeAttributes(\n    urlData,\n    describingAttributesWithValues,\n    describingAttributesWithoutValues\n  );\n}\n\nexports.DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES = DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITH_VALUES;\nexports.DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES = DEFAULT_ATTRIBUTES_DESCRIBING_REQUEST_WITHOUT_VALUES;\n\nexports.describeRequestFromOptions = describeRequestFromOptions;\nexports.describeRequestFromResponse = describeRequestFromResponse;\nexports.describeURL = describeURL;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvaHR0cC9yZXF1ZXN0X3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUEsb0JBQW9CLG1CQUFPLENBQUMsNkZBQXdCO0FBQ3BELGlCQUFpQixtQkFBTyxDQUFDLDZGQUF3Qjs7QUFFakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxzQkFBc0I7O0FBRWhDO0FBQ0EsTUFBTSxxQkFBcUI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNLHFCQUFxQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxlQUFlO0FBQzFCLFdBQVcsZUFBZTtBQUMxQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBLElBQUksc0JBQXNCLElBQUk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSxHQUFHOztBQUVILHFCQUFxQixnQkFBZ0IsSUFBSSxnQkFBZ0IsRUFBRSxrQkFBa0IsWUFBWSxPQUFPOztBQUVoRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5REFBeUQ7QUFDekQsNERBQTREOztBQUU1RCxrQ0FBa0M7QUFDbEMsbUNBQW1DO0FBQ25DLG1CQUFtQiIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9odHRwL3JlcXVlc3RfdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBMb2dnaW5nVXRpbCA9IHJlcXVpcmUoJy4uL2xvZ2dlci9sb2dnaW5nX3V0aWwnKTtcbmNvbnN0IHNmUGFyYW1zID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL3NmX3BhcmFtcycpO1xuXG4vLyBJbml0aWFsIHdoaXRlbGlzdCBmb3IgYXR0cmlidXRlcyAtIHRoZXkgd2lsbCBiZSBkZXNjcmliZWQgd2l0aCB2YWx1ZXNcbmNvbnN0IERFRkFVTFRfQVRUUklCVVRFU19ERVNDUklCSU5HX1JFUVVFU1RfV0lUSF9WQUxVRVMgPSBbXG4gICdiYXNlVXJsJyxcbiAgJ3BhdGgnLFxuICAnbWV0aG9kJyxcbiAgc2ZQYXJhbXMucGFyYW1zTmFtZXMuU0ZfUkVRVUVTVF9JRCxcbiAgc2ZQYXJhbXMucGFyYW1zTmFtZXMuU0ZfUkVRVUVTVF9HVUlELFxuICBzZlBhcmFtcy5wYXJhbXNOYW1lcy5TRl9XQVJFSE9VU0VfTkFNRSxcbiAgc2ZQYXJhbXMucGFyYW1zTmFtZXMuU0ZfREJfTkFNRSxcbiAgc2ZQYXJhbXMucGFyYW1zTmFtZXMuU0ZfU0NIRU1BX05BTUUsXG5dO1xuXG4vLyBJbml0aWFsIGJsYWNrbGlzdCBmb3IgYXR0cmlidXRlcyAtIGRlc2NyaWJlZCBhcyBwcmVzZW50L25vdCBwcmVzZW50IG9ubHlcbmNvbnN0IERFRkFVTFRfQVRUUklCVVRFU19ERVNDUklCSU5HX1JFUVVFU1RfV0lUSE9VVF9WQUxVRVMgPSBbXG4gIHNmUGFyYW1zLnBhcmFtc05hbWVzLlNGX1RPS0VOXG5dO1xuXG4vLyBIZWxwZXIgZnVuY3Rpb24gdG8gcmVzb2x2ZSBhdHRyaWJ1dGVzIGFycmF5cyBnaXZlbiBkZWZhdWx0cyBhbmQgb3ZlcnJpZGVzLlxuZnVuY3Rpb24gcmVzb2x2ZUF0dHJpYnV0ZUxpc3QoZGVmYXVsdEF0dHJzLCBvdmVycmlkZUF0dHJzKSB7XG4gIHJldHVybiBvdmVycmlkZUF0dHJzIHx8IGRlZmF1bHRBdHRycztcbn1cblxuLyoqXG4gKiBEZXNjcmliZXMgYSByZXF1ZXN0IGJhc2VkIG9uIGl0cyBvcHRpb25zLlxuICogU2hvdWxkIHdvcmsgd2l0aCBub3QteWV0LXBhcnNlZCBvcHRpb25zIGFzIHdlbGwgKGJlZm9yZSBjYWxsaW5nIHByZXBhcmVSZXF1ZXN0T3B0aW9ucyBtZXRob2QpLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0T3B0aW9ucyAtIE9iamVjdCByZXByZXNlbnRpbmcgdGhlIHJlcXVlc3QgZGF0YSB3aXRoIHRvcC1sZXZlbCBrZXlzLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIGRlc2NyaWJpbmcgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW29wdGlvbnMub3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aFZhbHVlc11cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW29wdGlvbnMub3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aG91dFZhbHVlc11cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXF1ZXN0IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zKFxuICByZXF1ZXN0T3B0aW9ucyxcbiAge1xuICAgIG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhWYWx1ZXMsXG4gICAgb3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aG91dFZhbHVlc1xuICB9ID0ge31cbikge1xuICBjb25zdCBkZXNjcmliaW5nQXR0cmlidXRlc1dpdGhWYWx1ZXMgPSByZXNvbHZlQXR0cmlidXRlTGlzdChcbiAgICBERUZBVUxUX0FUVFJJQlVURVNfREVTQ1JJQklOR19SRVFVRVNUX1dJVEhfVkFMVUVTLFxuICAgIG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhWYWx1ZXNcbiAgKTtcblxuICBjb25zdCBkZXNjcmliaW5nQXR0cmlidXRlc1dpdGhvdXRWYWx1ZXMgPSByZXNvbHZlQXR0cmlidXRlTGlzdChcbiAgICBERUZBVUxUX0FUVFJJQlVURVNfREVTQ1JJQklOR19SRVFVRVNUX1dJVEhPVVRfVkFMVUVTLFxuICAgIG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhvdXRWYWx1ZXNcbiAgKTtcblxuICBjb25zdCB7IG1ldGhvZCwgdXJsLCBwYXJhbXMgfSA9IHJlcXVlc3RPcHRpb25zIHx8IHt9O1xuXG4gIHJldHVybiBkZXNjcmliZVJlcXVlc3REYXRhKFxuICAgIHsgbWV0aG9kLCB1cmwsIHBhcmFtcyB9LFxuICAgIGRlc2NyaWJpbmdBdHRyaWJ1dGVzV2l0aFZhbHVlcyxcbiAgICBkZXNjcmliaW5nQXR0cmlidXRlc1dpdGhvdXRWYWx1ZXNcbiAgKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgc3RyaW5nIHRoYXQgcmVwcmVzZW50cyByZXF1ZXN0IGRhdGEgZnJvbSBhIHJlc3BvbnNlLlxuICogSGVscHMgdG8gaWRlbnRpZnkgdGhlIHJlcXVlc3QgdGhhdCB3YXMgdGhlIHNvdXJjZSBvZiB0aGUgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHJlc3BvbnNlIC0gQXhpb3MgcmVzcG9uc2Ugb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIGRlc2NyaWJpbmcgYXR0cmlidXRlcy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW29wdGlvbnMub3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aFZhbHVlc11cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gW29wdGlvbnMub3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aG91dFZhbHVlc11cbiAqIEByZXR1cm5zIHtzdHJpbmd9IEEgc3RyaW5nIHJlcHJlc2VudGF0aW9uIG9mIHRoZSByZXF1ZXN0IGRhdGEuXG4gKi9cbmZ1bmN0aW9uIGRlc2NyaWJlUmVxdWVzdEZyb21SZXNwb25zZShcbiAgcmVzcG9uc2UsXG4gIHtcbiAgICBvdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRoVmFsdWVzLFxuICAgIG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhvdXRWYWx1ZXNcbiAgfSA9IHt9XG4pIHtcbiAgbGV0IG1ldGhvZDtcbiAgbGV0IHVybDtcbiAgbGV0IHBhcmFtcztcbiAgY29uc3QgcmVzcG9uc2VDb25maWcgPSByZXNwb25zZT8uY29uZmlnO1xuXG4gIGNvbnN0IGRlc2NyaWJpbmdBdHRyaWJ1dGVzV2l0aFZhbHVlcyA9IHJlc29sdmVBdHRyaWJ1dGVMaXN0KFxuICAgIERFRkFVTFRfQVRUUklCVVRFU19ERVNDUklCSU5HX1JFUVVFU1RfV0lUSF9WQUxVRVMsXG4gICAgb3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aFZhbHVlc1xuICApO1xuXG4gIGNvbnN0IGRlc2NyaWJpbmdBdHRyaWJ1dGVzV2l0aG91dFZhbHVlcyA9IHJlc29sdmVBdHRyaWJ1dGVMaXN0KFxuICAgIERFRkFVTFRfQVRUUklCVVRFU19ERVNDUklCSU5HX1JFUVVFU1RfV0lUSE9VVF9WQUxVRVMsXG4gICAgb3ZlcnJpZGVBdHRyaWJ1dGVzRGVzY3JpYmVkV2l0aG91dFZhbHVlc1xuICApO1xuXG4gIGlmIChyZXNwb25zZUNvbmZpZykge1xuICAgIG1ldGhvZCA9IHJlc3BvbnNlQ29uZmlnLm1ldGhvZDtcbiAgICB1cmwgPSByZXNwb25zZUNvbmZpZy51cmw7XG4gICAgcGFyYW1zID0gcmVzcG9uc2VDb25maWcucGFyYW1zO1xuICB9XG5cbiAgcmV0dXJuIGRlc2NyaWJlUmVxdWVzdERhdGEoXG4gICAgeyBtZXRob2QsIHVybCwgcGFyYW1zIH0sXG4gICAgZGVzY3JpYmluZ0F0dHJpYnV0ZXNXaXRoVmFsdWVzLFxuICAgIGRlc2NyaWJpbmdBdHRyaWJ1dGVzV2l0aG91dFZhbHVlc1xuICApO1xufVxuXG4vKipcbiAqIENvbnN0cnVjdHMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgcmVxdWVzdCBkYXRhLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0RGF0YSAtIE9iamVjdCBjb250YWluaW5nIHRoZSBtZXRob2QsIHVybCwgYW5kIHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdERhdGEubWV0aG9kIC0gSFRUUCBtZXRob2QuXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdERhdGEudXJsIC0gUmVxdWVzdCBVUkwuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3REYXRhLnBhcmFtc10gLSBBZGRpdGlvbmFsIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF0dHJpYnV0ZXNXaXRoVmFsdWVzIC0gQXR0cmlidXRlcyB0byBkZXNjcmliZSB3aXRoIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXR0cmlidXRlc1dpdGhvdXRWYWx1ZXMgLSBBdHRyaWJ1dGVzIHRvIGRlc2NyaWJlIHdpdGhvdXQgdmFsdWVzLlxuICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgZGVzY3JpYmluZyB0aGUgcmVxdWVzdCBkYXRhLlxuICovXG5mdW5jdGlvbiBkZXNjcmliZVJlcXVlc3REYXRhKFxuICB7IG1ldGhvZCwgdXJsLCBwYXJhbXMgfSA9IHt9LFxuICBhdHRyaWJ1dGVzV2l0aFZhbHVlcyxcbiAgYXR0cmlidXRlc1dpdGhvdXRWYWx1ZXNcbikge1xuICBjb25zdCByZXF1ZXN0T2JqZWN0ID0ge1xuICAgIC8vIEVuc3VyZSBjb25zaXN0ZW50IGNhc2luZyBmb3IgbWV0aG9kcyB0byBtYXRjaCByZXF1ZXN0LXJlc3BvbnNlIHBhaXJzIGluIGxvZ3MuXG4gICAgbWV0aG9kOiBtZXRob2Q/LnRvVXBwZXJDYXNlKCksXG4gICAgLi4uY29uc3RydWN0VVJMRGF0YSh1cmwsIHBhcmFtcyksXG4gIH07XG5cbiAgcmV0dXJuIExvZ2dpbmdVdGlsLmRlc2NyaWJlQXR0cmlidXRlcyhcbiAgICByZXF1ZXN0T2JqZWN0LFxuICAgIGF0dHJpYnV0ZXNXaXRoVmFsdWVzLFxuICAgIGF0dHJpYnV0ZXNXaXRob3V0VmFsdWVzXG4gICk7XG59XG5cbi8qKlxuICogQ29uc3RydWN0cyBhbiBvYmplY3QgcmVwcmVzZW50aW5nIFVSTCBkYXRhIGluY2x1ZGluZyB0aGUgYmFzZSBVUkwsIHBhdGgsIGFuZCBxdWVyeSBwYXJhbWV0ZXJzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgLSBUaGUgZnVsbCBVUkwuXG4gKiBAcGFyYW0ge09iamVjdH0gW3BhcmFtc10gLSBBZGRpdGlvbmFsIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBDb250YWlucyBiYXNlVXJsLCBwYXRoLCBhbmQgbWVyZ2VkIHF1ZXJ5IHBhcmFtZXRlcnMuXG4gKi9cbmZ1bmN0aW9uIGNvbnN0cnVjdFVSTERhdGEodXJsLCBwYXJhbXMgPSB7fSkge1xuICBpZiAoIXVybCkge1xuICAgIHJldHVybiB7IGJhc2VVcmw6IHVuZGVmaW5lZCwgcGF0aDogdW5kZWZpbmVkLCBxdWVyeVBhcmFtczoge30gfTtcbiAgfVxuXG4gIGNvbnN0IHVybE9iaiA9IG5ldyBVUkwodXJsKTtcbiAgY29uc3QgcXVlcnlQYXJhbXMgPSB7IC4uLnBhcmFtcyB9O1xuXG4gIHVybE9iai5zZWFyY2hQYXJhbXMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIHF1ZXJ5UGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgY29uc3QgYmFzZVVybCA9IGAke3VybE9iai5wcm90b2NvbH0vLyR7dXJsT2JqLmhvc3RuYW1lfSR7dXJsT2JqLnBvcnQgPyBgOiR7dXJsT2JqLnBvcnR9YCA6ICcnfWA7XG5cbiAgcmV0dXJuIHtcbiAgICBiYXNlVXJsOiBiYXNlVXJsLFxuICAgIHBhdGg6IHVybE9iai5wYXRobmFtZSxcbiAgICAuLi5xdWVyeVBhcmFtcyxcbiAgfTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIC0gVGhlIFVSTCB0byBkZXNjcmliZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciBkZXNjcmliaW5nIGF0dHJpYnV0ZXMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtvcHRpb25zLm92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhWYWx1ZXNdXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IFtvcHRpb25zLm92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhvdXRWYWx1ZXNdXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBBIHN0cmluZyBkZXNjcmliaW5nIHRoZSBVUkwuXG4gKi9cbmZ1bmN0aW9uIGRlc2NyaWJlVVJMKFxuICB1cmwsXG4gIHtcbiAgICBvdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRoVmFsdWVzLFxuICAgIG92ZXJyaWRlQXR0cmlidXRlc0Rlc2NyaWJlZFdpdGhvdXRWYWx1ZXNcbiAgfSA9IHt9XG4pIHtcbiAgY29uc3QgZGVzY3JpYmluZ0F0dHJpYnV0ZXNXaXRoVmFsdWVzID0gcmVzb2x2ZUF0dHJpYnV0ZUxpc3QoXG4gICAgREVGQVVMVF9BVFRSSUJVVEVTX0RFU0NSSUJJTkdfUkVRVUVTVF9XSVRIX1ZBTFVFUyxcbiAgICBvdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRoVmFsdWVzXG4gICk7XG5cbiAgY29uc3QgZGVzY3JpYmluZ0F0dHJpYnV0ZXNXaXRob3V0VmFsdWVzID0gcmVzb2x2ZUF0dHJpYnV0ZUxpc3QoXG4gICAgREVGQVVMVF9BVFRSSUJVVEVTX0RFU0NSSUJJTkdfUkVRVUVTVF9XSVRIT1VUX1ZBTFVFUyxcbiAgICBvdmVycmlkZUF0dHJpYnV0ZXNEZXNjcmliZWRXaXRob3V0VmFsdWVzXG4gICk7XG5cbiAgY29uc3QgdXJsRGF0YSA9IGNvbnN0cnVjdFVSTERhdGEodXJsKTtcblxuICByZXR1cm4gTG9nZ2luZ1V0aWwuZGVzY3JpYmVBdHRyaWJ1dGVzKFxuICAgIHVybERhdGEsXG4gICAgZGVzY3JpYmluZ0F0dHJpYnV0ZXNXaXRoVmFsdWVzLFxuICAgIGRlc2NyaWJpbmdBdHRyaWJ1dGVzV2l0aG91dFZhbHVlc1xuICApO1xufVxuXG5leHBvcnRzLkRFRkFVTFRfQVRUUklCVVRFU19ERVNDUklCSU5HX1JFUVVFU1RfV0lUSF9WQUxVRVMgPSBERUZBVUxUX0FUVFJJQlVURVNfREVTQ1JJQklOR19SRVFVRVNUX1dJVEhfVkFMVUVTO1xuZXhwb3J0cy5ERUZBVUxUX0FUVFJJQlVURVNfREVTQ1JJQklOR19SRVFVRVNUX1dJVEhPVVRfVkFMVUVTID0gREVGQVVMVF9BVFRSSUJVVEVTX0RFU0NSSUJJTkdfUkVRVUVTVF9XSVRIT1VUX1ZBTFVFUztcblxuZXhwb3J0cy5kZXNjcmliZVJlcXVlc3RGcm9tT3B0aW9ucyA9IGRlc2NyaWJlUmVxdWVzdEZyb21PcHRpb25zO1xuZXhwb3J0cy5kZXNjcmliZVJlcXVlc3RGcm9tUmVzcG9uc2UgPSBkZXNjcmliZVJlcXVlc3RGcm9tUmVzcG9uc2U7XG5leHBvcnRzLmRlc2NyaWJlVVJMID0gZGVzY3JpYmVVUkw7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/http/request_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/logger.js":
/*!**************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/logger.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const BrowserLogger = __webpack_require__(/*! ./logger/browser */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger/browser.js\");\n\nlet instance;\n\n/**\n * Sets the logger instance. For internal use only.\n *\n * @param {*} newInstance\n */\nexports.setInstance = function (newInstance) {\n  instance = newInstance;\n};\n\n/**\n * Returns the current logger instance.\n *\n * @returns {Logger}\n */\nexports.getInstance = function () {\n  // use the browser implementation of logger as the default implementation;\n  // we do this so that unit tests don't fail when the modules they're testing\n  // log messages\n  if (!instance) {\n    instance = new BrowserLogger();\n  }\n\n  return instance;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvbG9nZ2VyLmpzIiwibWFwcGluZ3MiOiJBQUFBLHNCQUFzQixtQkFBTyxDQUFDLGtGQUFrQjs7QUFFaEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvbG9nZ2VyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEJyb3dzZXJMb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlci9icm93c2VyJyk7XG5cbmxldCBpbnN0YW5jZTtcblxuLyoqXG4gKiBTZXRzIHRoZSBsb2dnZXIgaW5zdGFuY2UuIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cbiAqXG4gKiBAcGFyYW0geyp9IG5ld0luc3RhbmNlXG4gKi9cbmV4cG9ydHMuc2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAobmV3SW5zdGFuY2UpIHtcbiAgaW5zdGFuY2UgPSBuZXdJbnN0YW5jZTtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0aGUgY3VycmVudCBsb2dnZXIgaW5zdGFuY2UuXG4gKlxuICogQHJldHVybnMge0xvZ2dlcn1cbiAqL1xuZXhwb3J0cy5nZXRJbnN0YW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgLy8gdXNlIHRoZSBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGxvZ2dlciBhcyB0aGUgZGVmYXVsdCBpbXBsZW1lbnRhdGlvbjtcbiAgLy8gd2UgZG8gdGhpcyBzbyB0aGF0IHVuaXQgdGVzdHMgZG9uJ3QgZmFpbCB3aGVuIHRoZSBtb2R1bGVzIHRoZXkncmUgdGVzdGluZ1xuICAvLyBsb2cgbWVzc2FnZXNcbiAgaWYgKCFpbnN0YW5jZSkge1xuICAgIGluc3RhbmNlID0gbmV3IEJyb3dzZXJMb2dnZXIoKTtcbiAgfVxuXG4gIHJldHVybiBpbnN0YW5jZTtcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/logger.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/logger/browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/logger/browser.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Core = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger/core.js\");\n\n/**\n * Creates a new Logger instance for when we're running in the browser.\n *\n * @param {Object} [options]\n *\n * @constructor\n */\nfunction Logger(options) {\n  /**\n   * The array to which all log messages will be added.\n   *\n   * @type {String[]}\n   */\n  const buffer = [];\n\n  /**\n   * Logs a message at a given level.\n   *\n   * @param {String} levelTag the tag associated with the level at which to log\n   *   the message.\n   * @param {String} message the message to log.\n   * @param {Number} bufferMaxLength the maximum size to which the message\n   *   buffer can grow.\n   */\n  const logMessage = function (levelTag, message, bufferMaxLength) {\n    // add the log level tag (e.g. info, warn, etc.) to the front of the message\n    message = Util.format('%s: %s', levelTag, message);\n\n    // if the buffer is full, evict old messages\n    while (buffer.length >= bufferMaxLength) {\n      buffer.shift();\n    }\n\n    // add the new message to the buffer\n    buffer.push(message);\n  };\n\n  // create an inner implementation to which all our methods will be forwarded\n  const common = Core.createLogger(options, logMessage);\n\n  /**\n   * Configures this logger.\n   *\n   * @param {Object} options\n   */\n  this.configure = function (options) {\n    common.configure(options);\n  };\n\n  /**\n   * Returns the current log level.\n   *\n   * @returns {Number}\n   */\n  this.getLevel = function () {\n    return common.getLevelNumber();\n  };\n\n  /**\n   * Logs a given message at the error level.\n   *\n   * @param {String} message\n   * @param params\n   */\n  this.error = function (message, ...params) {\n    common.error.apply(common, [message, ...params]);\n  };\n\n  /**\n   * Logs a given message at the warning level.\n   *\n   * @param {String} message\n   * @param params\n   */\n  this.warn = function (message, ...params) {\n    common.warn.apply(common, [message, ...params]);\n  };\n\n  /**\n   * Logs a given message at the info level.\n   *\n   * @param {String} message\n   * @param params\n   */\n  this.info = function (message, ...params) {\n    common.info.apply(common, [message, ...params]);\n  };\n\n  /**\n   * Logs a given message at the debug level.\n   *\n   * @param {String} message\n   * @param params\n   */\n  this.debug = function (message, ...params) {\n    common.debug.apply(common, [message, ...params]);\n  };\n\n  /**\n   * Logs a given message at the trace level.\n   *\n   * @param {String} message\n   * @param params\n   */\n  this.trace = function (message, ...params ) {\n    common.trace.apply(common, [message, ...params]);\n  };\n\n  /**\n   * Returns the log buffer.\n   *\n   * @returns {String[]}\n   */\n  this.getLogBuffer = function () {\n    // return a copy of the buffer array; calling slice() shallow-copies the\n    // original array, but that's sufficient in this case because the array\n    // contains strings\n    return buffer.slice();\n  };\n}\n\nmodule.exports = Logger;//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvbG9nZ2VyL2Jyb3dzZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsYUFBYSxtQkFBTyxDQUFDLCtEQUFTO0FBQzlCLGFBQWEsbUJBQU8sQ0FBQyxxRUFBUTs7QUFFN0I7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9sb2dnZXIvYnJvd3Nlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgQ29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTG9nZ2VyIGluc3RhbmNlIGZvciB3aGVuIHdlJ3JlIHJ1bm5pbmcgaW4gdGhlIGJyb3dzZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBMb2dnZXIob3B0aW9ucykge1xuICAvKipcbiAgICogVGhlIGFycmF5IHRvIHdoaWNoIGFsbCBsb2cgbWVzc2FnZXMgd2lsbCBiZSBhZGRlZC5cbiAgICpcbiAgICogQHR5cGUge1N0cmluZ1tdfVxuICAgKi9cbiAgY29uc3QgYnVmZmVyID0gW107XG5cbiAgLyoqXG4gICAqIExvZ3MgYSBtZXNzYWdlIGF0IGEgZ2l2ZW4gbGV2ZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBsZXZlbFRhZyB0aGUgdGFnIGFzc29jaWF0ZWQgd2l0aCB0aGUgbGV2ZWwgYXQgd2hpY2ggdG8gbG9nXG4gICAqICAgdGhlIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRvIGxvZy5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IGJ1ZmZlck1heExlbmd0aCB0aGUgbWF4aW11bSBzaXplIHRvIHdoaWNoIHRoZSBtZXNzYWdlXG4gICAqICAgYnVmZmVyIGNhbiBncm93LlxuICAgKi9cbiAgY29uc3QgbG9nTWVzc2FnZSA9IGZ1bmN0aW9uIChsZXZlbFRhZywgbWVzc2FnZSwgYnVmZmVyTWF4TGVuZ3RoKSB7XG4gICAgLy8gYWRkIHRoZSBsb2cgbGV2ZWwgdGFnIChlLmcuIGluZm8sIHdhcm4sIGV0Yy4pIHRvIHRoZSBmcm9udCBvZiB0aGUgbWVzc2FnZVxuICAgIG1lc3NhZ2UgPSBVdGlsLmZvcm1hdCgnJXM6ICVzJywgbGV2ZWxUYWcsIG1lc3NhZ2UpO1xuXG4gICAgLy8gaWYgdGhlIGJ1ZmZlciBpcyBmdWxsLCBldmljdCBvbGQgbWVzc2FnZXNcbiAgICB3aGlsZSAoYnVmZmVyLmxlbmd0aCA+PSBidWZmZXJNYXhMZW5ndGgpIHtcbiAgICAgIGJ1ZmZlci5zaGlmdCgpO1xuICAgIH1cblxuICAgIC8vIGFkZCB0aGUgbmV3IG1lc3NhZ2UgdG8gdGhlIGJ1ZmZlclxuICAgIGJ1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuICB9O1xuXG4gIC8vIGNyZWF0ZSBhbiBpbm5lciBpbXBsZW1lbnRhdGlvbiB0byB3aGljaCBhbGwgb3VyIG1ldGhvZHMgd2lsbCBiZSBmb3J3YXJkZWRcbiAgY29uc3QgY29tbW9uID0gQ29yZS5jcmVhdGVMb2dnZXIob3B0aW9ucywgbG9nTWVzc2FnZSk7XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgdGhpcyBsb2dnZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICB0aGlzLmNvbmZpZ3VyZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgY29tbW9uLmNvbmZpZ3VyZShvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBsb2cgbGV2ZWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb21tb24uZ2V0TGV2ZWxOdW1iZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIGVycm9yIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICB0aGlzLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIC4uLnBhcmFtcykge1xuICAgIGNvbW1vbi5lcnJvci5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIHdhcm5pbmcgbGV2ZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIHRoaXMud2FybiA9IGZ1bmN0aW9uIChtZXNzYWdlLCAuLi5wYXJhbXMpIHtcbiAgICBjb21tb24ud2Fybi5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIGluZm8gbGV2ZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIHRoaXMuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlLCAuLi5wYXJhbXMpIHtcbiAgICBjb21tb24uaW5mby5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIGRlYnVnIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICB0aGlzLmRlYnVnID0gZnVuY3Rpb24gKG1lc3NhZ2UsIC4uLnBhcmFtcykge1xuICAgIGNvbW1vbi5kZWJ1Zy5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIHRyYWNlIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICB0aGlzLnRyYWNlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIC4uLnBhcmFtcyApIHtcbiAgICBjb21tb24udHJhY2UuYXBwbHkoY29tbW9uLCBbbWVzc2FnZSwgLi4ucGFyYW1zXSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGxvZyBidWZmZXIuXG4gICAqXG4gICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICovXG4gIHRoaXMuZ2V0TG9nQnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHJldHVybiBhIGNvcHkgb2YgdGhlIGJ1ZmZlciBhcnJheTsgY2FsbGluZyBzbGljZSgpIHNoYWxsb3ctY29waWVzIHRoZVxuICAgIC8vIG9yaWdpbmFsIGFycmF5LCBidXQgdGhhdCdzIHN1ZmZpY2llbnQgaW4gdGhpcyBjYXNlIGJlY2F1c2UgdGhlIGFycmF5XG4gICAgLy8gY29udGFpbnMgc3RyaW5nc1xuICAgIHJldHVybiBidWZmZXIuc2xpY2UoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMb2dnZXI7Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/logger/browser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/logger/core.js":
/*!*******************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/logger/core.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const moment = __webpack_require__(/*! moment */ \"(rsc)/./node_modules/moment/moment.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst SecretDetector = new (__webpack_require__(/*! ../secret_detector.js */ \"(rsc)/./node_modules/snowflake-sdk/lib/secret_detector.js\"))();\n\nconst LOG_LEVEL_OFF =\n  {\n    tag: 'OFF',\n    level: -1\n  };\n\nconst LOG_LEVEL_ERROR =\n  {\n    tag: 'ERROR',\n    level: 0\n  };\n\nconst LOG_LEVEL_WARN =\n  {\n    tag: 'WARN',\n    level: 1\n  };\n\nconst LOG_LEVEL_INFO =\n  {\n    tag: 'INFO',\n    level: 2\n  };\n\nconst LOG_LEVEL_DEBUG =\n  {\n    tag: 'DEBUG',\n    level: 3\n  };\n\nconst LOG_LEVEL_TRACE =\n  {\n    tag: 'TRACE',\n    level: 4\n  };\n\nconst LOG_LEVELS =\n  [\n    LOG_LEVEL_OFF,\n    LOG_LEVEL_ERROR,\n    LOG_LEVEL_WARN,\n    LOG_LEVEL_INFO,\n    LOG_LEVEL_DEBUG,\n    LOG_LEVEL_TRACE\n  ];\n\nconst LOG_LEVEL_TAGS = {\n  OFF: LOG_LEVEL_OFF.tag,\n  ERROR: LOG_LEVEL_ERROR.tag,\n  WARN: LOG_LEVEL_WARN.tag,\n  INFO: LOG_LEVEL_INFO.tag,\n  DEBUG: LOG_LEVEL_DEBUG.tag,\n  TRACE: LOG_LEVEL_TRACE.tag,\n};\nexports.LOG_LEVEL_TAGS = LOG_LEVEL_TAGS;\n\n// create two maps, one in which the key is the log level and the value is the\n// corresponding log level object, and another in which the key is the log tag\n// and the value is the corresponding log level\nconst MAP_LOG_LEVEL_TO_OBJECT = {};\nconst MAP_LOG_TAG_TO_LEVEL = {};\nfor (let index = 0, length = LOG_LEVELS.length; index < length; index++) {\n  const logLevelObject = LOG_LEVELS[index];\n  MAP_LOG_LEVEL_TO_OBJECT[logLevelObject.level] = logLevelObject;\n  MAP_LOG_TAG_TO_LEVEL[logLevelObject.tag] = logLevelObject.level;\n}\n\nconst DEFAULT_BUFFER_MAX_LENGTH = 500;\nconst DEFAULT_MESSAGE_MAX_LENGTH = 500;\nconst DEFAULT_LEVEL = LOG_LEVEL_INFO;\n\n/**\n * Creates a new Logger instance.\n *\n * @param options {Object}\n * @param logMessage {Function}\n * @param reconfigureOperation {Function} Action to perform to change log destination file\n *\n * @returns {Object}\n */\nexports.createLogger = function (options, logMessage, reconfigureOperation) {\n  // a log function must be specified\n  Errors.assertInternal(Util.isFunction(logMessage));\n\n  /**\n   * Whether to include the current timestamp in the log message.\n   */\n  let includeTimestamp;\n\n  /**\n   * The maximum size (in terms of number of messages) to which the log buffer\n   * can grow.\n   *\n   * @type {Number}\n   */\n  let bufferMaxLength;\n\n  /**\n   * The maximum message length. Longer messages will be truncated.\n   *\n   * @type {Number}\n   */\n  let messageMaxLength;\n\n  /**\n   * The current log level. Any message logged at a lower level won't be added\n   * to the log buffer.\n   *\n   * @type {Object}\n   */\n  let currlevelObject;\n\n  // create a new logger instance\n  const logger = {\n    /**\n     * Configures this logger.\n     *\n     * @param {Object} options\n     */\n    configure: function (options) {\n      let localIncludeTimestamp;\n      let localBufferMaxLength;\n      let localMessageMaxLength;\n      let localLevel;\n      let localFilePath;\n      let localAdditionalLogToConsole;\n\n      // if an options argument is specified\n      if (Util.exists(options)) {\n        // make sure it's an object\n        Errors.assertInternal(Util.isObject(options));\n\n        localIncludeTimestamp = options.includeTimestamp;\n        localBufferMaxLength = options.bufferMaxLength;\n        localMessageMaxLength = options.messageMaxLength;\n        localLevel = options.level;\n        localFilePath = options.filePath;\n        localAdditionalLogToConsole = options.additionalLogToConsole;\n      }\n\n      // if an includeTimestamp options is specified, convert it to a boolean\n      if (Util.exists(localIncludeTimestamp)) {\n        includeTimestamp = !!localIncludeTimestamp;\n      } else if (!Util.exists(includeTimestamp)) {\n        // default to true\n        includeTimestamp = true;\n      }\n\n      // if a bufferMaxLength option is specified, make sure\n      // it's a positive integer before updating the logger option\n      if (Util.exists(localBufferMaxLength)) {\n        Errors.assertInternal(\n          Util.number.isPositiveInteger(localBufferMaxLength));\n        bufferMaxLength = localBufferMaxLength;\n      } else if (!Util.exists(bufferMaxLength)) { // initialize logger option if configure() hasn't been called before\n        bufferMaxLength = DEFAULT_BUFFER_MAX_LENGTH;\n      }\n\n      // if a messageMaxLength option is specified, make sure\n      // it's a positive integer before updating the logger option\n      if (Util.exists(localMessageMaxLength)) {\n        Errors.assertInternal(\n          Util.number.isPositiveInteger(localMessageMaxLength));\n        messageMaxLength = localMessageMaxLength;\n      } else if (!Util.exists(messageMaxLength)) { // initialize logger option if configure() hasn't been called before\n        messageMaxLength = DEFAULT_MESSAGE_MAX_LENGTH;\n      }\n\n      // if a level option is specified, make sure\n      // it's valid before updating the logger option\n      if (Util.exists(localLevel)) {\n        Errors.assertInternal(\n          Object.prototype.hasOwnProperty.call(MAP_LOG_LEVEL_TO_OBJECT, localLevel));\n        currlevelObject = MAP_LOG_LEVEL_TO_OBJECT[localLevel];\n      } else if (!Util.exists(currlevelObject)) { // initialize logger option if configure() hasn't been called before\n        currlevelObject = DEFAULT_LEVEL;\n      }\n\n      if (Util.isFunction(reconfigureOperation)) {\n        reconfigureOperation(localFilePath, localAdditionalLogToConsole);\n      }\n    },\n\n    /**\n     * Logs a given message at the error level.\n     *\n     * @param {String} message\n     */\n    error: function (message) {\n      log(LOG_LEVEL_ERROR, message, getMessageArgs(arguments));\n    },\n\n    /**\n     * Logs a given message at the warn level.\n     *\n     * @param {String} message\n     */\n    warn: function (message) {\n      log(LOG_LEVEL_WARN, message, getMessageArgs(arguments));\n    },\n\n    /**\n     * Logs a given message at the info level.\n     *\n     * @param {String} message\n     */\n    info: function (message) {\n      log(LOG_LEVEL_INFO, message, getMessageArgs(arguments));\n    },\n\n    /**\n     * Logs a given message at the debug level.\n     *\n     * @param {String} message\n     */\n    debug: function (message) {\n      log(LOG_LEVEL_DEBUG, message, getMessageArgs(arguments));\n    },\n\n    /**\n     * Logs a given message at the trace level.\n     *\n     * @param {String} message\n     */\n    trace: function (message) {\n      log(LOG_LEVEL_TRACE, message, getMessageArgs(arguments));\n    },\n\n    /**\n     * Returns the log buffer.\n     *\n     * @returns {String[]}\n     */\n    getLogBuffer: function () {\n      return [];\n    },\n\n    /**\n     * Returns the level number associated with the current log level.\n     *\n     * @returns {Number}\n     */\n    getLevelNumber: function () {\n      return currlevelObject.level;\n    },\n\n    /**\n     * Returns the tag associated with the current log level.\n     *\n     * @returns {String}\n     */\n    getLevelTag: function () {\n      return currlevelObject.tag;\n    },\n\n    /**\n     * Returns a map in which the keys are the level tags and the values are the\n     * corresponding log levels.\n     *\n     * @returns {Object}\n     */\n    getLevelTagsMap: function () {\n      return MAP_LOG_TAG_TO_LEVEL;\n    }\n  };\n\n  // configure the logger\n  logger.configure(options);\n\n  /**\n   * Logs a message at a given level.\n   *\n   * @param {Object} targetLevelObject the level at which to log the message.\n   * @param {String} message the message template.\n   * @param {String[]} messageArgs any arguments to substitute into the message.\n   */\n  const log = function (targetLevelObject, message, messageArgs) {\n    // the message should not be logged if the target\n    // level is more verbose than the current level\n    if (targetLevelObject.level <= currlevelObject.level) {\n      // substitute the messageArgs into the message template\n      messageArgs.unshift(message);\n      message = Util.format.apply(Util, messageArgs);\n\n      // truncate the message if it's too long\n      if (message.length > messageMaxLength) {\n        message = message.slice(0, messageMaxLength);\n      }\n\n      // if needed, add the current time to the front of the message\n      if (includeTimestamp) {\n        message = Util.format(\n          '[%s]: %s', moment().format('h:mm:ss.SSS A'), message);\n      }\n\n      // mask secrets\n      message = SecretDetector.maskSecrets(message).maskedtxt;\n\n      // log the message\n      logMessage(targetLevelObject.tag, message, bufferMaxLength);\n    }\n  };\n\n  return logger;\n};\n\nexports.isValidLogTag = function (logTag) {\n  if (!Util.isString(logTag)) {\n    return false;\n  }\n\n  return (Object.prototype.hasOwnProperty.call(MAP_LOG_TAG_TO_LEVEL, logTag.toUpperCase()));\n\n};\n\nexports.logTagToLevel = function (logTag) {\n  Errors.assertInternal(Util.isString(logTag));\n  return MAP_LOG_TAG_TO_LEVEL[logTag.toUpperCase()];\n};\n\n/**\n * Helper method to extract the messageArgs from the arguments passed to\n * trace(), debug(), info(), warn() and error().\n *\n * @param {Object} args\n *\n * @returns {*}\n */\nfunction getMessageArgs(args) {\n  return Array.prototype.slice.call(args, 1);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvbG9nZ2VyL2NvcmUuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLHFEQUFRO0FBQy9CLGFBQWEsbUJBQU8sQ0FBQywrREFBUztBQUM5QixlQUFlLG1CQUFPLENBQUMsbUVBQVc7QUFDbEMsNEJBQTRCLG1CQUFPLENBQUMsd0ZBQXVCOztBQUUzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxnQkFBZ0I7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQixzQkFBc0I7QUFDdEIsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwQ0FBMEM7QUFDbEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDJDQUEyQztBQUNuRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMENBQTBDO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvbG9nZ2VyL2NvcmUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgbW9tZW50ID0gcmVxdWlyZSgnbW9tZW50Jyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi4vZXJyb3JzJyk7XG5jb25zdCBTZWNyZXREZXRlY3RvciA9IG5ldyAocmVxdWlyZSgnLi4vc2VjcmV0X2RldGVjdG9yLmpzJykpKCk7XG5cbmNvbnN0IExPR19MRVZFTF9PRkYgPVxuICB7XG4gICAgdGFnOiAnT0ZGJyxcbiAgICBsZXZlbDogLTFcbiAgfTtcblxuY29uc3QgTE9HX0xFVkVMX0VSUk9SID1cbiAge1xuICAgIHRhZzogJ0VSUk9SJyxcbiAgICBsZXZlbDogMFxuICB9O1xuXG5jb25zdCBMT0dfTEVWRUxfV0FSTiA9XG4gIHtcbiAgICB0YWc6ICdXQVJOJyxcbiAgICBsZXZlbDogMVxuICB9O1xuXG5jb25zdCBMT0dfTEVWRUxfSU5GTyA9XG4gIHtcbiAgICB0YWc6ICdJTkZPJyxcbiAgICBsZXZlbDogMlxuICB9O1xuXG5jb25zdCBMT0dfTEVWRUxfREVCVUcgPVxuICB7XG4gICAgdGFnOiAnREVCVUcnLFxuICAgIGxldmVsOiAzXG4gIH07XG5cbmNvbnN0IExPR19MRVZFTF9UUkFDRSA9XG4gIHtcbiAgICB0YWc6ICdUUkFDRScsXG4gICAgbGV2ZWw6IDRcbiAgfTtcblxuY29uc3QgTE9HX0xFVkVMUyA9XG4gIFtcbiAgICBMT0dfTEVWRUxfT0ZGLFxuICAgIExPR19MRVZFTF9FUlJPUixcbiAgICBMT0dfTEVWRUxfV0FSTixcbiAgICBMT0dfTEVWRUxfSU5GTyxcbiAgICBMT0dfTEVWRUxfREVCVUcsXG4gICAgTE9HX0xFVkVMX1RSQUNFXG4gIF07XG5cbmNvbnN0IExPR19MRVZFTF9UQUdTID0ge1xuICBPRkY6IExPR19MRVZFTF9PRkYudGFnLFxuICBFUlJPUjogTE9HX0xFVkVMX0VSUk9SLnRhZyxcbiAgV0FSTjogTE9HX0xFVkVMX1dBUk4udGFnLFxuICBJTkZPOiBMT0dfTEVWRUxfSU5GTy50YWcsXG4gIERFQlVHOiBMT0dfTEVWRUxfREVCVUcudGFnLFxuICBUUkFDRTogTE9HX0xFVkVMX1RSQUNFLnRhZyxcbn07XG5leHBvcnRzLkxPR19MRVZFTF9UQUdTID0gTE9HX0xFVkVMX1RBR1M7XG5cbi8vIGNyZWF0ZSB0d28gbWFwcywgb25lIGluIHdoaWNoIHRoZSBrZXkgaXMgdGhlIGxvZyBsZXZlbCBhbmQgdGhlIHZhbHVlIGlzIHRoZVxuLy8gY29ycmVzcG9uZGluZyBsb2cgbGV2ZWwgb2JqZWN0LCBhbmQgYW5vdGhlciBpbiB3aGljaCB0aGUga2V5IGlzIHRoZSBsb2cgdGFnXG4vLyBhbmQgdGhlIHZhbHVlIGlzIHRoZSBjb3JyZXNwb25kaW5nIGxvZyBsZXZlbFxuY29uc3QgTUFQX0xPR19MRVZFTF9UT19PQkpFQ1QgPSB7fTtcbmNvbnN0IE1BUF9MT0dfVEFHX1RPX0xFVkVMID0ge307XG5mb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IExPR19MRVZFTFMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICBjb25zdCBsb2dMZXZlbE9iamVjdCA9IExPR19MRVZFTFNbaW5kZXhdO1xuICBNQVBfTE9HX0xFVkVMX1RPX09CSkVDVFtsb2dMZXZlbE9iamVjdC5sZXZlbF0gPSBsb2dMZXZlbE9iamVjdDtcbiAgTUFQX0xPR19UQUdfVE9fTEVWRUxbbG9nTGV2ZWxPYmplY3QudGFnXSA9IGxvZ0xldmVsT2JqZWN0LmxldmVsO1xufVxuXG5jb25zdCBERUZBVUxUX0JVRkZFUl9NQVhfTEVOR1RIID0gNTAwO1xuY29uc3QgREVGQVVMVF9NRVNTQUdFX01BWF9MRU5HVEggPSA1MDA7XG5jb25zdCBERUZBVUxUX0xFVkVMID0gTE9HX0xFVkVMX0lORk87XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBMb2dnZXIgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMge09iamVjdH1cbiAqIEBwYXJhbSBsb2dNZXNzYWdlIHtGdW5jdGlvbn1cbiAqIEBwYXJhbSByZWNvbmZpZ3VyZU9wZXJhdGlvbiB7RnVuY3Rpb259IEFjdGlvbiB0byBwZXJmb3JtIHRvIGNoYW5nZSBsb2cgZGVzdGluYXRpb24gZmlsZVxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuY3JlYXRlTG9nZ2VyID0gZnVuY3Rpb24gKG9wdGlvbnMsIGxvZ01lc3NhZ2UsIHJlY29uZmlndXJlT3BlcmF0aW9uKSB7XG4gIC8vIGEgbG9nIGZ1bmN0aW9uIG11c3QgYmUgc3BlY2lmaWVkXG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzRnVuY3Rpb24obG9nTWVzc2FnZSkpO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIGluY2x1ZGUgdGhlIGN1cnJlbnQgdGltZXN0YW1wIGluIHRoZSBsb2cgbWVzc2FnZS5cbiAgICovXG4gIGxldCBpbmNsdWRlVGltZXN0YW1wO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBzaXplIChpbiB0ZXJtcyBvZiBudW1iZXIgb2YgbWVzc2FnZXMpIHRvIHdoaWNoIHRoZSBsb2cgYnVmZmVyXG4gICAqIGNhbiBncm93LlxuICAgKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgbGV0IGJ1ZmZlck1heExlbmd0aDtcblxuICAvKipcbiAgICogVGhlIG1heGltdW0gbWVzc2FnZSBsZW5ndGguIExvbmdlciBtZXNzYWdlcyB3aWxsIGJlIHRydW5jYXRlZC5cbiAgICpcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGxldCBtZXNzYWdlTWF4TGVuZ3RoO1xuXG4gIC8qKlxuICAgKiBUaGUgY3VycmVudCBsb2cgbGV2ZWwuIEFueSBtZXNzYWdlIGxvZ2dlZCBhdCBhIGxvd2VyIGxldmVsIHdvbid0IGJlIGFkZGVkXG4gICAqIHRvIHRoZSBsb2cgYnVmZmVyLlxuICAgKlxuICAgKiBAdHlwZSB7T2JqZWN0fVxuICAgKi9cbiAgbGV0IGN1cnJsZXZlbE9iamVjdDtcblxuICAvLyBjcmVhdGUgYSBuZXcgbG9nZ2VyIGluc3RhbmNlXG4gIGNvbnN0IGxvZ2dlciA9IHtcbiAgICAvKipcbiAgICAgKiBDb25maWd1cmVzIHRoaXMgbG9nZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKi9cbiAgICBjb25maWd1cmU6IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICBsZXQgbG9jYWxJbmNsdWRlVGltZXN0YW1wO1xuICAgICAgbGV0IGxvY2FsQnVmZmVyTWF4TGVuZ3RoO1xuICAgICAgbGV0IGxvY2FsTWVzc2FnZU1heExlbmd0aDtcbiAgICAgIGxldCBsb2NhbExldmVsO1xuICAgICAgbGV0IGxvY2FsRmlsZVBhdGg7XG4gICAgICBsZXQgbG9jYWxBZGRpdGlvbmFsTG9nVG9Db25zb2xlO1xuXG4gICAgICAvLyBpZiBhbiBvcHRpb25zIGFyZ3VtZW50IGlzIHNwZWNpZmllZFxuICAgICAgaWYgKFV0aWwuZXhpc3RzKG9wdGlvbnMpKSB7XG4gICAgICAgIC8vIG1ha2Ugc3VyZSBpdCdzIGFuIG9iamVjdFxuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zKSk7XG5cbiAgICAgICAgbG9jYWxJbmNsdWRlVGltZXN0YW1wID0gb3B0aW9ucy5pbmNsdWRlVGltZXN0YW1wO1xuICAgICAgICBsb2NhbEJ1ZmZlck1heExlbmd0aCA9IG9wdGlvbnMuYnVmZmVyTWF4TGVuZ3RoO1xuICAgICAgICBsb2NhbE1lc3NhZ2VNYXhMZW5ndGggPSBvcHRpb25zLm1lc3NhZ2VNYXhMZW5ndGg7XG4gICAgICAgIGxvY2FsTGV2ZWwgPSBvcHRpb25zLmxldmVsO1xuICAgICAgICBsb2NhbEZpbGVQYXRoID0gb3B0aW9ucy5maWxlUGF0aDtcbiAgICAgICAgbG9jYWxBZGRpdGlvbmFsTG9nVG9Db25zb2xlID0gb3B0aW9ucy5hZGRpdGlvbmFsTG9nVG9Db25zb2xlO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhbiBpbmNsdWRlVGltZXN0YW1wIG9wdGlvbnMgaXMgc3BlY2lmaWVkLCBjb252ZXJ0IGl0IHRvIGEgYm9vbGVhblxuICAgICAgaWYgKFV0aWwuZXhpc3RzKGxvY2FsSW5jbHVkZVRpbWVzdGFtcCkpIHtcbiAgICAgICAgaW5jbHVkZVRpbWVzdGFtcCA9ICEhbG9jYWxJbmNsdWRlVGltZXN0YW1wO1xuICAgICAgfSBlbHNlIGlmICghVXRpbC5leGlzdHMoaW5jbHVkZVRpbWVzdGFtcCkpIHtcbiAgICAgICAgLy8gZGVmYXVsdCB0byB0cnVlXG4gICAgICAgIGluY2x1ZGVUaW1lc3RhbXAgPSB0cnVlO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhIGJ1ZmZlck1heExlbmd0aCBvcHRpb24gaXMgc3BlY2lmaWVkLCBtYWtlIHN1cmVcbiAgICAgIC8vIGl0J3MgYSBwb3NpdGl2ZSBpbnRlZ2VyIGJlZm9yZSB1cGRhdGluZyB0aGUgbG9nZ2VyIG9wdGlvblxuICAgICAgaWYgKFV0aWwuZXhpc3RzKGxvY2FsQnVmZmVyTWF4TGVuZ3RoKSkge1xuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoXG4gICAgICAgICAgVXRpbC5udW1iZXIuaXNQb3NpdGl2ZUludGVnZXIobG9jYWxCdWZmZXJNYXhMZW5ndGgpKTtcbiAgICAgICAgYnVmZmVyTWF4TGVuZ3RoID0gbG9jYWxCdWZmZXJNYXhMZW5ndGg7XG4gICAgICB9IGVsc2UgaWYgKCFVdGlsLmV4aXN0cyhidWZmZXJNYXhMZW5ndGgpKSB7IC8vIGluaXRpYWxpemUgbG9nZ2VyIG9wdGlvbiBpZiBjb25maWd1cmUoKSBoYXNuJ3QgYmVlbiBjYWxsZWQgYmVmb3JlXG4gICAgICAgIGJ1ZmZlck1heExlbmd0aCA9IERFRkFVTFRfQlVGRkVSX01BWF9MRU5HVEg7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGEgbWVzc2FnZU1heExlbmd0aCBvcHRpb24gaXMgc3BlY2lmaWVkLCBtYWtlIHN1cmVcbiAgICAgIC8vIGl0J3MgYSBwb3NpdGl2ZSBpbnRlZ2VyIGJlZm9yZSB1cGRhdGluZyB0aGUgbG9nZ2VyIG9wdGlvblxuICAgICAgaWYgKFV0aWwuZXhpc3RzKGxvY2FsTWVzc2FnZU1heExlbmd0aCkpIHtcbiAgICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFxuICAgICAgICAgIFV0aWwubnVtYmVyLmlzUG9zaXRpdmVJbnRlZ2VyKGxvY2FsTWVzc2FnZU1heExlbmd0aCkpO1xuICAgICAgICBtZXNzYWdlTWF4TGVuZ3RoID0gbG9jYWxNZXNzYWdlTWF4TGVuZ3RoO1xuICAgICAgfSBlbHNlIGlmICghVXRpbC5leGlzdHMobWVzc2FnZU1heExlbmd0aCkpIHsgLy8gaW5pdGlhbGl6ZSBsb2dnZXIgb3B0aW9uIGlmIGNvbmZpZ3VyZSgpIGhhc24ndCBiZWVuIGNhbGxlZCBiZWZvcmVcbiAgICAgICAgbWVzc2FnZU1heExlbmd0aCA9IERFRkFVTFRfTUVTU0FHRV9NQVhfTEVOR1RIO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiBhIGxldmVsIG9wdGlvbiBpcyBzcGVjaWZpZWQsIG1ha2Ugc3VyZVxuICAgICAgLy8gaXQncyB2YWxpZCBiZWZvcmUgdXBkYXRpbmcgdGhlIGxvZ2dlciBvcHRpb25cbiAgICAgIGlmIChVdGlsLmV4aXN0cyhsb2NhbExldmVsKSkge1xuICAgICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoXG4gICAgICAgICAgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKE1BUF9MT0dfTEVWRUxfVE9fT0JKRUNULCBsb2NhbExldmVsKSk7XG4gICAgICAgIGN1cnJsZXZlbE9iamVjdCA9IE1BUF9MT0dfTEVWRUxfVE9fT0JKRUNUW2xvY2FsTGV2ZWxdO1xuICAgICAgfSBlbHNlIGlmICghVXRpbC5leGlzdHMoY3VycmxldmVsT2JqZWN0KSkgeyAvLyBpbml0aWFsaXplIGxvZ2dlciBvcHRpb24gaWYgY29uZmlndXJlKCkgaGFzbid0IGJlZW4gY2FsbGVkIGJlZm9yZVxuICAgICAgICBjdXJybGV2ZWxPYmplY3QgPSBERUZBVUxUX0xFVkVMO1xuICAgICAgfVxuXG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKHJlY29uZmlndXJlT3BlcmF0aW9uKSkge1xuICAgICAgICByZWNvbmZpZ3VyZU9wZXJhdGlvbihsb2NhbEZpbGVQYXRoLCBsb2NhbEFkZGl0aW9uYWxMb2dUb0NvbnNvbGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgZ2l2ZW4gbWVzc2FnZSBhdCB0aGUgZXJyb3IgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIGVycm9yOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgbG9nKExPR19MRVZFTF9FUlJPUiwgbWVzc2FnZSwgZ2V0TWVzc2FnZUFyZ3MoYXJndW1lbnRzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSB3YXJuIGxldmVsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2VcbiAgICAgKi9cbiAgICB3YXJuOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgbG9nKExPR19MRVZFTF9XQVJOLCBtZXNzYWdlLCBnZXRNZXNzYWdlQXJncyhhcmd1bWVudHMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIGluZm8gbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIGluZm86IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBsb2coTE9HX0xFVkVMX0lORk8sIG1lc3NhZ2UsIGdldE1lc3NhZ2VBcmdzKGFyZ3VtZW50cykpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBMb2dzIGEgZ2l2ZW4gbWVzc2FnZSBhdCB0aGUgZGVidWcgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgICAqL1xuICAgIGRlYnVnOiBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgbG9nKExPR19MRVZFTF9ERUJVRywgbWVzc2FnZSwgZ2V0TWVzc2FnZUFyZ3MoYXJndW1lbnRzKSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIExvZ3MgYSBnaXZlbiBtZXNzYWdlIGF0IHRoZSB0cmFjZSBsZXZlbC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAgICovXG4gICAgdHJhY2U6IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICBsb2coTE9HX0xFVkVMX1RSQUNFLCBtZXNzYWdlLCBnZXRNZXNzYWdlQXJncyhhcmd1bWVudHMpKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbG9nIGJ1ZmZlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmdbXX1cbiAgICAgKi9cbiAgICBnZXRMb2dCdWZmZXI6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbGV2ZWwgbnVtYmVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgY3VycmVudCBsb2cgbGV2ZWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGdldExldmVsTnVtYmVyOiBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gY3VycmxldmVsT2JqZWN0LmxldmVsO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB0YWcgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IGxvZyBsZXZlbC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtTdHJpbmd9XG4gICAgICovXG4gICAgZ2V0TGV2ZWxUYWc6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBjdXJybGV2ZWxPYmplY3QudGFnO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbWFwIGluIHdoaWNoIHRoZSBrZXlzIGFyZSB0aGUgbGV2ZWwgdGFncyBhbmQgdGhlIHZhbHVlcyBhcmUgdGhlXG4gICAgICogY29ycmVzcG9uZGluZyBsb2cgbGV2ZWxzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAgKi9cbiAgICBnZXRMZXZlbFRhZ3NNYXA6IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBNQVBfTE9HX1RBR19UT19MRVZFTDtcbiAgICB9XG4gIH07XG5cbiAgLy8gY29uZmlndXJlIHRoZSBsb2dnZXJcbiAgbG9nZ2VyLmNvbmZpZ3VyZShvcHRpb25zKTtcblxuICAvKipcbiAgICogTG9ncyBhIG1lc3NhZ2UgYXQgYSBnaXZlbiBsZXZlbC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHRhcmdldExldmVsT2JqZWN0IHRoZSBsZXZlbCBhdCB3aGljaCB0byBsb2cgdGhlIG1lc3NhZ2UuXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIHRoZSBtZXNzYWdlIHRlbXBsYXRlLlxuICAgKiBAcGFyYW0ge1N0cmluZ1tdfSBtZXNzYWdlQXJncyBhbnkgYXJndW1lbnRzIHRvIHN1YnN0aXR1dGUgaW50byB0aGUgbWVzc2FnZS5cbiAgICovXG4gIGNvbnN0IGxvZyA9IGZ1bmN0aW9uICh0YXJnZXRMZXZlbE9iamVjdCwgbWVzc2FnZSwgbWVzc2FnZUFyZ3MpIHtcbiAgICAvLyB0aGUgbWVzc2FnZSBzaG91bGQgbm90IGJlIGxvZ2dlZCBpZiB0aGUgdGFyZ2V0XG4gICAgLy8gbGV2ZWwgaXMgbW9yZSB2ZXJib3NlIHRoYW4gdGhlIGN1cnJlbnQgbGV2ZWxcbiAgICBpZiAodGFyZ2V0TGV2ZWxPYmplY3QubGV2ZWwgPD0gY3VycmxldmVsT2JqZWN0LmxldmVsKSB7XG4gICAgICAvLyBzdWJzdGl0dXRlIHRoZSBtZXNzYWdlQXJncyBpbnRvIHRoZSBtZXNzYWdlIHRlbXBsYXRlXG4gICAgICBtZXNzYWdlQXJncy51bnNoaWZ0KG1lc3NhZ2UpO1xuICAgICAgbWVzc2FnZSA9IFV0aWwuZm9ybWF0LmFwcGx5KFV0aWwsIG1lc3NhZ2VBcmdzKTtcblxuICAgICAgLy8gdHJ1bmNhdGUgdGhlIG1lc3NhZ2UgaWYgaXQncyB0b28gbG9uZ1xuICAgICAgaWYgKG1lc3NhZ2UubGVuZ3RoID4gbWVzc2FnZU1heExlbmd0aCkge1xuICAgICAgICBtZXNzYWdlID0gbWVzc2FnZS5zbGljZSgwLCBtZXNzYWdlTWF4TGVuZ3RoKTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgbmVlZGVkLCBhZGQgdGhlIGN1cnJlbnQgdGltZSB0byB0aGUgZnJvbnQgb2YgdGhlIG1lc3NhZ2VcbiAgICAgIGlmIChpbmNsdWRlVGltZXN0YW1wKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBVdGlsLmZvcm1hdChcbiAgICAgICAgICAnWyVzXTogJXMnLCBtb21lbnQoKS5mb3JtYXQoJ2g6bW06c3MuU1NTIEEnKSwgbWVzc2FnZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIG1hc2sgc2VjcmV0c1xuICAgICAgbWVzc2FnZSA9IFNlY3JldERldGVjdG9yLm1hc2tTZWNyZXRzKG1lc3NhZ2UpLm1hc2tlZHR4dDtcblxuICAgICAgLy8gbG9nIHRoZSBtZXNzYWdlXG4gICAgICBsb2dNZXNzYWdlKHRhcmdldExldmVsT2JqZWN0LnRhZywgbWVzc2FnZSwgYnVmZmVyTWF4TGVuZ3RoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIGxvZ2dlcjtcbn07XG5cbmV4cG9ydHMuaXNWYWxpZExvZ1RhZyA9IGZ1bmN0aW9uIChsb2dUYWcpIHtcbiAgaWYgKCFVdGlsLmlzU3RyaW5nKGxvZ1RhZykpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChNQVBfTE9HX1RBR19UT19MRVZFTCwgbG9nVGFnLnRvVXBwZXJDYXNlKCkpKTtcblxufTtcblxuZXhwb3J0cy5sb2dUYWdUb0xldmVsID0gZnVuY3Rpb24gKGxvZ1RhZykge1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc1N0cmluZyhsb2dUYWcpKTtcbiAgcmV0dXJuIE1BUF9MT0dfVEFHX1RPX0xFVkVMW2xvZ1RhZy50b1VwcGVyQ2FzZSgpXTtcbn07XG5cbi8qKlxuICogSGVscGVyIG1ldGhvZCB0byBleHRyYWN0IHRoZSBtZXNzYWdlQXJncyBmcm9tIHRoZSBhcmd1bWVudHMgcGFzc2VkIHRvXG4gKiB0cmFjZSgpLCBkZWJ1ZygpLCBpbmZvKCksIHdhcm4oKSBhbmQgZXJyb3IoKS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYXJnc1xuICpcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBnZXRNZXNzYWdlQXJncyhhcmdzKSB7XG4gIHJldHVybiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmdzLCAxKTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/logger/core.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/logger/easy_logging_starter.js":
/*!***********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/logger/easy_logging_starter.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const os = __webpack_require__(/*! os */ \"os\");\nconst path = __webpack_require__(/*! path */ \"path\");\nconst fsPromises = __webpack_require__(/*! fs/promises */ \"fs/promises\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst { logTagToLevel } = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger/core.js\");\nconst { ConfigurationUtil, Levels } = __webpack_require__(/*! ../configuration/client_configuration */ \"(rsc)/./node_modules/snowflake-sdk/lib/configuration/client_configuration.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst { isFileModeCorrect } = __webpack_require__(/*! ../file_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/file_util.js\");\nconst { exists } = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst clientConfiguration = new ConfigurationUtil();\nconst getClientConfig = clientConfiguration.getClientConfig;\n\nlet initTrialParameters;\n\n/**\n * @param {string} configFilePathFromConnectionString\n * @returns {Promise<void>}\n */\nexports.init = async function (configFilePathFromConnectionString) {\n  try {\n    if (!allowedToInitialize(configFilePathFromConnectionString)) {\n      return;\n    }\n    Logger.getInstance().info('Trying to initialize Easy Logging');\n    const config = await getClientConfig(configFilePathFromConnectionString);\n    if (!config) {\n      Logger.getInstance().info('Easy Logging is disabled as no config has been found');\n      initTrialParameters = {\n        configFilePathFromConnectionString: configFilePathFromConnectionString\n      };\n      return;\n    }\n    const logLevel = mapLogLevel(config);\n    const logPath = await getLogPath(config);\n    const logger = Logger.getInstance();\n    logger.info('Initializing Easy Logging with logPath=%s and logLevel=%s from file: %s', logPath, config.loggingConfig.logLevel, config.configPath);\n    logger.configure({\n      level: logLevel,\n      filePath: path.join(logPath, 'snowflake.log'),\n      additionalLogToConsole: false\n    });\n    logger.easyLoggingConfigureCounter = (logger.easyLoggingConfigureCounter ?? 0) + 1;\n    initTrialParameters = {\n      configFilePathFromConnectionString: configFilePathFromConnectionString\n    };\n  } catch (err) {\n    const error = new EasyLoggingError('Failed to initialize easy logging', err);\n    Logger.getInstance().error(error);\n    throw error;\n  }\n};\n\nexports.reset = function () {\n  initTrialParameters = undefined;\n  Logger.getInstance().easyLoggingConfigureCounter = undefined;\n};\n\nfunction allowedToInitialize(configFilePathFromConnectionString) {\n  const everTriedToInitialize = !!initTrialParameters;\n  const triedToInitializeWithoutConfigFile = everTriedToInitialize && initTrialParameters.configFilePathFromConnectionString == null;\n  const isGivenConfigFilePath = !!configFilePathFromConnectionString;\n  const isAllowedToInitialize = !everTriedToInitialize || (triedToInitializeWithoutConfigFile && isGivenConfigFilePath);\n  if (!isAllowedToInitialize && initTrialParameters.configFilePathFromConnectionString !== configFilePathFromConnectionString) {\n    Logger.getInstance().warn(`Easy logging will not be configured for CLIENT_CONFIG_FILE=${configFilePathFromConnectionString} because it was previously configured for a different client config`);\n  }\n  return isAllowedToInitialize;\n}\n\nfunction mapLogLevel(config) {\n  const configLogLevel = getLogLevel(config);\n  const logLevelNumber = logTagToLevel(configLogLevel);\n  if (logLevelNumber === null || logLevelNumber === undefined) {\n    throw new Error('Failed to convert configuration log level into internal one');\n  }\n  return logLevelNumber;\n}\n\nfunction getLogLevel(config) {\n  const logLevel = config.loggingConfig.logLevel;\n  if (!logLevel) {\n    Logger.getInstance().warn('LogLevel in client config not found. Using default value: OFF');\n    return Levels.Off;\n  }\n  return logLevel;\n}\n\nasync function getLogPath(config) {\n  let logPath = config.loggingConfig.logPath;\n  if (!logPath) {\n    Logger.getInstance().warn('LogPath in client config not found. Using home directory as a default value');\n    logPath = os.homedir();\n    if (!exists(logPath)) {\n      throw new EasyLoggingError('Home directory does not exist');\n    }\n  }\n  const pathWithNodeJsSubdirectory = path.join(logPath, 'nodejs');\n  await fsPromises.access(pathWithNodeJsSubdirectory, fs.constants.F_OK)\n    .then(async () => {\n      if (!(await isFileModeCorrect(pathWithNodeJsSubdirectory, 0o700, fsPromises))) {\n        Logger.getInstance().warn('Log directory: %s could potentially be accessed by others', pathWithNodeJsSubdirectory);\n      }\n    })\n    .catch(async () => {\n      try {\n        await fsPromises.mkdir(pathWithNodeJsSubdirectory, { recursive: true, mode: 0o700 });\n      } catch (err) {\n        throw new EasyLoggingError(`Failed to create the directory for logs: ${pathWithNodeJsSubdirectory}`);\n      }\n    });\n  return pathWithNodeJsSubdirectory;\n}\n\nclass EasyLoggingError extends Error {\n  name = 'EasyLoggingError';\n\n  constructor(message, cause) {\n    super(message);\n    this.cause = cause;\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  toString() {\n    return this.message + ': ' + this.cause.toString();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvbG9nZ2VyL2Vhc3lfbG9nZ2luZ19zdGFydGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQyxnQ0FBYTtBQUN4QyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixRQUFRLGdCQUFnQixFQUFFLG1CQUFPLENBQUMscUVBQVE7QUFDMUMsUUFBUSw0QkFBNEIsRUFBRSxtQkFBTyxDQUFDLDJIQUF1QztBQUNyRixlQUFlLG1CQUFPLENBQUMsbUVBQVc7QUFDbEMsUUFBUSxvQkFBb0IsRUFBRSxtQkFBTyxDQUFDLHlFQUFjO0FBQ3BELFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsK0RBQVM7QUFDcEM7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RkFBNEYsb0NBQW9DO0FBQ2hJO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSw2REFBNkQsOEJBQThCO0FBQzNGLFFBQVE7QUFDUiwrRUFBK0UsMkJBQTJCO0FBQzFHO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2xvZ2dlci9lYXN5X2xvZ2dpbmdfc3RhcnRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xuY29uc3QgZnNQcm9taXNlcyA9IHJlcXVpcmUoJ2ZzL3Byb21pc2VzJyk7XG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJyk7XG5jb25zdCB7IGxvZ1RhZ1RvTGV2ZWwgfSA9IHJlcXVpcmUoJy4vY29yZScpO1xuY29uc3QgeyBDb25maWd1cmF0aW9uVXRpbCwgTGV2ZWxzIH0gPSByZXF1aXJlKCcuLi9jb25maWd1cmF0aW9uL2NsaWVudF9jb25maWd1cmF0aW9uJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuLi9sb2dnZXInKTtcbmNvbnN0IHsgaXNGaWxlTW9kZUNvcnJlY3QgfSA9IHJlcXVpcmUoJy4uL2ZpbGVfdXRpbCcpO1xuY29uc3QgeyBleGlzdHMgfSA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IGNsaWVudENvbmZpZ3VyYXRpb24gPSBuZXcgQ29uZmlndXJhdGlvblV0aWwoKTtcbmNvbnN0IGdldENsaWVudENvbmZpZyA9IGNsaWVudENvbmZpZ3VyYXRpb24uZ2V0Q2xpZW50Q29uZmlnO1xuXG5sZXQgaW5pdFRyaWFsUGFyYW1ldGVycztcblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZ1xuICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gKi9cbmV4cG9ydHMuaW5pdCA9IGFzeW5jIGZ1bmN0aW9uIChjb25maWdGaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgaWYgKCFhbGxvd2VkVG9Jbml0aWFsaXplKGNvbmZpZ0ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmcpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmluZm8oJ1RyeWluZyB0byBpbml0aWFsaXplIEVhc3kgTG9nZ2luZycpO1xuICAgIGNvbnN0IGNvbmZpZyA9IGF3YWl0IGdldENsaWVudENvbmZpZyhjb25maWdGaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nKTtcbiAgICBpZiAoIWNvbmZpZykge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuaW5mbygnRWFzeSBMb2dnaW5nIGlzIGRpc2FibGVkIGFzIG5vIGNvbmZpZyBoYXMgYmVlbiBmb3VuZCcpO1xuICAgICAgaW5pdFRyaWFsUGFyYW1ldGVycyA9IHtcbiAgICAgICAgY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZzogY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZ1xuICAgICAgfTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbG9nTGV2ZWwgPSBtYXBMb2dMZXZlbChjb25maWcpO1xuICAgIGNvbnN0IGxvZ1BhdGggPSBhd2FpdCBnZXRMb2dQYXRoKGNvbmZpZyk7XG4gICAgY29uc3QgbG9nZ2VyID0gTG9nZ2VyLmdldEluc3RhbmNlKCk7XG4gICAgbG9nZ2VyLmluZm8oJ0luaXRpYWxpemluZyBFYXN5IExvZ2dpbmcgd2l0aCBsb2dQYXRoPSVzIGFuZCBsb2dMZXZlbD0lcyBmcm9tIGZpbGU6ICVzJywgbG9nUGF0aCwgY29uZmlnLmxvZ2dpbmdDb25maWcubG9nTGV2ZWwsIGNvbmZpZy5jb25maWdQYXRoKTtcbiAgICBsb2dnZXIuY29uZmlndXJlKHtcbiAgICAgIGxldmVsOiBsb2dMZXZlbCxcbiAgICAgIGZpbGVQYXRoOiBwYXRoLmpvaW4obG9nUGF0aCwgJ3Nub3dmbGFrZS5sb2cnKSxcbiAgICAgIGFkZGl0aW9uYWxMb2dUb0NvbnNvbGU6IGZhbHNlXG4gICAgfSk7XG4gICAgbG9nZ2VyLmVhc3lMb2dnaW5nQ29uZmlndXJlQ291bnRlciA9IChsb2dnZXIuZWFzeUxvZ2dpbmdDb25maWd1cmVDb3VudGVyID8/IDApICsgMTtcbiAgICBpbml0VHJpYWxQYXJhbWV0ZXJzID0ge1xuICAgICAgY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZzogY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZ1xuICAgIH07XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGNvbnN0IGVycm9yID0gbmV3IEVhc3lMb2dnaW5nRXJyb3IoJ0ZhaWxlZCB0byBpbml0aWFsaXplIGVhc3kgbG9nZ2luZycsIGVycik7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnRzLnJlc2V0ID0gZnVuY3Rpb24gKCkge1xuICBpbml0VHJpYWxQYXJhbWV0ZXJzID0gdW5kZWZpbmVkO1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lYXN5TG9nZ2luZ0NvbmZpZ3VyZUNvdW50ZXIgPSB1bmRlZmluZWQ7XG59O1xuXG5mdW5jdGlvbiBhbGxvd2VkVG9Jbml0aWFsaXplKGNvbmZpZ0ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmcpIHtcbiAgY29uc3QgZXZlclRyaWVkVG9Jbml0aWFsaXplID0gISFpbml0VHJpYWxQYXJhbWV0ZXJzO1xuICBjb25zdCB0cmllZFRvSW5pdGlhbGl6ZVdpdGhvdXRDb25maWdGaWxlID0gZXZlclRyaWVkVG9Jbml0aWFsaXplICYmIGluaXRUcmlhbFBhcmFtZXRlcnMuY29uZmlnRmlsZVBhdGhGcm9tQ29ubmVjdGlvblN0cmluZyA9PSBudWxsO1xuICBjb25zdCBpc0dpdmVuQ29uZmlnRmlsZVBhdGggPSAhIWNvbmZpZ0ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmc7XG4gIGNvbnN0IGlzQWxsb3dlZFRvSW5pdGlhbGl6ZSA9ICFldmVyVHJpZWRUb0luaXRpYWxpemUgfHwgKHRyaWVkVG9Jbml0aWFsaXplV2l0aG91dENvbmZpZ0ZpbGUgJiYgaXNHaXZlbkNvbmZpZ0ZpbGVQYXRoKTtcbiAgaWYgKCFpc0FsbG93ZWRUb0luaXRpYWxpemUgJiYgaW5pdFRyaWFsUGFyYW1ldGVycy5jb25maWdGaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nICE9PSBjb25maWdGaWxlUGF0aEZyb21Db25uZWN0aW9uU3RyaW5nKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihgRWFzeSBsb2dnaW5nIHdpbGwgbm90IGJlIGNvbmZpZ3VyZWQgZm9yIENMSUVOVF9DT05GSUdfRklMRT0ke2NvbmZpZ0ZpbGVQYXRoRnJvbUNvbm5lY3Rpb25TdHJpbmd9IGJlY2F1c2UgaXQgd2FzIHByZXZpb3VzbHkgY29uZmlndXJlZCBmb3IgYSBkaWZmZXJlbnQgY2xpZW50IGNvbmZpZ2ApO1xuICB9XG4gIHJldHVybiBpc0FsbG93ZWRUb0luaXRpYWxpemU7XG59XG5cbmZ1bmN0aW9uIG1hcExvZ0xldmVsKGNvbmZpZykge1xuICBjb25zdCBjb25maWdMb2dMZXZlbCA9IGdldExvZ0xldmVsKGNvbmZpZyk7XG4gIGNvbnN0IGxvZ0xldmVsTnVtYmVyID0gbG9nVGFnVG9MZXZlbChjb25maWdMb2dMZXZlbCk7XG4gIGlmIChsb2dMZXZlbE51bWJlciA9PT0gbnVsbCB8fCBsb2dMZXZlbE51bWJlciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdGYWlsZWQgdG8gY29udmVydCBjb25maWd1cmF0aW9uIGxvZyBsZXZlbCBpbnRvIGludGVybmFsIG9uZScpO1xuICB9XG4gIHJldHVybiBsb2dMZXZlbE51bWJlcjtcbn1cblxuZnVuY3Rpb24gZ2V0TG9nTGV2ZWwoY29uZmlnKSB7XG4gIGNvbnN0IGxvZ0xldmVsID0gY29uZmlnLmxvZ2dpbmdDb25maWcubG9nTGV2ZWw7XG4gIGlmICghbG9nTGV2ZWwpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdMb2dMZXZlbCBpbiBjbGllbnQgY29uZmlnIG5vdCBmb3VuZC4gVXNpbmcgZGVmYXVsdCB2YWx1ZTogT0ZGJyk7XG4gICAgcmV0dXJuIExldmVscy5PZmY7XG4gIH1cbiAgcmV0dXJuIGxvZ0xldmVsO1xufVxuXG5hc3luYyBmdW5jdGlvbiBnZXRMb2dQYXRoKGNvbmZpZykge1xuICBsZXQgbG9nUGF0aCA9IGNvbmZpZy5sb2dnaW5nQ29uZmlnLmxvZ1BhdGg7XG4gIGlmICghbG9nUGF0aCkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oJ0xvZ1BhdGggaW4gY2xpZW50IGNvbmZpZyBub3QgZm91bmQuIFVzaW5nIGhvbWUgZGlyZWN0b3J5IGFzIGEgZGVmYXVsdCB2YWx1ZScpO1xuICAgIGxvZ1BhdGggPSBvcy5ob21lZGlyKCk7XG4gICAgaWYgKCFleGlzdHMobG9nUGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBFYXN5TG9nZ2luZ0Vycm9yKCdIb21lIGRpcmVjdG9yeSBkb2VzIG5vdCBleGlzdCcpO1xuICAgIH1cbiAgfVxuICBjb25zdCBwYXRoV2l0aE5vZGVKc1N1YmRpcmVjdG9yeSA9IHBhdGguam9pbihsb2dQYXRoLCAnbm9kZWpzJyk7XG4gIGF3YWl0IGZzUHJvbWlzZXMuYWNjZXNzKHBhdGhXaXRoTm9kZUpzU3ViZGlyZWN0b3J5LCBmcy5jb25zdGFudHMuRl9PSylcbiAgICAudGhlbihhc3luYyAoKSA9PiB7XG4gICAgICBpZiAoIShhd2FpdCBpc0ZpbGVNb2RlQ29ycmVjdChwYXRoV2l0aE5vZGVKc1N1YmRpcmVjdG9yeSwgMG83MDAsIGZzUHJvbWlzZXMpKSkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS53YXJuKCdMb2cgZGlyZWN0b3J5OiAlcyBjb3VsZCBwb3RlbnRpYWxseSBiZSBhY2Nlc3NlZCBieSBvdGhlcnMnLCBwYXRoV2l0aE5vZGVKc1N1YmRpcmVjdG9yeSk7XG4gICAgICB9XG4gICAgfSlcbiAgICAuY2F0Y2goYXN5bmMgKCkgPT4ge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgZnNQcm9taXNlcy5ta2RpcihwYXRoV2l0aE5vZGVKc1N1YmRpcmVjdG9yeSwgeyByZWN1cnNpdmU6IHRydWUsIG1vZGU6IDBvNzAwIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IG5ldyBFYXN5TG9nZ2luZ0Vycm9yKGBGYWlsZWQgdG8gY3JlYXRlIHRoZSBkaXJlY3RvcnkgZm9yIGxvZ3M6ICR7cGF0aFdpdGhOb2RlSnNTdWJkaXJlY3Rvcnl9YCk7XG4gICAgICB9XG4gICAgfSk7XG4gIHJldHVybiBwYXRoV2l0aE5vZGVKc1N1YmRpcmVjdG9yeTtcbn1cblxuY2xhc3MgRWFzeUxvZ2dpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgbmFtZSA9ICdFYXN5TG9nZ2luZ0Vycm9yJztcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjYXVzZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgfVxuXG4gIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2UgKyAnOiAnICsgdGhpcy5jYXVzZS50b1N0cmluZygpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/logger/easy_logging_starter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/logger/execution_timer.js":
/*!******************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/logger/execution_timer.js ***!
  \******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { performance } = __webpack_require__(/*! perf_hooks */ \"perf_hooks\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\n\nfunction ExecutionTimer() {\n  let startTime = null;\n  let endTime = null;\n\n  // Private function to log and check if the timer was started\n  function wasStarted() {\n    return Util.exists(startTime);\n\n  }\n\n  this.start = function () {\n    startTime = performance.now();\n    endTime = null; // Reset endTime if the timer is reused\n    return this;\n  };\n\n\n  this.stop = function () {\n    if (!wasStarted()) {\n      // Returning this to allow chaining even after invalid call.\n      // startTime can be used to check, if any start point was ever recorded.\n      Logger.getInstance().debug('Tried to stop timer, that was not started');\n      return this;\n    }\n    endTime = performance.now();\n    return this;\n  };\n\n  // Get the duration in milliseconds\n  this.getDuration = function () {\n    if (!wasStarted()) {\n      return;\n    }\n    if (endTime === null) {\n      endTime = performance.now();\n    }\n    return endTime - startTime;\n  };\n}\n\nmodule.exports = ExecutionTimer;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvbG9nZ2VyL2V4ZWN1dGlvbl90aW1lci5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLGNBQWMsRUFBRSxtQkFBTyxDQUFDLDhCQUFZO0FBQzVDLGVBQWUsbUJBQU8sQ0FBQyxtRUFBVztBQUNsQyxhQUFhLG1CQUFPLENBQUMsK0RBQVM7O0FBRTlCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL2xvZ2dlci9leGVjdXRpb25fdGltZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgeyBwZXJmb3JtYW5jZSB9ID0gcmVxdWlyZSgncGVyZl9ob29rcycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5mdW5jdGlvbiBFeGVjdXRpb25UaW1lcigpIHtcbiAgbGV0IHN0YXJ0VGltZSA9IG51bGw7XG4gIGxldCBlbmRUaW1lID0gbnVsbDtcblxuICAvLyBQcml2YXRlIGZ1bmN0aW9uIHRvIGxvZyBhbmQgY2hlY2sgaWYgdGhlIHRpbWVyIHdhcyBzdGFydGVkXG4gIGZ1bmN0aW9uIHdhc1N0YXJ0ZWQoKSB7XG4gICAgcmV0dXJuIFV0aWwuZXhpc3RzKHN0YXJ0VGltZSk7XG5cbiAgfVxuXG4gIHRoaXMuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgc3RhcnRUaW1lID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgZW5kVGltZSA9IG51bGw7IC8vIFJlc2V0IGVuZFRpbWUgaWYgdGhlIHRpbWVyIGlzIHJldXNlZFxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG5cbiAgdGhpcy5zdG9wID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghd2FzU3RhcnRlZCgpKSB7XG4gICAgICAvLyBSZXR1cm5pbmcgdGhpcyB0byBhbGxvdyBjaGFpbmluZyBldmVuIGFmdGVyIGludmFsaWQgY2FsbC5cbiAgICAgIC8vIHN0YXJ0VGltZSBjYW4gYmUgdXNlZCB0byBjaGVjaywgaWYgYW55IHN0YXJ0IHBvaW50IHdhcyBldmVyIHJlY29yZGVkLlxuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1RyaWVkIHRvIHN0b3AgdGltZXIsIHRoYXQgd2FzIG5vdCBzdGFydGVkJyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW5kVGltZSA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgZHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzXG4gIHRoaXMuZ2V0RHVyYXRpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF3YXNTdGFydGVkKCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVuZFRpbWUgPT09IG51bGwpIHtcbiAgICAgIGVuZFRpbWUgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuZFRpbWUgLSBzdGFydFRpbWU7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXhlY3V0aW9uVGltZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/logger/execution_timer.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/logger/logging_util.js":
/*!***************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/logger/logging_util.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\n\nconst PROVIDED_TEXT = 'provided';\nconst NOT_PROVIDED_TEXT = 'not provided';\n\n/**\n * Describes the presence of a given value. If the value is not empty (as a string),\n * returns the corresponding text (by default: 'provided' or 'not provided').\n *\n * @param {*} valueToDescribe - The value to check for presence.\n * @param {Object} [options] - Optional overrides for the \"provided\" and \"not provided\" text.\n * @param {string} [options.overrideProvidedText]\n * @param {string} [options.overrideNotProvidedText]\n * @returns {string} A string indicating the presence of `valueToDescribe`.\n */\nexports.describePresence = function (valueToDescribe, { overrideProvidedText, overrideNotProvidedText } = {}) {\n  const providedText = overrideProvidedText || PROVIDED_TEXT;\n  const notProvidedText = overrideNotProvidedText || NOT_PROVIDED_TEXT;\n  return Util.isNotEmptyAsString(valueToDescribe) ? providedText : notProvidedText;\n};\n\n/**\n * @param {Object} sourceObject - The object holding attribute values.\n * @param {Array<string>} attributesWithValues - Attributes to show with their values.\n * @param {Array<string>} attributesWithoutValues - Attributes to show as present/not present.\n * @returns {string} Comma-separated string describing the attributes.\n */\nexports.attributesToString = function (\n  sourceObject = {},\n  attributesWithValues = [],\n  attributesWithoutValues = []\n) {\n  const withValues = attributesWithValues\n    .filter(attr => sourceObject[attr] !== undefined)\n    .map(attr => `${attr}=${String(sourceObject[attr])}`);\n\n  const withoutValues = attributesWithoutValues\n    .filter(attr => sourceObject[attr] !== undefined)\n    .map(attr => `${attr} is ${exports.describePresence(sourceObject[attr])}`);\n\n  return [...withValues, ...withoutValues].join(', ');\n};\n\n/**\n * @param {Object} sourceObject - The object holding attribute values.\n * @param {Array<string>} attributesWithValues - Attributes to show with their values.\n * @param {Array<string>} attributesWithoutValues - Attributes to show as present/not present.\n * @returns {string} A bracketed string of described attributes.\n */\nexports.describeAttributes = function (\n  sourceObject,\n  attributesWithValues,\n  attributesWithoutValues\n) {\n  const attributesDescription = exports.attributesToString(\n    sourceObject,\n    attributesWithValues,\n    attributesWithoutValues\n  );\n  return `[${attributesDescription}]`;\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvbG9nZ2VyL2xvZ2dpbmdfdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsK0RBQVM7O0FBRTlCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQSx3QkFBd0IsZ0NBQWdDLGdEQUFnRCxJQUFJO0FBQzVHO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsZUFBZTtBQUMxQixXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsMEJBQTBCO0FBQzFCLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLEtBQUssR0FBRywyQkFBMkI7O0FBRXZEO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTSxLQUFLLDZDQUE2Qzs7QUFFNUU7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLGVBQWU7QUFDMUIsV0FBVyxlQUFlO0FBQzFCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNCQUFzQjtBQUNuQyIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9sb2dnZXIvbG9nZ2luZ191dGlsLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbmNvbnN0IFBST1ZJREVEX1RFWFQgPSAncHJvdmlkZWQnO1xuY29uc3QgTk9UX1BST1ZJREVEX1RFWFQgPSAnbm90IHByb3ZpZGVkJztcblxuLyoqXG4gKiBEZXNjcmliZXMgdGhlIHByZXNlbmNlIG9mIGEgZ2l2ZW4gdmFsdWUuIElmIHRoZSB2YWx1ZSBpcyBub3QgZW1wdHkgKGFzIGEgc3RyaW5nKSxcbiAqIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgdGV4dCAoYnkgZGVmYXVsdDogJ3Byb3ZpZGVkJyBvciAnbm90IHByb3ZpZGVkJykuXG4gKlxuICogQHBhcmFtIHsqfSB2YWx1ZVRvRGVzY3JpYmUgLSBUaGUgdmFsdWUgdG8gY2hlY2sgZm9yIHByZXNlbmNlLlxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbmFsIG92ZXJyaWRlcyBmb3IgdGhlIFwicHJvdmlkZWRcIiBhbmQgXCJub3QgcHJvdmlkZWRcIiB0ZXh0LlxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm92ZXJyaWRlUHJvdmlkZWRUZXh0XVxuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm92ZXJyaWRlTm90UHJvdmlkZWRUZXh0XVxuICogQHJldHVybnMge3N0cmluZ30gQSBzdHJpbmcgaW5kaWNhdGluZyB0aGUgcHJlc2VuY2Ugb2YgYHZhbHVlVG9EZXNjcmliZWAuXG4gKi9cbmV4cG9ydHMuZGVzY3JpYmVQcmVzZW5jZSA9IGZ1bmN0aW9uICh2YWx1ZVRvRGVzY3JpYmUsIHsgb3ZlcnJpZGVQcm92aWRlZFRleHQsIG92ZXJyaWRlTm90UHJvdmlkZWRUZXh0IH0gPSB7fSkge1xuICBjb25zdCBwcm92aWRlZFRleHQgPSBvdmVycmlkZVByb3ZpZGVkVGV4dCB8fCBQUk9WSURFRF9URVhUO1xuICBjb25zdCBub3RQcm92aWRlZFRleHQgPSBvdmVycmlkZU5vdFByb3ZpZGVkVGV4dCB8fCBOT1RfUFJPVklERURfVEVYVDtcbiAgcmV0dXJuIFV0aWwuaXNOb3RFbXB0eUFzU3RyaW5nKHZhbHVlVG9EZXNjcmliZSkgPyBwcm92aWRlZFRleHQgOiBub3RQcm92aWRlZFRleHQ7XG59O1xuXG4vKipcbiAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2VPYmplY3QgLSBUaGUgb2JqZWN0IGhvbGRpbmcgYXR0cmlidXRlIHZhbHVlcy5cbiAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gYXR0cmlidXRlc1dpdGhWYWx1ZXMgLSBBdHRyaWJ1dGVzIHRvIHNob3cgd2l0aCB0aGVpciB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF0dHJpYnV0ZXNXaXRob3V0VmFsdWVzIC0gQXR0cmlidXRlcyB0byBzaG93IGFzIHByZXNlbnQvbm90IHByZXNlbnQuXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBDb21tYS1zZXBhcmF0ZWQgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGF0dHJpYnV0ZXMuXG4gKi9cbmV4cG9ydHMuYXR0cmlidXRlc1RvU3RyaW5nID0gZnVuY3Rpb24gKFxuICBzb3VyY2VPYmplY3QgPSB7fSxcbiAgYXR0cmlidXRlc1dpdGhWYWx1ZXMgPSBbXSxcbiAgYXR0cmlidXRlc1dpdGhvdXRWYWx1ZXMgPSBbXVxuKSB7XG4gIGNvbnN0IHdpdGhWYWx1ZXMgPSBhdHRyaWJ1dGVzV2l0aFZhbHVlc1xuICAgIC5maWx0ZXIoYXR0ciA9PiBzb3VyY2VPYmplY3RbYXR0cl0gIT09IHVuZGVmaW5lZClcbiAgICAubWFwKGF0dHIgPT4gYCR7YXR0cn09JHtTdHJpbmcoc291cmNlT2JqZWN0W2F0dHJdKX1gKTtcblxuICBjb25zdCB3aXRob3V0VmFsdWVzID0gYXR0cmlidXRlc1dpdGhvdXRWYWx1ZXNcbiAgICAuZmlsdGVyKGF0dHIgPT4gc291cmNlT2JqZWN0W2F0dHJdICE9PSB1bmRlZmluZWQpXG4gICAgLm1hcChhdHRyID0+IGAke2F0dHJ9IGlzICR7ZXhwb3J0cy5kZXNjcmliZVByZXNlbmNlKHNvdXJjZU9iamVjdFthdHRyXSl9YCk7XG5cbiAgcmV0dXJuIFsuLi53aXRoVmFsdWVzLCAuLi53aXRob3V0VmFsdWVzXS5qb2luKCcsICcpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0ge09iamVjdH0gc291cmNlT2JqZWN0IC0gVGhlIG9iamVjdCBob2xkaW5nIGF0dHJpYnV0ZSB2YWx1ZXMuXG4gKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IGF0dHJpYnV0ZXNXaXRoVmFsdWVzIC0gQXR0cmlidXRlcyB0byBzaG93IHdpdGggdGhlaXIgdmFsdWVzLlxuICogQHBhcmFtIHtBcnJheTxzdHJpbmc+fSBhdHRyaWJ1dGVzV2l0aG91dFZhbHVlcyAtIEF0dHJpYnV0ZXMgdG8gc2hvdyBhcyBwcmVzZW50L25vdCBwcmVzZW50LlxuICogQHJldHVybnMge3N0cmluZ30gQSBicmFja2V0ZWQgc3RyaW5nIG9mIGRlc2NyaWJlZCBhdHRyaWJ1dGVzLlxuICovXG5leHBvcnRzLmRlc2NyaWJlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChcbiAgc291cmNlT2JqZWN0LFxuICBhdHRyaWJ1dGVzV2l0aFZhbHVlcyxcbiAgYXR0cmlidXRlc1dpdGhvdXRWYWx1ZXNcbikge1xuICBjb25zdCBhdHRyaWJ1dGVzRGVzY3JpcHRpb24gPSBleHBvcnRzLmF0dHJpYnV0ZXNUb1N0cmluZyhcbiAgICBzb3VyY2VPYmplY3QsXG4gICAgYXR0cmlidXRlc1dpdGhWYWx1ZXMsXG4gICAgYXR0cmlidXRlc1dpdGhvdXRWYWx1ZXNcbiAgKTtcbiAgcmV0dXJuIGBbJHthdHRyaWJ1dGVzRGVzY3JpcHRpb259XWA7XG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/logger/logging_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/logger/node.js":
/*!*******************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/logger/node.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const winston = __webpack_require__(/*! winston */ \"(rsc)/./node_modules/winston/lib/winston.js\");\nconst Core = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger/core.js\");\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\n\nconst DEFAULT_ADDITIONAL_LOG_TO_CONSOLE = true;\n\n/**\n * Creates a new Logger instance for when we're running in node.\n *\n * @param {Object} [options]\n *\n * @constructor\n */\nfunction Logger(options) {\n  let winstonLogger;\n  const defaultFilePath = 'snowflake.log';\n  let filePath = getFilePath(options);\n  let additionalLogToConsole = DEFAULT_ADDITIONAL_LOG_TO_CONSOLE;\n  let transportLabels = [];\n\n  this.setLogger = function (logger) {\n    winstonLogger = logger;\n  };\n\n  /**\n   * This operation is for purpose of tests only. The idea is to force flushing logs to files.\n   * Winston logger emits 'finish' event before flushes all the transports so waiting for this event on logger is not good enough.\n   * For simplicity, we just close each transport without waiting here.\n   */\n  this.closeTransports = function () {\n    if (transportsCreated()) {\n      for (const transport of winstonLogger.transports) {\n        closeTransport(transport);\n      }\n    }\n  };\n\n  function transportsCreated() {\n    try {\n      winstonLogger.transports;\n      return true;\n    } catch (err) {\n      return false;\n    }\n  }\n\n  function closeTransport(transport) {\n    if (!transport.close) {\n      return;\n    }\n    transport.close();\n  }\n\n  function reconfigureWinstonLogger(filePathInput, additionalLogToConsoleInput) {\n    const currentWinstonLogger = winstonLogger;\n    filePath = filePathInput ?? filePath;\n    if (Util.isBoolean(additionalLogToConsoleInput)) {\n      additionalLogToConsole = additionalLogToConsoleInput;\n    } else {\n      additionalLogToConsole = DEFAULT_ADDITIONAL_LOG_TO_CONSOLE;\n    }\n    winstonLogger = null; // it will be created for the first log operation\n    if (currentWinstonLogger) {\n      currentWinstonLogger.close();\n    }\n  }\n\n  function setTransportLabels(transportLabelsInput) {\n    transportLabels = transportLabelsInput;\n  }\n\n  this.getTransportLabels = function () {\n    return transportLabels;\n  };\n\n  /**\n   * Logs a message at a given level.\n   *\n   * @param {String} levelTag the tag associated with the level at which to log\n   *   the message.\n   * @param {String} message the message to log.\n   */\n  const logMessage = function (levelTag, message) {\n    // initialize the winston logger if needed\n    if (!winstonLogger) {\n      let transports;\n      let transportLabels;\n\n      if ('STDOUT' === filePath.toUpperCase()) {\n        transports = [new (winston.transports.Console)()];\n        transportLabels = ['Console'];\n      } else if (additionalLogToConsole === true) {\n        transports = [new (winston.transports.Console)(), new (winston.transports.File)({ filename: filePath })];\n        transportLabels = ['Console', 'File'];\n      } else {\n        transports = [new (winston.transports.File)({ filename: filePath })];\n        transportLabels = ['File'];\n      }\n\n      winstonLogger = new winston.createLogger(\n        {\n          transports: transports,\n          level: common.getLevelTag(),\n          levels: common.getLevelTagsMap()\n        });\n      setTransportLabels(transportLabels);\n    }\n\n    // get the appropriate logging method using the level tag and use this\n    // method to log the message\n    winstonLogger[levelTag](message);\n  };\n\n  // create an inner implementation to which all our methods will be forwarded\n  const common = Core.createLogger(options, logMessage, reconfigureWinstonLogger);\n\n  function getFilePath(options) {\n    if (Util.exists(options)) {\n      Errors.assertInternal(Util.isObject(options));\n      return options.filePath ?? defaultFilePath;\n    }\n    return defaultFilePath;\n  }\n\n  this.getLevelTag = function () {\n    return common.getLevelTag();\n  };\n\n  this.getLevelTagsMap = function () {\n    return common.getLevelTagsMap();\n  };\n\n  /**\n   * Configures this logger.\n   *\n   * @param {Object} options\n   */\n  this.configure = function (options) {\n    if (Util.isBoolean(options.additionalLogToConsole)) {\n      additionalLogToConsole = options.additionalLogToConsole;\n    } else {\n      additionalLogToConsole = DEFAULT_ADDITIONAL_LOG_TO_CONSOLE;\n    }\n    common.configure(options);\n  };\n\n  /**\n   * Returns the current log level.\n   *\n   * @returns {Number}\n   */\n  this.getLevel = function () {\n    return common.getLevelNumber();\n  };\n\n  /**\n   * Logs a given message at the error level.\n   *\n   * @param {String} message\n   * @param params\n   */\n  this.error = function (message, ...params) {\n    common.error.apply(common, [message, ...params]);\n  };\n\n  /**\n   * Logs a given message at the warning level.\n   *\n   * @param {String} message\n   * @param params\n   */\n  this.warn = function (message, ...params) {\n    common.warn.apply(common, [message, ...params]);\n  };\n\n  /**\n   * Logs a given message at the info level.\n   *\n   * @param {String} message\n   * @param params\n   */\n  this.info = function (message, ...params) {\n    common.info.apply(common, [message, ...params]);\n  };\n\n  /**\n   * Logs a given message at the debug level.\n   *\n   * @param {String} message\n   * @param params\n   */\n  this.debug = function (message, ...params) {\n    common.debug.apply(common, [message, ...params]);\n  };\n\n  /**\n   * Logs a given message at the trace level.\n   *\n   * @param {String} message\n   * @param params\n   */\n  this.trace = function (message, ...params) {\n    common.trace.apply(common, [message, ...params]);\n  };\n\n  /**\n   * Returns the log buffer.\n   *\n   * @returns {String[]}\n   */\n  this.getLogBuffer = function () {\n    return common.getLogBuffer();\n  };\n}\n\nmodule.exports = Logger;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvbG9nZ2VyL25vZGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsZ0JBQWdCLG1CQUFPLENBQUMsNERBQVM7QUFDakMsYUFBYSxtQkFBTyxDQUFDLHFFQUFRO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQywrREFBUztBQUM5QixlQUFlLG1CQUFPLENBQUMsbUVBQVc7O0FBRWxDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLDBGQUEwRixvQkFBb0I7QUFDOUc7QUFDQSxRQUFRO0FBQ1Isc0RBQXNELG9CQUFvQjtBQUMxRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9sb2dnZXIvbm9kZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB3aW5zdG9uID0gcmVxdWlyZSgnd2luc3RvbicpO1xuY29uc3QgQ29yZSA9IHJlcXVpcmUoJy4vY29yZScpO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuXG5jb25zdCBERUZBVUxUX0FERElUSU9OQUxfTE9HX1RPX0NPTlNPTEUgPSB0cnVlO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgTG9nZ2VyIGluc3RhbmNlIGZvciB3aGVuIHdlJ3JlIHJ1bm5pbmcgaW4gbm9kZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIExvZ2dlcihvcHRpb25zKSB7XG4gIGxldCB3aW5zdG9uTG9nZ2VyO1xuICBjb25zdCBkZWZhdWx0RmlsZVBhdGggPSAnc25vd2ZsYWtlLmxvZyc7XG4gIGxldCBmaWxlUGF0aCA9IGdldEZpbGVQYXRoKG9wdGlvbnMpO1xuICBsZXQgYWRkaXRpb25hbExvZ1RvQ29uc29sZSA9IERFRkFVTFRfQURESVRJT05BTF9MT0dfVE9fQ09OU09MRTtcbiAgbGV0IHRyYW5zcG9ydExhYmVscyA9IFtdO1xuXG4gIHRoaXMuc2V0TG9nZ2VyID0gZnVuY3Rpb24gKGxvZ2dlcikge1xuICAgIHdpbnN0b25Mb2dnZXIgPSBsb2dnZXI7XG4gIH07XG5cbiAgLyoqXG4gICAqIFRoaXMgb3BlcmF0aW9uIGlzIGZvciBwdXJwb3NlIG9mIHRlc3RzIG9ubHkuIFRoZSBpZGVhIGlzIHRvIGZvcmNlIGZsdXNoaW5nIGxvZ3MgdG8gZmlsZXMuXG4gICAqIFdpbnN0b24gbG9nZ2VyIGVtaXRzICdmaW5pc2gnIGV2ZW50IGJlZm9yZSBmbHVzaGVzIGFsbCB0aGUgdHJhbnNwb3J0cyBzbyB3YWl0aW5nIGZvciB0aGlzIGV2ZW50IG9uIGxvZ2dlciBpcyBub3QgZ29vZCBlbm91Z2guXG4gICAqIEZvciBzaW1wbGljaXR5LCB3ZSBqdXN0IGNsb3NlIGVhY2ggdHJhbnNwb3J0IHdpdGhvdXQgd2FpdGluZyBoZXJlLlxuICAgKi9cbiAgdGhpcy5jbG9zZVRyYW5zcG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRyYW5zcG9ydHNDcmVhdGVkKCkpIHtcbiAgICAgIGZvciAoY29uc3QgdHJhbnNwb3J0IG9mIHdpbnN0b25Mb2dnZXIudHJhbnNwb3J0cykge1xuICAgICAgICBjbG9zZVRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiB0cmFuc3BvcnRzQ3JlYXRlZCgpIHtcbiAgICB0cnkge1xuICAgICAgd2luc3RvbkxvZ2dlci50cmFuc3BvcnRzO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gY2xvc2VUcmFuc3BvcnQodHJhbnNwb3J0KSB7XG4gICAgaWYgKCF0cmFuc3BvcnQuY2xvc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gIH1cblxuICBmdW5jdGlvbiByZWNvbmZpZ3VyZVdpbnN0b25Mb2dnZXIoZmlsZVBhdGhJbnB1dCwgYWRkaXRpb25hbExvZ1RvQ29uc29sZUlucHV0KSB7XG4gICAgY29uc3QgY3VycmVudFdpbnN0b25Mb2dnZXIgPSB3aW5zdG9uTG9nZ2VyO1xuICAgIGZpbGVQYXRoID0gZmlsZVBhdGhJbnB1dCA/PyBmaWxlUGF0aDtcbiAgICBpZiAoVXRpbC5pc0Jvb2xlYW4oYWRkaXRpb25hbExvZ1RvQ29uc29sZUlucHV0KSkge1xuICAgICAgYWRkaXRpb25hbExvZ1RvQ29uc29sZSA9IGFkZGl0aW9uYWxMb2dUb0NvbnNvbGVJbnB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkaXRpb25hbExvZ1RvQ29uc29sZSA9IERFRkFVTFRfQURESVRJT05BTF9MT0dfVE9fQ09OU09MRTtcbiAgICB9XG4gICAgd2luc3RvbkxvZ2dlciA9IG51bGw7IC8vIGl0IHdpbGwgYmUgY3JlYXRlZCBmb3IgdGhlIGZpcnN0IGxvZyBvcGVyYXRpb25cbiAgICBpZiAoY3VycmVudFdpbnN0b25Mb2dnZXIpIHtcbiAgICAgIGN1cnJlbnRXaW5zdG9uTG9nZ2VyLmNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gc2V0VHJhbnNwb3J0TGFiZWxzKHRyYW5zcG9ydExhYmVsc0lucHV0KSB7XG4gICAgdHJhbnNwb3J0TGFiZWxzID0gdHJhbnNwb3J0TGFiZWxzSW5wdXQ7XG4gIH1cblxuICB0aGlzLmdldFRyYW5zcG9ydExhYmVscyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdHJhbnNwb3J0TGFiZWxzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBMb2dzIGEgbWVzc2FnZSBhdCBhIGdpdmVuIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbGV2ZWxUYWcgdGhlIHRhZyBhc3NvY2lhdGVkIHdpdGggdGhlIGxldmVsIGF0IHdoaWNoIHRvIGxvZ1xuICAgKiAgIHRoZSBtZXNzYWdlLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSB0aGUgbWVzc2FnZSB0byBsb2cuXG4gICAqL1xuICBjb25zdCBsb2dNZXNzYWdlID0gZnVuY3Rpb24gKGxldmVsVGFnLCBtZXNzYWdlKSB7XG4gICAgLy8gaW5pdGlhbGl6ZSB0aGUgd2luc3RvbiBsb2dnZXIgaWYgbmVlZGVkXG4gICAgaWYgKCF3aW5zdG9uTG9nZ2VyKSB7XG4gICAgICBsZXQgdHJhbnNwb3J0cztcbiAgICAgIGxldCB0cmFuc3BvcnRMYWJlbHM7XG5cbiAgICAgIGlmICgnU1RET1VUJyA9PT0gZmlsZVBhdGgudG9VcHBlckNhc2UoKSkge1xuICAgICAgICB0cmFuc3BvcnRzID0gW25ldyAod2luc3Rvbi50cmFuc3BvcnRzLkNvbnNvbGUpKCldO1xuICAgICAgICB0cmFuc3BvcnRMYWJlbHMgPSBbJ0NvbnNvbGUnXTtcbiAgICAgIH0gZWxzZSBpZiAoYWRkaXRpb25hbExvZ1RvQ29uc29sZSA9PT0gdHJ1ZSkge1xuICAgICAgICB0cmFuc3BvcnRzID0gW25ldyAod2luc3Rvbi50cmFuc3BvcnRzLkNvbnNvbGUpKCksIG5ldyAod2luc3Rvbi50cmFuc3BvcnRzLkZpbGUpKHsgZmlsZW5hbWU6IGZpbGVQYXRoIH0pXTtcbiAgICAgICAgdHJhbnNwb3J0TGFiZWxzID0gWydDb25zb2xlJywgJ0ZpbGUnXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYW5zcG9ydHMgPSBbbmV3ICh3aW5zdG9uLnRyYW5zcG9ydHMuRmlsZSkoeyBmaWxlbmFtZTogZmlsZVBhdGggfSldO1xuICAgICAgICB0cmFuc3BvcnRMYWJlbHMgPSBbJ0ZpbGUnXTtcbiAgICAgIH1cblxuICAgICAgd2luc3RvbkxvZ2dlciA9IG5ldyB3aW5zdG9uLmNyZWF0ZUxvZ2dlcihcbiAgICAgICAge1xuICAgICAgICAgIHRyYW5zcG9ydHM6IHRyYW5zcG9ydHMsXG4gICAgICAgICAgbGV2ZWw6IGNvbW1vbi5nZXRMZXZlbFRhZygpLFxuICAgICAgICAgIGxldmVsczogY29tbW9uLmdldExldmVsVGFnc01hcCgpXG4gICAgICAgIH0pO1xuICAgICAgc2V0VHJhbnNwb3J0TGFiZWxzKHRyYW5zcG9ydExhYmVscyk7XG4gICAgfVxuXG4gICAgLy8gZ2V0IHRoZSBhcHByb3ByaWF0ZSBsb2dnaW5nIG1ldGhvZCB1c2luZyB0aGUgbGV2ZWwgdGFnIGFuZCB1c2UgdGhpc1xuICAgIC8vIG1ldGhvZCB0byBsb2cgdGhlIG1lc3NhZ2VcbiAgICB3aW5zdG9uTG9nZ2VyW2xldmVsVGFnXShtZXNzYWdlKTtcbiAgfTtcblxuICAvLyBjcmVhdGUgYW4gaW5uZXIgaW1wbGVtZW50YXRpb24gdG8gd2hpY2ggYWxsIG91ciBtZXRob2RzIHdpbGwgYmUgZm9yd2FyZGVkXG4gIGNvbnN0IGNvbW1vbiA9IENvcmUuY3JlYXRlTG9nZ2VyKG9wdGlvbnMsIGxvZ01lc3NhZ2UsIHJlY29uZmlndXJlV2luc3RvbkxvZ2dlcik7XG5cbiAgZnVuY3Rpb24gZ2V0RmlsZVBhdGgob3B0aW9ucykge1xuICAgIGlmIChVdGlsLmV4aXN0cyhvcHRpb25zKSkge1xuICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucykpO1xuICAgICAgcmV0dXJuIG9wdGlvbnMuZmlsZVBhdGggPz8gZGVmYXVsdEZpbGVQYXRoO1xuICAgIH1cbiAgICByZXR1cm4gZGVmYXVsdEZpbGVQYXRoO1xuICB9XG5cbiAgdGhpcy5nZXRMZXZlbFRhZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gY29tbW9uLmdldExldmVsVGFnKCk7XG4gIH07XG5cbiAgdGhpcy5nZXRMZXZlbFRhZ3NNYXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbW1vbi5nZXRMZXZlbFRhZ3NNYXAoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ29uZmlndXJlcyB0aGlzIGxvZ2dlci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIHRoaXMuY29uZmlndXJlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBpZiAoVXRpbC5pc0Jvb2xlYW4ob3B0aW9ucy5hZGRpdGlvbmFsTG9nVG9Db25zb2xlKSkge1xuICAgICAgYWRkaXRpb25hbExvZ1RvQ29uc29sZSA9IG9wdGlvbnMuYWRkaXRpb25hbExvZ1RvQ29uc29sZTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWRkaXRpb25hbExvZ1RvQ29uc29sZSA9IERFRkFVTFRfQURESVRJT05BTF9MT0dfVE9fQ09OU09MRTtcbiAgICB9XG4gICAgY29tbW9uLmNvbmZpZ3VyZShvcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCBsb2cgbGV2ZWwuXG4gICAqXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9XG4gICAqL1xuICB0aGlzLmdldExldmVsID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjb21tb24uZ2V0TGV2ZWxOdW1iZXIoKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIGVycm9yIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICB0aGlzLmVycm9yID0gZnVuY3Rpb24gKG1lc3NhZ2UsIC4uLnBhcmFtcykge1xuICAgIGNvbW1vbi5lcnJvci5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIHdhcm5pbmcgbGV2ZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIHRoaXMud2FybiA9IGZ1bmN0aW9uIChtZXNzYWdlLCAuLi5wYXJhbXMpIHtcbiAgICBjb21tb24ud2Fybi5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIGluZm8gbGV2ZWwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlXG4gICAqIEBwYXJhbSBwYXJhbXNcbiAgICovXG4gIHRoaXMuaW5mbyA9IGZ1bmN0aW9uIChtZXNzYWdlLCAuLi5wYXJhbXMpIHtcbiAgICBjb21tb24uaW5mby5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIGRlYnVnIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICB0aGlzLmRlYnVnID0gZnVuY3Rpb24gKG1lc3NhZ2UsIC4uLnBhcmFtcykge1xuICAgIGNvbW1vbi5kZWJ1Zy5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgfTtcblxuICAvKipcbiAgICogTG9ncyBhIGdpdmVuIG1lc3NhZ2UgYXQgdGhlIHRyYWNlIGxldmVsLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZVxuICAgKiBAcGFyYW0gcGFyYW1zXG4gICAqL1xuICB0aGlzLnRyYWNlID0gZnVuY3Rpb24gKG1lc3NhZ2UsIC4uLnBhcmFtcykge1xuICAgIGNvbW1vbi50cmFjZS5hcHBseShjb21tb24sIFttZXNzYWdlLCAuLi5wYXJhbXNdKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbG9nIGJ1ZmZlci5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ1tdfVxuICAgKi9cbiAgdGhpcy5nZXRMb2dCdWZmZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGNvbW1vbi5nZXRMb2dCdWZmZXIoKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMb2dnZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/logger/node.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/parameters.js":
/*!******************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/parameters.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\n\n/**\n * Creates a new Parameter.\n *\n * @param {Object} options\n * @constructor\n */\nfunction Parameter(options) {\n  // validate input\n  Errors.assertInternal(Util.isObject(options));\n  Errors.assertInternal(Util.isString(options.name));\n  Errors.assertInternal(Util.exists(options.value));\n\n  const name = options.name;\n  let value = options.value;\n\n  /**\n   * Returns the name of the parameter.\n   *\n   * @returns {String}\n   */\n  this.getName = function () {\n    return name;\n  };\n\n  /**\n   * Returns the value of the parameter.\n   *\n   * @returns {*}\n   */\n  this.getValue = function () {\n    return value;\n  };\n\n  /**\n   * Updates the value of the parameter.\n   *\n   * @param {*} targetValue\n   */\n  this.setValue = function (targetValue) {\n    value = targetValue;\n  };\n}\n\nconst names = exports.names = {};\nnames.JS_DRIVER_DISABLE_OCSP_FOR_NON_SF_ENDPOINTS = 'JS_DRIVER_DISABLE_OCSP_FOR_NON_SF_ENDPOINTS';\nnames.SERVICE_NAME = 'SERVICE_NAME';\nnames.CLIENT_SESSION_KEEP_ALIVE = 'CLIENT_SESSION_KEEP_ALIVE';\nnames.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY = 'CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY';\nnames.JS_TREAT_INTEGER_AS_BIGINT = 'JS_TREAT_INTEGER_AS_BIGINT';\nnames.CLIENT_STAGE_ARRAY_BINDING_THRESHOLD = 'CLIENT_STAGE_ARRAY_BINDING_THRESHOLD';\nnames.MULTI_STATEMENT_COUNT = 'MULTI_STATEMENT_COUNT';\nnames.QUERY_CONTEXT_CACHE_SIZE = 'QUERY_CONTEXT_CACHE_SIZE';\n\nconst parameters =\n  [\n    new Parameter(\n      {\n        name: names.JS_DRIVER_DISABLE_OCSP_FOR_NON_SF_ENDPOINTS,\n        value: false,\n        desc: 'Whether to disable OCSP validation in the JavaScript driver ' +\n          'when communicating with non-Snowflake endpoints (e.g. S3/Blob).'\n      }),\n    new Parameter(\n      {\n        name: names.SERVICE_NAME,\n        value: '',\n        desc: 'Hint for load balancer.'\n      }),\n    new Parameter(\n      {\n        name: names.CLIENT_SESSION_KEEP_ALIVE,\n        value: false,\n        desc: 'When true, enables the driver to keep the session alive indefinitely'\n      }),\n    new Parameter(\n      {\n        name: names.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY,\n        value: 3600,\n        desc: 'The amount of time (in seconds) between subsequent heartbeat requests to the server.'\n      }),\n    new Parameter(\n      {\n        name: names.JS_TREAT_INTEGER_AS_BIGINT,\n        value: false,\n        desc: 'When true, enables the driver converts integer columns into BigInt'\n      }),\n    new Parameter(\n      {\n        name: names.CLIENT_STAGE_ARRAY_BINDING_THRESHOLD,\n        value: 100000,\n        desc: 'The client stage array binding threshold'\n      }),\n    new Parameter(\n      {\n        name: names.MULTI_STATEMENT_COUNT,\n        value: 1,\n        desc: 'When 1, multi statement is disable, when 0, multi statement is unlimited'\n      }),\n    new Parameter(\n      {\n        name: names.QUERY_CONTEXT_CACHE_SIZE,\n        value: 5,\n        desc: 'Query Context Cache Size'\n      }),\n  ];\n\n// put all the parameters in a map so they're easy to retrieve and update\nconst mapParamNameToParam = {};\nfor (let index = 0, length = parameters.length; index < length; index++) {\n  const parameter = parameters[index];\n  mapParamNameToParam[parameter.getName()] = parameter;\n}\n\n/**\n * Returns the value of a given parameter.\n *\n * @param {String} parameterName\n *\n * @returns {*}\n */\nexports.getValue = function (parameterName) {\n  // resolve the parameter name\n  const parameter = mapParamNameToParam[parameterName];\n\n  // verify that a valid parameter name was specified\n  Errors.assertInternal(\n    Util.exists(parameter), 'invalid parameter name: ' + parameterName);\n\n  return parameter.getValue();\n};\n\n/**\n * Updates the parameter values.\n *\n * @param {Object[]} parametersConfig\n */\nexports.update = function (parametersConfig) {\n  // if an input is specified\n  if (Util.exists(parametersConfig)) {\n    Errors.assertInternal(Util.isArray(parametersConfig));\n\n    // if any of the items in the configs array matches a known\n    // parameter, update the corresponding parameter's value\n    for (let index = 0, length = parametersConfig.length;\n      index < length; index++) {\n      const parameterConfig = parametersConfig[index];\n      if (Object.prototype.hasOwnProperty.call(mapParamNameToParam, parameterConfig.name)) {\n        const parameter = mapParamNameToParam[parameterConfig.name];\n        parameter.setValue(parameterConfig.value);\n      }\n    }\n  }\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvcGFyYW1ldGVycy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsOERBQVE7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLGtFQUFVOztBQUVqQztBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWMsYUFBYTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQjtBQUNoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9wYXJhbWV0ZXJzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IFV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4vZXJyb3JzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBQYXJhbWV0ZXIuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBQYXJhbWV0ZXIob3B0aW9ucykge1xuICAvLyB2YWxpZGF0ZSBpbnB1dFxuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChvcHRpb25zKSk7XG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzU3RyaW5nKG9wdGlvbnMubmFtZSkpO1xuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5leGlzdHMob3B0aW9ucy52YWx1ZSkpO1xuXG4gIGNvbnN0IG5hbWUgPSBvcHRpb25zLm5hbWU7XG4gIGxldCB2YWx1ZSA9IG9wdGlvbnMudmFsdWU7XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIG5hbWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHJldHVybnMge1N0cmluZ31cbiAgICovXG4gIHRoaXMuZ2V0TmFtZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbmFtZTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICB0aGlzLmdldFZhbHVlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvKipcbiAgICogVXBkYXRlcyB0aGUgdmFsdWUgb2YgdGhlIHBhcmFtZXRlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSB0YXJnZXRWYWx1ZVxuICAgKi9cbiAgdGhpcy5zZXRWYWx1ZSA9IGZ1bmN0aW9uICh0YXJnZXRWYWx1ZSkge1xuICAgIHZhbHVlID0gdGFyZ2V0VmFsdWU7XG4gIH07XG59XG5cbmNvbnN0IG5hbWVzID0gZXhwb3J0cy5uYW1lcyA9IHt9O1xubmFtZXMuSlNfRFJJVkVSX0RJU0FCTEVfT0NTUF9GT1JfTk9OX1NGX0VORFBPSU5UUyA9ICdKU19EUklWRVJfRElTQUJMRV9PQ1NQX0ZPUl9OT05fU0ZfRU5EUE9JTlRTJztcbm5hbWVzLlNFUlZJQ0VfTkFNRSA9ICdTRVJWSUNFX05BTUUnO1xubmFtZXMuQ0xJRU5UX1NFU1NJT05fS0VFUF9BTElWRSA9ICdDTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFJztcbm5hbWVzLkNMSUVOVF9TRVNTSU9OX0tFRVBfQUxJVkVfSEVBUlRCRUFUX0ZSRVFVRU5DWSA9ICdDTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFX0hFQVJUQkVBVF9GUkVRVUVOQ1knO1xubmFtZXMuSlNfVFJFQVRfSU5URUdFUl9BU19CSUdJTlQgPSAnSlNfVFJFQVRfSU5URUdFUl9BU19CSUdJTlQnO1xubmFtZXMuQ0xJRU5UX1NUQUdFX0FSUkFZX0JJTkRJTkdfVEhSRVNIT0xEID0gJ0NMSUVOVF9TVEFHRV9BUlJBWV9CSU5ESU5HX1RIUkVTSE9MRCc7XG5uYW1lcy5NVUxUSV9TVEFURU1FTlRfQ09VTlQgPSAnTVVMVElfU1RBVEVNRU5UX0NPVU5UJztcbm5hbWVzLlFVRVJZX0NPTlRFWFRfQ0FDSEVfU0laRSA9ICdRVUVSWV9DT05URVhUX0NBQ0hFX1NJWkUnO1xuXG5jb25zdCBwYXJhbWV0ZXJzID1cbiAgW1xuICAgIG5ldyBQYXJhbWV0ZXIoXG4gICAgICB7XG4gICAgICAgIG5hbWU6IG5hbWVzLkpTX0RSSVZFUl9ESVNBQkxFX09DU1BfRk9SX05PTl9TRl9FTkRQT0lOVFMsXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgZGVzYzogJ1doZXRoZXIgdG8gZGlzYWJsZSBPQ1NQIHZhbGlkYXRpb24gaW4gdGhlIEphdmFTY3JpcHQgZHJpdmVyICcgK1xuICAgICAgICAgICd3aGVuIGNvbW11bmljYXRpbmcgd2l0aCBub24tU25vd2ZsYWtlIGVuZHBvaW50cyAoZS5nLiBTMy9CbG9iKS4nXG4gICAgICB9KSxcbiAgICBuZXcgUGFyYW1ldGVyKFxuICAgICAge1xuICAgICAgICBuYW1lOiBuYW1lcy5TRVJWSUNFX05BTUUsXG4gICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgZGVzYzogJ0hpbnQgZm9yIGxvYWQgYmFsYW5jZXIuJ1xuICAgICAgfSksXG4gICAgbmV3IFBhcmFtZXRlcihcbiAgICAgIHtcbiAgICAgICAgbmFtZTogbmFtZXMuQ0xJRU5UX1NFU1NJT05fS0VFUF9BTElWRSxcbiAgICAgICAgdmFsdWU6IGZhbHNlLFxuICAgICAgICBkZXNjOiAnV2hlbiB0cnVlLCBlbmFibGVzIHRoZSBkcml2ZXIgdG8ga2VlcCB0aGUgc2Vzc2lvbiBhbGl2ZSBpbmRlZmluaXRlbHknXG4gICAgICB9KSxcbiAgICBuZXcgUGFyYW1ldGVyKFxuICAgICAge1xuICAgICAgICBuYW1lOiBuYW1lcy5DTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFX0hFQVJUQkVBVF9GUkVRVUVOQ1ksXG4gICAgICAgIHZhbHVlOiAzNjAwLFxuICAgICAgICBkZXNjOiAnVGhlIGFtb3VudCBvZiB0aW1lIChpbiBzZWNvbmRzKSBiZXR3ZWVuIHN1YnNlcXVlbnQgaGVhcnRiZWF0IHJlcXVlc3RzIHRvIHRoZSBzZXJ2ZXIuJ1xuICAgICAgfSksXG4gICAgbmV3IFBhcmFtZXRlcihcbiAgICAgIHtcbiAgICAgICAgbmFtZTogbmFtZXMuSlNfVFJFQVRfSU5URUdFUl9BU19CSUdJTlQsXG4gICAgICAgIHZhbHVlOiBmYWxzZSxcbiAgICAgICAgZGVzYzogJ1doZW4gdHJ1ZSwgZW5hYmxlcyB0aGUgZHJpdmVyIGNvbnZlcnRzIGludGVnZXIgY29sdW1ucyBpbnRvIEJpZ0ludCdcbiAgICAgIH0pLFxuICAgIG5ldyBQYXJhbWV0ZXIoXG4gICAgICB7XG4gICAgICAgIG5hbWU6IG5hbWVzLkNMSUVOVF9TVEFHRV9BUlJBWV9CSU5ESU5HX1RIUkVTSE9MRCxcbiAgICAgICAgdmFsdWU6IDEwMDAwMCxcbiAgICAgICAgZGVzYzogJ1RoZSBjbGllbnQgc3RhZ2UgYXJyYXkgYmluZGluZyB0aHJlc2hvbGQnXG4gICAgICB9KSxcbiAgICBuZXcgUGFyYW1ldGVyKFxuICAgICAge1xuICAgICAgICBuYW1lOiBuYW1lcy5NVUxUSV9TVEFURU1FTlRfQ09VTlQsXG4gICAgICAgIHZhbHVlOiAxLFxuICAgICAgICBkZXNjOiAnV2hlbiAxLCBtdWx0aSBzdGF0ZW1lbnQgaXMgZGlzYWJsZSwgd2hlbiAwLCBtdWx0aSBzdGF0ZW1lbnQgaXMgdW5saW1pdGVkJ1xuICAgICAgfSksXG4gICAgbmV3IFBhcmFtZXRlcihcbiAgICAgIHtcbiAgICAgICAgbmFtZTogbmFtZXMuUVVFUllfQ09OVEVYVF9DQUNIRV9TSVpFLFxuICAgICAgICB2YWx1ZTogNSxcbiAgICAgICAgZGVzYzogJ1F1ZXJ5IENvbnRleHQgQ2FjaGUgU2l6ZSdcbiAgICAgIH0pLFxuICBdO1xuXG4vLyBwdXQgYWxsIHRoZSBwYXJhbWV0ZXJzIGluIGEgbWFwIHNvIHRoZXkncmUgZWFzeSB0byByZXRyaWV2ZSBhbmQgdXBkYXRlXG5jb25zdCBtYXBQYXJhbU5hbWVUb1BhcmFtID0ge307XG5mb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IHBhcmFtZXRlcnMubGVuZ3RoOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICBjb25zdCBwYXJhbWV0ZXIgPSBwYXJhbWV0ZXJzW2luZGV4XTtcbiAgbWFwUGFyYW1OYW1lVG9QYXJhbVtwYXJhbWV0ZXIuZ2V0TmFtZSgpXSA9IHBhcmFtZXRlcjtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB2YWx1ZSBvZiBhIGdpdmVuIHBhcmFtZXRlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1ldGVyTmFtZVxuICpcbiAqIEByZXR1cm5zIHsqfVxuICovXG5leHBvcnRzLmdldFZhbHVlID0gZnVuY3Rpb24gKHBhcmFtZXRlck5hbWUpIHtcbiAgLy8gcmVzb2x2ZSB0aGUgcGFyYW1ldGVyIG5hbWVcbiAgY29uc3QgcGFyYW1ldGVyID0gbWFwUGFyYW1OYW1lVG9QYXJhbVtwYXJhbWV0ZXJOYW1lXTtcblxuICAvLyB2ZXJpZnkgdGhhdCBhIHZhbGlkIHBhcmFtZXRlciBuYW1lIHdhcyBzcGVjaWZpZWRcbiAgRXJyb3JzLmFzc2VydEludGVybmFsKFxuICAgIFV0aWwuZXhpc3RzKHBhcmFtZXRlciksICdpbnZhbGlkIHBhcmFtZXRlciBuYW1lOiAnICsgcGFyYW1ldGVyTmFtZSk7XG5cbiAgcmV0dXJuIHBhcmFtZXRlci5nZXRWYWx1ZSgpO1xufTtcblxuLyoqXG4gKiBVcGRhdGVzIHRoZSBwYXJhbWV0ZXIgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0W119IHBhcmFtZXRlcnNDb25maWdcbiAqL1xuZXhwb3J0cy51cGRhdGUgPSBmdW5jdGlvbiAocGFyYW1ldGVyc0NvbmZpZykge1xuICAvLyBpZiBhbiBpbnB1dCBpcyBzcGVjaWZpZWRcbiAgaWYgKFV0aWwuZXhpc3RzKHBhcmFtZXRlcnNDb25maWcpKSB7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNBcnJheShwYXJhbWV0ZXJzQ29uZmlnKSk7XG5cbiAgICAvLyBpZiBhbnkgb2YgdGhlIGl0ZW1zIGluIHRoZSBjb25maWdzIGFycmF5IG1hdGNoZXMgYSBrbm93blxuICAgIC8vIHBhcmFtZXRlciwgdXBkYXRlIHRoZSBjb3JyZXNwb25kaW5nIHBhcmFtZXRlcidzIHZhbHVlXG4gICAgZm9yIChsZXQgaW5kZXggPSAwLCBsZW5ndGggPSBwYXJhbWV0ZXJzQ29uZmlnLmxlbmd0aDtcbiAgICAgIGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICBjb25zdCBwYXJhbWV0ZXJDb25maWcgPSBwYXJhbWV0ZXJzQ29uZmlnW2luZGV4XTtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobWFwUGFyYW1OYW1lVG9QYXJhbSwgcGFyYW1ldGVyQ29uZmlnLm5hbWUpKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlciA9IG1hcFBhcmFtTmFtZVRvUGFyYW1bcGFyYW1ldGVyQ29uZmlnLm5hbWVdO1xuICAgICAgICBwYXJhbWV0ZXIuc2V0VmFsdWUocGFyYW1ldGVyQ29uZmlnLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/parameters.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/proxy_util.js":
/*!******************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/proxy_util.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst GlobalConfig = __webpack_require__(/*! ./global_config */ \"(rsc)/./node_modules/snowflake-sdk/lib/global_config.js\");\nconst LoggingUtil = __webpack_require__(/*! ./logger/logging_util */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger/logging_util.js\");\nconst ErrorCodes = Errors.codes;\n\n/**\n * @typedef {object} Proxy\n * @property {string} host - The host address of the proxy.\n * @property {string} protocol - The protocol used by the proxy (e.g., \"http\" or \"https\")\n * @property {string} user - The username for the proxy\n * @property {number} port - The port number.\n * @property {string} password - The password for the proxy\n * @property {string} noProxy -  Optional list of domains that should bypass the prox\n */\n\n/**\n* remove http:// or https:// from the input, e.g. used with proxy URL\n* @param input\n* @returns {string}\n*/\nexports.removeScheme = function (input) {\n  return input.toString().replace(/(^\\w+:|^)\\/\\//, '');\n};\n\n/**\n * Try to get the PROXY environmental variables\n * On Windows, envvar name is case-insensitive, but on *nix, it's case-sensitive\n *\n * Compare them with the proxy specified on the Connection, if any\n * Return with the log constructed from the components detection and comparison\n * If there's something to warn the user about, return that too\n *\n * @param {Proxy} agentOptions from agent creation\n * @returns {{messages: string, warnings: string}} log messages\n */\nexports.getCompareAndLogEnvAndAgentProxies = function (agentOptions) {\n  const envProxy = {};\n  const logMessages = { 'messages': '', 'warnings': '' };\n  envProxy.httpProxy = process.env.http_proxy || process.env.HTTP_PROXY;\n  envProxy.httpsProxy = process.env.https_proxy || process.env.HTTPS_PROXY;\n  envProxy.noProxy = process.env.no_proxy || process.env.NO_PROXY;\n  \n  envProxy.logHttpProxy = envProxy.httpProxy ?\n    'HTTP_PROXY: ' + envProxy.httpProxy : 'HTTP_PROXY: <unset>';\n  envProxy.logHttpsProxy = envProxy.httpsProxy ?\n    'HTTPS_PROXY: ' + envProxy.httpsProxy : 'HTTPS_PROXY: <unset>';\n  envProxy.logNoProxy = envProxy.noProxy ?\n    'NO_PROXY: ' + envProxy.noProxy : 'NO_PROXY: <unset>';\n  \n  // log PROXY envvars\n  if (envProxy.httpProxy || envProxy.httpsProxy) {\n    logMessages.messages = logMessages.messages + ' // PROXY environment variables: '\n        + `${envProxy.logHttpProxy} ${envProxy.logHttpsProxy} ${envProxy.logNoProxy}.`;\n  }\n  \n  // log proxy config on Connection, if any set\n  if (agentOptions.host) {\n    const proxyHostAndPort = agentOptions.host + ':' + agentOptions.port;\n    const proxyProtocolHostAndPort = agentOptions.protocol ?\n      ' protocol=' + agentOptions.protocol + ' proxy=' + proxyHostAndPort\n      : ' proxy=' + proxyHostAndPort;\n    const proxyUsername = agentOptions.user ? ' user=' + agentOptions.user : '';\n    const proxyString = `${Util.exists(agentOptions.user) ? `${agentOptions.user}:${agentOptions.password}@` : ''}${proxyHostAndPort}`.toLowerCase();\n    logMessages.messages = logMessages.messages + ` // Proxy configured in Agent:${proxyProtocolHostAndPort}${proxyUsername}`;\n  \n    // check if both the PROXY envvars and Connection proxy config is set\n    // generate warnings if they are, and are also different\n    if (envProxy.httpProxy &&\n            this.removeScheme(envProxy.httpProxy).toLowerCase() !== proxyString.toLowerCase()) {\n      logMessages.warnings = logMessages.warnings + ` Using both the HTTP_PROXY (${this.describeProxy(this.getProxyFromEnv(false))})`\n            + ` and the Connection proxy (${this.describeProxy(agentOptions)}), but with different values.`\n            + ' If you experience connectivity issues, try unsetting one of them.';\n    }\n    if (envProxy.httpsProxy && this.removeScheme(envProxy.httpsProxy).toLowerCase() !== proxyString.toLowerCase()) {\n      logMessages.warnings = logMessages.warnings + ` Using both the HTTPS_PROXY (${this.describeProxy(this.getProxyFromEnv(true))})`\n            + ` and the Connection proxy (${this.describeProxy(agentOptions)}) settings to connect, but with different values.`\n            + ' If you experience connectivity issues, try unsetting one of them.';\n    }\n  }\n  logMessages.messages = logMessages.messages ? logMessages.messages : ' none.';\n  \n  return logMessages;\n};\n\n/**\n * Validate whether the proxy object has the appropriate information\n *\n * @param {Proxy} proxy\n * @returns {Proxy}\n */\nexports.validateProxy = function (proxy) {\n  const { host, port, noProxy, user, password } = proxy;\n  // check for missing proxyHost\n  Errors.checkArgumentExists(Util.exists(host),\n    ErrorCodes.ERR_CONN_CREATE_MISSING_PROXY_HOST);\n  \n  // check for invalid proxyHost\n  Errors.checkArgumentValid(Util.isString(host),\n    ErrorCodes.ERR_CONN_CREATE_INVALID_PROXY_HOST);\n  \n  // check for missing proxyPort\n  Errors.checkArgumentExists(Util.exists(port),\n    ErrorCodes.ERR_CONN_CREATE_MISSING_PROXY_PORT);\n  \n  // check for invalid proxyPort\n  Errors.checkArgumentValid(Util.isNumber(port),\n    ErrorCodes.ERR_CONN_CREATE_INVALID_PROXY_PORT);\n  \n  if (Util.exists(noProxy)) {\n    // check for invalid noProxy\n    Errors.checkArgumentValid(Util.isString(noProxy),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_NO_PROXY);\n  }\n  \n  if (Util.exists(user) || Util.exists(password)) {\n    // check for missing proxyUser\n    Errors.checkArgumentExists(Util.exists(user),\n      ErrorCodes.ERR_CONN_CREATE_MISSING_PROXY_USER);\n  \n    // check for invalid proxyUser\n    Errors.checkArgumentValid(Util.isString(user),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_PROXY_USER);\n  \n    // check for missing proxyPassword\n    Errors.checkArgumentExists(Util.exists(password),\n      ErrorCodes.ERR_CONN_CREATE_MISSING_PROXY_PASS);\n  \n    // check for invalid proxyPassword\n    Errors.checkArgumentValid(Util.isString(password),\n      ErrorCodes.ERR_CONN_CREATE_INVALID_PROXY_PASS);\n  \n  } else {\n    delete proxy.user;\n    delete proxy.password;\n  }\n};\n\n/**\n * Obtain the proxy information from the environment variable.\n *\n * @param {boolean} isHttps \n * @returns {Proxy}\n */\nexports.getProxyFromEnv = function (isHttps = true) {\n  const getDefaultPortIfNotSet = (proxyFromEnv) => {\n    const isProxyProtocolHttps = proxyFromEnv.protocol === 'https:';\n    if (!proxyFromEnv.port) {\n      return isProxyProtocolHttps ? 443 : 80;\n    } else {\n      return proxyFromEnv.port;\n    }\n  };\n  \n  const protocol = isHttps ? 'https' : 'http';\n  let proxyFromEnv = Util.getEnvVar(`${protocol}_proxy`);\n  if (!proxyFromEnv){\n    return null;\n  }\n  \n  Logger.getInstance().debug(`Util.getProxyEnv: Using ${protocol.toUpperCase()}_PROXY from the environment variable`);\n  if (proxyFromEnv.indexOf('://') === -1) {\n    Logger.getInstance().info('Util.getProxyEnv: the protocol was missing from the environment proxy. Use the HTTP protocol.');\n    proxyFromEnv = 'http' + '://' + proxyFromEnv;\n  }\n  proxyFromEnv = new URL(proxyFromEnv);\n  const port = getDefaultPortIfNotSet(proxyFromEnv);\n  const proxy = {\n    host: Util.validateEmptyString(proxyFromEnv.hostname),\n    port: Number(port),\n    user: Util.validateEmptyString(proxyFromEnv.username),\n    password: Util.validateEmptyString(proxyFromEnv.password),\n    protocol: Util.validateEmptyString(proxyFromEnv.protocol),\n    noProxy: this.getNoProxyEnv(),\n  };\n  this.validateProxy(proxy);\n  return proxy;\n};\n\n/**\n * Obtain the no proxy information from the environment variable.\n * \n * @returns {string | undefined}\n */  \nexports.getNoProxyEnv = function () {\n  const noProxy = Util.getEnvVar('no_proxy');\n  if (noProxy) {\n    return noProxy.split(',').join('|');\n  }\n  return undefined;\n};\n\n/**\n * Extract the host from the destination URL to check whether the same agent already exists or not.\n *\n * @param {string} destination\n * @returns {string} \n */  \nexports.getHostFromURL = function (destination) {\n  if (destination.indexOf('://') === -1) {\n    destination = 'https' + '://' + destination;\n  }\n  \n  try {\n    return new URL(destination).hostname;\n  } catch (err) {\n    Logger.getInstance().error(`Failed to parse the destination to URL with the error: ${err}. Return destination as the host: ${destination}`);\n    return destination;\n  }\n};\n\n/**\n * if proxy exists, return the proxy. If not and the useEnvProxy is true, return the proxy from the environment variable.\n * @param {Proxy} proxy\n * @param {string} moduleName\n * @param {string} isHttp\n *\n * @returns {Proxy}\n */ \nexports.getProxy = function (proxy, moduleName, isHttps) {\n  if (!proxy && GlobalConfig.isEnvProxyActive()) {\n    proxy = this.getProxyFromEnv(isHttps);\n    if (proxy) {\n      Logger.getInstance().debug(`${moduleName} loads the proxy info from the environment variable host: ${proxy.host}`);\n    }\n  }\n  return proxy;\n};\n\n/**\n * The proxy configuration fields in Azure are different from the proxy fields in the snowflake node.js driver.\n * Because of that, this function converts the snowflake proxy info to the Azure proxy info.\n * @param {Proxy} proxy\n * @returns {{host:string, port:number, user?:string, password?:string}}}\n */ \nexports.getAzureProxy = function (proxy) {\n  const AzureProxy = {\n    ...proxy, host: `${proxy.protocol}${(proxy.protocol).endsWith(':') ? '' : ':'}//${proxy.host}`, \n  };\n  delete AzureProxy.noProxy;\n  delete AzureProxy.protocol;\n\n  if (!Util.exists(AzureProxy.user) || !Util.exists(AzureProxy.password)) {\n    delete AzureProxy.user;\n    delete AzureProxy.password;\n  }\n  return AzureProxy;\n};\n\n/**\n * Currently, there is no way to disable loading the proxy information from the environment path in Azure/blob.\n * To control this proxy option on the driver side, A temporary workaround is hide(remove) the environment proxy from the process\n * when the client is created (At this time, the client loads the proxy from the environment variables internally). \n * After the client is created, restore them with the 'restoreEnvironmentProxy' function.\n */\nlet envProxyList;\nconst proxyEnvList = ['http_proxy', 'https_proxy', 'no_proxy'];\nexports.hideEnvironmentProxy = function () {\n  if (GlobalConfig.isEnvProxyActive()) {\n    return;\n  }\n  Logger.getInstance().debug('As the useEnvProxy option is disabled, the proxy environment variables are temporarily hidden during the creation of an Azure client');\n  envProxyList = [];\n  for (const envVar of proxyEnvList) {\n    saveProxyInfoInList(envVar);\n    if (!Util.isWindows()) {\n      saveProxyInfoInList(envVar.toUpperCase());\n    }\n  }\n};\n\nfunction saveProxyInfoInList(envVar) {\n  const proxyEnv = process.env[envVar];\n  envProxyList.push(process.env[envVar]);\n  delete process.env[envVar];\n\n  if (Util.exists(proxyEnv)) {\n    Logger.getInstance().debug(`Temporarily exclude ${envVar} from the environment variable value: ${proxyEnv}`);\n  } else {\n    Logger.getInstance().debug(`${envVar} was not defined, nothing to do`);\n  }\n}\n\nexports.restoreEnvironmentProxy = function () {\n  if (GlobalConfig.isEnvProxyActive()) {\n    return;\n  }\n\n  const iterator = envProxyList[Symbol.iterator]();\n  let nextValue = iterator.next().value;\n  for (const envVar of proxyEnvList) {\n    if (Util.exists(nextValue)) {\n      Logger.getInstance().debug(`The ${envVar} value exists with the value: ${nextValue} Restore back the proxy environment variable values`);\n      process.env[envVar] = nextValue;\n    }\n    nextValue = iterator.next().value;\n\n    if (!Util.isWindows()) {\n      if (Util.exists(nextValue)) {\n        Logger.getInstance().debug(`The ${envVar.toUpperCase()} value exists with the value: ${nextValue} Restore back the proxy environment variable values (for Non-Windows machine)`);\n        process.env[envVar.toUpperCase()] = nextValue;\n      }\n      nextValue = iterator.next().value;\n    }\n  }\n  Logger.getInstance().debug('An Azure client has been created. Restore back the proxy environment variable values');\n};\n\n/**\n * Provide the details of the proxy info.\n * @param proxy\n * @returns {string} \n */\nexports.describeProxy = function (proxy) {\n  if (Util.exists(proxy)) {\n    return `proxyHost: ${proxy.host}, proxyPort: ${proxy.port}, ` +\n  `${Util.exists(proxy.user) ? `proxyUser: ${proxy.user}, proxyPassword is ${LoggingUtil.describePresence(proxy.password)}, ` : ''}` + \n  `proxyProtocol: ${proxy.protocol}, noProxy: ${proxy.noProxy}`;\n  } else {\n    return 'proxy was not configured';\n  }\n};\n\n/**\n * Make the proxy string with the proxy info (json format)\n * @param proxy\n * @returns {string} \n */\nexports.stringifyProxy = function (proxy) {\n  if (Util.isEmptyObject(proxy)) {\n    return null;\n  }\n  return `${(proxy.protocol).startsWith('https') ? 'https' : 'http'}://` + \n  `${Util.exists(proxy.user) ? `${proxy.user}:${proxy.password}@` : ''}` +\n  `${proxy.host}:${proxy.port}`;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvcHJveHlfdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxlQUFlLG1CQUFPLENBQUMsa0VBQVU7QUFDakMsZUFBZSxtQkFBTyxDQUFDLGtFQUFVO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyw4REFBUTtBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQyxnRkFBaUI7QUFDOUMsb0JBQW9CLG1CQUFPLENBQUMsNEZBQXVCO0FBQ25EOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCLGNBQWMsUUFBUTtBQUN0QixjQUFjLFFBQVE7QUFDdEIsY0FBYyxRQUFRO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsY0FBYyxxQ0FBcUM7QUFDbkQ7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsdUJBQXVCLEVBQUUsd0JBQXdCLEVBQUUsb0JBQW9CO0FBQ3BGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixvQ0FBb0Msa0JBQWtCLEdBQUcsc0JBQXNCLFFBQVEsRUFBRSxpQkFBaUI7QUFDckksbUZBQW1GLHlCQUF5QixFQUFFLGNBQWM7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRixnREFBZ0Q7QUFDbkksNENBQTRDLGlDQUFpQztBQUM3RTtBQUNBO0FBQ0E7QUFDQSxvRkFBb0YsK0NBQStDO0FBQ25JLDRDQUE0QyxpQ0FBaUM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBLHFCQUFxQjtBQUNyQixVQUFVLHNDQUFzQztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCLGFBQWE7QUFDYjtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFNBQVM7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsdUJBQXVCO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSix5RkFBeUYsSUFBSSxvQ0FBb0MsWUFBWTtBQUM3STtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxZQUFZLDJEQUEyRCxXQUFXO0FBQ3RIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQixjQUFjO0FBQ2Q7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSx1QkFBdUIsZUFBZSxFQUFFLDBDQUEwQyxJQUFJLFdBQVc7QUFDakc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNEQUFzRCxRQUFRLHVDQUF1QyxTQUFTO0FBQzlHLElBQUk7QUFDSixrQ0FBa0MsUUFBUTtBQUMxQztBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsUUFBUSwrQkFBK0IsV0FBVztBQUMxRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBDQUEwQyxzQkFBc0IsK0JBQStCLFdBQVc7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EseUJBQXlCLFdBQVcsZUFBZSxXQUFXO0FBQzlELEtBQUssd0NBQXdDLFdBQVcscUJBQXFCLDZDQUE2QyxTQUFTO0FBQ25JLG9CQUFvQixlQUFlLGFBQWEsY0FBYztBQUM5RCxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxZQUFZLHdEQUF3RDtBQUNwRSxLQUFLLDZCQUE2QixXQUFXLEdBQUcsZUFBZSxRQUFRO0FBQ3ZFLEtBQUssV0FBVyxHQUFHLFdBQVc7QUFDOUIiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvcHJveHlfdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbmNvbnN0IEdsb2JhbENvbmZpZyA9IHJlcXVpcmUoJy4vZ2xvYmFsX2NvbmZpZycpO1xuY29uc3QgTG9nZ2luZ1V0aWwgPSByZXF1aXJlKCcuL2xvZ2dlci9sb2dnaW5nX3V0aWwnKTtcbmNvbnN0IEVycm9yQ29kZXMgPSBFcnJvcnMuY29kZXM7XG5cbi8qKlxuICogQHR5cGVkZWYge29iamVjdH0gUHJveHlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBob3N0IC0gVGhlIGhvc3QgYWRkcmVzcyBvZiB0aGUgcHJveHkuXG4gKiBAcHJvcGVydHkge3N0cmluZ30gcHJvdG9jb2wgLSBUaGUgcHJvdG9jb2wgdXNlZCBieSB0aGUgcHJveHkgKGUuZy4sIFwiaHR0cFwiIG9yIFwiaHR0cHNcIilcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSB1c2VyIC0gVGhlIHVzZXJuYW1lIGZvciB0aGUgcHJveHlcbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBwb3J0IC0gVGhlIHBvcnQgbnVtYmVyLlxuICogQHByb3BlcnR5IHtzdHJpbmd9IHBhc3N3b3JkIC0gVGhlIHBhc3N3b3JkIGZvciB0aGUgcHJveHlcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBub1Byb3h5IC0gIE9wdGlvbmFsIGxpc3Qgb2YgZG9tYWlucyB0aGF0IHNob3VsZCBieXBhc3MgdGhlIHByb3hcbiAqL1xuXG4vKipcbiogcmVtb3ZlIGh0dHA6Ly8gb3IgaHR0cHM6Ly8gZnJvbSB0aGUgaW5wdXQsIGUuZy4gdXNlZCB3aXRoIHByb3h5IFVSTFxuKiBAcGFyYW0gaW5wdXRcbiogQHJldHVybnMge3N0cmluZ31cbiovXG5leHBvcnRzLnJlbW92ZVNjaGVtZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICByZXR1cm4gaW5wdXQudG9TdHJpbmcoKS5yZXBsYWNlKC8oXlxcdys6fF4pXFwvXFwvLywgJycpO1xufTtcblxuLyoqXG4gKiBUcnkgdG8gZ2V0IHRoZSBQUk9YWSBlbnZpcm9ubWVudGFsIHZhcmlhYmxlc1xuICogT24gV2luZG93cywgZW52dmFyIG5hbWUgaXMgY2FzZS1pbnNlbnNpdGl2ZSwgYnV0IG9uICpuaXgsIGl0J3MgY2FzZS1zZW5zaXRpdmVcbiAqXG4gKiBDb21wYXJlIHRoZW0gd2l0aCB0aGUgcHJveHkgc3BlY2lmaWVkIG9uIHRoZSBDb25uZWN0aW9uLCBpZiBhbnlcbiAqIFJldHVybiB3aXRoIHRoZSBsb2cgY29uc3RydWN0ZWQgZnJvbSB0aGUgY29tcG9uZW50cyBkZXRlY3Rpb24gYW5kIGNvbXBhcmlzb25cbiAqIElmIHRoZXJlJ3Mgc29tZXRoaW5nIHRvIHdhcm4gdGhlIHVzZXIgYWJvdXQsIHJldHVybiB0aGF0IHRvb1xuICpcbiAqIEBwYXJhbSB7UHJveHl9IGFnZW50T3B0aW9ucyBmcm9tIGFnZW50IGNyZWF0aW9uXG4gKiBAcmV0dXJucyB7e21lc3NhZ2VzOiBzdHJpbmcsIHdhcm5pbmdzOiBzdHJpbmd9fSBsb2cgbWVzc2FnZXNcbiAqL1xuZXhwb3J0cy5nZXRDb21wYXJlQW5kTG9nRW52QW5kQWdlbnRQcm94aWVzID0gZnVuY3Rpb24gKGFnZW50T3B0aW9ucykge1xuICBjb25zdCBlbnZQcm94eSA9IHt9O1xuICBjb25zdCBsb2dNZXNzYWdlcyA9IHsgJ21lc3NhZ2VzJzogJycsICd3YXJuaW5ncyc6ICcnIH07XG4gIGVudlByb3h5Lmh0dHBQcm94eSA9IHByb2Nlc3MuZW52Lmh0dHBfcHJveHkgfHwgcHJvY2Vzcy5lbnYuSFRUUF9QUk9YWTtcbiAgZW52UHJveHkuaHR0cHNQcm94eSA9IHByb2Nlc3MuZW52Lmh0dHBzX3Byb3h5IHx8IHByb2Nlc3MuZW52LkhUVFBTX1BST1hZO1xuICBlbnZQcm94eS5ub1Byb3h5ID0gcHJvY2Vzcy5lbnYubm9fcHJveHkgfHwgcHJvY2Vzcy5lbnYuTk9fUFJPWFk7XG4gIFxuICBlbnZQcm94eS5sb2dIdHRwUHJveHkgPSBlbnZQcm94eS5odHRwUHJveHkgP1xuICAgICdIVFRQX1BST1hZOiAnICsgZW52UHJveHkuaHR0cFByb3h5IDogJ0hUVFBfUFJPWFk6IDx1bnNldD4nO1xuICBlbnZQcm94eS5sb2dIdHRwc1Byb3h5ID0gZW52UHJveHkuaHR0cHNQcm94eSA/XG4gICAgJ0hUVFBTX1BST1hZOiAnICsgZW52UHJveHkuaHR0cHNQcm94eSA6ICdIVFRQU19QUk9YWTogPHVuc2V0Pic7XG4gIGVudlByb3h5LmxvZ05vUHJveHkgPSBlbnZQcm94eS5ub1Byb3h5ID9cbiAgICAnTk9fUFJPWFk6ICcgKyBlbnZQcm94eS5ub1Byb3h5IDogJ05PX1BST1hZOiA8dW5zZXQ+JztcbiAgXG4gIC8vIGxvZyBQUk9YWSBlbnZ2YXJzXG4gIGlmIChlbnZQcm94eS5odHRwUHJveHkgfHwgZW52UHJveHkuaHR0cHNQcm94eSkge1xuICAgIGxvZ01lc3NhZ2VzLm1lc3NhZ2VzID0gbG9nTWVzc2FnZXMubWVzc2FnZXMgKyAnIC8vIFBST1hZIGVudmlyb25tZW50IHZhcmlhYmxlczogJ1xuICAgICAgICArIGAke2VudlByb3h5LmxvZ0h0dHBQcm94eX0gJHtlbnZQcm94eS5sb2dIdHRwc1Byb3h5fSAke2VudlByb3h5LmxvZ05vUHJveHl9LmA7XG4gIH1cbiAgXG4gIC8vIGxvZyBwcm94eSBjb25maWcgb24gQ29ubmVjdGlvbiwgaWYgYW55IHNldFxuICBpZiAoYWdlbnRPcHRpb25zLmhvc3QpIHtcbiAgICBjb25zdCBwcm94eUhvc3RBbmRQb3J0ID0gYWdlbnRPcHRpb25zLmhvc3QgKyAnOicgKyBhZ2VudE9wdGlvbnMucG9ydDtcbiAgICBjb25zdCBwcm94eVByb3RvY29sSG9zdEFuZFBvcnQgPSBhZ2VudE9wdGlvbnMucHJvdG9jb2wgP1xuICAgICAgJyBwcm90b2NvbD0nICsgYWdlbnRPcHRpb25zLnByb3RvY29sICsgJyBwcm94eT0nICsgcHJveHlIb3N0QW5kUG9ydFxuICAgICAgOiAnIHByb3h5PScgKyBwcm94eUhvc3RBbmRQb3J0O1xuICAgIGNvbnN0IHByb3h5VXNlcm5hbWUgPSBhZ2VudE9wdGlvbnMudXNlciA/ICcgdXNlcj0nICsgYWdlbnRPcHRpb25zLnVzZXIgOiAnJztcbiAgICBjb25zdCBwcm94eVN0cmluZyA9IGAke1V0aWwuZXhpc3RzKGFnZW50T3B0aW9ucy51c2VyKSA/IGAke2FnZW50T3B0aW9ucy51c2VyfToke2FnZW50T3B0aW9ucy5wYXNzd29yZH1AYCA6ICcnfSR7cHJveHlIb3N0QW5kUG9ydH1gLnRvTG93ZXJDYXNlKCk7XG4gICAgbG9nTWVzc2FnZXMubWVzc2FnZXMgPSBsb2dNZXNzYWdlcy5tZXNzYWdlcyArIGAgLy8gUHJveHkgY29uZmlndXJlZCBpbiBBZ2VudDoke3Byb3h5UHJvdG9jb2xIb3N0QW5kUG9ydH0ke3Byb3h5VXNlcm5hbWV9YDtcbiAgXG4gICAgLy8gY2hlY2sgaWYgYm90aCB0aGUgUFJPWFkgZW52dmFycyBhbmQgQ29ubmVjdGlvbiBwcm94eSBjb25maWcgaXMgc2V0XG4gICAgLy8gZ2VuZXJhdGUgd2FybmluZ3MgaWYgdGhleSBhcmUsIGFuZCBhcmUgYWxzbyBkaWZmZXJlbnRcbiAgICBpZiAoZW52UHJveHkuaHR0cFByb3h5ICYmXG4gICAgICAgICAgICB0aGlzLnJlbW92ZVNjaGVtZShlbnZQcm94eS5odHRwUHJveHkpLnRvTG93ZXJDYXNlKCkgIT09IHByb3h5U3RyaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgIGxvZ01lc3NhZ2VzLndhcm5pbmdzID0gbG9nTWVzc2FnZXMud2FybmluZ3MgKyBgIFVzaW5nIGJvdGggdGhlIEhUVFBfUFJPWFkgKCR7dGhpcy5kZXNjcmliZVByb3h5KHRoaXMuZ2V0UHJveHlGcm9tRW52KGZhbHNlKSl9KWBcbiAgICAgICAgICAgICsgYCBhbmQgdGhlIENvbm5lY3Rpb24gcHJveHkgKCR7dGhpcy5kZXNjcmliZVByb3h5KGFnZW50T3B0aW9ucyl9KSwgYnV0IHdpdGggZGlmZmVyZW50IHZhbHVlcy5gXG4gICAgICAgICAgICArICcgSWYgeW91IGV4cGVyaWVuY2UgY29ubmVjdGl2aXR5IGlzc3VlcywgdHJ5IHVuc2V0dGluZyBvbmUgb2YgdGhlbS4nO1xuICAgIH1cbiAgICBpZiAoZW52UHJveHkuaHR0cHNQcm94eSAmJiB0aGlzLnJlbW92ZVNjaGVtZShlbnZQcm94eS5odHRwc1Byb3h5KS50b0xvd2VyQ2FzZSgpICE9PSBwcm94eVN0cmluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICBsb2dNZXNzYWdlcy53YXJuaW5ncyA9IGxvZ01lc3NhZ2VzLndhcm5pbmdzICsgYCBVc2luZyBib3RoIHRoZSBIVFRQU19QUk9YWSAoJHt0aGlzLmRlc2NyaWJlUHJveHkodGhpcy5nZXRQcm94eUZyb21FbnYodHJ1ZSkpfSlgXG4gICAgICAgICAgICArIGAgYW5kIHRoZSBDb25uZWN0aW9uIHByb3h5ICgke3RoaXMuZGVzY3JpYmVQcm94eShhZ2VudE9wdGlvbnMpfSkgc2V0dGluZ3MgdG8gY29ubmVjdCwgYnV0IHdpdGggZGlmZmVyZW50IHZhbHVlcy5gXG4gICAgICAgICAgICArICcgSWYgeW91IGV4cGVyaWVuY2UgY29ubmVjdGl2aXR5IGlzc3VlcywgdHJ5IHVuc2V0dGluZyBvbmUgb2YgdGhlbS4nO1xuICAgIH1cbiAgfVxuICBsb2dNZXNzYWdlcy5tZXNzYWdlcyA9IGxvZ01lc3NhZ2VzLm1lc3NhZ2VzID8gbG9nTWVzc2FnZXMubWVzc2FnZXMgOiAnIG5vbmUuJztcbiAgXG4gIHJldHVybiBsb2dNZXNzYWdlcztcbn07XG5cbi8qKlxuICogVmFsaWRhdGUgd2hldGhlciB0aGUgcHJveHkgb2JqZWN0IGhhcyB0aGUgYXBwcm9wcmlhdGUgaW5mb3JtYXRpb25cbiAqXG4gKiBAcGFyYW0ge1Byb3h5fSBwcm94eVxuICogQHJldHVybnMge1Byb3h5fVxuICovXG5leHBvcnRzLnZhbGlkYXRlUHJveHkgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgY29uc3QgeyBob3N0LCBwb3J0LCBub1Byb3h5LCB1c2VyLCBwYXNzd29yZCB9ID0gcHJveHk7XG4gIC8vIGNoZWNrIGZvciBtaXNzaW5nIHByb3h5SG9zdFxuICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhob3N0KSxcbiAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX1BST1hZX0hPU1QpO1xuICBcbiAgLy8gY2hlY2sgZm9yIGludmFsaWQgcHJveHlIb3N0XG4gIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyhob3N0KSxcbiAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9JTlZBTElEX1BST1hZX0hPU1QpO1xuICBcbiAgLy8gY2hlY2sgZm9yIG1pc3NpbmcgcHJveHlQb3J0XG4gIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKFV0aWwuZXhpc3RzKHBvcnQpLFxuICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUFJPWFlfUE9SVCk7XG4gIFxuICAvLyBjaGVjayBmb3IgaW52YWxpZCBwcm94eVBvcnRcbiAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzTnVtYmVyKHBvcnQpLFxuICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJPWFlfUE9SVCk7XG4gIFxuICBpZiAoVXRpbC5leGlzdHMobm9Qcm94eSkpIHtcbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBub1Byb3h5XG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKG5vUHJveHkpLFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9DUkVBVEVfSU5WQUxJRF9OT19QUk9YWSk7XG4gIH1cbiAgXG4gIGlmIChVdGlsLmV4aXN0cyh1c2VyKSB8fCBVdGlsLmV4aXN0cyhwYXNzd29yZCkpIHtcbiAgICAvLyBjaGVjayBmb3IgbWlzc2luZyBwcm94eVVzZXJcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyh1c2VyKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfUFJPWFlfVVNFUik7XG4gIFxuICAgIC8vIGNoZWNrIGZvciBpbnZhbGlkIHByb3h5VXNlclxuICAgIEVycm9ycy5jaGVja0FyZ3VtZW50VmFsaWQoVXRpbC5pc1N0cmluZyh1c2VyKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJPWFlfVVNFUik7XG4gIFxuICAgIC8vIGNoZWNrIGZvciBtaXNzaW5nIHByb3h5UGFzc3dvcmRcbiAgICBFcnJvcnMuY2hlY2tBcmd1bWVudEV4aXN0cyhVdGlsLmV4aXN0cyhwYXNzd29yZCksXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NSRUFURV9NSVNTSU5HX1BST1hZX1BBU1MpO1xuICBcbiAgICAvLyBjaGVjayBmb3IgaW52YWxpZCBwcm94eVBhc3N3b3JkXG4gICAgRXJyb3JzLmNoZWNrQXJndW1lbnRWYWxpZChVdGlsLmlzU3RyaW5nKHBhc3N3b3JkKSxcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ1JFQVRFX0lOVkFMSURfUFJPWFlfUEFTUyk7XG4gIFxuICB9IGVsc2Uge1xuICAgIGRlbGV0ZSBwcm94eS51c2VyO1xuICAgIGRlbGV0ZSBwcm94eS5wYXNzd29yZDtcbiAgfVxufTtcblxuLyoqXG4gKiBPYnRhaW4gdGhlIHByb3h5IGluZm9ybWF0aW9uIGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICpcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNIdHRwcyBcbiAqIEByZXR1cm5zIHtQcm94eX1cbiAqL1xuZXhwb3J0cy5nZXRQcm94eUZyb21FbnYgPSBmdW5jdGlvbiAoaXNIdHRwcyA9IHRydWUpIHtcbiAgY29uc3QgZ2V0RGVmYXVsdFBvcnRJZk5vdFNldCA9IChwcm94eUZyb21FbnYpID0+IHtcbiAgICBjb25zdCBpc1Byb3h5UHJvdG9jb2xIdHRwcyA9IHByb3h5RnJvbUVudi5wcm90b2NvbCA9PT0gJ2h0dHBzOic7XG4gICAgaWYgKCFwcm94eUZyb21FbnYucG9ydCkge1xuICAgICAgcmV0dXJuIGlzUHJveHlQcm90b2NvbEh0dHBzID8gNDQzIDogODA7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBwcm94eUZyb21FbnYucG9ydDtcbiAgICB9XG4gIH07XG4gIFxuICBjb25zdCBwcm90b2NvbCA9IGlzSHR0cHMgPyAnaHR0cHMnIDogJ2h0dHAnO1xuICBsZXQgcHJveHlGcm9tRW52ID0gVXRpbC5nZXRFbnZWYXIoYCR7cHJvdG9jb2x9X3Byb3h5YCk7XG4gIGlmICghcHJveHlGcm9tRW52KXtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBcbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFV0aWwuZ2V0UHJveHlFbnY6IFVzaW5nICR7cHJvdG9jb2wudG9VcHBlckNhc2UoKX1fUFJPWFkgZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGVgKTtcbiAgaWYgKHByb3h5RnJvbUVudi5pbmRleE9mKCc6Ly8nKSA9PT0gLTEpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5pbmZvKCdVdGlsLmdldFByb3h5RW52OiB0aGUgcHJvdG9jb2wgd2FzIG1pc3NpbmcgZnJvbSB0aGUgZW52aXJvbm1lbnQgcHJveHkuIFVzZSB0aGUgSFRUUCBwcm90b2NvbC4nKTtcbiAgICBwcm94eUZyb21FbnYgPSAnaHR0cCcgKyAnOi8vJyArIHByb3h5RnJvbUVudjtcbiAgfVxuICBwcm94eUZyb21FbnYgPSBuZXcgVVJMKHByb3h5RnJvbUVudik7XG4gIGNvbnN0IHBvcnQgPSBnZXREZWZhdWx0UG9ydElmTm90U2V0KHByb3h5RnJvbUVudik7XG4gIGNvbnN0IHByb3h5ID0ge1xuICAgIGhvc3Q6IFV0aWwudmFsaWRhdGVFbXB0eVN0cmluZyhwcm94eUZyb21FbnYuaG9zdG5hbWUpLFxuICAgIHBvcnQ6IE51bWJlcihwb3J0KSxcbiAgICB1c2VyOiBVdGlsLnZhbGlkYXRlRW1wdHlTdHJpbmcocHJveHlGcm9tRW52LnVzZXJuYW1lKSxcbiAgICBwYXNzd29yZDogVXRpbC52YWxpZGF0ZUVtcHR5U3RyaW5nKHByb3h5RnJvbUVudi5wYXNzd29yZCksXG4gICAgcHJvdG9jb2w6IFV0aWwudmFsaWRhdGVFbXB0eVN0cmluZyhwcm94eUZyb21FbnYucHJvdG9jb2wpLFxuICAgIG5vUHJveHk6IHRoaXMuZ2V0Tm9Qcm94eUVudigpLFxuICB9O1xuICB0aGlzLnZhbGlkYXRlUHJveHkocHJveHkpO1xuICByZXR1cm4gcHJveHk7XG59O1xuXG4vKipcbiAqIE9idGFpbiB0aGUgbm8gcHJveHkgaW5mb3JtYXRpb24gZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUuXG4gKiBcbiAqIEByZXR1cm5zIHtzdHJpbmcgfCB1bmRlZmluZWR9XG4gKi8gIFxuZXhwb3J0cy5nZXROb1Byb3h5RW52ID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBub1Byb3h5ID0gVXRpbC5nZXRFbnZWYXIoJ25vX3Byb3h5Jyk7XG4gIGlmIChub1Byb3h5KSB7XG4gICAgcmV0dXJuIG5vUHJveHkuc3BsaXQoJywnKS5qb2luKCd8Jyk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8qKlxuICogRXh0cmFjdCB0aGUgaG9zdCBmcm9tIHRoZSBkZXN0aW5hdGlvbiBVUkwgdG8gY2hlY2sgd2hldGhlciB0aGUgc2FtZSBhZ2VudCBhbHJlYWR5IGV4aXN0cyBvciBub3QuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGRlc3RpbmF0aW9uXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBcbiAqLyAgXG5leHBvcnRzLmdldEhvc3RGcm9tVVJMID0gZnVuY3Rpb24gKGRlc3RpbmF0aW9uKSB7XG4gIGlmIChkZXN0aW5hdGlvbi5pbmRleE9mKCc6Ly8nKSA9PT0gLTEpIHtcbiAgICBkZXN0aW5hdGlvbiA9ICdodHRwcycgKyAnOi8vJyArIGRlc3RpbmF0aW9uO1xuICB9XG4gIFxuICB0cnkge1xuICAgIHJldHVybiBuZXcgVVJMKGRlc3RpbmF0aW9uKS5ob3N0bmFtZTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoYEZhaWxlZCB0byBwYXJzZSB0aGUgZGVzdGluYXRpb24gdG8gVVJMIHdpdGggdGhlIGVycm9yOiAke2Vycn0uIFJldHVybiBkZXN0aW5hdGlvbiBhcyB0aGUgaG9zdDogJHtkZXN0aW5hdGlvbn1gKTtcbiAgICByZXR1cm4gZGVzdGluYXRpb247XG4gIH1cbn07XG5cbi8qKlxuICogaWYgcHJveHkgZXhpc3RzLCByZXR1cm4gdGhlIHByb3h5LiBJZiBub3QgYW5kIHRoZSB1c2VFbnZQcm94eSBpcyB0cnVlLCByZXR1cm4gdGhlIHByb3h5IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlLlxuICogQHBhcmFtIHtQcm94eX0gcHJveHlcbiAqIEBwYXJhbSB7c3RyaW5nfSBtb2R1bGVOYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gaXNIdHRwXG4gKlxuICogQHJldHVybnMge1Byb3h5fVxuICovIFxuZXhwb3J0cy5nZXRQcm94eSA9IGZ1bmN0aW9uIChwcm94eSwgbW9kdWxlTmFtZSwgaXNIdHRwcykge1xuICBpZiAoIXByb3h5ICYmIEdsb2JhbENvbmZpZy5pc0VudlByb3h5QWN0aXZlKCkpIHtcbiAgICBwcm94eSA9IHRoaXMuZ2V0UHJveHlGcm9tRW52KGlzSHR0cHMpO1xuICAgIGlmIChwcm94eSkge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYCR7bW9kdWxlTmFtZX0gbG9hZHMgdGhlIHByb3h5IGluZm8gZnJvbSB0aGUgZW52aXJvbm1lbnQgdmFyaWFibGUgaG9zdDogJHtwcm94eS5ob3N0fWApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcHJveHk7XG59O1xuXG4vKipcbiAqIFRoZSBwcm94eSBjb25maWd1cmF0aW9uIGZpZWxkcyBpbiBBenVyZSBhcmUgZGlmZmVyZW50IGZyb20gdGhlIHByb3h5IGZpZWxkcyBpbiB0aGUgc25vd2ZsYWtlIG5vZGUuanMgZHJpdmVyLlxuICogQmVjYXVzZSBvZiB0aGF0LCB0aGlzIGZ1bmN0aW9uIGNvbnZlcnRzIHRoZSBzbm93Zmxha2UgcHJveHkgaW5mbyB0byB0aGUgQXp1cmUgcHJveHkgaW5mby5cbiAqIEBwYXJhbSB7UHJveHl9IHByb3h5XG4gKiBAcmV0dXJucyB7e2hvc3Q6c3RyaW5nLCBwb3J0Om51bWJlciwgdXNlcj86c3RyaW5nLCBwYXNzd29yZD86c3RyaW5nfX19XG4gKi8gXG5leHBvcnRzLmdldEF6dXJlUHJveHkgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgY29uc3QgQXp1cmVQcm94eSA9IHtcbiAgICAuLi5wcm94eSwgaG9zdDogYCR7cHJveHkucHJvdG9jb2x9JHsocHJveHkucHJvdG9jb2wpLmVuZHNXaXRoKCc6JykgPyAnJyA6ICc6J30vLyR7cHJveHkuaG9zdH1gLCBcbiAgfTtcbiAgZGVsZXRlIEF6dXJlUHJveHkubm9Qcm94eTtcbiAgZGVsZXRlIEF6dXJlUHJveHkucHJvdG9jb2w7XG5cbiAgaWYgKCFVdGlsLmV4aXN0cyhBenVyZVByb3h5LnVzZXIpIHx8ICFVdGlsLmV4aXN0cyhBenVyZVByb3h5LnBhc3N3b3JkKSkge1xuICAgIGRlbGV0ZSBBenVyZVByb3h5LnVzZXI7XG4gICAgZGVsZXRlIEF6dXJlUHJveHkucGFzc3dvcmQ7XG4gIH1cbiAgcmV0dXJuIEF6dXJlUHJveHk7XG59O1xuXG4vKipcbiAqIEN1cnJlbnRseSwgdGhlcmUgaXMgbm8gd2F5IHRvIGRpc2FibGUgbG9hZGluZyB0aGUgcHJveHkgaW5mb3JtYXRpb24gZnJvbSB0aGUgZW52aXJvbm1lbnQgcGF0aCBpbiBBenVyZS9ibG9iLlxuICogVG8gY29udHJvbCB0aGlzIHByb3h5IG9wdGlvbiBvbiB0aGUgZHJpdmVyIHNpZGUsIEEgdGVtcG9yYXJ5IHdvcmthcm91bmQgaXMgaGlkZShyZW1vdmUpIHRoZSBlbnZpcm9ubWVudCBwcm94eSBmcm9tIHRoZSBwcm9jZXNzXG4gKiB3aGVuIHRoZSBjbGllbnQgaXMgY3JlYXRlZCAoQXQgdGhpcyB0aW1lLCB0aGUgY2xpZW50IGxvYWRzIHRoZSBwcm94eSBmcm9tIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgaW50ZXJuYWxseSkuIFxuICogQWZ0ZXIgdGhlIGNsaWVudCBpcyBjcmVhdGVkLCByZXN0b3JlIHRoZW0gd2l0aCB0aGUgJ3Jlc3RvcmVFbnZpcm9ubWVudFByb3h5JyBmdW5jdGlvbi5cbiAqL1xubGV0IGVudlByb3h5TGlzdDtcbmNvbnN0IHByb3h5RW52TGlzdCA9IFsnaHR0cF9wcm94eScsICdodHRwc19wcm94eScsICdub19wcm94eSddO1xuZXhwb3J0cy5oaWRlRW52aXJvbm1lbnRQcm94eSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKEdsb2JhbENvbmZpZy5pc0VudlByb3h5QWN0aXZlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0FzIHRoZSB1c2VFbnZQcm94eSBvcHRpb24gaXMgZGlzYWJsZWQsIHRoZSBwcm94eSBlbnZpcm9ubWVudCB2YXJpYWJsZXMgYXJlIHRlbXBvcmFyaWx5IGhpZGRlbiBkdXJpbmcgdGhlIGNyZWF0aW9uIG9mIGFuIEF6dXJlIGNsaWVudCcpO1xuICBlbnZQcm94eUxpc3QgPSBbXTtcbiAgZm9yIChjb25zdCBlbnZWYXIgb2YgcHJveHlFbnZMaXN0KSB7XG4gICAgc2F2ZVByb3h5SW5mb0luTGlzdChlbnZWYXIpO1xuICAgIGlmICghVXRpbC5pc1dpbmRvd3MoKSkge1xuICAgICAgc2F2ZVByb3h5SW5mb0luTGlzdChlbnZWYXIudG9VcHBlckNhc2UoKSk7XG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBzYXZlUHJveHlJbmZvSW5MaXN0KGVudlZhcikge1xuICBjb25zdCBwcm94eUVudiA9IHByb2Nlc3MuZW52W2VudlZhcl07XG4gIGVudlByb3h5TGlzdC5wdXNoKHByb2Nlc3MuZW52W2VudlZhcl0pO1xuICBkZWxldGUgcHJvY2Vzcy5lbnZbZW52VmFyXTtcblxuICBpZiAoVXRpbC5leGlzdHMocHJveHlFbnYpKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFRlbXBvcmFyaWx5IGV4Y2x1ZGUgJHtlbnZWYXJ9IGZyb20gdGhlIGVudmlyb25tZW50IHZhcmlhYmxlIHZhbHVlOiAke3Byb3h5RW52fWApO1xuICB9IGVsc2Uge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGAke2VudlZhcn0gd2FzIG5vdCBkZWZpbmVkLCBub3RoaW5nIHRvIGRvYCk7XG4gIH1cbn1cblxuZXhwb3J0cy5yZXN0b3JlRW52aXJvbm1lbnRQcm94eSA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKEdsb2JhbENvbmZpZy5pc0VudlByb3h5QWN0aXZlKCkpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBjb25zdCBpdGVyYXRvciA9IGVudlByb3h5TGlzdFtTeW1ib2wuaXRlcmF0b3JdKCk7XG4gIGxldCBuZXh0VmFsdWUgPSBpdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gIGZvciAoY29uc3QgZW52VmFyIG9mIHByb3h5RW52TGlzdCkge1xuICAgIGlmIChVdGlsLmV4aXN0cyhuZXh0VmFsdWUpKSB7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgVGhlICR7ZW52VmFyfSB2YWx1ZSBleGlzdHMgd2l0aCB0aGUgdmFsdWU6ICR7bmV4dFZhbHVlfSBSZXN0b3JlIGJhY2sgdGhlIHByb3h5IGVudmlyb25tZW50IHZhcmlhYmxlIHZhbHVlc2ApO1xuICAgICAgcHJvY2Vzcy5lbnZbZW52VmFyXSA9IG5leHRWYWx1ZTtcbiAgICB9XG4gICAgbmV4dFZhbHVlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuXG4gICAgaWYgKCFVdGlsLmlzV2luZG93cygpKSB7XG4gICAgICBpZiAoVXRpbC5leGlzdHMobmV4dFZhbHVlKSkge1xuICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgVGhlICR7ZW52VmFyLnRvVXBwZXJDYXNlKCl9IHZhbHVlIGV4aXN0cyB3aXRoIHRoZSB2YWx1ZTogJHtuZXh0VmFsdWV9IFJlc3RvcmUgYmFjayB0aGUgcHJveHkgZW52aXJvbm1lbnQgdmFyaWFibGUgdmFsdWVzIChmb3IgTm9uLVdpbmRvd3MgbWFjaGluZSlgKTtcbiAgICAgICAgcHJvY2Vzcy5lbnZbZW52VmFyLnRvVXBwZXJDYXNlKCldID0gbmV4dFZhbHVlO1xuICAgICAgfVxuICAgICAgbmV4dFZhbHVlID0gaXRlcmF0b3IubmV4dCgpLnZhbHVlO1xuICAgIH1cbiAgfVxuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQW4gQXp1cmUgY2xpZW50IGhhcyBiZWVuIGNyZWF0ZWQuIFJlc3RvcmUgYmFjayB0aGUgcHJveHkgZW52aXJvbm1lbnQgdmFyaWFibGUgdmFsdWVzJyk7XG59O1xuXG4vKipcbiAqIFByb3ZpZGUgdGhlIGRldGFpbHMgb2YgdGhlIHByb3h5IGluZm8uXG4gKiBAcGFyYW0gcHJveHlcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFxuICovXG5leHBvcnRzLmRlc2NyaWJlUHJveHkgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgaWYgKFV0aWwuZXhpc3RzKHByb3h5KSkge1xuICAgIHJldHVybiBgcHJveHlIb3N0OiAke3Byb3h5Lmhvc3R9LCBwcm94eVBvcnQ6ICR7cHJveHkucG9ydH0sIGAgK1xuICBgJHtVdGlsLmV4aXN0cyhwcm94eS51c2VyKSA/IGBwcm94eVVzZXI6ICR7cHJveHkudXNlcn0sIHByb3h5UGFzc3dvcmQgaXMgJHtMb2dnaW5nVXRpbC5kZXNjcmliZVByZXNlbmNlKHByb3h5LnBhc3N3b3JkKX0sIGAgOiAnJ31gICsgXG4gIGBwcm94eVByb3RvY29sOiAke3Byb3h5LnByb3RvY29sfSwgbm9Qcm94eTogJHtwcm94eS5ub1Byb3h5fWA7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuICdwcm94eSB3YXMgbm90IGNvbmZpZ3VyZWQnO1xuICB9XG59O1xuXG4vKipcbiAqIE1ha2UgdGhlIHByb3h5IHN0cmluZyB3aXRoIHRoZSBwcm94eSBpbmZvIChqc29uIGZvcm1hdClcbiAqIEBwYXJhbSBwcm94eVxuICogQHJldHVybnMge3N0cmluZ30gXG4gKi9cbmV4cG9ydHMuc3RyaW5naWZ5UHJveHkgPSBmdW5jdGlvbiAocHJveHkpIHtcbiAgaWYgKFV0aWwuaXNFbXB0eU9iamVjdChwcm94eSkpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gYCR7KHByb3h5LnByb3RvY29sKS5zdGFydHNXaXRoKCdodHRwcycpID8gJ2h0dHBzJyA6ICdodHRwJ306Ly9gICsgXG4gIGAke1V0aWwuZXhpc3RzKHByb3h5LnVzZXIpID8gYCR7cHJveHkudXNlcn06JHtwcm94eS5wYXNzd29yZH1AYCA6ICcnfWAgK1xuICBgJHtwcm94eS5ob3N0fToke3Byb3h5LnBvcnR9YDtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/proxy_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/queryContextCache.js":
/*!*************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/queryContextCache.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\n\n/**\n *\n * @param {String} id \n * @param {Number} timestamp \n * @param {Number} priority \n * @param {String} context \n */\nfunction QueryContextElement(id, timestamp, priority, context) {\n  this.id = id;\n  this.timestamp = timestamp;\n  this.priority = priority;\n  this.context = context;\n}\n\n/**\n * Most Recently Used and Priority based cache. A separate cache for each connection in the driver.\n */\n\n/**\n * @param {Number} capacity Maximum capacity of the cache.\n * @param {Number} sessionId Session for which the cache is created.\n */\nfunction QueryContextCache(capacity, sessionId) {\n  Logger.getInstance().debug(`Creating new QueryContextCache with capacity ${capacity} for session ${sessionId}`);\n  this.sessionId = sessionId;\n  this.capacity = capacity;\n  this.idMap = new Map(); // Map for id and QCC\n  this.treeSet = new Set(); // Order data as per priority\n  this.priorityMap = new Map(); // Map for priority and QCC\n}\n\nQueryContextCache.prototype.sortTreeSet = function () {\n  this.treeSet = new Set(Array.from(this.treeSet).sort((a, b) => a.priority - b.priority));\n};\n\nQueryContextCache.prototype.addQCE = function (qce) {\n  this.idMap.set(qce.id, qce);\n  this.priorityMap.set(qce.priority, qce);\n  this.treeSet.add(qce);\n  this.sortTreeSet();\n  Logger.getInstance().trace(`QCC session ${this.sessionId} - Added QCE: ${JSON.stringify(qce)}`);\n};\n\n/**\n   * Remove an element from the cache.\n   *\n   * @param {Object} qce element to remove.\n   */\nQueryContextCache.prototype.removeQCE = function (qce) {\n  this.idMap.delete(qce.id);\n  this.priorityMap.delete(qce.priority);\n  this.treeSet.delete(qce);\n  Logger.getInstance().trace(`QCC session ${this.sessionId} - Removed QCE: ${JSON.stringify(qce)}`);\n};\n\n/**\n   * Replace the cache element with a new response element. Remove old element exist in the cache\n   * and add a new element received.\n   *\n   * @param {Object} oldQCE an element exist in the cache\n   * @param {Object} newQCE a new element just received.\n   */\nQueryContextCache.prototype.replaceQCE = function (oldQCE, newQCE) {\n\n  // Remove old element from the cache\n  this.removeQCE(oldQCE);\n  // Add new element in the cache\n  this.addQCE(newQCE);\n\n  Logger.getInstance().debug(`QCC session ${this.sessionId} - Replaced QCE: ${JSON.stringify(oldQCE)} with ${JSON.stringify(newQCE)}`);\n};\n\n/**\n   * Merge a new element comes from the server with the existing cache. Merge is based on read time\n   * stamp for the same id and based on priority for two different ids.\n   *\n   * @param {Number} id \n   * @param {Number} timestamp \n   * @param {Number} priority \n   * @param {String} context\n   * \n   */\nQueryContextCache.prototype.merge = function (newQCE) {\n  Logger.getInstance().debug(`QCC session ${this.sessionId} - Merging QCE: ${JSON.stringify(newQCE)}`);\n  if (this.idMap.has(newQCE.id)) {\n    Logger.getInstance().debug(`QCC session ${this.sessionId} - Element id ${newQCE.id} found in cache`);\n\n    // ID found in the cache\n    const qce = this.idMap.get(newQCE.id);\n    if (newQCE.timestamp > qce.timestamp) {\n      Logger.getInstance().trace(`QCC session ${this.sessionId} - New element is more recent. Current timestamp: ${qce.timestamp}, new timestamp: ${newQCE.timestamp}`);\n      if (qce.priority === newQCE.priority) {\n        Logger.getInstance().trace(`QCC session ${this.sessionId} - Element priority (${qce.priority}) is the same`);\n        // Same priority, overwrite new data at same place\n        qce.timestamp = newQCE.timestamp;\n        qce.context = newQCE.context;\n      } else {\n        Logger.getInstance().trace(`QCC session ${this.sessionId} - Element priority changed. Current priority: ${qce.priority}, new priority: ${newQCE.priority}`);\n        // Change in priority\n        this.replaceQCE(qce, newQCE);\n      } \n    } else if (newQCE.timestamp === qce.timestamp && qce.priority !== newQCE.priority) {\n      Logger.getInstance().trace(`QCC session ${this.sessionId} - Element timestamp is the same, but priority changes. Current priority: ${qce.priority}, new priority: ${newQCE.priority}`);\n      // Same read timestamp but change in priority\n      this.replaceQCE(qce, newQCE);\n    } else {\n      Logger.getInstance().trace(`QCC session ${this.sessionId} - Element is the same. Doing nothing.`);\n    }\n  } else {\n    Logger.getInstance().trace(`QCC session ${this.sessionId} - New element`);\n    // new id\n    if (this.priorityMap.has(newQCE.priority)) {\n\n      // Same priority with different id\n      const qce = this.priorityMap.get(newQCE.priority);\n\n      Logger.getInstance().trace(`QCC session ${this.sessionId} - Element with the same priority found: ${JSON.stringify(qce)}. Replacing with new element: ${JSON.stringify(newQCE)}`);\n      // Replace with new data\n      this.replaceQCE(qce, newQCE);\n    } else {\n      Logger.getInstance().debug(`QCC session ${this.sessionId} - Adding new element to the cache: ${JSON.stringify(newQCE)}`);\n      // new priority\n      // Add new element in the cache\n      this.addQCE(newQCE, newQCE);\n    }\n  }\n};\n\n/**\n   * After the merge, loop through priority list and make sure cache is at most capacity. Remove all\n   * other elements from the list based on priority.\n   */\nQueryContextCache.prototype.checkCacheCapacity = function () {\n  Logger.getInstance().trace(\n    `QCC session ${this.sessionId} - checkCacheCapacity() called. treeSet size ${this.treeSet.size}, cache capacity ${this.capacity}`);\n\n  // remove elements based on priority\n  while (this.treeSet.size > this.capacity) {\n    const qce = Array.from(this.treeSet).pop();\n    this.removeQCE(qce);\n  }\n  Logger.getInstance().trace(\n    `QCC session ${this.sessionId} - checkCacheCapacity() returns. treeSet size ${this.treeSet.size}, cache capacity ${this.capacity}`);\n};\n\n/** Clear the cache. */\nQueryContextCache.prototype.clearCache = function () {\n  Logger.getInstance().trace(`QCC session ${this.sessionId} - clearCache() called`);\n  this.idMap.clear();\n  this.priorityMap.clear();\n  this.treeSet.clear();\n  Logger.getInstance().trace(`QCC session ${this.sessionId} - clearCache() returns. Number of entries in cache now ${this.treeSet.size}`);\n};\n\nQueryContextCache.prototype.getElements = function () {\n  return this.treeSet;\n};\n\n/**\n * @param data: the QueryContext Object serialized as a JSON format string\n */\nQueryContextCache.prototype.deserializeQueryContext = function (data) {\n  const stringifyData = JSON.stringify(data);\n  Logger.getInstance().debug(`QCC session ${this.sessionId} - deserializeQueryContext() called: data from server: ${stringifyData}`);\n  if (!data || stringifyData === '{}' || data.entries === null) {\n\n    this.clearCache();\n    Logger.getInstance().trace(`QCC session ${this.sessionId} - deserializeQueryContext() returns`);\n    this.logCacheEntries();\n    return;\n  }\n  try {\n    // Deserialize the entries. The first entry with priority is the main entry. An example JSON is:\n    // {\n    //   \"entries\": [\n    //    {\n    //     \"id\": 0,\n    //     \"readtimestamp\": 123456789,\n    //     \"priority\": 0,\n    //     \"context\": \"base64 encoded context\"\n    //    },\n    //     {\n    //       \"id\": 1,\n    //       \"readtimestamp\": 123456789,\n    //       \"priority\": 1,\n    //       \"context\": \"base64 encoded context\"\n    //     },\n    //     {\n    //       \"id\": 2,\n    //       \"readtimestamp\": 123456789,\n    //       \"priority\": 2,\n    //       \"context\": \"base64 encoded context\"\n    //     }\n    //   ]\n\n    const entries = data.entries;\n    if (entries !== null && Array.isArray(entries)) {\n      for (const entryNode of entries) {\n        const entry = this.deserializeQueryContextElement(entryNode);\n        if (entry != null) {\n          this.merge(entry);\n        } else {\n          Logger.getInstance().warn(\n            `QCC session ${this.sessionId} - deserializeQueryContextJson: deserializeQueryContextElement meets mismatch field type. Clear the QueryContextCache.`);\n          this.clearCache();\n          return;\n        }\n      }\n     \n    }\n  } catch (e) {\n    Logger.getInstance().debug(`QCC session ${this.sessionId} - deserializeQueryContextJson: Exception = ${e.getMessage}`);\n\n    // Not rethrowing. clear the cache as incomplete merge can lead to unexpected behavior.\n    this.clearCache();\n  }\n\n  this.checkCacheCapacity();\n  this.logCacheEntries();\n}; \n\nQueryContextCache.prototype.deserializeQueryContextElement = function (node) {\n  const { id, timestamp, priority, context } = node;\n  const entry = new QueryContextElement (id, timestamp, priority, null);\n\n  if (typeof context === 'string'){\n    entry.context = context;\n  } else if (context === null || context === undefined) {  \n    entry.context = null;\n    Logger.getInstance().debug(`QCC session ${this.sessionId} - deserializeQueryContextElement \\`context\\` field is empty`);\n  } else {\n    Logger.getInstance().warn(`QCC session ${this.sessionId} - deserializeQueryContextElement: \\`context\\` field is not String type`);\n    return null;\n  }\n\n  return entry;\n};\n\nQueryContextCache.prototype.logCacheEntries = function () {\n\n  this.treeSet.forEach(function (elem) {\n    Logger.getInstance().debug(\n      `QCC session ${this.sessionId} - Cache Entry: id: ${elem.id} timestamp: ${elem.timestamp} priority: ${elem.priority}`);\n  }, this);\n};\n\nQueryContextCache.prototype.getSize = function () {\n  return this.treeSet.size;\n};\n\nQueryContextCache.prototype.getQueryContextDTO = function () {\n  const arr = [];\n  const querycontexts = Array.from(this.getElements());\n  for (let i = 0; i < this.treeSet.size; i++) {\n    arr.push({ id: querycontexts[i].id, timestamp: querycontexts[i].timestamp,\n      priority: querycontexts[i].priority, context: { base64Data: querycontexts[i].context } || null });\n  }\n  return {\n    entries: arr\n  };\n};\n\nQueryContextCache.prototype.getSerializeQueryContext = function () {\n  const arr = [];\n  const querycontexts = Array.from(this.getElements());\n  for (let i = 0; i < this.treeSet.size; i++) {\n    arr.push({ id: querycontexts[i].id, timestamp: querycontexts[i].timestamp, priority: querycontexts[i].priority, context: querycontexts[i].context || null });\n  }\n\n  return {\n    entries: arr\n  };\n};\n\nmodule.exports = QueryContextCache;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvcXVlcnlDb250ZXh0Q2FjaGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLGtFQUFVOztBQUVqQztBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLDZFQUE2RSxVQUFVLGNBQWMsVUFBVTtBQUMvRztBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCLDRCQUE0QjtBQUM1QixnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCLGVBQWUsb0JBQW9CO0FBQy9GOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQixpQkFBaUIsb0JBQW9CO0FBQ2pHOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRDQUE0QyxnQkFBZ0Isa0JBQWtCLHdCQUF3QixPQUFPLHVCQUF1QjtBQUNwSTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCLGlCQUFpQix1QkFBdUI7QUFDcEc7QUFDQSw4Q0FBOEMsZ0JBQWdCLGVBQWUsV0FBVzs7QUFFeEY7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGdCQUFnQixtREFBbUQsY0FBYyxtQkFBbUIsaUJBQWlCO0FBQ3JLO0FBQ0Esa0RBQWtELGdCQUFnQixzQkFBc0IsYUFBYTtBQUNyRztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1Isa0RBQWtELGdCQUFnQixnREFBZ0QsYUFBYSxrQkFBa0IsZ0JBQWdCO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixnREFBZ0QsZ0JBQWdCLDJFQUEyRSxhQUFhLGtCQUFrQixnQkFBZ0I7QUFDMUw7QUFDQTtBQUNBLE1BQU07QUFDTixnREFBZ0QsZ0JBQWdCO0FBQ2hFO0FBQ0EsSUFBSTtBQUNKLDhDQUE4QyxnQkFBZ0I7QUFDOUQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdEQUFnRCxnQkFBZ0IsMENBQTBDLG9CQUFvQixnQ0FBZ0MsdUJBQXVCO0FBQ3JMO0FBQ0E7QUFDQSxNQUFNO0FBQ04sZ0RBQWdELGdCQUFnQixxQ0FBcUMsdUJBQXVCO0FBQzVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCLDhDQUE4QyxrQkFBa0IsbUJBQW1CLGNBQWM7O0FBRXBJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0IsK0NBQStDLGtCQUFrQixtQkFBbUIsY0FBYztBQUNySTs7QUFFQTtBQUNBO0FBQ0EsNENBQTRDLGdCQUFnQjtBQUM1RDtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCLHlEQUF5RCxrQkFBa0I7QUFDdkk7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsZ0JBQWdCLHdEQUF3RCxjQUFjO0FBQ2xJLG9DQUFvQzs7QUFFcEM7QUFDQSw4Q0FBOEMsZ0JBQWdCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLDJCQUEyQixnQkFBZ0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLDhDQUE4QyxnQkFBZ0IsNkNBQTZDLGFBQWE7O0FBRXhIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLG1DQUFtQztBQUM3Qzs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsOENBQThDLGdCQUFnQjtBQUM5RCxJQUFJO0FBQ0osNkNBQTZDLGdCQUFnQjtBQUM3RDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLHFCQUFxQixnQkFBZ0IscUJBQXFCLFNBQVMsYUFBYSxnQkFBZ0IsWUFBWSxjQUFjO0FBQzFILEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QyxlQUFlO0FBQ2Ysc0RBQXNELHVDQUF1QyxTQUFTO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHVCQUF1QjtBQUN6QyxlQUFlLGdKQUFnSjtBQUMvSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9xdWVyeUNvbnRleHRDYWNoZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaWQgXG4gKiBAcGFyYW0ge051bWJlcn0gdGltZXN0YW1wIFxuICogQHBhcmFtIHtOdW1iZXJ9IHByaW9yaXR5IFxuICogQHBhcmFtIHtTdHJpbmd9IGNvbnRleHQgXG4gKi9cbmZ1bmN0aW9uIFF1ZXJ5Q29udGV4dEVsZW1lbnQoaWQsIHRpbWVzdGFtcCwgcHJpb3JpdHksIGNvbnRleHQpIHtcbiAgdGhpcy5pZCA9IGlkO1xuICB0aGlzLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgdGhpcy5wcmlvcml0eSA9IHByaW9yaXR5O1xuICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xufVxuXG4vKipcbiAqIE1vc3QgUmVjZW50bHkgVXNlZCBhbmQgUHJpb3JpdHkgYmFzZWQgY2FjaGUuIEEgc2VwYXJhdGUgY2FjaGUgZm9yIGVhY2ggY29ubmVjdGlvbiBpbiB0aGUgZHJpdmVyLlxuICovXG5cbi8qKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNhcGFjaXR5IE1heGltdW0gY2FwYWNpdHkgb2YgdGhlIGNhY2hlLlxuICogQHBhcmFtIHtOdW1iZXJ9IHNlc3Npb25JZCBTZXNzaW9uIGZvciB3aGljaCB0aGUgY2FjaGUgaXMgY3JlYXRlZC5cbiAqL1xuZnVuY3Rpb24gUXVlcnlDb250ZXh0Q2FjaGUoY2FwYWNpdHksIHNlc3Npb25JZCkge1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgQ3JlYXRpbmcgbmV3IFF1ZXJ5Q29udGV4dENhY2hlIHdpdGggY2FwYWNpdHkgJHtjYXBhY2l0eX0gZm9yIHNlc3Npb24gJHtzZXNzaW9uSWR9YCk7XG4gIHRoaXMuc2Vzc2lvbklkID0gc2Vzc2lvbklkO1xuICB0aGlzLmNhcGFjaXR5ID0gY2FwYWNpdHk7XG4gIHRoaXMuaWRNYXAgPSBuZXcgTWFwKCk7IC8vIE1hcCBmb3IgaWQgYW5kIFFDQ1xuICB0aGlzLnRyZWVTZXQgPSBuZXcgU2V0KCk7IC8vIE9yZGVyIGRhdGEgYXMgcGVyIHByaW9yaXR5XG4gIHRoaXMucHJpb3JpdHlNYXAgPSBuZXcgTWFwKCk7IC8vIE1hcCBmb3IgcHJpb3JpdHkgYW5kIFFDQ1xufVxuXG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuc29ydFRyZWVTZXQgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMudHJlZVNldCA9IG5ldyBTZXQoQXJyYXkuZnJvbSh0aGlzLnRyZWVTZXQpLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KSk7XG59O1xuXG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuYWRkUUNFID0gZnVuY3Rpb24gKHFjZSkge1xuICB0aGlzLmlkTWFwLnNldChxY2UuaWQsIHFjZSk7XG4gIHRoaXMucHJpb3JpdHlNYXAuc2V0KHFjZS5wcmlvcml0eSwgcWNlKTtcbiAgdGhpcy50cmVlU2V0LmFkZChxY2UpO1xuICB0aGlzLnNvcnRUcmVlU2V0KCk7XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIEFkZGVkIFFDRTogJHtKU09OLnN0cmluZ2lmeShxY2UpfWApO1xufTtcblxuLyoqXG4gICAqIFJlbW92ZSBhbiBlbGVtZW50IGZyb20gdGhlIGNhY2hlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcWNlIGVsZW1lbnQgdG8gcmVtb3ZlLlxuICAgKi9cblF1ZXJ5Q29udGV4dENhY2hlLnByb3RvdHlwZS5yZW1vdmVRQ0UgPSBmdW5jdGlvbiAocWNlKSB7XG4gIHRoaXMuaWRNYXAuZGVsZXRlKHFjZS5pZCk7XG4gIHRoaXMucHJpb3JpdHlNYXAuZGVsZXRlKHFjZS5wcmlvcml0eSk7XG4gIHRoaXMudHJlZVNldC5kZWxldGUocWNlKTtcbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gUmVtb3ZlZCBRQ0U6ICR7SlNPTi5zdHJpbmdpZnkocWNlKX1gKTtcbn07XG5cbi8qKlxuICAgKiBSZXBsYWNlIHRoZSBjYWNoZSBlbGVtZW50IHdpdGggYSBuZXcgcmVzcG9uc2UgZWxlbWVudC4gUmVtb3ZlIG9sZCBlbGVtZW50IGV4aXN0IGluIHRoZSBjYWNoZVxuICAgKiBhbmQgYWRkIGEgbmV3IGVsZW1lbnQgcmVjZWl2ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvbGRRQ0UgYW4gZWxlbWVudCBleGlzdCBpbiB0aGUgY2FjaGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG5ld1FDRSBhIG5ldyBlbGVtZW50IGp1c3QgcmVjZWl2ZWQuXG4gICAqL1xuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLnJlcGxhY2VRQ0UgPSBmdW5jdGlvbiAob2xkUUNFLCBuZXdRQ0UpIHtcblxuICAvLyBSZW1vdmUgb2xkIGVsZW1lbnQgZnJvbSB0aGUgY2FjaGVcbiAgdGhpcy5yZW1vdmVRQ0Uob2xkUUNFKTtcbiAgLy8gQWRkIG5ldyBlbGVtZW50IGluIHRoZSBjYWNoZVxuICB0aGlzLmFkZFFDRShuZXdRQ0UpO1xuXG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIFJlcGxhY2VkIFFDRTogJHtKU09OLnN0cmluZ2lmeShvbGRRQ0UpfSB3aXRoICR7SlNPTi5zdHJpbmdpZnkobmV3UUNFKX1gKTtcbn07XG5cbi8qKlxuICAgKiBNZXJnZSBhIG5ldyBlbGVtZW50IGNvbWVzIGZyb20gdGhlIHNlcnZlciB3aXRoIHRoZSBleGlzdGluZyBjYWNoZS4gTWVyZ2UgaXMgYmFzZWQgb24gcmVhZCB0aW1lXG4gICAqIHN0YW1wIGZvciB0aGUgc2FtZSBpZCBhbmQgYmFzZWQgb24gcHJpb3JpdHkgZm9yIHR3byBkaWZmZXJlbnQgaWRzLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gaWQgXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lc3RhbXAgXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBwcmlvcml0eSBcbiAgICogQHBhcmFtIHtTdHJpbmd9IGNvbnRleHRcbiAgICogXG4gICAqL1xuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLm1lcmdlID0gZnVuY3Rpb24gKG5ld1FDRSkge1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBNZXJnaW5nIFFDRTogJHtKU09OLnN0cmluZ2lmeShuZXdRQ0UpfWApO1xuICBpZiAodGhpcy5pZE1hcC5oYXMobmV3UUNFLmlkKSkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIEVsZW1lbnQgaWQgJHtuZXdRQ0UuaWR9IGZvdW5kIGluIGNhY2hlYCk7XG5cbiAgICAvLyBJRCBmb3VuZCBpbiB0aGUgY2FjaGVcbiAgICBjb25zdCBxY2UgPSB0aGlzLmlkTWFwLmdldChuZXdRQ0UuaWQpO1xuICAgIGlmIChuZXdRQ0UudGltZXN0YW1wID4gcWNlLnRpbWVzdGFtcCkge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gTmV3IGVsZW1lbnQgaXMgbW9yZSByZWNlbnQuIEN1cnJlbnQgdGltZXN0YW1wOiAke3FjZS50aW1lc3RhbXB9LCBuZXcgdGltZXN0YW1wOiAke25ld1FDRS50aW1lc3RhbXB9YCk7XG4gICAgICBpZiAocWNlLnByaW9yaXR5ID09PSBuZXdRQ0UucHJpb3JpdHkpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gRWxlbWVudCBwcmlvcml0eSAoJHtxY2UucHJpb3JpdHl9KSBpcyB0aGUgc2FtZWApO1xuICAgICAgICAvLyBTYW1lIHByaW9yaXR5LCBvdmVyd3JpdGUgbmV3IGRhdGEgYXQgc2FtZSBwbGFjZVxuICAgICAgICBxY2UudGltZXN0YW1wID0gbmV3UUNFLnRpbWVzdGFtcDtcbiAgICAgICAgcWNlLmNvbnRleHQgPSBuZXdRQ0UuY29udGV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIEVsZW1lbnQgcHJpb3JpdHkgY2hhbmdlZC4gQ3VycmVudCBwcmlvcml0eTogJHtxY2UucHJpb3JpdHl9LCBuZXcgcHJpb3JpdHk6ICR7bmV3UUNFLnByaW9yaXR5fWApO1xuICAgICAgICAvLyBDaGFuZ2UgaW4gcHJpb3JpdHlcbiAgICAgICAgdGhpcy5yZXBsYWNlUUNFKHFjZSwgbmV3UUNFKTtcbiAgICAgIH0gXG4gICAgfSBlbHNlIGlmIChuZXdRQ0UudGltZXN0YW1wID09PSBxY2UudGltZXN0YW1wICYmIHFjZS5wcmlvcml0eSAhPT0gbmV3UUNFLnByaW9yaXR5KSB7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBFbGVtZW50IHRpbWVzdGFtcCBpcyB0aGUgc2FtZSwgYnV0IHByaW9yaXR5IGNoYW5nZXMuIEN1cnJlbnQgcHJpb3JpdHk6ICR7cWNlLnByaW9yaXR5fSwgbmV3IHByaW9yaXR5OiAke25ld1FDRS5wcmlvcml0eX1gKTtcbiAgICAgIC8vIFNhbWUgcmVhZCB0aW1lc3RhbXAgYnV0IGNoYW5nZSBpbiBwcmlvcml0eVxuICAgICAgdGhpcy5yZXBsYWNlUUNFKHFjZSwgbmV3UUNFKTtcbiAgICB9IGVsc2Uge1xuICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gRWxlbWVudCBpcyB0aGUgc2FtZS4gRG9pbmcgbm90aGluZy5gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gTmV3IGVsZW1lbnRgKTtcbiAgICAvLyBuZXcgaWRcbiAgICBpZiAodGhpcy5wcmlvcml0eU1hcC5oYXMobmV3UUNFLnByaW9yaXR5KSkge1xuXG4gICAgICAvLyBTYW1lIHByaW9yaXR5IHdpdGggZGlmZmVyZW50IGlkXG4gICAgICBjb25zdCBxY2UgPSB0aGlzLnByaW9yaXR5TWFwLmdldChuZXdRQ0UucHJpb3JpdHkpO1xuXG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBFbGVtZW50IHdpdGggdGhlIHNhbWUgcHJpb3JpdHkgZm91bmQ6ICR7SlNPTi5zdHJpbmdpZnkocWNlKX0uIFJlcGxhY2luZyB3aXRoIG5ldyBlbGVtZW50OiAke0pTT04uc3RyaW5naWZ5KG5ld1FDRSl9YCk7XG4gICAgICAvLyBSZXBsYWNlIHdpdGggbmV3IGRhdGFcbiAgICAgIHRoaXMucmVwbGFjZVFDRShxY2UsIG5ld1FDRSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIEFkZGluZyBuZXcgZWxlbWVudCB0byB0aGUgY2FjaGU6ICR7SlNPTi5zdHJpbmdpZnkobmV3UUNFKX1gKTtcbiAgICAgIC8vIG5ldyBwcmlvcml0eVxuICAgICAgLy8gQWRkIG5ldyBlbGVtZW50IGluIHRoZSBjYWNoZVxuICAgICAgdGhpcy5hZGRRQ0UobmV3UUNFLCBuZXdRQ0UpO1xuICAgIH1cbiAgfVxufTtcblxuLyoqXG4gICAqIEFmdGVyIHRoZSBtZXJnZSwgbG9vcCB0aHJvdWdoIHByaW9yaXR5IGxpc3QgYW5kIG1ha2Ugc3VyZSBjYWNoZSBpcyBhdCBtb3N0IGNhcGFjaXR5LiBSZW1vdmUgYWxsXG4gICAqIG90aGVyIGVsZW1lbnRzIGZyb20gdGhlIGxpc3QgYmFzZWQgb24gcHJpb3JpdHkuXG4gICAqL1xuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLmNoZWNrQ2FjaGVDYXBhY2l0eSA9IGZ1bmN0aW9uICgpIHtcbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoXG4gICAgYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gY2hlY2tDYWNoZUNhcGFjaXR5KCkgY2FsbGVkLiB0cmVlU2V0IHNpemUgJHt0aGlzLnRyZWVTZXQuc2l6ZX0sIGNhY2hlIGNhcGFjaXR5ICR7dGhpcy5jYXBhY2l0eX1gKTtcblxuICAvLyByZW1vdmUgZWxlbWVudHMgYmFzZWQgb24gcHJpb3JpdHlcbiAgd2hpbGUgKHRoaXMudHJlZVNldC5zaXplID4gdGhpcy5jYXBhY2l0eSkge1xuICAgIGNvbnN0IHFjZSA9IEFycmF5LmZyb20odGhpcy50cmVlU2V0KS5wb3AoKTtcbiAgICB0aGlzLnJlbW92ZVFDRShxY2UpO1xuICB9XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKFxuICAgIGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIGNoZWNrQ2FjaGVDYXBhY2l0eSgpIHJldHVybnMuIHRyZWVTZXQgc2l6ZSAke3RoaXMudHJlZVNldC5zaXplfSwgY2FjaGUgY2FwYWNpdHkgJHt0aGlzLmNhcGFjaXR5fWApO1xufTtcblxuLyoqIENsZWFyIHRoZSBjYWNoZS4gKi9cblF1ZXJ5Q29udGV4dENhY2hlLnByb3RvdHlwZS5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS50cmFjZShgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBjbGVhckNhY2hlKCkgY2FsbGVkYCk7XG4gIHRoaXMuaWRNYXAuY2xlYXIoKTtcbiAgdGhpcy5wcmlvcml0eU1hcC5jbGVhcigpO1xuICB0aGlzLnRyZWVTZXQuY2xlYXIoKTtcbiAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gY2xlYXJDYWNoZSgpIHJldHVybnMuIE51bWJlciBvZiBlbnRyaWVzIGluIGNhY2hlIG5vdyAke3RoaXMudHJlZVNldC5zaXplfWApO1xufTtcblxuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLmdldEVsZW1lbnRzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy50cmVlU2V0O1xufTtcblxuLyoqXG4gKiBAcGFyYW0gZGF0YTogdGhlIFF1ZXJ5Q29udGV4dCBPYmplY3Qgc2VyaWFsaXplZCBhcyBhIEpTT04gZm9ybWF0IHN0cmluZ1xuICovXG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuZGVzZXJpYWxpemVRdWVyeUNvbnRleHQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICBjb25zdCBzdHJpbmdpZnlEYXRhID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIGRlc2VyaWFsaXplUXVlcnlDb250ZXh0KCkgY2FsbGVkOiBkYXRhIGZyb20gc2VydmVyOiAke3N0cmluZ2lmeURhdGF9YCk7XG4gIGlmICghZGF0YSB8fCBzdHJpbmdpZnlEYXRhID09PSAne30nIHx8IGRhdGEuZW50cmllcyA9PT0gbnVsbCkge1xuXG4gICAgdGhpcy5jbGVhckNhY2hlKCk7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gZGVzZXJpYWxpemVRdWVyeUNvbnRleHQoKSByZXR1cm5zYCk7XG4gICAgdGhpcy5sb2dDYWNoZUVudHJpZXMoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdHJ5IHtcbiAgICAvLyBEZXNlcmlhbGl6ZSB0aGUgZW50cmllcy4gVGhlIGZpcnN0IGVudHJ5IHdpdGggcHJpb3JpdHkgaXMgdGhlIG1haW4gZW50cnkuIEFuIGV4YW1wbGUgSlNPTiBpczpcbiAgICAvLyB7XG4gICAgLy8gICBcImVudHJpZXNcIjogW1xuICAgIC8vICAgIHtcbiAgICAvLyAgICAgXCJpZFwiOiAwLFxuICAgIC8vICAgICBcInJlYWR0aW1lc3RhbXBcIjogMTIzNDU2Nzg5LFxuICAgIC8vICAgICBcInByaW9yaXR5XCI6IDAsXG4gICAgLy8gICAgIFwiY29udGV4dFwiOiBcImJhc2U2NCBlbmNvZGVkIGNvbnRleHRcIlxuICAgIC8vICAgIH0sXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICBcImlkXCI6IDEsXG4gICAgLy8gICAgICAgXCJyZWFkdGltZXN0YW1wXCI6IDEyMzQ1Njc4OSxcbiAgICAvLyAgICAgICBcInByaW9yaXR5XCI6IDEsXG4gICAgLy8gICAgICAgXCJjb250ZXh0XCI6IFwiYmFzZTY0IGVuY29kZWQgY29udGV4dFwiXG4gICAgLy8gICAgIH0sXG4gICAgLy8gICAgIHtcbiAgICAvLyAgICAgICBcImlkXCI6IDIsXG4gICAgLy8gICAgICAgXCJyZWFkdGltZXN0YW1wXCI6IDEyMzQ1Njc4OSxcbiAgICAvLyAgICAgICBcInByaW9yaXR5XCI6IDIsXG4gICAgLy8gICAgICAgXCJjb250ZXh0XCI6IFwiYmFzZTY0IGVuY29kZWQgY29udGV4dFwiXG4gICAgLy8gICAgIH1cbiAgICAvLyAgIF1cblxuICAgIGNvbnN0IGVudHJpZXMgPSBkYXRhLmVudHJpZXM7XG4gICAgaWYgKGVudHJpZXMgIT09IG51bGwgJiYgQXJyYXkuaXNBcnJheShlbnRyaWVzKSkge1xuICAgICAgZm9yIChjb25zdCBlbnRyeU5vZGUgb2YgZW50cmllcykge1xuICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXMuZGVzZXJpYWxpemVRdWVyeUNvbnRleHRFbGVtZW50KGVudHJ5Tm9kZSk7XG4gICAgICAgIGlmIChlbnRyeSAhPSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5tZXJnZShlbnRyeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkud2FybihcbiAgICAgICAgICAgIGBRQ0Mgc2Vzc2lvbiAke3RoaXMuc2Vzc2lvbklkfSAtIGRlc2VyaWFsaXplUXVlcnlDb250ZXh0SnNvbjogZGVzZXJpYWxpemVRdWVyeUNvbnRleHRFbGVtZW50IG1lZXRzIG1pc21hdGNoIGZpZWxkIHR5cGUuIENsZWFyIHRoZSBRdWVyeUNvbnRleHRDYWNoZS5gKTtcbiAgICAgICAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgXG4gICAgfVxuICB9IGNhdGNoIChlKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gZGVzZXJpYWxpemVRdWVyeUNvbnRleHRKc29uOiBFeGNlcHRpb24gPSAke2UuZ2V0TWVzc2FnZX1gKTtcblxuICAgIC8vIE5vdCByZXRocm93aW5nLiBjbGVhciB0aGUgY2FjaGUgYXMgaW5jb21wbGV0ZSBtZXJnZSBjYW4gbGVhZCB0byB1bmV4cGVjdGVkIGJlaGF2aW9yLlxuICAgIHRoaXMuY2xlYXJDYWNoZSgpO1xuICB9XG5cbiAgdGhpcy5jaGVja0NhY2hlQ2FwYWNpdHkoKTtcbiAgdGhpcy5sb2dDYWNoZUVudHJpZXMoKTtcbn07IFxuXG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuZGVzZXJpYWxpemVRdWVyeUNvbnRleHRFbGVtZW50ID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgY29uc3QgeyBpZCwgdGltZXN0YW1wLCBwcmlvcml0eSwgY29udGV4dCB9ID0gbm9kZTtcbiAgY29uc3QgZW50cnkgPSBuZXcgUXVlcnlDb250ZXh0RWxlbWVudCAoaWQsIHRpbWVzdGFtcCwgcHJpb3JpdHksIG51bGwpO1xuXG4gIGlmICh0eXBlb2YgY29udGV4dCA9PT0gJ3N0cmluZycpe1xuICAgIGVudHJ5LmNvbnRleHQgPSBjb250ZXh0O1xuICB9IGVsc2UgaWYgKGNvbnRleHQgPT09IG51bGwgfHwgY29udGV4dCA9PT0gdW5kZWZpbmVkKSB7ICBcbiAgICBlbnRyeS5jb250ZXh0ID0gbnVsbDtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgUUNDIHNlc3Npb24gJHt0aGlzLnNlc3Npb25JZH0gLSBkZXNlcmlhbGl6ZVF1ZXJ5Q29udGV4dEVsZW1lbnQgXFxgY29udGV4dFxcYCBmaWVsZCBpcyBlbXB0eWApO1xuICB9IGVsc2Uge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLndhcm4oYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gZGVzZXJpYWxpemVRdWVyeUNvbnRleHRFbGVtZW50OiBcXGBjb250ZXh0XFxgIGZpZWxkIGlzIG5vdCBTdHJpbmcgdHlwZWApO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIGVudHJ5O1xufTtcblxuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLmxvZ0NhY2hlRW50cmllcyA9IGZ1bmN0aW9uICgpIHtcblxuICB0aGlzLnRyZWVTZXQuZm9yRWFjaChmdW5jdGlvbiAoZWxlbSkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKFxuICAgICAgYFFDQyBzZXNzaW9uICR7dGhpcy5zZXNzaW9uSWR9IC0gQ2FjaGUgRW50cnk6IGlkOiAke2VsZW0uaWR9IHRpbWVzdGFtcDogJHtlbGVtLnRpbWVzdGFtcH0gcHJpb3JpdHk6ICR7ZWxlbS5wcmlvcml0eX1gKTtcbiAgfSwgdGhpcyk7XG59O1xuXG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuZ2V0U2l6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXMudHJlZVNldC5zaXplO1xufTtcblxuUXVlcnlDb250ZXh0Q2FjaGUucHJvdG90eXBlLmdldFF1ZXJ5Q29udGV4dERUTyA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYXJyID0gW107XG4gIGNvbnN0IHF1ZXJ5Y29udGV4dHMgPSBBcnJheS5mcm9tKHRoaXMuZ2V0RWxlbWVudHMoKSk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy50cmVlU2V0LnNpemU7IGkrKykge1xuICAgIGFyci5wdXNoKHsgaWQ6IHF1ZXJ5Y29udGV4dHNbaV0uaWQsIHRpbWVzdGFtcDogcXVlcnljb250ZXh0c1tpXS50aW1lc3RhbXAsXG4gICAgICBwcmlvcml0eTogcXVlcnljb250ZXh0c1tpXS5wcmlvcml0eSwgY29udGV4dDogeyBiYXNlNjREYXRhOiBxdWVyeWNvbnRleHRzW2ldLmNvbnRleHQgfSB8fCBudWxsIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgZW50cmllczogYXJyXG4gIH07XG59O1xuXG5RdWVyeUNvbnRleHRDYWNoZS5wcm90b3R5cGUuZ2V0U2VyaWFsaXplUXVlcnlDb250ZXh0ID0gZnVuY3Rpb24gKCkge1xuICBjb25zdCBhcnIgPSBbXTtcbiAgY29uc3QgcXVlcnljb250ZXh0cyA9IEFycmF5LmZyb20odGhpcy5nZXRFbGVtZW50cygpKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnRyZWVTZXQuc2l6ZTsgaSsrKSB7XG4gICAgYXJyLnB1c2goeyBpZDogcXVlcnljb250ZXh0c1tpXS5pZCwgdGltZXN0YW1wOiBxdWVyeWNvbnRleHRzW2ldLnRpbWVzdGFtcCwgcHJpb3JpdHk6IHF1ZXJ5Y29udGV4dHNbaV0ucHJpb3JpdHksIGNvbnRleHQ6IHF1ZXJ5Y29udGV4dHNbaV0uY29udGV4dCB8fCBudWxsIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbnRyaWVzOiBhcnJcbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gUXVlcnlDb250ZXh0Q2FjaGU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/queryContextCache.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/secret_detector.js":
/*!***********************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/secret_detector.js ***!
  \***********************************************************/
/***/ ((module) => {

eval("/**\n * The secret detector detects sensitive information.\n * It masks secrets that might be leaked from two potential avenues\n *  1. Out of Band Telemetry\n *  2. Logging\n *  \n* @param {Object} customPatterns contains 'regex' and 'mask' for customized masking\n * @param {Object} mock\n * \n * @returns {Object}\n * @constructor\n */\nfunction SecretDetector(customPatterns, mock) {\n  const CUSTOM_PATTERNS_REGEX = [];\n  const CUSTOM_PATTERNS_MASK = [];\n  let CUSTOM_PATTERNS_LENGTH;\n\n  if (customPatterns) {\n    // Check that the customPatterns object contains the keys 'regex' and 'mask\n    if (!customPatterns.regex) {\n      throw new Error('The customPatterns object must contain the \\'regex\\' key');\n    }\n    if (!customPatterns.mask) {\n      throw new Error('The customPatterns object must contain the \\'mask\\' key');\n    }\n    // Also check that their lengths are equal\n    if (customPatterns.regex.length !== customPatterns.mask.length) {\n      throw new Error('The customPatterns object must have equal length for both \\'regex\\' and \\'mask\\'');\n    }\n\n    CUSTOM_PATTERNS_LENGTH = customPatterns.regex.length;\n\n    // Push the regex and mask elements onto their respective arrays\n    for (let index = 0; index < CUSTOM_PATTERNS_LENGTH; index++) {\n      CUSTOM_PATTERNS_REGEX.push(new RegExp(`${customPatterns.regex[index]}`, 'gi'));\n      CUSTOM_PATTERNS_MASK.push(String.raw`${customPatterns.mask[index]}`);\n    }\n  }\n\n  function maskCustomPattern(text) {\n    let result;\n    for (let index = 0; index < CUSTOM_PATTERNS_LENGTH; index++) {\n      result = text.replace(CUSTOM_PATTERNS_REGEX[index], CUSTOM_PATTERNS_MASK[index]);\n      // If the text is replaced, return the result\n      if (text !== result) {\n        return result;\n      }\n    }\n    // If text is unchanged, return the original\n    return text;\n  }\n\n  const AWS_KEY_PATTERN = new RegExp(String.raw`(aws_key_id|aws_secret_key|access_key_id|secret_access_key)\\s*=\\s*'([^']+)'`,\n    'gi');\n  const AWS_TOKEN_PATTERN = new RegExp(String.raw`(accessToken|tempToken|keySecret)\\s*:\\s*\"([a-z0-9/+]{32,}={0,2})\"`,\n    'gi');\n  const SAS_TOKEN_PATTERN = new RegExp(String.raw`(sig|signature|AWSAccessKeyId|password|passcode)=(\\?P<secret>[a-z0-9%/+]{16,})`,\n    'gi');\n  const PRIVATE_KEY_PATTERN = new RegExp(String.raw`-----BEGIN PRIVATE KEY-----\\\\n([a-z0-9/+=\\\\n]{32,})\\\\n-----END PRIVATE KEY-----`, // pragma: allowlist secret\n    'gim');\n  const PRIVATE_KEY_DATA_PATTERN = new RegExp(String.raw`\"privateKeyData\": \"([a-z0-9/+=\\\\n]{10,})\"`,\n    'gim');\n  // Colon in the group ([a-z0-9=/:_%-+]{8,}) was added to detect tokens that contain additional details before the actual token.\n  // Such as version or hint (token=ver:1-hint:1233-realToken...).\n  const CONNECTION_TOKEN_PATTERN = new RegExp(String.raw`(token|assertion content)([\\'\\\"\\s:=]+)([a-z0-9=/:_\\%\\-\\+]{8,})`,\n    'gi');\n  const PASSWORD_PATTERN = new RegExp(\n    String.raw`(password|pwd)([\\'\\\"\\s:=]+)([a-z0-9!\\\"#\\$%&\\\\\\'\\(\\)\\*\\+\\,-\\./:;<=>\\?\\@\\[\\]\\^_` +\n    '`' +\n    String.raw`\\{\\|\\}~]{8,})`,\n    'gi');\n  const PASSCODE_PATTERN = new RegExp(String.raw`(passcode|otp|pin|otac)\\s*([:=])\\s*([0-9]{4,6})`, 'gi');\n\n\n  function maskAwsKeys(text) {\n    return text.replace(AWS_KEY_PATTERN, String.raw`$1$2****`);\n  }\n\n  function maskAwsToken(text) {\n    return text.replace(AWS_TOKEN_PATTERN, String.raw`$1\":\"XXXX\"`);\n  }\n\n  function maskSasToken(text) {\n    return text.replace(SAS_TOKEN_PATTERN, String.raw`$1=****`);\n  }\n\n  function maskPrivateKey(text) {\n    return text.replace(PRIVATE_KEY_PATTERN, String.raw`-----BEGIN PRIVATE KEY-----\\\\\\\\nXXXX\\\\\\\\n-----END PRIVATE KEY-----`); // pragma: allowlist secret\n  }\n\n  function maskPrivateKeyData(text) {\n    return text.replace(PRIVATE_KEY_DATA_PATTERN, String.raw`\"privateKeyData\": \"XXXX\"`);\n  }\n\n  function maskConnectionToken(text) {\n    return text.replace(CONNECTION_TOKEN_PATTERN, String.raw`$1$2****`);\n  }\n\n  function maskPassword(text) {\n    return text.replace(PASSWORD_PATTERN, String.raw`$1$2****`);\n  }\n\n  function maskPasscode(text) {\n    return text.replace(PASSCODE_PATTERN, String.raw`$1$2****`);\n  }\n\n\n  /**\n   * Masks any secrets.\n   *\n   * @param {String} text may contain a secret.\n   *\n   * @returns {Object} the masked string.\n   */\n  this.maskSecrets = function (text) {\n    let result;\n    if (!text) {\n      result =\n      {\n        masked: false,\n        maskedtxt: text,\n        errstr: null\n      };\n      return result;\n    }\n\n    let masked = false;\n    let maskedtxt = '';\n    let errstr = null;\n    try {\n      if (mock) {\n        mock.execute();\n      }\n\n      maskedtxt =\n        maskPasscode(\n          maskConnectionToken(\n            maskPassword(\n              maskPrivateKeyData(\n                maskPrivateKey(\n                  maskAwsToken(\n                    maskSasToken(\n                      maskAwsKeys(text)\n                    )\n                  )\n                )\n              )\n            )\n          )\n        );\n      if (CUSTOM_PATTERNS_LENGTH > 0) {\n        maskedtxt = maskCustomPattern(maskedtxt);\n      }\n      if (maskedtxt !== text) {\n        masked = true;\n      }\n    } catch (err) {\n      masked = true;\n      maskedtxt = err.toString();\n      errstr = err.toString();\n    }\n\n    result =\n    {\n      masked: masked,\n      maskedtxt: maskedtxt,\n      errstr: errstr\n    };\n    return result;\n  };\n}\n\nmodule.exports = SecretDetector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvc2VjcmV0X2RldGVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsUUFBUTtBQUNsQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQsK0NBQStDLDRCQUE0QjtBQUMzRSw2Q0FBNkMsMkJBQTJCO0FBQ3hFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixnQ0FBZ0M7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1R0FBdUcsSUFBSSxFQUFFLElBQUk7QUFDakg7QUFDQSwySEFBMkgsSUFBSTtBQUMvSDtBQUNBLGtHQUFrRyxJQUFJO0FBQ3RHO0FBQ0EsNEZBQTRGLElBQUk7QUFDaEc7QUFDQSx5Q0FBeUMsR0FBRztBQUM1QztBQUNBLG1IQUFtSCxHQUFHO0FBQ3RIO0FBQ0E7QUFDQSw4RUFBOEU7QUFDOUU7QUFDQSxpQkFBaUIsSUFBSSxHQUFHLEdBQUc7QUFDM0I7QUFDQSwyRkFBMkYsSUFBSTs7O0FBRy9GO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOEhBQThIO0FBQzlIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvc2VjcmV0X2RldGVjdG9yLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogVGhlIHNlY3JldCBkZXRlY3RvciBkZXRlY3RzIHNlbnNpdGl2ZSBpbmZvcm1hdGlvbi5cbiAqIEl0IG1hc2tzIHNlY3JldHMgdGhhdCBtaWdodCBiZSBsZWFrZWQgZnJvbSB0d28gcG90ZW50aWFsIGF2ZW51ZXNcbiAqICAxLiBPdXQgb2YgQmFuZCBUZWxlbWV0cnlcbiAqICAyLiBMb2dnaW5nXG4gKiAgXG4qIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21QYXR0ZXJucyBjb250YWlucyAncmVnZXgnIGFuZCAnbWFzaycgZm9yIGN1c3RvbWl6ZWQgbWFza2luZ1xuICogQHBhcmFtIHtPYmplY3R9IG1vY2tcbiAqIFxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTZWNyZXREZXRlY3RvcihjdXN0b21QYXR0ZXJucywgbW9jaykge1xuICBjb25zdCBDVVNUT01fUEFUVEVSTlNfUkVHRVggPSBbXTtcbiAgY29uc3QgQ1VTVE9NX1BBVFRFUk5TX01BU0sgPSBbXTtcbiAgbGV0IENVU1RPTV9QQVRURVJOU19MRU5HVEg7XG5cbiAgaWYgKGN1c3RvbVBhdHRlcm5zKSB7XG4gICAgLy8gQ2hlY2sgdGhhdCB0aGUgY3VzdG9tUGF0dGVybnMgb2JqZWN0IGNvbnRhaW5zIHRoZSBrZXlzICdyZWdleCcgYW5kICdtYXNrXG4gICAgaWYgKCFjdXN0b21QYXR0ZXJucy5yZWdleCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VzdG9tUGF0dGVybnMgb2JqZWN0IG11c3QgY29udGFpbiB0aGUgXFwncmVnZXhcXCcga2V5Jyk7XG4gICAgfVxuICAgIGlmICghY3VzdG9tUGF0dGVybnMubWFzaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgY3VzdG9tUGF0dGVybnMgb2JqZWN0IG11c3QgY29udGFpbiB0aGUgXFwnbWFza1xcJyBrZXknKTtcbiAgICB9XG4gICAgLy8gQWxzbyBjaGVjayB0aGF0IHRoZWlyIGxlbmd0aHMgYXJlIGVxdWFsXG4gICAgaWYgKGN1c3RvbVBhdHRlcm5zLnJlZ2V4Lmxlbmd0aCAhPT0gY3VzdG9tUGF0dGVybnMubWFzay5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIGN1c3RvbVBhdHRlcm5zIG9iamVjdCBtdXN0IGhhdmUgZXF1YWwgbGVuZ3RoIGZvciBib3RoIFxcJ3JlZ2V4XFwnIGFuZCBcXCdtYXNrXFwnJyk7XG4gICAgfVxuXG4gICAgQ1VTVE9NX1BBVFRFUk5TX0xFTkdUSCA9IGN1c3RvbVBhdHRlcm5zLnJlZ2V4Lmxlbmd0aDtcblxuICAgIC8vIFB1c2ggdGhlIHJlZ2V4IGFuZCBtYXNrIGVsZW1lbnRzIG9udG8gdGhlaXIgcmVzcGVjdGl2ZSBhcnJheXNcbiAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgQ1VTVE9NX1BBVFRFUk5TX0xFTkdUSDsgaW5kZXgrKykge1xuICAgICAgQ1VTVE9NX1BBVFRFUk5TX1JFR0VYLnB1c2gobmV3IFJlZ0V4cChgJHtjdXN0b21QYXR0ZXJucy5yZWdleFtpbmRleF19YCwgJ2dpJykpO1xuICAgICAgQ1VTVE9NX1BBVFRFUk5TX01BU0sucHVzaChTdHJpbmcucmF3YCR7Y3VzdG9tUGF0dGVybnMubWFza1tpbmRleF19YCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWFza0N1c3RvbVBhdHRlcm4odGV4dCkge1xuICAgIGxldCByZXN1bHQ7XG4gICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IENVU1RPTV9QQVRURVJOU19MRU5HVEg7IGluZGV4KyspIHtcbiAgICAgIHJlc3VsdCA9IHRleHQucmVwbGFjZShDVVNUT01fUEFUVEVSTlNfUkVHRVhbaW5kZXhdLCBDVVNUT01fUEFUVEVSTlNfTUFTS1tpbmRleF0pO1xuICAgICAgLy8gSWYgdGhlIHRleHQgaXMgcmVwbGFjZWQsIHJldHVybiB0aGUgcmVzdWx0XG4gICAgICBpZiAodGV4dCAhPT0gcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRleHQgaXMgdW5jaGFuZ2VkLCByZXR1cm4gdGhlIG9yaWdpbmFsXG4gICAgcmV0dXJuIHRleHQ7XG4gIH1cblxuICBjb25zdCBBV1NfS0VZX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFN0cmluZy5yYXdgKGF3c19rZXlfaWR8YXdzX3NlY3JldF9rZXl8YWNjZXNzX2tleV9pZHxzZWNyZXRfYWNjZXNzX2tleSlcXHMqPVxccyonKFteJ10rKSdgLFxuICAgICdnaScpO1xuICBjb25zdCBBV1NfVE9LRU5fUEFUVEVSTiA9IG5ldyBSZWdFeHAoU3RyaW5nLnJhd2AoYWNjZXNzVG9rZW58dGVtcFRva2VufGtleVNlY3JldClcXHMqOlxccypcIihbYS16MC05LytdezMyLH09ezAsMn0pXCJgLFxuICAgICdnaScpO1xuICBjb25zdCBTQVNfVE9LRU5fUEFUVEVSTiA9IG5ldyBSZWdFeHAoU3RyaW5nLnJhd2Aoc2lnfHNpZ25hdHVyZXxBV1NBY2Nlc3NLZXlJZHxwYXNzd29yZHxwYXNzY29kZSk9KFxcP1A8c2VjcmV0PlthLXowLTklLytdezE2LH0pYCxcbiAgICAnZ2knKTtcbiAgY29uc3QgUFJJVkFURV9LRVlfUEFUVEVSTiA9IG5ldyBSZWdFeHAoU3RyaW5nLnJhd2AtLS0tLUJFR0lOIFBSSVZBVEUgS0VZLS0tLS1cXFxcbihbYS16MC05Lys9XFxcXG5dezMyLH0pXFxcXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYCwgLy8gcHJhZ21hOiBhbGxvd2xpc3Qgc2VjcmV0XG4gICAgJ2dpbScpO1xuICBjb25zdCBQUklWQVRFX0tFWV9EQVRBX1BBVFRFUk4gPSBuZXcgUmVnRXhwKFN0cmluZy5yYXdgXCJwcml2YXRlS2V5RGF0YVwiOiBcIihbYS16MC05Lys9XFxcXG5dezEwLH0pXCJgLFxuICAgICdnaW0nKTtcbiAgLy8gQ29sb24gaW4gdGhlIGdyb3VwIChbYS16MC05PS86XyUtK117OCx9KSB3YXMgYWRkZWQgdG8gZGV0ZWN0IHRva2VucyB0aGF0IGNvbnRhaW4gYWRkaXRpb25hbCBkZXRhaWxzIGJlZm9yZSB0aGUgYWN0dWFsIHRva2VuLlxuICAvLyBTdWNoIGFzIHZlcnNpb24gb3IgaGludCAodG9rZW49dmVyOjEtaGludDoxMjMzLXJlYWxUb2tlbi4uLikuXG4gIGNvbnN0IENPTk5FQ1RJT05fVE9LRU5fUEFUVEVSTiA9IG5ldyBSZWdFeHAoU3RyaW5nLnJhd2AodG9rZW58YXNzZXJ0aW9uIGNvbnRlbnQpKFtcXCdcXFwiXFxzOj1dKykoW2EtejAtOT0vOl9cXCVcXC1cXCtdezgsfSlgLFxuICAgICdnaScpO1xuICBjb25zdCBQQVNTV09SRF9QQVRURVJOID0gbmV3IFJlZ0V4cChcbiAgICBTdHJpbmcucmF3YChwYXNzd29yZHxwd2QpKFtcXCdcXFwiXFxzOj1dKykoW2EtejAtOSFcXFwiI1xcJCUmXFxcXFxcJ1xcKFxcKVxcKlxcK1xcLC1cXC4vOjs8PT5cXD9cXEBcXFtcXF1cXF5fYCArXG4gICAgJ2AnICtcbiAgICBTdHJpbmcucmF3YFxce1xcfFxcfX5dezgsfSlgLFxuICAgICdnaScpO1xuICBjb25zdCBQQVNTQ09ERV9QQVRURVJOID0gbmV3IFJlZ0V4cChTdHJpbmcucmF3YChwYXNzY29kZXxvdHB8cGlufG90YWMpXFxzKihbOj1dKVxccyooWzAtOV17NCw2fSlgLCAnZ2knKTtcblxuXG4gIGZ1bmN0aW9uIG1hc2tBd3NLZXlzKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKEFXU19LRVlfUEFUVEVSTiwgU3RyaW5nLnJhd2AkMSQyKioqKmApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFza0F3c1Rva2VuKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKEFXU19UT0tFTl9QQVRURVJOLCBTdHJpbmcucmF3YCQxXCI6XCJYWFhYXCJgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hc2tTYXNUb2tlbih0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZShTQVNfVE9LRU5fUEFUVEVSTiwgU3RyaW5nLnJhd2AkMT0qKioqYCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXNrUHJpdmF0ZUtleSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZShQUklWQVRFX0tFWV9QQVRURVJOLCBTdHJpbmcucmF3YC0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLVxcXFxcXFxcblhYWFhcXFxcXFxcXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tYCk7IC8vIHByYWdtYTogYWxsb3dsaXN0IHNlY3JldFxuICB9XG5cbiAgZnVuY3Rpb24gbWFza1ByaXZhdGVLZXlEYXRhKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKFBSSVZBVEVfS0VZX0RBVEFfUEFUVEVSTiwgU3RyaW5nLnJhd2BcInByaXZhdGVLZXlEYXRhXCI6IFwiWFhYWFwiYCk7XG4gIH1cblxuICBmdW5jdGlvbiBtYXNrQ29ubmVjdGlvblRva2VuKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKENPTk5FQ1RJT05fVE9LRU5fUEFUVEVSTiwgU3RyaW5nLnJhd2AkMSQyKioqKmApO1xuICB9XG5cbiAgZnVuY3Rpb24gbWFza1Bhc3N3b3JkKHRleHQpIHtcbiAgICByZXR1cm4gdGV4dC5yZXBsYWNlKFBBU1NXT1JEX1BBVFRFUk4sIFN0cmluZy5yYXdgJDEkMioqKipgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1hc2tQYXNzY29kZSh0ZXh0KSB7XG4gICAgcmV0dXJuIHRleHQucmVwbGFjZShQQVNTQ09ERV9QQVRURVJOLCBTdHJpbmcucmF3YCQxJDIqKioqYCk7XG4gIH1cblxuXG4gIC8qKlxuICAgKiBNYXNrcyBhbnkgc2VjcmV0cy5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHRleHQgbWF5IGNvbnRhaW4gYSBzZWNyZXQuXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IHRoZSBtYXNrZWQgc3RyaW5nLlxuICAgKi9cbiAgdGhpcy5tYXNrU2VjcmV0cyA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJlc3VsdCA9XG4gICAgICB7XG4gICAgICAgIG1hc2tlZDogZmFsc2UsXG4gICAgICAgIG1hc2tlZHR4dDogdGV4dCxcbiAgICAgICAgZXJyc3RyOiBudWxsXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBsZXQgbWFza2VkID0gZmFsc2U7XG4gICAgbGV0IG1hc2tlZHR4dCA9ICcnO1xuICAgIGxldCBlcnJzdHIgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICBpZiAobW9jaykge1xuICAgICAgICBtb2NrLmV4ZWN1dGUoKTtcbiAgICAgIH1cblxuICAgICAgbWFza2VkdHh0ID1cbiAgICAgICAgbWFza1Bhc3Njb2RlKFxuICAgICAgICAgIG1hc2tDb25uZWN0aW9uVG9rZW4oXG4gICAgICAgICAgICBtYXNrUGFzc3dvcmQoXG4gICAgICAgICAgICAgIG1hc2tQcml2YXRlS2V5RGF0YShcbiAgICAgICAgICAgICAgICBtYXNrUHJpdmF0ZUtleShcbiAgICAgICAgICAgICAgICAgIG1hc2tBd3NUb2tlbihcbiAgICAgICAgICAgICAgICAgICAgbWFza1Nhc1Rva2VuKFxuICAgICAgICAgICAgICAgICAgICAgIG1hc2tBd3NLZXlzKHRleHQpXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgIClcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICBpZiAoQ1VTVE9NX1BBVFRFUk5TX0xFTkdUSCA+IDApIHtcbiAgICAgICAgbWFza2VkdHh0ID0gbWFza0N1c3RvbVBhdHRlcm4obWFza2VkdHh0KTtcbiAgICAgIH1cbiAgICAgIGlmIChtYXNrZWR0eHQgIT09IHRleHQpIHtcbiAgICAgICAgbWFza2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIG1hc2tlZCA9IHRydWU7XG4gICAgICBtYXNrZWR0eHQgPSBlcnIudG9TdHJpbmcoKTtcbiAgICAgIGVycnN0ciA9IGVyci50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHJlc3VsdCA9XG4gICAge1xuICAgICAgbWFza2VkOiBtYXNrZWQsXG4gICAgICBtYXNrZWR0eHQ6IG1hc2tlZHR4dCxcbiAgICAgIGVycnN0cjogZXJyc3RyXG4gICAgfTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlY3JldERldGVjdG9yO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/secret_detector.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/services/large_result_set.js":
/*!*********************************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/services/large_result_set.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst ErrorCodes = Errors.codes;\n\n/**\n * Creates a new instance of an LargeResultSetService.\n *\n * @param {Object} connectionConfig\n * @param {Object} httpClient\n * @constructor\n */\nfunction LargeResultSetService(connectionConfig, httpClient) {\n  // validate input\n  Errors.assertInternal(Util.isObject(connectionConfig));\n  Errors.assertInternal(Util.isObject(httpClient));\n\n  /**\n   * Should HTTP client error be retried\n   * @param err Client error or null/undefined\n   * @return {boolean}\n   */\n  function isRetryableClientError(err) {\n    return err && (\n      err.code === 'ECONNRESET' ||\n        err.code === 'ETIMEDOUT' ||\n        // error code ECONNABORTED is thrown from axios on timeout\n        (err.name === 'AxiosError' && err.code === 'ECONNABORTED')\n    );\n  }\n\n  function isRetryableError(response, err) {\n    // https://aws.amazon.com/articles/1904 (Handling Errors)\n    // Note: 403's are retried because of a bug in S3/Blob\n    return Util.isRetryableHttpError(response, true) || isRetryableClientError(err);\n  }\n\n  function isUnsuccessfulResponse(response) {\n    // even for 200 OK S3 can return xml error (large files are normally binary)\n    return response && (response.statusCode !== 200 || response.getResponseHeader('Content-Type') === 'application/xml');\n  }\n\n  /**\n   * Issues a request to get an object from S3/Blob.\n   *\n   * @param {Object} options\n   */\n  this.getObject = function getObject(options) {\n    let numRetries = 0, sleep = 1;\n\n    // get the maximum number of retries\n    let maxNumRetries = options.maxNumRetries;\n    if (!Util.exists(maxNumRetries)) {\n      maxNumRetries = connectionConfig.getRetryLargeResultSetMaxNumRetries();\n    }\n    Errors.assertInternal(Util.isNumber(maxNumRetries) && maxNumRetries >= 0);\n\n    // invoked when the request completes\n    const callback = function callback(err, response, body) {\n      // err happens on timeouts and response is passed when server responded\n      if (err || isUnsuccessfulResponse(response)) {\n        // if we're running in DEBUG loglevel, probably we want to see the full error too\n        const logErr = err ? JSON.stringify(err, Object.getOwnPropertyNames(err))\n          : `status: ${JSON.stringify(response.status)} ${JSON.stringify(response.statusText)}`\n            + ` headers: ${JSON.stringify(response.headers)}`;\n        Logger.getInstance().debug('Encountered an error when getting data from cloud storage: ' + logErr);\n        // if we haven't exceeded the maximum number of retries yet and the\n        // server came back with a retryable error code.\n        if (numRetries < maxNumRetries && isRetryableError(response, err)) {\n          // increment the number of retries\n          numRetries++;\n\n          // use exponential backoff with decorrelated jitter to compute the\n          // next sleep time:\n          const cap = connectionConfig.getRetryLargeResultSetMaxSleepTime();\n          sleep = Util.nextSleepTime(1, cap, sleep);\n\n          // wait the appropriate amount of time before retrying the request\n          const nextSendRequestWaitTimeMs = sleep * 1000;\n          Logger.getInstance().trace('Request will be retried after %d milliseconds', Math.floor(nextSendRequestWaitTimeMs));\n          setTimeout(sendRequest, nextSendRequestWaitTimeMs);\n          return;\n        } else {\n          Logger.getInstance().trace('Request won\\'t be retried');\n          if (isUnsuccessfulResponse(response)) {\n            err = Errors.createLargeResultSetError(ErrorCodes.ERR_LARGE_RESULT_SET_RESPONSE_FAILURE, response);\n          } else {\n            err = Errors.createNetworkError(ErrorCodes.ERR_LARGE_RESULT_SET_NETWORK_COULD_NOT_CONNECT, err);\n          }\n        }\n      }\n      if (response) {\n        Logger.getInstance().trace(`Response headers are: ${JSON.stringify(response.headers)}`);\n      }\n      // if we have an error, clear the body\n      if (err) {\n        body = null;\n      }\n\n      // if a callback was specified, invoke it\n      if (Util.isFunction(options.callback)) {\n        try {\n          options.callback(err, body);\n        } catch (e) {\n          Logger.getInstance().error(`Callback failed with ${e}`);\n        }\n      }\n    };\n\n    const sendRequest = function sendRequest() {\n      // issue a request to get the object from S3/Blob\n      httpClient.request(\n        {\n          method: 'GET',\n          url: options.url,\n          headers: options.headers,\n          gzip: true, // gunzip the response\n          appendRequestId: false,\n          callback,\n        });\n    };\n\n    sendRequest();\n  };\n}\n\nUtil.inherits(LargeResultSetService, EventEmitter);\n\nmodule.exports = LargeResultSetService;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvc2VydmljZXMvbGFyZ2VfcmVzdWx0X3NldC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxxQkFBcUIsMERBQThCO0FBQ25ELGFBQWEsbUJBQU8sQ0FBQywrREFBUztBQUM5QixlQUFlLG1CQUFPLENBQUMsbUVBQVc7QUFDbEMsZUFBZSxtQkFBTyxDQUFDLG1FQUFXO0FBQ2xDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUNBQWlDLEVBQUUsb0NBQW9DO0FBQzlGLDJCQUEyQixpQ0FBaUM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsaUNBQWlDO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsNkRBQTZELEVBQUU7QUFDL0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi9zZXJ2aWNlcy9sYXJnZV9yZXN1bHRfc2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbImNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbmNvbnN0IFV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKTtcbmNvbnN0IExvZ2dlciA9IHJlcXVpcmUoJy4uL2xvZ2dlcicpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2RlcztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIGFuIExhcmdlUmVzdWx0U2V0U2VydmljZS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29ubmVjdGlvbkNvbmZpZ1xuICogQHBhcmFtIHtPYmplY3R9IGh0dHBDbGllbnRcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBMYXJnZVJlc3VsdFNldFNlcnZpY2UoY29ubmVjdGlvbkNvbmZpZywgaHR0cENsaWVudCkge1xuICAvLyB2YWxpZGF0ZSBpbnB1dFxuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjb25uZWN0aW9uQ29uZmlnKSk7XG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGh0dHBDbGllbnQpKTtcblxuICAvKipcbiAgICogU2hvdWxkIEhUVFAgY2xpZW50IGVycm9yIGJlIHJldHJpZWRcbiAgICogQHBhcmFtIGVyciBDbGllbnQgZXJyb3Igb3IgbnVsbC91bmRlZmluZWRcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGZ1bmN0aW9uIGlzUmV0cnlhYmxlQ2xpZW50RXJyb3IoZXJyKSB7XG4gICAgcmV0dXJuIGVyciAmJiAoXG4gICAgICBlcnIuY29kZSA9PT0gJ0VDT05OUkVTRVQnIHx8XG4gICAgICAgIGVyci5jb2RlID09PSAnRVRJTUVET1VUJyB8fFxuICAgICAgICAvLyBlcnJvciBjb2RlIEVDT05OQUJPUlRFRCBpcyB0aHJvd24gZnJvbSBheGlvcyBvbiB0aW1lb3V0XG4gICAgICAgIChlcnIubmFtZSA9PT0gJ0F4aW9zRXJyb3InICYmIGVyci5jb2RlID09PSAnRUNPTk5BQk9SVEVEJylcbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNSZXRyeWFibGVFcnJvcihyZXNwb25zZSwgZXJyKSB7XG4gICAgLy8gaHR0cHM6Ly9hd3MuYW1hem9uLmNvbS9hcnRpY2xlcy8xOTA0IChIYW5kbGluZyBFcnJvcnMpXG4gICAgLy8gTm90ZTogNDAzJ3MgYXJlIHJldHJpZWQgYmVjYXVzZSBvZiBhIGJ1ZyBpbiBTMy9CbG9iXG4gICAgcmV0dXJuIFV0aWwuaXNSZXRyeWFibGVIdHRwRXJyb3IocmVzcG9uc2UsIHRydWUpIHx8IGlzUmV0cnlhYmxlQ2xpZW50RXJyb3IoZXJyKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzVW5zdWNjZXNzZnVsUmVzcG9uc2UocmVzcG9uc2UpIHtcbiAgICAvLyBldmVuIGZvciAyMDAgT0sgUzMgY2FuIHJldHVybiB4bWwgZXJyb3IgKGxhcmdlIGZpbGVzIGFyZSBub3JtYWxseSBiaW5hcnkpXG4gICAgcmV0dXJuIHJlc3BvbnNlICYmIChyZXNwb25zZS5zdGF0dXNDb2RlICE9PSAyMDAgfHwgcmVzcG9uc2UuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpID09PSAnYXBwbGljYXRpb24veG1sJyk7XG4gIH1cblxuICAvKipcbiAgICogSXNzdWVzIGEgcmVxdWVzdCB0byBnZXQgYW4gb2JqZWN0IGZyb20gUzMvQmxvYi5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICovXG4gIHRoaXMuZ2V0T2JqZWN0ID0gZnVuY3Rpb24gZ2V0T2JqZWN0KG9wdGlvbnMpIHtcbiAgICBsZXQgbnVtUmV0cmllcyA9IDAsIHNsZWVwID0gMTtcblxuICAgIC8vIGdldCB0aGUgbWF4aW11bSBudW1iZXIgb2YgcmV0cmllc1xuICAgIGxldCBtYXhOdW1SZXRyaWVzID0gb3B0aW9ucy5tYXhOdW1SZXRyaWVzO1xuICAgIGlmICghVXRpbC5leGlzdHMobWF4TnVtUmV0cmllcykpIHtcbiAgICAgIG1heE51bVJldHJpZXMgPSBjb25uZWN0aW9uQ29uZmlnLmdldFJldHJ5TGFyZ2VSZXN1bHRTZXRNYXhOdW1SZXRyaWVzKCk7XG4gICAgfVxuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzTnVtYmVyKG1heE51bVJldHJpZXMpICYmIG1heE51bVJldHJpZXMgPj0gMCk7XG5cbiAgICAvLyBpbnZva2VkIHdoZW4gdGhlIHJlcXVlc3QgY29tcGxldGVzXG4gICAgY29uc3QgY2FsbGJhY2sgPSBmdW5jdGlvbiBjYWxsYmFjayhlcnIsIHJlc3BvbnNlLCBib2R5KSB7XG4gICAgICAvLyBlcnIgaGFwcGVucyBvbiB0aW1lb3V0cyBhbmQgcmVzcG9uc2UgaXMgcGFzc2VkIHdoZW4gc2VydmVyIHJlc3BvbmRlZFxuICAgICAgaWYgKGVyciB8fCBpc1Vuc3VjY2Vzc2Z1bFJlc3BvbnNlKHJlc3BvbnNlKSkge1xuICAgICAgICAvLyBpZiB3ZSdyZSBydW5uaW5nIGluIERFQlVHIGxvZ2xldmVsLCBwcm9iYWJseSB3ZSB3YW50IHRvIHNlZSB0aGUgZnVsbCBlcnJvciB0b29cbiAgICAgICAgY29uc3QgbG9nRXJyID0gZXJyID8gSlNPTi5zdHJpbmdpZnkoZXJyLCBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlcnIpKVxuICAgICAgICAgIDogYHN0YXR1czogJHtKU09OLnN0cmluZ2lmeShyZXNwb25zZS5zdGF0dXMpfSAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlLnN0YXR1c1RleHQpfWBcbiAgICAgICAgICAgICsgYCBoZWFkZXJzOiAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmhlYWRlcnMpfWA7XG4gICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdFbmNvdW50ZXJlZCBhbiBlcnJvciB3aGVuIGdldHRpbmcgZGF0YSBmcm9tIGNsb3VkIHN0b3JhZ2U6ICcgKyBsb2dFcnIpO1xuICAgICAgICAvLyBpZiB3ZSBoYXZlbid0IGV4Y2VlZGVkIHRoZSBtYXhpbXVtIG51bWJlciBvZiByZXRyaWVzIHlldCBhbmQgdGhlXG4gICAgICAgIC8vIHNlcnZlciBjYW1lIGJhY2sgd2l0aCBhIHJldHJ5YWJsZSBlcnJvciBjb2RlLlxuICAgICAgICBpZiAobnVtUmV0cmllcyA8IG1heE51bVJldHJpZXMgJiYgaXNSZXRyeWFibGVFcnJvcihyZXNwb25zZSwgZXJyKSkge1xuICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgbnVtYmVyIG9mIHJldHJpZXNcbiAgICAgICAgICBudW1SZXRyaWVzKys7XG5cbiAgICAgICAgICAvLyB1c2UgZXhwb25lbnRpYWwgYmFja29mZiB3aXRoIGRlY29ycmVsYXRlZCBqaXR0ZXIgdG8gY29tcHV0ZSB0aGVcbiAgICAgICAgICAvLyBuZXh0IHNsZWVwIHRpbWU6XG4gICAgICAgICAgY29uc3QgY2FwID0gY29ubmVjdGlvbkNvbmZpZy5nZXRSZXRyeUxhcmdlUmVzdWx0U2V0TWF4U2xlZXBUaW1lKCk7XG4gICAgICAgICAgc2xlZXAgPSBVdGlsLm5leHRTbGVlcFRpbWUoMSwgY2FwLCBzbGVlcCk7XG5cbiAgICAgICAgICAvLyB3YWl0IHRoZSBhcHByb3ByaWF0ZSBhbW91bnQgb2YgdGltZSBiZWZvcmUgcmV0cnlpbmcgdGhlIHJlcXVlc3RcbiAgICAgICAgICBjb25zdCBuZXh0U2VuZFJlcXVlc3RXYWl0VGltZU1zID0gc2xlZXAgKiAxMDAwO1xuICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLnRyYWNlKCdSZXF1ZXN0IHdpbGwgYmUgcmV0cmllZCBhZnRlciAlZCBtaWxsaXNlY29uZHMnLCBNYXRoLmZsb29yKG5leHRTZW5kUmVxdWVzdFdhaXRUaW1lTXMpKTtcbiAgICAgICAgICBzZXRUaW1lb3V0KHNlbmRSZXF1ZXN0LCBuZXh0U2VuZFJlcXVlc3RXYWl0VGltZU1zKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoJ1JlcXVlc3Qgd29uXFwndCBiZSByZXRyaWVkJyk7XG4gICAgICAgICAgaWYgKGlzVW5zdWNjZXNzZnVsUmVzcG9uc2UocmVzcG9uc2UpKSB7XG4gICAgICAgICAgICBlcnIgPSBFcnJvcnMuY3JlYXRlTGFyZ2VSZXN1bHRTZXRFcnJvcihFcnJvckNvZGVzLkVSUl9MQVJHRV9SRVNVTFRfU0VUX1JFU1BPTlNFX0ZBSUxVUkUsIHJlc3BvbnNlKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZU5ldHdvcmtFcnJvcihFcnJvckNvZGVzLkVSUl9MQVJHRV9SRVNVTFRfU0VUX05FVFdPUktfQ09VTERfTk9UX0NPTk5FQ1QsIGVycik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocmVzcG9uc2UpIHtcbiAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkudHJhY2UoYFJlc3BvbnNlIGhlYWRlcnMgYXJlOiAke0pTT04uc3RyaW5naWZ5KHJlc3BvbnNlLmhlYWRlcnMpfWApO1xuICAgICAgfVxuICAgICAgLy8gaWYgd2UgaGF2ZSBhbiBlcnJvciwgY2xlYXIgdGhlIGJvZHlcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgYm9keSA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIGEgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgaW52b2tlIGl0XG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKG9wdGlvbnMuY2FsbGJhY2spKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgb3B0aW9ucy5jYWxsYmFjayhlcnIsIGJvZHkpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZXJyb3IoYENhbGxiYWNrIGZhaWxlZCB3aXRoICR7ZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICBjb25zdCBzZW5kUmVxdWVzdCA9IGZ1bmN0aW9uIHNlbmRSZXF1ZXN0KCkge1xuICAgICAgLy8gaXNzdWUgYSByZXF1ZXN0IHRvIGdldCB0aGUgb2JqZWN0IGZyb20gUzMvQmxvYlxuICAgICAgaHR0cENsaWVudC5yZXF1ZXN0KFxuICAgICAgICB7XG4gICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICB1cmw6IG9wdGlvbnMudXJsLFxuICAgICAgICAgIGhlYWRlcnM6IG9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgICBnemlwOiB0cnVlLCAvLyBndW56aXAgdGhlIHJlc3BvbnNlXG4gICAgICAgICAgYXBwZW5kUmVxdWVzdElkOiBmYWxzZSxcbiAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgfSk7XG4gICAgfTtcblxuICAgIHNlbmRSZXF1ZXN0KCk7XG4gIH07XG59XG5cblV0aWwuaW5oZXJpdHMoTGFyZ2VSZXN1bHRTZXRTZXJ2aWNlLCBFdmVudEVtaXR0ZXIpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IExhcmdlUmVzdWx0U2V0U2VydmljZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/services/large_result_set.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/services/sf.js":
/*!*******************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/services/sf.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/*\n  SnowflakeService state machine\n\n  Preconnected - enter()      - Preconnected\n               - connect()    - Connecting\n               - request()    - Connecting\n               - destroy()    - Preconnected\n\n  Connecting   - enter()      - async operation\n                                - Connected if operation succeeds\n                                - Disconnected if network error (we need another PreConnected state)\n                                - Disconnected if operation fails\n                 connect()    - error\n                 request()    - enqueue\n                 destroy()    - enqueue\n\n  Connected    - enter()      - Connected\n                 connect()    - error\n                 request()    - async operation\n                                - Connected if operation succeeds\n                                - Connected if network error\n                                - Renewing if GS says session token has expired\n                                - Disconnected if GS says session token is invalid\n                 destroy()    - async operation\n                              - Disconnected if operation succeeds\n                              - Connected if network error\n                              - Connected if operation fails\n\n  Renewing     - enter()      - async operation\n                                - Connected if operation succeeds\n                                - Connected if network error\n                                - Disconnected if operation fails\n               - connect()    - error\n               - request()    - enqueue\n               - destroy()    - enqueue\n\n  Disconnected - enter()      - Disconnected\n               - connect()    - Disconnected\n               - request()    - Disconnected\n               - destroy()    - Disconnected\n */\n\nconst { v4: uuidv4 } = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/index.js\");\nconst EventEmitter = (__webpack_require__(/*! events */ \"events\").EventEmitter);\nconst Util = __webpack_require__(/*! ../util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ../errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\nconst Url = __webpack_require__(/*! url */ \"url\");\nconst QueryString = __webpack_require__(/*! querystring */ \"querystring\");\nconst Parameters = __webpack_require__(/*! ../parameters */ \"(rsc)/./node_modules/snowflake-sdk/lib/parameters.js\");\nconst GSErrors = __webpack_require__(/*! ../constants/gs_errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/constants/gs_errors.js\");\nconst QueryContextCache = __webpack_require__(/*! ../queryContextCache */ \"(rsc)/./node_modules/snowflake-sdk/lib/queryContextCache.js\");\nconst Logger = __webpack_require__(/*! ../logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst GlobalConfig = __webpack_require__(/*! ../global_config */ \"(rsc)/./node_modules/snowflake-sdk/lib/global_config.js\");\nconst AuthenticationTypes  = __webpack_require__(/*! ../authentication/authentication_types */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/authentication_types.js\");\nconst AuthOkta = __webpack_require__(/*! ../authentication/auth_okta */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_okta.js\");\nconst AuthKeypair = __webpack_require__(/*! ../authentication/auth_keypair */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/auth_keypair.js\");\nconst Authenticator = __webpack_require__(/*! ../authentication/authentication */ \"(rsc)/./node_modules/snowflake-sdk/lib/authentication/authentication.js\");\nconst sfParams = __webpack_require__(/*! ../constants/sf_params */ \"(rsc)/./node_modules/snowflake-sdk/lib/constants/sf_params.js\");\n\nfunction isRetryableNetworkError(err) {\n  // anything other than REVOKED error can be retryable.\n  return !Object.prototype.hasOwnProperty.call(err, 'cause') ||\n    err.cause === undefined ||\n    !Object.prototype.hasOwnProperty.call(err.cause, 'code') ||\n    (\n      err.cause.code !== ErrorCodes.ERR_OCSP_REVOKED &&\n      err.cause.code !== 'DEPTH_ZERO_SELF_SIGNED_CERT' &&\n      err.cause.code !== 'CERT_HAS_EXPIRED' &&\n      err.cause.code !== 'UNABLE_TO_VERIFY_LEAF_SIGNATURE' &&\n      err.cause.code !== 'SELF_SIGNED_CERT_IN_CHAIN'\n    );\n}\n\nfunction isRetryableHttpError(err) {\n  return Object.prototype.hasOwnProperty.call(err, 'response') &&\n    Util.isRetryableHttpError(err.response, false);\n}\n\n/**\n * Creates a new SnowflakeService instance.\n *\n * @param {Object} connectionConfig\n * @param {Object} httpClient\n * @param {Object} [config]\n * @constructor\n */\nfunction SnowflakeService(connectionConfig, httpClient, config) {\n  // validate input\n  Errors.assertInternal(Util.isObject(connectionConfig));\n  Errors.assertInternal(Util.isObject(httpClient));\n  Errors.assertInternal(!Util.exists(config) || Util.isObject(config));\n\n  // if a config object was specified, verify\n  // that it has all the information we need\n  let tokenInfoConfig;\n  if (Util.exists(config)) {\n    Errors.assertInternal(Util.isObject(config));\n    Errors.assertInternal(Util.isObject(config.tokenInfo));\n\n    tokenInfoConfig = config.tokenInfo;\n  } else if (connectionConfig.sessionToken) {\n    tokenInfoConfig = {\n      sessionToken: connectionConfig.sessionToken,\n      masterToken: connectionConfig.masterToken || connectionConfig.sessionToken,\n      sessionTokenExpirationTime: connectionConfig.sessionTokenExpirationTime || Date.now() + 1000 * 60 * 60 * 24,\n      masterTokenExpirationTime: connectionConfig.masterTokenExpirationTime || Date.now() + 1000 * 60 * 60 * 24\n    };\n  }\n\n  // create a new TokenInfo instance\n  const tokenInfo = new TokenInfo(tokenInfoConfig);\n\n  this.authenticator = Authenticator.getAuthenticator(connectionConfig, httpClient);\n\n  // create state objects for all the different states we can be in\n  const stateOptions =\n    {\n      snowflakeService: this,\n      httpClient: httpClient,\n      connectionConfig: connectionConfig,\n      tokenInfo: tokenInfo\n    };\n  const statePristine = new StatePristine(stateOptions);\n  const stateConnecting = new StateConnecting(stateOptions);\n  const stateConnected = new StateConnected(stateOptions);\n  const stateRenewing = new StateRenewing(stateOptions);\n  const stateDisconnected = new StateDisconnected(stateOptions);\n\n  let currentState;\n\n  /**\n   * Transitions to a given state.\n   *\n   * @param {Object} state\n   * @param {Object} [transitionContext]\n   */\n  const transitionTo = function (state, transitionContext) {\n    // this check is necessary to make sure we don't re-enter a transient state\n    // like Renewing when we're already in it\n    if (currentState !== state) {\n      // if we have a current state, exit it; the null check is necessary\n      // because the currentState is undefined at bootstrap time when we\n      // transition to the first state\n      if (currentState) {\n        currentState.exit();\n      }\n\n      // update the current state\n      currentState = state;\n\n      // enter the new state\n      currentState.enter(transitionContext);\n    }\n  };\n\n  /**\n   * Set the session id for the current SnowflakeService\n   * @param sessionId\n   */\n  this.setSessionId = function (sessionId) {\n    this.sessionId = sessionId;\n  };\n\n  /**\n   * Get the session id.\n   * @returns {number}\n   */\n  this.getSessionId = function () {\n    return this.sessionId;\n  };\n\n  /**\n   * Transitions to the Pristine state.\n   *\n   * {Object} [transitionContext]\n   */\n  this.transitionToPristine = function (transitionContext) {\n    transitionTo(statePristine, transitionContext);\n  };\n\n  /**\n   * Transitions to the Connecting state.\n   *\n   * {Object} [transitionContext]\n   */\n  this.transitionToConnecting = function (transitionContext) {\n    transitionTo(stateConnecting, transitionContext);\n  };\n\n  /**\n   * Transitions to the Connected state.\n   *\n   * {Object} [transitionContext]\n   */\n  this.transitionToConnected = function (transitionContext) {\n    transitionTo(stateConnected, transitionContext);\n  };\n\n  /**\n   * Transitions to the Renewing state.\n   *\n   * {Object} [transitionContext]\n   */\n  this.transitionToRenewing = function (transitionContext) {\n    transitionTo(stateRenewing, transitionContext);\n  };\n\n  /**\n   * Transitions to the Disconnected state.\n   *\n   * {Object} [transitionContext]\n   */\n  this.transitionToDisconnected = function (transitionContext) {\n    transitionTo(stateDisconnected, transitionContext);\n\n    // clear the tokens because we're in a fatal state and we don't want the\n    // tokens to be available via getConfig() anymore\n    tokenInfo.clearTokens();\n  };\n\n  /**\n   * Returns a configuration object that can be passed to the SnowflakeService\n   * constructor to get an equivalent SnowflakeService object.\n   *\n   * @returns {Object}\n   */\n  this.getConfig = function () {\n    return {\n      tokenInfo: tokenInfo.getConfig()\n    };\n  };\n\n  /**\n   * Establishes a connection to Snowflake.\n   *\n   * @param {Object} options\n   */\n  this.connect = function (options) {\n    new OperationConnect(options).validate().execute();\n  };\n\n  /**\n   * Issues a connect-continue request to Snowflake.\n   *\n   * @param {Object} [options]\n   */\n  this.continue = function (options) {\n    new OperationContinue(options).validate().execute();\n  };\n\n  /**\n   * Issues a generic request to Snowflake.\n   *\n   * @param {Object} options\n   */\n  this.request = function (options) {\n    new OperationRequest(options).validate().execute();\n  };\n\n  /**\n   * Issues a generic async request to Snowflake.\n   *\n   * @param {Object} options\n   */\n  this.requestAsync = async function (options) {\n    return await new OperationRequest(options).validate().executeAsync();\n  };\n\n  /**\n   * Terminates the current connection to Snowflake.\n   *\n   * @param {Object} options\n   */\n  this.destroy = function (options) {\n    this.clearCache();\n    new OperationDestroy(options).validate().execute();\n  };\n\n  /**\n   * Creates a new OperationAbstract.\n   *\n   * @param {Object} options\n   * @constructor\n   */\n  function OperationAbstract(options) {\n    this.options = options;\n  }\n\n  /**\n   * Validates the operation options.\n   *\n   * @returns {Object} the operation.\n   */\n  OperationAbstract.prototype.validate = function () {\n    return this;\n  };\n\n  /**\n   * Executes the operation.\n   */\n  OperationAbstract.prototype.execute = function () {\n  };\n\n  /**\n   * Creates a new OperationConnect.\n   *\n   * @param {Object} options\n   * @constructor\n   */\n  function OperationConnect(options) {\n    OperationAbstract.apply(this, [options]);\n  }\n\n  Util.inherits(OperationConnect, OperationAbstract);\n\n  /**\n   * @inheritDoc\n   */\n  OperationConnect.prototype.validate = function () {\n    // verify that the options object contains a callback function\n    const options = this.options;\n    Errors.assertInternal(\n      (Util.isObject(options) && Util.isFunction(options.callback)));\n\n    return this;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  OperationConnect.prototype.execute = function () {\n    currentState.connect(this.options);\n  };\n\n  /**\n   * Creates a new OperationContinue.\n   *\n   * @param {Object} options\n   * @constructor\n   */\n  function OperationContinue(options) {\n    OperationAbstract.apply(this, [options]);\n  }\n\n  Util.inherits(OperationContinue, OperationAbstract);\n\n  /**\n   * @inheritDoc\n   */\n  OperationContinue.prototype.validate = function () {\n    // verify that the options contain a json object\n    const options = this.options;\n    Errors.assertInternal(\n      Util.isObject(options) && Util.isObject(options.json));\n\n    return this;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  OperationContinue.prototype.execute = function () {\n    currentState.continue(this.options);\n  };\n\n  /**\n   * Creates a new OperationRequest.\n   *\n   * @param {Object} options\n   * @constructor\n   */\n  function OperationRequest(options) {\n    OperationAbstract.apply(this, [options]);\n  }\n\n  Util.inherits(OperationRequest, OperationAbstract);\n\n  /**\n   * @inheritDoc\n   */\n  OperationRequest.prototype.validate = function () {\n    // verify that the options object contains all the necessary information\n    const options = this.options;\n    Errors.assertInternal(Util.isObject(options));\n    Errors.assertInternal(Util.isString(options.method));\n    Errors.assertInternal(\n      !Util.exists(options.headers) || Util.isObject(options.headers));\n    Errors.assertInternal(Util.isString(options.url));\n    Errors.assertInternal(\n      !Util.exists(options.json) || Util.isObject(options.json));\n\n    return this;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  OperationRequest.prototype.execute = function () {\n    currentState.request(this.options);\n  };\n\n  /**\n  * @inheritDoc\n  */\n  OperationRequest.prototype.executeAsync = async function () {\n    return await currentState.requestAsync(this.options);\n  };\n\n  /**\n   * Creates a new OperationDestroy.\n   *\n   * @param {Object} options\n   * @constructor\n   */\n  function OperationDestroy(options) {\n    OperationAbstract.apply(this, [options]);\n  }\n\n  Util.inherits(OperationDestroy, OperationAbstract);\n\n  /**\n   * @inheritDoc\n   */\n  OperationDestroy.prototype.validate = function () {\n    // verify that the options object contains a callback function\n    const options = this.options;\n    Errors.assertInternal(Util.isObject(options) &&\n      Util.isFunction(options.callback));\n\n    return this;\n  };\n\n  /**\n   * @inheritDoc\n   */\n  OperationDestroy.prototype.execute = function () {\n    // delegate to current state\n    currentState.destroy(this.options);\n  };\n\n  /* All queued operations will be added to this array */\n  const operationQueue = [];\n\n  /**\n   * Appends a request operation to the queue.\n   *\n   * @param {Object} options\n   */\n  this.enqueueRequest = function (options) {\n    operationQueue.push(new OperationRequest(options));\n  };\n\n  /**\n   * Appends a destroy operation to the queue.\n   *\n   * @param {Object} options\n   */\n  this.enqueueDestroy = function (options) {\n    operationQueue.push(new OperationDestroy(options));\n  };\n\n  /**\n   * Executes all the operations in the queue.\n   */\n  this.drainOperationQueue = function () {\n    // execute all the operations in the queue\n    for (let index = 0, length = operationQueue.length; index < length; index++) {\n      operationQueue[index].execute();\n    }\n\n    // empty the queue\n    operationQueue.length = 0;\n  };\n\n  this.isConnected = function () {\n    return currentState === stateConnected ||\n      currentState === stateConnecting ||\n      currentState === stateRenewing;\n  };\n\n  this.getServiceName = function () {\n    return Parameters.getValue(Parameters.names.SERVICE_NAME);\n  };\n\n  this.getClientSessionKeepAlive = function () {\n    return Parameters.getValue(Parameters.names.CLIENT_SESSION_KEEP_ALIVE);\n  };\n\n  this.getClientSessionKeepAliveHeartbeatFrequency = function () {\n    return Parameters.getValue(Parameters.names.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY);\n  };\n\n  this.getJsTreatIntegerAsBigInt = function () {\n    return Parameters.getValue(Parameters.names.JS_TREAT_INTEGER_AS_BIGINT);\n  };\n\n  this.getAuthenticator = function () {\n    return this.authenticator;\n  };\n\n  // if we don't have any tokens, start out as pristine\n  if (tokenInfo.isEmpty()) {\n    this.transitionToPristine();\n  } else {\n    // we're already connected\n    this.transitionToConnected();\n  }\n\n  /**\n  * Issues a post request to Snowflake.\n  *\n  * @param {Object} options\n  */\n  this.postAsync = function (options) {\n    return new OperationRequest(options).validate().executeAsync();\n  };\n\n  this.getQueryContextDTO = function () {\n    if (!this.qcc){\n      return;\n    }\n    return this.qcc.getQueryContextDTO();\n  };\n\n  this.deserializeQueryContext = function (data) {\n    if (!this.qcc){\n      return;\n    }\n    this.qcc.deserializeQueryContext(data);\n  };\n\n  this.clearCache = function () {\n    if (!this.qcc){\n      return;\n    }\n    this.qcc.clearCache(); \n  };\n\n  this.initializeQueryContextCache = function (size) {\n    if (!connectionConfig.getDisableQueryContextCache()){\n      this.qcc = new QueryContextCache(size, this.getSessionId());\n    } else {\n      Logger.getInstance().debug(`QueryContextCache initialization skipped as it is disabled for connection with sessionId: ${this.sessionId}`);\n    }\n  };\n\n  // testing purpose\n  this.getQueryContextCacheSize = function () {\n    if (!this.qcc){\n      return;\n    }\n    return this.qcc.getSize();\n  };\n}\n\nUtil.inherits(SnowflakeService, EventEmitter);\n\nmodule.exports = SnowflakeService;\n\n\n///////////////////////////////////////////////////////////////////////////\n////                StateAbstract                                      ////\n///////////////////////////////////////////////////////////////////////////\n\n/**\n * Creates a new StateAbstract instance.\n *\n * @param {Object} options\n * @constructor\n */\nfunction StateAbstract(options) {\n  /**\n   * Issues an http request to Snowflake.\n   *\n   * @param {Object} requestOptions\n   * @param {Object} httpClient\n   * @param {Object} auth\n   * @returns {Object} the http request object.\n   */\n  function sendHttpRequest(requestOptions, httpClient, auth) {\n\n    const params = requestOptions.params || {};\n    if (!requestOptions.excludeGuid) {\n      addGuidToParams(params);\n    }\n\n    const realRequestOptions =\n      {\n        method: requestOptions.method,\n        headers: requestOptions.headers,\n        url: requestOptions.absoluteUrl,\n        gzip: requestOptions.gzip,\n        json: requestOptions.json,\n        params: params,\n        callback: async function (err, response, body) {\n          // if we got an error, wrap it into a network error\n          if (err) {\n            // if we're running in DEBUG loglevel, probably we want to see the full error instead\n            Logger.getInstance().debug('Encountered an error when sending the request. Details: '\n                + JSON.stringify(err, Object.getOwnPropertyNames(err)));\n\n            err = Errors.createNetworkError(\n              ErrorCodes.ERR_SF_NETWORK_COULD_NOT_CONNECT, err);\n          } else if (!response) {\n            // empty response\n            err = Errors.createUnexpectedContentError(\n              ErrorCodes.ERR_SF_RESPONSE_NOT_JSON, '(EMPTY)');\n          } else if (Object.prototype.hasOwnProperty.call(response, 'statusCode') &&\n            response.statusCode !== 200) {\n            // if we didn't get a 200, the request failed\n            if (response.statusCode === 401 && response.body) {\n              let innerCode;\n              try {\n                innerCode = JSON.parse(response.body).code;\n              } catch (e) {\n                err = Errors.createRequestFailedError(\n                  ErrorCodes.ERR_SF_RESPONSE_FAILURE, response);\n                Logger.getInstance().debug('HTTP Error: %s', response.statusCode);\n              }\n              if (innerCode === '390104') {\n                err = Errors.createRequestFailedError(\n                  ErrorCodes.ERR_SF_RESPONSE_INVALID_TOKEN, response);\n                Logger.getInstance().debug('HTTP Error: %s', response.statusCode);\n              } else {\n                err = Errors.createRequestFailedError(\n                  ErrorCodes.ERR_SF_RESPONSE_FAILURE, response);\n                Logger.getInstance().debug('HTTP Error: %s', response.statusCode);\n              }\n            } else {\n              err = Errors.createRequestFailedError(\n                ErrorCodes.ERR_SF_RESPONSE_FAILURE, response);\n              Logger.getInstance().debug('HTTP Error: %s', response.statusCode);\n            }\n          } else {\n            // if the response body is a non-empty string and the response is\n            // supposed to contain json, try to json-parse the body\n            if (Util.isString(body) &&\n              response.getResponseHeader('Content-Type') ===\n              'application/json') {\n              try {\n                if (body.includes('smkId')) {\n                  body = Util.convertSmkIdToString(body);\n                }\n                body = JSON.parse(body);\n              } catch (parseError) {\n                // we expected to get json\n                err = Errors.createUnexpectedContentError(\n                  ErrorCodes.ERR_SF_RESPONSE_NOT_JSON, response.body);\n              }\n            }\n\n            // if we were able to successfully json-parse the body and the\n            // success flag is false, the operation we tried to perform failed\n            if (body && !body.success) {\n              const data = body.data;\n\n              if (body.code === GSErrors.code.ID_TOKEN_INVALID && data.authnMethod === 'TOKEN') {\n                Logger.getInstance().debug('ID Token being used has expired. Reauthenticating');\n                const key = Util.buildCredentialCacheKey(connectionConfig.host,\n                  connectionConfig.username, AuthenticationTypes.ID_TOKEN_AUTHENTICATOR);\n                await GlobalConfig.getCredentialManager().remove(key);\n                await auth.reauthenticate(requestOptions.json);\n                return httpClient.request(realRequestOptions);\n              }\n\n              err = Errors.createOperationFailedError(\n                body.code, data, body.message,\n                data && data.sqlState ? data.sqlState : undefined);\n            }\n          }\n          \n          // if we have an error, clear the body\n          if (err) {\n            body = undefined;\n          }\n\n          // if a callback was specified, invoke it\n          if (Util.isFunction(requestOptions.callback)) {\n            await requestOptions.callback.apply(requestOptions.scope, [err, body]);\n          }\n        }\n      };\n\n    if (requestOptions.retry > 2) {\n      const includesParam = requestOptions.url.includes('?');\n      realRequestOptions.url += (includesParam ? '&' : '?');\n      realRequestOptions.url +=\n        ('clientStartTime=' + requestOptions.startTime\n          + '&' + 'retryCount=' + (requestOptions.retry - 1));\n    }\n\n    return httpClient.request(realRequestOptions);\n  }\n\n  this.snowflakeService = options.snowflakeService;\n  this.httpClient = options.httpClient;\n  this.connectionConfig = options.connectionConfig;\n  this.tokenInfo = options.tokenInfo;\n\n  const connectionConfig = options.connectionConfig;\n  const snowflakeService = options.snowflakeService;\n  const httpClient = options.httpClient;\n\n  ///////////////////////////////////////////////////////////////////////////\n  ////                Request                                            ////\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Creates a new Request to Snowflake.\n   *\n   * @param {Object} requestOptions\n   * @constructor\n   */\n  function Request(requestOptions) {\n    this.requestOptions = requestOptions;\n  }\n\n  /**\n  * Sends out the request.\n  *\n  * @returns {Object} the request that was issued.\n  */\n  Request.prototype.sendAsync = async function () {\n    // pre-process the request options\n    this.preprocessOptions(this.requestOptions);\n\n    const params = this.requestOptions.params || {};\n    if (!this.requestOptions.excludeGuid) {\n      addGuidToParams(params);\n    }\n    const options =\n    {\n      method: this.requestOptions.method,\n      headers: this.requestOptions.headers,\n      url: this.requestOptions.absoluteUrl,\n      json: this.requestOptions.json,\n      params: params\n    };\n\n    // issue the async http request\n    //TODO: this should be wrapped with the same operations, as in the synchronous send method's callback.\n    return await httpClient.requestAsync(options);\n  };\n\n  function addGuidToParams(params) {\n    // In case of repeated requests for the same request ID,\n    // the Global UID is added for better traceability.\n    const guid = uuidv4();\n    params[sfParams.paramsNames.SF_REQUEST_GUID] = guid;\n  }\n\n  /**\n   * Sends out the request.\n   *\n   * @returns {Object} the request that was issued.\n   */\n  Request.prototype.send = function () {\n    // pre-process the request options\n    this.preprocessOptions(this.requestOptions);\n\n    // issue the http request\n    sendHttpRequest(this.requestOptions, httpClient, snowflakeService.getAuthenticator());\n  };\n\n  /**\n   * Pre-processes the request options just before the request is sent.\n   *\n   * @param {Object} requestOptions\n   */\n  Request.prototype.preprocessOptions = function (requestOptions) {\n    // augment the headers with the default request headers\n    requestOptions.headers =\n      Util.apply(this.getDefaultReqHeaders(), requestOptions.headers || {});\n\n    if (Util.isLoginRequest(requestOptions.url)) {\n      Util.apply(requestOptions.headers, {\n        'CLIENT_APP_VERSION': requestOptions.json.data.CLIENT_APP_VERSION,\n        'CLIENT_APP_ID': requestOptions.json.data.CLIENT_APP_ID,\n      });\n    }\n\n    // augment the options with the absolute url\n    requestOptions.absoluteUrl = this.buildFullUrl(requestOptions.url);\n\n    requestOptions.excludeGuid = !Util.exists(requestOptions.excludeGuid) ? false : requestOptions.excludeGuid;\n  };\n\n  /**\n   * Converts a relative url to an absolute url.\n   *\n   * @param {String} relativeUrl\n   *\n   * @returns {String}\n   */\n  Request.prototype.buildFullUrl = function (relativeUrl) {\n    return connectionConfig.accessUrl + relativeUrl;\n  };\n\n  /**\n   * Returns the default headers to send with every request.\n   *\n   * @returns {Object}\n   */\n  Request.prototype.getDefaultReqHeaders = function () {\n    return {\n      'Accept': 'application/json',\n      'Content-Type': 'application/json'\n    };\n  };\n\n  ///////////////////////////////////////////////////////////////////////////\n  ////                SessionTokenRequest                                ////\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @constructor\n   */\n  function SessionTokenRequest() {\n    Request.apply(this, arguments);\n  }\n\n  Util.inherits(SessionTokenRequest, Request);\n\n  /**\n   * @inheritDoc\n   */\n  SessionTokenRequest.prototype.preprocessOptions = function (requestOptions) {\n    // call super\n    Request.prototype.preprocessOptions.apply(this, arguments);\n\n    // add the current session token to the request headers\n    requestOptions.headers = requestOptions.headers || {};\n    requestOptions.headers.Authorization =\n      'Snowflake Token=\"' + options.tokenInfo.getSessionToken() + '\"';\n    if (Util.string.isNotNullOrEmpty(\n      Parameters.getValue(Parameters.names.SERVICE_NAME))) {\n      requestOptions.headers['X-Snowflake-Service'] =\n        Parameters.getValue(Parameters.names.SERVICE_NAME);\n    }\n  };\n\n  ///////////////////////////////////////////////////////////////////////////\n  ////                MasterTokenRequest                                 ////\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @constructor\n   */\n  function MasterTokenRequest() {\n    Request.apply(this, arguments);\n  }\n\n  Util.inherits(MasterTokenRequest, Request);\n\n  /**\n   * @inheritDoc\n   */\n  MasterTokenRequest.prototype.preprocessOptions = function (requestOptions) {\n    // call super\n    Request.prototype.preprocessOptions.apply(this, arguments);\n\n    // add the current master token to the request headers\n    requestOptions.headers = requestOptions.headers || {};\n    requestOptions.headers.Authorization =\n      'Snowflake Token=\"' + options.tokenInfo.getMasterToken() + '\"';\n  };\n\n  ///////////////////////////////////////////////////////////////////////////\n  ////                UnauthenticatedRequest                             ////\n  ///////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Creates a new UnauthenticatedRequest.\n   *\n   * @constructor\n   */\n  function UnauthenticatedRequest() {\n    Request.apply(this, arguments);\n  }\n\n  Util.inherits(UnauthenticatedRequest, Request);\n\n  /**\n   * Creates a new SessionTokenRequest.\n   *\n   * @param {Object} requestOptions\n   *\n   * @returns {Object}\n   */\n  this.createSessionTokenRequest = function (requestOptions) {\n    return new SessionTokenRequest(requestOptions);\n  };\n\n  /**\n   * Creates a new MasterTokenRequest.\n   *\n   * @param {Object} requestOptions\n   *\n   * @returns {Object}\n   */\n  this.createMasterTokenRequest = function (requestOptions) {\n    return new MasterTokenRequest(requestOptions);\n  };\n\n  /**\n   * Creates a new UnauthenticatedRequest.\n   *\n   * @param {Object} requestOptions\n   *\n   * @returns {Object}\n   */\n  this.createUnauthenticatedRequest = function (requestOptions) {\n    return new UnauthenticatedRequest(requestOptions);\n  };\n}\n\n/**\n * Enters this state.\n * @abstract\n */\nStateAbstract.prototype.enter = function () {\n};\n\n/**\n * Exits this state.\n * @abstract\n */\nStateAbstract.prototype.exit = function () {\n};\n\n/**\n * Establishes a connection to Snowflake.\n *\n * @abstract\n */\nStateAbstract.prototype.connect = function () {\n};\n\n/**\n * Issues a connect-continue request to Snowflake.\n *\n * @abstract\n */\nStateAbstract.prototype.continue = function () {\n};\n\n/**\n * Issues a generic request to Snowflake.\n *\n * @abstract\n */\nStateAbstract.prototype.request = function () {\n};\n\n/**\n * Terminates the current connection to Snowflake.\n *\n * @abstract\n */\nStateAbstract.prototype.destroy = function () {\n};\n\n///////////////////////////////////////////////////////////////////////////\n////                StatePristine                                      ////\n///////////////////////////////////////////////////////////////////////////\n\nfunction StatePristine() {\n  StateAbstract.apply(this, arguments);\n}\n\nUtil.inherits(StatePristine, StateAbstract);\n\n/**\n * @inheritDoc\n */\nStatePristine.prototype.connect = function (options) {\n  // transition to the Connecting state with the callback in the transition\n  // context\n  this.snowflakeService.transitionToConnecting(\n    {\n      options: options\n    });\n};\n\n/**\n * @inheritDoc\n */\nStatePristine.prototype.request = function (options) {\n  const callback = options.callback;\n  process.nextTick(function () {\n    callback(Errors.createClientError(\n      ErrorCodes.ERR_CONN_REQUEST_STATUS_PRISTINE));\n  });\n};\n\n/**\n * @inheritDoc\n */\nStatePristine.prototype.destroy = function (options) {\n  // we're still in the preconnected state so any\n  // attempts to destroy should result in an error\n  const callback = options.callback;\n  process.nextTick(function () {\n    callback(Errors.createClientError(\n      ErrorCodes.ERR_CONN_DESTROY_STATUS_PRISTINE));\n  });\n};\n\n///////////////////////////////////////////////////////////////////////////\n////                StateConnecting                                    ////\n///////////////////////////////////////////////////////////////////////////\n\nfunction StateConnecting() {\n  StateAbstract.apply(this, arguments);\n}\n\nUtil.inherits(StateConnecting, StateAbstract);\n\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.enter = function (context) {\n  // save the context\n  this.context = context;\n\n  // initiate the connection process\n  this.continue();\n};\n\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.exit = function () {\n  // clear the context\n  this.context = null;\n};\n\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.connect = function (options) {\n  // we're already connecting so any attempts\n  // to connect should result in an error\n  const callback = options.callback;\n  process.nextTick(function () {\n    callback(Errors.createClientError(\n      ErrorCodes.ERR_CONN_CONNECT_STATUS_CONNECTING));\n  });\n};\n\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.continue = function () {\n  const context = this.context;\n  const err = context.options.err;\n  let json = context.options.json;\n  \n  // if no json was specified, treat this as the first connect\n  // and get the necessary information from connectionConfig\n  if (!json) {\n    json =\n      {\n        data:\n          {\n            ACCOUNT_NAME: this.connectionConfig.account,\n            LOGIN_NAME: this.connectionConfig.username,\n            PASSWORD: this.connectionConfig.password\n          }\n      };\n  }\n\n  // extract the inflight context from the error and put it back in the json\n  if (err && err.data && err.data.inFlightCtx) {\n    json.inFlightCtx = err.data.inFlightCtx;\n  }\n\n  // initialize the json data if necessary\n  json.data = json.data || {};\n\n  // add the client-app-id, client-app-version, and client-app-name\n  const clientInfo =\n    {\n      CLIENT_APP_ID: this.connectionConfig.getClientType(),\n      CLIENT_APP_VERSION: this.connectionConfig.getClientVersion(),\n    };\n\n  // if we have some information about the client environment, add it as well\n  const clientEnvironment = this.connectionConfig.getClientEnvironment();\n  if (Util.isObject(clientEnvironment)) {\n    clientInfo.CLIENT_ENVIRONMENT = clientEnvironment;\n  }\n\n  const clientApplication = this.connectionConfig.getClientApplication();\n  if (Util.isString(clientApplication)) {\n    clientEnvironment['APPLICATION'] = clientApplication;\n  }\n\n  const sessionParameters =\n    {\n      SESSION_PARAMETERS: {}\n    };\n\n  if (Util.exists(this.connectionConfig.getClientSessionKeepAlive())) {\n    sessionParameters.SESSION_PARAMETERS.CLIENT_SESSION_KEEP_ALIVE =\n      this.connectionConfig.getClientSessionKeepAlive();\n  }\n\n  if (Util.exists(this.connectionConfig.getClientSessionKeepAliveHeartbeatFrequency())) {\n    sessionParameters.SESSION_PARAMETERS.CLIENT_SESSION_KEEP_ALIVE_HEARTBEAT_FREQUENCY =\n      this.connectionConfig.getClientSessionKeepAliveHeartbeatFrequency();\n  }\n\n  if (Util.exists(this.connectionConfig.getJsTreatIntegerAsBigInt())) {\n    sessionParameters.SESSION_PARAMETERS.JS_TREAT_INTEGER_AS_BIGINT =\n      this.connectionConfig.getJsTreatIntegerAsBigInt();\n  }\n\n  if (Util.exists(this.connectionConfig.getGcsUseDownscopedCredential())) {\n    sessionParameters.SESSION_PARAMETERS.GCS_USE_DOWNSCOPED_CREDENTIAL =\n      this.connectionConfig.getGcsUseDownscopedCredential();\n  }\n\n  if (Util.exists(this.connectionConfig.getClientRequestMFAToken())) {\n    sessionParameters.SESSION_PARAMETERS.CLIENT_REQUEST_MFA_TOKEN =\n      this.connectionConfig.getClientRequestMFAToken();\n  }\n\n  if (Util.exists(this.connectionConfig.getClientStoreTemporaryCredential())) {\n    sessionParameters.SESSION_PARAMETERS.CLIENT_STORE_TEMPORARY_CREDENTIAL =\n      this.connectionConfig.getClientStoreTemporaryCredential();\n  }\n\n  Util.apply(json.data, clientInfo);\n  Util.apply(json.data, sessionParameters);\n\n  const connectionConfig = this.connectionConfig;\n  const maxLoginRetries = connectionConfig.getRetrySfMaxLoginRetries();\n  const maxRetryTimeout = connectionConfig.getRetryTimeout();\n  const startTime = connectionConfig.accessUrl.startsWith('https://') ?\n    Date.now() : 'FIXEDTIMESTAMP';\n  let numRetries = 0;\n  let sleep = connectionConfig.getRetrySfStartingSleepTime();\n  let totalElapsedTime = 0;\n  Logger.getInstance().debug('Total retryTimeout is for the retries = ' + maxRetryTimeout === 0 ? \n    0 : maxRetryTimeout);\n  const parent = this;\n  const requestCallback = async function (err, body) {\n    // clear credential-related information\n    connectionConfig.clearCredentials();\n\n    // if the request succeeded\n    if (!err) {\n      Errors.assertInternal(Util.exists(body));\n      Errors.assertInternal(Util.exists(body.data));\n\n      parent.snowflakeService.setSessionId(body.data.sessionId);\n      Logger.getInstance().debug(`New session with id ${parent.snowflakeService.getSessionId()} initialized`);\n      \n      // update the parameters\n      Parameters.update(body.data.parameters);\n\n      // update all token-related information\n      parent.tokenInfo.update(body.data);\n\n      if (connectionConfig.getClientRequestMFAToken() && body.data.mfaToken) {\n        const key = Util.buildCredentialCacheKey(connectionConfig.host,\n          connectionConfig.username, AuthenticationTypes.USER_PWD_MFA_AUTHENTICATOR);\n        await GlobalConfig.getCredentialManager().write(key, body.data.mfaToken);\n      }\n\n      if (connectionConfig.getClientStoreTemporaryCredential() && body.data.idToken) {\n        const key = Util.buildCredentialCacheKey(connectionConfig.host,\n          connectionConfig.username, AuthenticationTypes.ID_TOKEN_AUTHENTICATOR);\n        await GlobalConfig.getCredentialManager().write(key, body.data.idToken);\n      }\n\n      // we're now connected\n      parent.snowflakeService.transitionToConnected();\n\n      const qccSize = Parameters.getValue('QUERY_CONTEXT_CACHE_SIZE');\n      parent.snowflakeService.initializeQueryContextCache(qccSize);\n    } else {\n      if (Errors.isNetworkError(err) || Errors.isRequestFailedError(err)) {\n        if (numRetries < maxLoginRetries && (\n          isRetryableNetworkError(err) || isRetryableHttpError(err)) &&\n          (maxRetryTimeout === 0 || totalElapsedTime < maxRetryTimeout)) {\n          numRetries++;\n          const jitter = Util.getJitteredSleepTime(numRetries, sleep, totalElapsedTime, maxRetryTimeout);\n          sleep = jitter.sleep;\n          totalElapsedTime = jitter.totalElapsedTime;\n\n          if (sleep <= 0) {\n            Logger.getInstance().debug('Reached out to the max Login Timeout');\n            parent.snowflakeService.transitionToDisconnected();\n          }\n\n          const auth = parent.snowflakeService.getAuthenticator();\n          if (auth instanceof AuthOkta) {\n            Logger.getInstance().debug('OKTA authentication requires token refresh.');\n            const retryOption = {\n              totalElapsedTime, \n              numRetries,\n            };\n\n            await auth.reauthenticate(context.options.json, retryOption);\n            numRetries = retryOption.numRetries;\n            totalElapsedTime = retryOption.totalElapsedTime;\n            setTimeout(sendRequest, sleep * 1000);\n            return;\n          } else {\n            if (auth instanceof AuthKeypair) {\n              Logger.getInstance().debug('AuthKeyPair authentication requires token refresh.');\n              await auth.reauthenticate(context.options.json);\n            }\n            setTimeout(sendRequest, sleep * 1000);\n            return;\n          }\n        } else {\n          Logger.getInstance().debug('Failed to all retries to SF.');\n          // we're now disconnected\n          parent.snowflakeService.transitionToDisconnected();\n        }\n      } else {\n        // we're now disconnected\n        parent.snowflakeService.transitionToDisconnected();\n      }\n    }\n\n    // invoke the transition-context callback that was passed to us by the\n    // Pristine state on connect()\n    if (Util.isFunction(context.options.callback)) {\n      context.options.callback(err);\n    }\n\n    // all queued operations are now free to go\n    parent.snowflakeService.drainOperationQueue();\n  };\n\n  // issue a login request\n  const sendRequest = function () {\n    const targetUrl = buildLoginUrl(connectionConfig);\n    Logger.getInstance().debug(\n      'Contacting SF: %s, (%s/%s)', targetUrl, numRetries, maxLoginRetries);\n    const request = parent.createUnauthenticatedRequest({\n      method: 'POST',\n      url: targetUrl,\n      json: json,\n      scope: this,\n      startTime: startTime,\n      retry: numRetries,\n      callback: requestCallback\n    });\n    request.send();\n  };\n  sendRequest();\n};\n\n/**\n * Builds the url for a login request.\n *\n * @param connectionConfig\n *\n * @returns {*}\n */\nfunction buildLoginUrl(connectionConfig) {\n  const queryParams =\n    [\n      { name: 'warehouse', value: connectionConfig.getWarehouse() },\n      { name: 'databaseName', value: connectionConfig.getDatabase() },\n      { name: 'schemaName', value: connectionConfig.getSchema() },\n      { name: 'roleName', value: connectionConfig.getRole() }\n    ];\n\n  const queryStringObject = {};\n  if (!connectionConfig.isQaMode()) {\n    // No requestId is attached to login-request in test mode.\n    queryStringObject.requestId = uuidv4();\n  }\n  for (let index = 0, length = queryParams.length; index < length; index++) {\n    const queryParam = queryParams[index];\n    if (Util.string.isNotNullOrEmpty(queryParam.value)) {\n      queryStringObject[queryParam.name] = queryParam.value;\n    }\n  }\n\n  return Url.format(\n    {\n      pathname: '/session/v1/login-request',\n      search: QueryString.stringify(queryStringObject)\n    });\n}\n\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.request = function (options) {\n  // enqueue the request operation\n  this.snowflakeService.enqueueRequest(options);\n};\n\n/**\n * @inheritDoc\n */\nStateConnecting.prototype.destroy = function (options) {\n  // enqueue the destroy operation\n  this.snowflakeService.enqueueDestroy(options);\n};\n\n///////////////////////////////////////////////////////////////////////////\n////                StateConnected                                     ////\n///////////////////////////////////////////////////////////////////////////\n\nfunction StateConnected() {\n  StateAbstract.apply(this, arguments);\n}\n\nUtil.inherits(StateConnected, StateAbstract);\n\n/**\n * @inheritDoc\n */\nStateConnected.prototype.connect = function (options) {\n  // we're already connected so any attempts\n  // to connect should result in an error\n  const callback = options.callback;\n  process.nextTick(function () {\n    callback(Errors.createClientError(\n      ErrorCodes.ERR_CONN_CONNECT_STATUS_CONNECTED));\n  });\n};\n\nStateConnected.prototype.requestAsync = async function (options) {\n  // create a session token request from the options and send out the request\n  return await this.createSessionTokenRequest(options).sendAsync();\n};\n\n/**\n * @inheritDoc\n */\nStateConnected.prototype.request = function (options) {\n  const scopeOrig = options.scope;\n  const callbackOrig = options.callback;\n\n  // define our own scope and callback\n  options.scope = this;\n  options.callback = async function (err, body) {\n    // if there was no error, invoke the callback if one was specified\n    if (!err) {\n      if (Util.isFunction(callbackOrig)) {\n        await callbackOrig.apply(scopeOrig, [err, body]);\n      }\n    } else {\n      // restore the original scope and callback to the options object because\n      // we might need to repeat the request\n      options.scope = scopeOrig;\n      options.callback = callbackOrig;\n\n      // if the session token has expired\n      if (err.code === GSErrors.code.SESSION_TOKEN_EXPIRED) {\n        // enqueue the request operation\n        this.snowflakeService.enqueueRequest(options);\n\n        // if a session token renewal isn't already in progress, issue a\n        // request to renew the session token\n        this.snowflakeService.transitionToRenewing();\n      } else if ((err.code === GSErrors.code.SESSION_TOKEN_INVALID) ||\n        (err.code === GSErrors.code.GONE_SESSION)) {\n        // if the session token is invalid or it doesn't exist\n        // enqueue the request operation\n        this.snowflakeService.enqueueRequest(options);\n\n        // we're disconnected\n        this.snowflakeService.transitionToDisconnected();\n\n        // all queued operations are now free to go\n        this.snowflakeService.drainOperationQueue();\n\n        // TODO: remember that a session renewal is no longer in progress\n        // TODO: make sure the last session renewal did not time out\n      } else {\n        // it's a normal failure\n        // if a callback was specified, invoke it\n        if (Util.isFunction(callbackOrig)) {\n          callbackOrig.apply(scopeOrig, [err, body]);\n        }\n      }\n    }\n  };\n\n  // create a session token request from the options and send out the request\n  this.createSessionTokenRequest(options).send();\n};\n\n/**\n * @inheritDoc\n */\nStateConnected.prototype.destroy = function (options) {\n  const requestID = uuidv4();\n\n  // send out a session token request to terminate the current connection\n  this.createSessionTokenRequest(\n    {\n      method: 'POST',\n      url: `/session?delete=true&requestId=${requestID}`,\n      scope: this,\n      callback: function (err) {\n        // if the destroy request succeeded or the session already expired, we're disconnected\n        if (!err || err.code === GSErrors.code.GONE_SESSION || err.code === GSErrors.code.SESSION_TOKEN_EXPIRED) {\n          err = undefined;\n          this.snowflakeService.transitionToDisconnected();\n        }\n\n        // invoke the original callback\n        options.callback(err);\n      }\n    }).send();\n};\n\n///////////////////////////////////////////////////////////////////////////\n////                StateRenewing                                      ////\n///////////////////////////////////////////////////////////////////////////\n\nfunction StateRenewing() {\n  StateAbstract.apply(this, arguments);\n}\n\nUtil.inherits(StateRenewing, StateAbstract);\n\n/**\n * @inheritDoc\n */\nStateRenewing.prototype.enter = function () {\n  // send out a master token request to renew the current session token\n  this.createMasterTokenRequest(\n    {\n      method: 'POST',\n      url: '/session/token-request',\n      headers: {\n        CLIENT_APP_ID: this.connectionConfig.getClientType(),\n        CLIENT_APP_VERSION: this.connectionConfig.getClientVersion(),\n      },\n      json: {\n        'REQUEST_TYPE': 'RENEW',\n        'oldSessionToken': this.tokenInfo.getSessionToken(),\n      },\n      scope: this,\n      callback: function (err, body) {\n        // if the request succeeded\n        if (!err) {\n          // update the token information\n          this.tokenInfo.update(body.data);\n\n          // we're now connected again\n          this.snowflakeService.transitionToConnected();\n        } else {\n          // if the master token has expired, transition to the disconnected\n          // state\n          if (err.code === GSErrors.code.MASTER_TOKEN_EXPIRED) {\n            this.snowflakeService.transitionToDisconnected();\n          } else if (Errors.isNetworkError(err)) {\n            // go back to the connected state\n            this.snowflakeService.transitionToConnected();\n          } else {\n            // if the renewal failed for some other reason, we're\n            // disconnected\n            // TODO: what should our state be here? also disconnected?\n            this.snowflakeService.transitionToDisconnected();\n          }\n        }\n\n        // all queued operations are now free to go\n        this.snowflakeService.drainOperationQueue();\n      }\n    }).send();\n};\n\n/**\n * @inheritDoc\n */\nStateRenewing.prototype.connect = function (options) {\n  // we're renewing the session token, which means we're connected,\n  // so any attempts to connect should result in an error\n  const callback = options.callback;\n  process.nextTick(function () {\n    callback(Errors.createClientError(\n      ErrorCodes.ERR_CONN_CONNECT_STATUS_CONNECTED));\n  });\n};\n\n/**\n * @inheritDoc\n */\nStateRenewing.prototype.request = function (options) {\n  // enqueue the request operation\n  this.snowflakeService.enqueueRequest(options);\n};\n\n/**\n * @inheritDoc\n */\nStateRenewing.prototype.destroy = function (options) {\n  // enqueue the destroy operation\n  this.snowflakeService.enqueueDestroy(options);\n};\n\n///////////////////////////////////////////////////////////////////////////\n////                StateDisconnected                                  ////\n///////////////////////////////////////////////////////////////////////////\n\nfunction StateDisconnected() {\n  StateAbstract.apply(this, arguments);\n}\n\nUtil.inherits(StateDisconnected, StateAbstract);\n\n/**\n * @inheritDoc\n */\nStateDisconnected.prototype.connect = function (options) {\n  // we're disconnected -- and fatally so -- so any\n  // attempts to connect should result in an error\n  const callback = options.callback;\n  process.nextTick(function () {\n    callback(Errors.createClientError(\n      ErrorCodes.ERR_CONN_CONNECT_STATUS_DISCONNECTED));\n  });\n};\n\n/**\n * @inheritDoc\n */\nStateDisconnected.prototype.request = function (options) {\n  // we're disconnected, so any attempts to\n  // send a request should result in an error\n  const callback = options.callback;\n  process.nextTick(function () {\n    callback(Errors.createClientError(\n      ErrorCodes.ERR_CONN_REQUEST_STATUS_DISCONNECTED, true));\n  });\n};\n\n/**\n * @inheritDoc\n */\nStateDisconnected.prototype.destroy = function (options) {\n  // we're already disconnected so any attempts\n  // to destroy should result in an error\n  const callback = options.callback;\n  process.nextTick(function () {\n    callback(Errors.createClientError(\n      ErrorCodes.ERR_CONN_DESTROY_STATUS_DISCONNECTED));\n  });\n};\n\n/**\n * Creates a TokenInfo object that encapsulates all token-related information,\n * e.g. the master token, the session token, the tokens' expiration times, etc.\n *\n * @param {Object} [config]\n *\n * @constructor\n */\nfunction TokenInfo(config) {\n  let masterToken;\n  let sessionToken;\n  let masterTokenExpirationTime;\n  let sessionTokenExpirationTime;\n\n  if (Util.isObject(config)) {\n    masterToken = config.masterToken;\n    sessionToken = config.sessionToken;\n    masterTokenExpirationTime = config.masterTokenExpirationTime;\n    sessionTokenExpirationTime = config.sessionTokenExpirationTime;\n  }\n\n  /**\n   * Returns true if no token-related information is available, false otherwise.\n   *\n   * @returns {Boolean}\n   */\n  this.isEmpty = function () {\n    return !Util.exists(masterToken) ||\n      !Util.exists(masterTokenExpirationTime) ||\n      !Util.exists(sessionToken) ||\n      !Util.exists(sessionTokenExpirationTime);\n  };\n\n  /**\n   * Clears all token-related information.\n   */\n  this.clearTokens = function () {\n    masterToken = undefined;\n    masterTokenExpirationTime = undefined;\n    sessionToken = undefined;\n    sessionTokenExpirationTime = undefined;\n  };\n\n  /**\n   * Updates the tokens and their expiration times.\n   *\n   * @param {Object} data\n   */\n  this.update = function (data) {\n    masterToken = data.masterToken;\n    sessionToken = data.token || data.sessionToken;\n\n    const currentTime = new Date().getTime();\n\n    masterTokenExpirationTime = currentTime +\n      1000 * (data.masterValidityInSeconds ||\n        data.validityInSecondsMT);\n\n    sessionTokenExpirationTime = currentTime +\n      1000 * (data.validityInSeconds ||\n        data.validityInSecondsST);\n  };\n\n  /**\n   * Returns the master token.\n   *\n   * @returns {String}\n   */\n  this.getMasterToken = function () {\n    return masterToken;\n  };\n\n  /**\n   * Returns the expiration time of the master token.\n   *\n   * @returns {Number}\n   */\n  this.getMasterTokenExpirationTime = function () {\n    return masterTokenExpirationTime;\n  };\n\n  /**\n   * Returns the session token.\n   *\n   * @returns {String}\n   */\n  this.getSessionToken = function () {\n    return sessionToken;\n  };\n\n  /**\n   * Returns the expiration time of the session token.\n   *\n   * @returns {Number}\n   */\n  this.getSessionTokenExpirationTime = function () {\n    return sessionTokenExpirationTime;\n  };\n\n  /**\n   * Returns a configuration object that can be passed to the TokenInfo\n   * constructor to get an equivalent TokenInfo object.\n   *\n   * @returns {Object}\n   */\n  this.getConfig = function () {\n    return {\n      masterToken: masterToken,\n      masterTokenExpirationTime: masterTokenExpirationTime,\n      sessionToken: sessionToken,\n      sessionTokenExpirationTime: sessionTokenExpirationTime\n    };\n  };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvc2VydmljZXMvc2YuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyw4REFBTTtBQUNyQyxxQkFBcUIsMERBQThCO0FBQ25ELGFBQWEsbUJBQU8sQ0FBQywrREFBUztBQUM5QixlQUFlLG1CQUFPLENBQUMsbUVBQVc7QUFDbEM7QUFDQSxZQUFZLG1CQUFPLENBQUMsZ0JBQUs7QUFDekIsb0JBQW9CLG1CQUFPLENBQUMsZ0NBQWE7QUFDekMsbUJBQW1CLG1CQUFPLENBQUMsMkVBQWU7QUFDMUMsaUJBQWlCLG1CQUFPLENBQUMsNkZBQXdCO0FBQ2pELDBCQUEwQixtQkFBTyxDQUFDLHlGQUFzQjtBQUN4RCxlQUFlLG1CQUFPLENBQUMsbUVBQVc7QUFDbEMscUJBQXFCLG1CQUFPLENBQUMsaUZBQWtCO0FBQy9DLDZCQUE2QixtQkFBTyxDQUFDLDZIQUF3QztBQUM3RSxpQkFBaUIsbUJBQU8sQ0FBQyx1R0FBNkI7QUFDdEQsb0JBQW9CLG1CQUFPLENBQUMsNkdBQWdDO0FBQzVELHNCQUFzQixtQkFBTyxDQUFDLGlIQUFrQztBQUNoRSxpQkFBaUIsbUJBQU8sQ0FBQyw2RkFBd0I7O0FBRWpEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVE7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNLFFBQVE7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQkFBZ0I7QUFDeEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw4SEFBOEgsZUFBZTtBQUM3STtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFFBQVE7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTs7QUFFMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLENBQVc7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdEQUF3RCx3Q0FBd0M7QUFDaEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsMkRBQTJEO0FBQ25FLFFBQVEsNkRBQTZEO0FBQ3JFLFFBQVEseURBQXlEO0FBQ2pFLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELGdCQUFnQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsVUFBVTtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvc2VydmljZXMvc2YuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgU25vd2ZsYWtlU2VydmljZSBzdGF0ZSBtYWNoaW5lXG5cbiAgUHJlY29ubmVjdGVkIC0gZW50ZXIoKSAgICAgIC0gUHJlY29ubmVjdGVkXG4gICAgICAgICAgICAgICAtIGNvbm5lY3QoKSAgICAtIENvbm5lY3RpbmdcbiAgICAgICAgICAgICAgIC0gcmVxdWVzdCgpICAgIC0gQ29ubmVjdGluZ1xuICAgICAgICAgICAgICAgLSBkZXN0cm95KCkgICAgLSBQcmVjb25uZWN0ZWRcblxuICBDb25uZWN0aW5nICAgLSBlbnRlcigpICAgICAgLSBhc3luYyBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBDb25uZWN0ZWQgaWYgb3BlcmF0aW9uIHN1Y2NlZWRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gRGlzY29ubmVjdGVkIGlmIG5ldHdvcmsgZXJyb3IgKHdlIG5lZWQgYW5vdGhlciBQcmVDb25uZWN0ZWQgc3RhdGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gRGlzY29ubmVjdGVkIGlmIG9wZXJhdGlvbiBmYWlsc1xuICAgICAgICAgICAgICAgICBjb25uZWN0KCkgICAgLSBlcnJvclxuICAgICAgICAgICAgICAgICByZXF1ZXN0KCkgICAgLSBlbnF1ZXVlXG4gICAgICAgICAgICAgICAgIGRlc3Ryb3koKSAgICAtIGVucXVldWVcblxuICBDb25uZWN0ZWQgICAgLSBlbnRlcigpICAgICAgLSBDb25uZWN0ZWRcbiAgICAgICAgICAgICAgICAgY29ubmVjdCgpICAgIC0gZXJyb3JcbiAgICAgICAgICAgICAgICAgcmVxdWVzdCgpICAgIC0gYXN5bmMgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQ29ubmVjdGVkIGlmIG9wZXJhdGlvbiBzdWNjZWVkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIENvbm5lY3RlZCBpZiBuZXR3b3JrIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gUmVuZXdpbmcgaWYgR1Mgc2F5cyBzZXNzaW9uIHRva2VuIGhhcyBleHBpcmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gRGlzY29ubmVjdGVkIGlmIEdTIHNheXMgc2Vzc2lvbiB0b2tlbiBpcyBpbnZhbGlkXG4gICAgICAgICAgICAgICAgIGRlc3Ryb3koKSAgICAtIGFzeW5jIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBEaXNjb25uZWN0ZWQgaWYgb3BlcmF0aW9uIHN1Y2NlZWRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIENvbm5lY3RlZCBpZiBuZXR3b3JrIGVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtIENvbm5lY3RlZCBpZiBvcGVyYXRpb24gZmFpbHNcblxuICBSZW5ld2luZyAgICAgLSBlbnRlcigpICAgICAgLSBhc3luYyBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBDb25uZWN0ZWQgaWYgb3BlcmF0aW9uIHN1Y2NlZWRzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC0gQ29ubmVjdGVkIGlmIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLSBEaXNjb25uZWN0ZWQgaWYgb3BlcmF0aW9uIGZhaWxzXG4gICAgICAgICAgICAgICAtIGNvbm5lY3QoKSAgICAtIGVycm9yXG4gICAgICAgICAgICAgICAtIHJlcXVlc3QoKSAgICAtIGVucXVldWVcbiAgICAgICAgICAgICAgIC0gZGVzdHJveSgpICAgIC0gZW5xdWV1ZVxuXG4gIERpc2Nvbm5lY3RlZCAtIGVudGVyKCkgICAgICAtIERpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgLSBjb25uZWN0KCkgICAgLSBEaXNjb25uZWN0ZWRcbiAgICAgICAgICAgICAgIC0gcmVxdWVzdCgpICAgIC0gRGlzY29ubmVjdGVkXG4gICAgICAgICAgICAgICAtIGRlc3Ryb3koKSAgICAtIERpc2Nvbm5lY3RlZFxuICovXG5cbmNvbnN0IHsgdjQ6IHV1aWR2NCB9ID0gcmVxdWlyZSgndXVpZCcpO1xuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuY29uc3QgVXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcbmNvbnN0IEVycm9ycyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2RlcztcbmNvbnN0IFVybCA9IHJlcXVpcmUoJ3VybCcpO1xuY29uc3QgUXVlcnlTdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuY29uc3QgUGFyYW1ldGVycyA9IHJlcXVpcmUoJy4uL3BhcmFtZXRlcnMnKTtcbmNvbnN0IEdTRXJyb3JzID0gcmVxdWlyZSgnLi4vY29uc3RhbnRzL2dzX2Vycm9ycycpO1xuY29uc3QgUXVlcnlDb250ZXh0Q2FjaGUgPSByZXF1aXJlKCcuLi9xdWVyeUNvbnRleHRDYWNoZScpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vbG9nZ2VyJyk7XG5jb25zdCBHbG9iYWxDb25maWcgPSByZXF1aXJlKCcuLi9nbG9iYWxfY29uZmlnJyk7XG5jb25zdCBBdXRoZW50aWNhdGlvblR5cGVzICA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL2F1dGhlbnRpY2F0aW9uX3R5cGVzJyk7XG5jb25zdCBBdXRoT2t0YSA9IHJlcXVpcmUoJy4uL2F1dGhlbnRpY2F0aW9uL2F1dGhfb2t0YScpO1xuY29uc3QgQXV0aEtleXBhaXIgPSByZXF1aXJlKCcuLi9hdXRoZW50aWNhdGlvbi9hdXRoX2tleXBhaXInKTtcbmNvbnN0IEF1dGhlbnRpY2F0b3IgPSByZXF1aXJlKCcuLi9hdXRoZW50aWNhdGlvbi9hdXRoZW50aWNhdGlvbicpO1xuY29uc3Qgc2ZQYXJhbXMgPSByZXF1aXJlKCcuLi9jb25zdGFudHMvc2ZfcGFyYW1zJyk7XG5cbmZ1bmN0aW9uIGlzUmV0cnlhYmxlTmV0d29ya0Vycm9yKGVycikge1xuICAvLyBhbnl0aGluZyBvdGhlciB0aGFuIFJFVk9LRUQgZXJyb3IgY2FuIGJlIHJldHJ5YWJsZS5cbiAgcmV0dXJuICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXJyLCAnY2F1c2UnKSB8fFxuICAgIGVyci5jYXVzZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlcnIuY2F1c2UsICdjb2RlJykgfHxcbiAgICAoXG4gICAgICBlcnIuY2F1c2UuY29kZSAhPT0gRXJyb3JDb2Rlcy5FUlJfT0NTUF9SRVZPS0VEICYmXG4gICAgICBlcnIuY2F1c2UuY29kZSAhPT0gJ0RFUFRIX1pFUk9fU0VMRl9TSUdORURfQ0VSVCcgJiZcbiAgICAgIGVyci5jYXVzZS5jb2RlICE9PSAnQ0VSVF9IQVNfRVhQSVJFRCcgJiZcbiAgICAgIGVyci5jYXVzZS5jb2RlICE9PSAnVU5BQkxFX1RPX1ZFUklGWV9MRUFGX1NJR05BVFVSRScgJiZcbiAgICAgIGVyci5jYXVzZS5jb2RlICE9PSAnU0VMRl9TSUdORURfQ0VSVF9JTl9DSEFJTidcbiAgICApO1xufVxuXG5mdW5jdGlvbiBpc1JldHJ5YWJsZUh0dHBFcnJvcihlcnIpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlcnIsICdyZXNwb25zZScpICYmXG4gICAgVXRpbC5pc1JldHJ5YWJsZUh0dHBFcnJvcihlcnIucmVzcG9uc2UsIGZhbHNlKTtcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFNub3dmbGFrZVNlcnZpY2UgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbm5lY3Rpb25Db25maWdcbiAqIEBwYXJhbSB7T2JqZWN0fSBodHRwQ2xpZW50XG4gKiBAcGFyYW0ge09iamVjdH0gW2NvbmZpZ11cbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTbm93Zmxha2VTZXJ2aWNlKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQsIGNvbmZpZykge1xuICAvLyB2YWxpZGF0ZSBpbnB1dFxuICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjb25uZWN0aW9uQ29uZmlnKSk7XG4gIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KGh0dHBDbGllbnQpKTtcbiAgRXJyb3JzLmFzc2VydEludGVybmFsKCFVdGlsLmV4aXN0cyhjb25maWcpIHx8IFV0aWwuaXNPYmplY3QoY29uZmlnKSk7XG5cbiAgLy8gaWYgYSBjb25maWcgb2JqZWN0IHdhcyBzcGVjaWZpZWQsIHZlcmlmeVxuICAvLyB0aGF0IGl0IGhhcyBhbGwgdGhlIGluZm9ybWF0aW9uIHdlIG5lZWRcbiAgbGV0IHRva2VuSW5mb0NvbmZpZztcbiAgaWYgKFV0aWwuZXhpc3RzKGNvbmZpZykpIHtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjb25maWcpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc09iamVjdChjb25maWcudG9rZW5JbmZvKSk7XG5cbiAgICB0b2tlbkluZm9Db25maWcgPSBjb25maWcudG9rZW5JbmZvO1xuICB9IGVsc2UgaWYgKGNvbm5lY3Rpb25Db25maWcuc2Vzc2lvblRva2VuKSB7XG4gICAgdG9rZW5JbmZvQ29uZmlnID0ge1xuICAgICAgc2Vzc2lvblRva2VuOiBjb25uZWN0aW9uQ29uZmlnLnNlc3Npb25Ub2tlbixcbiAgICAgIG1hc3RlclRva2VuOiBjb25uZWN0aW9uQ29uZmlnLm1hc3RlclRva2VuIHx8IGNvbm5lY3Rpb25Db25maWcuc2Vzc2lvblRva2VuLFxuICAgICAgc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWU6IGNvbm5lY3Rpb25Db25maWcuc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWUgfHwgRGF0ZS5ub3coKSArIDEwMDAgKiA2MCAqIDYwICogMjQsXG4gICAgICBtYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lOiBjb25uZWN0aW9uQ29uZmlnLm1hc3RlclRva2VuRXhwaXJhdGlvblRpbWUgfHwgRGF0ZS5ub3coKSArIDEwMDAgKiA2MCAqIDYwICogMjRcbiAgICB9O1xuICB9XG5cbiAgLy8gY3JlYXRlIGEgbmV3IFRva2VuSW5mbyBpbnN0YW5jZVxuICBjb25zdCB0b2tlbkluZm8gPSBuZXcgVG9rZW5JbmZvKHRva2VuSW5mb0NvbmZpZyk7XG5cbiAgdGhpcy5hdXRoZW50aWNhdG9yID0gQXV0aGVudGljYXRvci5nZXRBdXRoZW50aWNhdG9yKGNvbm5lY3Rpb25Db25maWcsIGh0dHBDbGllbnQpO1xuXG4gIC8vIGNyZWF0ZSBzdGF0ZSBvYmplY3RzIGZvciBhbGwgdGhlIGRpZmZlcmVudCBzdGF0ZXMgd2UgY2FuIGJlIGluXG4gIGNvbnN0IHN0YXRlT3B0aW9ucyA9XG4gICAge1xuICAgICAgc25vd2ZsYWtlU2VydmljZTogdGhpcyxcbiAgICAgIGh0dHBDbGllbnQ6IGh0dHBDbGllbnQsXG4gICAgICBjb25uZWN0aW9uQ29uZmlnOiBjb25uZWN0aW9uQ29uZmlnLFxuICAgICAgdG9rZW5JbmZvOiB0b2tlbkluZm9cbiAgICB9O1xuICBjb25zdCBzdGF0ZVByaXN0aW5lID0gbmV3IFN0YXRlUHJpc3RpbmUoc3RhdGVPcHRpb25zKTtcbiAgY29uc3Qgc3RhdGVDb25uZWN0aW5nID0gbmV3IFN0YXRlQ29ubmVjdGluZyhzdGF0ZU9wdGlvbnMpO1xuICBjb25zdCBzdGF0ZUNvbm5lY3RlZCA9IG5ldyBTdGF0ZUNvbm5lY3RlZChzdGF0ZU9wdGlvbnMpO1xuICBjb25zdCBzdGF0ZVJlbmV3aW5nID0gbmV3IFN0YXRlUmVuZXdpbmcoc3RhdGVPcHRpb25zKTtcbiAgY29uc3Qgc3RhdGVEaXNjb25uZWN0ZWQgPSBuZXcgU3RhdGVEaXNjb25uZWN0ZWQoc3RhdGVPcHRpb25zKTtcblxuICBsZXQgY3VycmVudFN0YXRlO1xuXG4gIC8qKlxuICAgKiBUcmFuc2l0aW9ucyB0byBhIGdpdmVuIHN0YXRlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFt0cmFuc2l0aW9uQ29udGV4dF1cbiAgICovXG4gIGNvbnN0IHRyYW5zaXRpb25UbyA9IGZ1bmN0aW9uIChzdGF0ZSwgdHJhbnNpdGlvbkNvbnRleHQpIHtcbiAgICAvLyB0aGlzIGNoZWNrIGlzIG5lY2Vzc2FyeSB0byBtYWtlIHN1cmUgd2UgZG9uJ3QgcmUtZW50ZXIgYSB0cmFuc2llbnQgc3RhdGVcbiAgICAvLyBsaWtlIFJlbmV3aW5nIHdoZW4gd2UncmUgYWxyZWFkeSBpbiBpdFxuICAgIGlmIChjdXJyZW50U3RhdGUgIT09IHN0YXRlKSB7XG4gICAgICAvLyBpZiB3ZSBoYXZlIGEgY3VycmVudCBzdGF0ZSwgZXhpdCBpdDsgdGhlIG51bGwgY2hlY2sgaXMgbmVjZXNzYXJ5XG4gICAgICAvLyBiZWNhdXNlIHRoZSBjdXJyZW50U3RhdGUgaXMgdW5kZWZpbmVkIGF0IGJvb3RzdHJhcCB0aW1lIHdoZW4gd2VcbiAgICAgIC8vIHRyYW5zaXRpb24gdG8gdGhlIGZpcnN0IHN0YXRlXG4gICAgICBpZiAoY3VycmVudFN0YXRlKSB7XG4gICAgICAgIGN1cnJlbnRTdGF0ZS5leGl0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIHVwZGF0ZSB0aGUgY3VycmVudCBzdGF0ZVxuICAgICAgY3VycmVudFN0YXRlID0gc3RhdGU7XG5cbiAgICAgIC8vIGVudGVyIHRoZSBuZXcgc3RhdGVcbiAgICAgIGN1cnJlbnRTdGF0ZS5lbnRlcih0cmFuc2l0aW9uQ29udGV4dCk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHNlc3Npb24gaWQgZm9yIHRoZSBjdXJyZW50IFNub3dmbGFrZVNlcnZpY2VcbiAgICogQHBhcmFtIHNlc3Npb25JZFxuICAgKi9cbiAgdGhpcy5zZXRTZXNzaW9uSWQgPSBmdW5jdGlvbiAoc2Vzc2lvbklkKSB7XG4gICAgdGhpcy5zZXNzaW9uSWQgPSBzZXNzaW9uSWQ7XG4gIH07XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgc2Vzc2lvbiBpZC5cbiAgICogQHJldHVybnMge251bWJlcn1cbiAgICovXG4gIHRoaXMuZ2V0U2Vzc2lvbklkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzLnNlc3Npb25JZDtcbiAgfTtcblxuICAvKipcbiAgICogVHJhbnNpdGlvbnMgdG8gdGhlIFByaXN0aW5lIHN0YXRlLlxuICAgKlxuICAgKiB7T2JqZWN0fSBbdHJhbnNpdGlvbkNvbnRleHRdXG4gICAqL1xuICB0aGlzLnRyYW5zaXRpb25Ub1ByaXN0aW5lID0gZnVuY3Rpb24gKHRyYW5zaXRpb25Db250ZXh0KSB7XG4gICAgdHJhbnNpdGlvblRvKHN0YXRlUHJpc3RpbmUsIHRyYW5zaXRpb25Db250ZXh0KTtcbiAgfTtcblxuICAvKipcbiAgICogVHJhbnNpdGlvbnMgdG8gdGhlIENvbm5lY3Rpbmcgc3RhdGUuXG4gICAqXG4gICAqIHtPYmplY3R9IFt0cmFuc2l0aW9uQ29udGV4dF1cbiAgICovXG4gIHRoaXMudHJhbnNpdGlvblRvQ29ubmVjdGluZyA9IGZ1bmN0aW9uICh0cmFuc2l0aW9uQ29udGV4dCkge1xuICAgIHRyYW5zaXRpb25UbyhzdGF0ZUNvbm5lY3RpbmcsIHRyYW5zaXRpb25Db250ZXh0KTtcbiAgfTtcblxuICAvKipcbiAgICogVHJhbnNpdGlvbnMgdG8gdGhlIENvbm5lY3RlZCBzdGF0ZS5cbiAgICpcbiAgICoge09iamVjdH0gW3RyYW5zaXRpb25Db250ZXh0XVxuICAgKi9cbiAgdGhpcy50cmFuc2l0aW9uVG9Db25uZWN0ZWQgPSBmdW5jdGlvbiAodHJhbnNpdGlvbkNvbnRleHQpIHtcbiAgICB0cmFuc2l0aW9uVG8oc3RhdGVDb25uZWN0ZWQsIHRyYW5zaXRpb25Db250ZXh0KTtcbiAgfTtcblxuICAvKipcbiAgICogVHJhbnNpdGlvbnMgdG8gdGhlIFJlbmV3aW5nIHN0YXRlLlxuICAgKlxuICAgKiB7T2JqZWN0fSBbdHJhbnNpdGlvbkNvbnRleHRdXG4gICAqL1xuICB0aGlzLnRyYW5zaXRpb25Ub1JlbmV3aW5nID0gZnVuY3Rpb24gKHRyYW5zaXRpb25Db250ZXh0KSB7XG4gICAgdHJhbnNpdGlvblRvKHN0YXRlUmVuZXdpbmcsIHRyYW5zaXRpb25Db250ZXh0KTtcbiAgfTtcblxuICAvKipcbiAgICogVHJhbnNpdGlvbnMgdG8gdGhlIERpc2Nvbm5lY3RlZCBzdGF0ZS5cbiAgICpcbiAgICoge09iamVjdH0gW3RyYW5zaXRpb25Db250ZXh0XVxuICAgKi9cbiAgdGhpcy50cmFuc2l0aW9uVG9EaXNjb25uZWN0ZWQgPSBmdW5jdGlvbiAodHJhbnNpdGlvbkNvbnRleHQpIHtcbiAgICB0cmFuc2l0aW9uVG8oc3RhdGVEaXNjb25uZWN0ZWQsIHRyYW5zaXRpb25Db250ZXh0KTtcblxuICAgIC8vIGNsZWFyIHRoZSB0b2tlbnMgYmVjYXVzZSB3ZSdyZSBpbiBhIGZhdGFsIHN0YXRlIGFuZCB3ZSBkb24ndCB3YW50IHRoZVxuICAgIC8vIHRva2VucyB0byBiZSBhdmFpbGFibGUgdmlhIGdldENvbmZpZygpIGFueW1vcmVcbiAgICB0b2tlbkluZm8uY2xlYXJUb2tlbnMoKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyBhIGNvbmZpZ3VyYXRpb24gb2JqZWN0IHRoYXQgY2FuIGJlIHBhc3NlZCB0byB0aGUgU25vd2ZsYWtlU2VydmljZVxuICAgKiBjb25zdHJ1Y3RvciB0byBnZXQgYW4gZXF1aXZhbGVudCBTbm93Zmxha2VTZXJ2aWNlIG9iamVjdC5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHRoaXMuZ2V0Q29uZmlnID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0b2tlbkluZm86IHRva2VuSW5mby5nZXRDb25maWcoKVxuICAgIH07XG4gIH07XG5cbiAgLyoqXG4gICAqIEVzdGFibGlzaGVzIGEgY29ubmVjdGlvbiB0byBTbm93Zmxha2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICB0aGlzLmNvbm5lY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG5ldyBPcGVyYXRpb25Db25uZWN0KG9wdGlvbnMpLnZhbGlkYXRlKCkuZXhlY3V0ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJc3N1ZXMgYSBjb25uZWN0LWNvbnRpbnVlIHJlcXVlc3QgdG8gU25vd2ZsYWtlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gICAqL1xuICB0aGlzLmNvbnRpbnVlID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBuZXcgT3BlcmF0aW9uQ29udGludWUob3B0aW9ucykudmFsaWRhdGUoKS5leGVjdXRlKCk7XG4gIH07XG5cbiAgLyoqXG4gICAqIElzc3VlcyBhIGdlbmVyaWMgcmVxdWVzdCB0byBTbm93Zmxha2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICB0aGlzLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIG5ldyBPcGVyYXRpb25SZXF1ZXN0KG9wdGlvbnMpLnZhbGlkYXRlKCkuZXhlY3V0ZSgpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJc3N1ZXMgYSBnZW5lcmljIGFzeW5jIHJlcXVlc3QgdG8gU25vd2ZsYWtlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5yZXF1ZXN0QXN5bmMgPSBhc3luYyBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgIHJldHVybiBhd2FpdCBuZXcgT3BlcmF0aW9uUmVxdWVzdChvcHRpb25zKS52YWxpZGF0ZSgpLmV4ZWN1dGVBc3luYygpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBUZXJtaW5hdGVzIHRoZSBjdXJyZW50IGNvbm5lY3Rpb24gdG8gU25vd2ZsYWtlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5kZXN0cm95ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLmNsZWFyQ2FjaGUoKTtcbiAgICBuZXcgT3BlcmF0aW9uRGVzdHJveShvcHRpb25zKS52YWxpZGF0ZSgpLmV4ZWN1dGUoKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBPcGVyYXRpb25BYnN0cmFjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBPcGVyYXRpb25BYnN0cmFjdChvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBWYWxpZGF0ZXMgdGhlIG9wZXJhdGlvbiBvcHRpb25zLlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgb3BlcmF0aW9uLlxuICAgKi9cbiAgT3BlcmF0aW9uQWJzdHJhY3QucHJvdG90eXBlLnZhbGlkYXRlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgb3BlcmF0aW9uLlxuICAgKi9cbiAgT3BlcmF0aW9uQWJzdHJhY3QucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgT3BlcmF0aW9uQ29ubmVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBPcGVyYXRpb25Db25uZWN0KG9wdGlvbnMpIHtcbiAgICBPcGVyYXRpb25BYnN0cmFjdC5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICB9XG5cbiAgVXRpbC5pbmhlcml0cyhPcGVyYXRpb25Db25uZWN0LCBPcGVyYXRpb25BYnN0cmFjdCk7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBPcGVyYXRpb25Db25uZWN0LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGUgb3B0aW9ucyBvYmplY3QgY29udGFpbnMgYSBjYWxsYmFjayBmdW5jdGlvblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFxuICAgICAgKFV0aWwuaXNPYmplY3Qob3B0aW9ucykgJiYgVXRpbC5pc0Z1bmN0aW9uKG9wdGlvbnMuY2FsbGJhY2spKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE9wZXJhdGlvbkNvbm5lY3QucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY3VycmVudFN0YXRlLmNvbm5lY3QodGhpcy5vcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBPcGVyYXRpb25Db250aW51ZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBPcGVyYXRpb25Db250aW51ZShvcHRpb25zKSB7XG4gICAgT3BlcmF0aW9uQWJzdHJhY3QuYXBwbHkodGhpcywgW29wdGlvbnNdKTtcbiAgfVxuXG4gIFV0aWwuaW5oZXJpdHMoT3BlcmF0aW9uQ29udGludWUsIE9wZXJhdGlvbkFic3RyYWN0KTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE9wZXJhdGlvbkNvbnRpbnVlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGUgb3B0aW9ucyBjb250YWluIGEganNvbiBvYmplY3RcbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChcbiAgICAgIFV0aWwuaXNPYmplY3Qob3B0aW9ucykgJiYgVXRpbC5pc09iamVjdChvcHRpb25zLmpzb24pKTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8qKlxuICAgKiBAaW5oZXJpdERvY1xuICAgKi9cbiAgT3BlcmF0aW9uQ29udGludWUucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgY3VycmVudFN0YXRlLmNvbnRpbnVlKHRoaXMub3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgT3BlcmF0aW9uUmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBPcGVyYXRpb25SZXF1ZXN0KG9wdGlvbnMpIHtcbiAgICBPcGVyYXRpb25BYnN0cmFjdC5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICB9XG5cbiAgVXRpbC5pbmhlcml0cyhPcGVyYXRpb25SZXF1ZXN0LCBPcGVyYXRpb25BYnN0cmFjdCk7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBPcGVyYXRpb25SZXF1ZXN0LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGUgb3B0aW9ucyBvYmplY3QgY29udGFpbnMgYWxsIHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb25cbiAgICBjb25zdCBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChVdGlsLmlzT2JqZWN0KG9wdGlvbnMpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5pc1N0cmluZyhvcHRpb25zLm1ldGhvZCkpO1xuICAgIEVycm9ycy5hc3NlcnRJbnRlcm5hbChcbiAgICAgICFVdGlsLmV4aXN0cyhvcHRpb25zLmhlYWRlcnMpIHx8IFV0aWwuaXNPYmplY3Qob3B0aW9ucy5oZWFkZXJzKSk7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNTdHJpbmcob3B0aW9ucy51cmwpKTtcbiAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoXG4gICAgICAhVXRpbC5leGlzdHMob3B0aW9ucy5qc29uKSB8fCBVdGlsLmlzT2JqZWN0KG9wdGlvbnMuanNvbikpO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBPcGVyYXRpb25SZXF1ZXN0LnByb3RvdHlwZS5leGVjdXRlID0gZnVuY3Rpb24gKCkge1xuICAgIGN1cnJlbnRTdGF0ZS5yZXF1ZXN0KHRoaXMub3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICogQGluaGVyaXREb2NcbiAgKi9cbiAgT3BlcmF0aW9uUmVxdWVzdC5wcm90b3R5cGUuZXhlY3V0ZUFzeW5jID0gYXN5bmMgZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBhd2FpdCBjdXJyZW50U3RhdGUucmVxdWVzdEFzeW5jKHRoaXMub3B0aW9ucyk7XG4gIH07XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgT3BlcmF0aW9uRGVzdHJveS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBPcGVyYXRpb25EZXN0cm95KG9wdGlvbnMpIHtcbiAgICBPcGVyYXRpb25BYnN0cmFjdC5hcHBseSh0aGlzLCBbb3B0aW9uc10pO1xuICB9XG5cbiAgVXRpbC5pbmhlcml0cyhPcGVyYXRpb25EZXN0cm95LCBPcGVyYXRpb25BYnN0cmFjdCk7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBPcGVyYXRpb25EZXN0cm95LnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyB2ZXJpZnkgdGhhdCB0aGUgb3B0aW9ucyBvYmplY3QgY29udGFpbnMgYSBjYWxsYmFjayBmdW5jdGlvblxuICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XG4gICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuaXNPYmplY3Qob3B0aW9ucykgJiZcbiAgICAgIFV0aWwuaXNGdW5jdGlvbihvcHRpb25zLmNhbGxiYWNrKSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE9wZXJhdGlvbkRlc3Ryb3kucHJvdG90eXBlLmV4ZWN1dGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgLy8gZGVsZWdhdGUgdG8gY3VycmVudCBzdGF0ZVxuICAgIGN1cnJlbnRTdGF0ZS5kZXN0cm95KHRoaXMub3B0aW9ucyk7XG4gIH07XG5cbiAgLyogQWxsIHF1ZXVlZCBvcGVyYXRpb25zIHdpbGwgYmUgYWRkZWQgdG8gdGhpcyBhcnJheSAqL1xuICBjb25zdCBvcGVyYXRpb25RdWV1ZSA9IFtdO1xuXG4gIC8qKlxuICAgKiBBcHBlbmRzIGEgcmVxdWVzdCBvcGVyYXRpb24gdG8gdGhlIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cbiAgdGhpcy5lbnF1ZXVlUmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgb3BlcmF0aW9uUXVldWUucHVzaChuZXcgT3BlcmF0aW9uUmVxdWVzdChvcHRpb25zKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgYSBkZXN0cm95IG9wZXJhdGlvbiB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqL1xuICB0aGlzLmVucXVldWVEZXN0cm95ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICBvcGVyYXRpb25RdWV1ZS5wdXNoKG5ldyBPcGVyYXRpb25EZXN0cm95KG9wdGlvbnMpKTtcbiAgfTtcblxuICAvKipcbiAgICogRXhlY3V0ZXMgYWxsIHRoZSBvcGVyYXRpb25zIGluIHRoZSBxdWV1ZS5cbiAgICovXG4gIHRoaXMuZHJhaW5PcGVyYXRpb25RdWV1ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAvLyBleGVjdXRlIGFsbCB0aGUgb3BlcmF0aW9ucyBpbiB0aGUgcXVldWVcbiAgICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IG9wZXJhdGlvblF1ZXVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIG9wZXJhdGlvblF1ZXVlW2luZGV4XS5leGVjdXRlKCk7XG4gICAgfVxuXG4gICAgLy8gZW1wdHkgdGhlIHF1ZXVlXG4gICAgb3BlcmF0aW9uUXVldWUubGVuZ3RoID0gMDtcbiAgfTtcblxuICB0aGlzLmlzQ29ubmVjdGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBjdXJyZW50U3RhdGUgPT09IHN0YXRlQ29ubmVjdGVkIHx8XG4gICAgICBjdXJyZW50U3RhdGUgPT09IHN0YXRlQ29ubmVjdGluZyB8fFxuICAgICAgY3VycmVudFN0YXRlID09PSBzdGF0ZVJlbmV3aW5nO1xuICB9O1xuXG4gIHRoaXMuZ2V0U2VydmljZU5hbWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIFBhcmFtZXRlcnMuZ2V0VmFsdWUoUGFyYW1ldGVycy5uYW1lcy5TRVJWSUNFX05BTUUpO1xuICB9O1xuXG4gIHRoaXMuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUGFyYW1ldGVycy5nZXRWYWx1ZShQYXJhbWV0ZXJzLm5hbWVzLkNMSUVOVF9TRVNTSU9OX0tFRVBfQUxJVkUpO1xuICB9O1xuXG4gIHRoaXMuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZUhlYXJ0YmVhdEZyZXF1ZW5jeSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gUGFyYW1ldGVycy5nZXRWYWx1ZShQYXJhbWV0ZXJzLm5hbWVzLkNMSUVOVF9TRVNTSU9OX0tFRVBfQUxJVkVfSEVBUlRCRUFUX0ZSRVFVRU5DWSk7XG4gIH07XG5cbiAgdGhpcy5nZXRKc1RyZWF0SW50ZWdlckFzQmlnSW50ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBQYXJhbWV0ZXJzLmdldFZhbHVlKFBhcmFtZXRlcnMubmFtZXMuSlNfVFJFQVRfSU5URUdFUl9BU19CSUdJTlQpO1xuICB9O1xuXG4gIHRoaXMuZ2V0QXV0aGVudGljYXRvciA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gdGhpcy5hdXRoZW50aWNhdG9yO1xuICB9O1xuXG4gIC8vIGlmIHdlIGRvbid0IGhhdmUgYW55IHRva2Vucywgc3RhcnQgb3V0IGFzIHByaXN0aW5lXG4gIGlmICh0b2tlbkluZm8uaXNFbXB0eSgpKSB7XG4gICAgdGhpcy50cmFuc2l0aW9uVG9QcmlzdGluZSgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHdlJ3JlIGFscmVhZHkgY29ubmVjdGVkXG4gICAgdGhpcy50cmFuc2l0aW9uVG9Db25uZWN0ZWQoKTtcbiAgfVxuXG4gIC8qKlxuICAqIElzc3VlcyBhIHBvc3QgcmVxdWVzdCB0byBTbm93Zmxha2UuXG4gICpcbiAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAqL1xuICB0aGlzLnBvc3RBc3luYyA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBPcGVyYXRpb25SZXF1ZXN0KG9wdGlvbnMpLnZhbGlkYXRlKCkuZXhlY3V0ZUFzeW5jKCk7XG4gIH07XG5cbiAgdGhpcy5nZXRRdWVyeUNvbnRleHREVE8gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnFjYyl7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnFjYy5nZXRRdWVyeUNvbnRleHREVE8oKTtcbiAgfTtcblxuICB0aGlzLmRlc2VyaWFsaXplUXVlcnlDb250ZXh0ID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICBpZiAoIXRoaXMucWNjKXtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5xY2MuZGVzZXJpYWxpemVRdWVyeUNvbnRleHQoZGF0YSk7XG4gIH07XG5cbiAgdGhpcy5jbGVhckNhY2hlID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICghdGhpcy5xY2Mpe1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnFjYy5jbGVhckNhY2hlKCk7IFxuICB9O1xuXG4gIHRoaXMuaW5pdGlhbGl6ZVF1ZXJ5Q29udGV4dENhY2hlID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgICBpZiAoIWNvbm5lY3Rpb25Db25maWcuZ2V0RGlzYWJsZVF1ZXJ5Q29udGV4dENhY2hlKCkpe1xuICAgICAgdGhpcy5xY2MgPSBuZXcgUXVlcnlDb250ZXh0Q2FjaGUoc2l6ZSwgdGhpcy5nZXRTZXNzaW9uSWQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKGBRdWVyeUNvbnRleHRDYWNoZSBpbml0aWFsaXphdGlvbiBza2lwcGVkIGFzIGl0IGlzIGRpc2FibGVkIGZvciBjb25uZWN0aW9uIHdpdGggc2Vzc2lvbklkOiAke3RoaXMuc2Vzc2lvbklkfWApO1xuICAgIH1cbiAgfTtcblxuICAvLyB0ZXN0aW5nIHB1cnBvc2VcbiAgdGhpcy5nZXRRdWVyeUNvbnRleHRDYWNoZVNpemUgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCF0aGlzLnFjYyl7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnFjYy5nZXRTaXplKCk7XG4gIH07XG59XG5cblV0aWwuaW5oZXJpdHMoU25vd2ZsYWtlU2VydmljZSwgRXZlbnRFbWl0dGVyKTtcblxubW9kdWxlLmV4cG9ydHMgPSBTbm93Zmxha2VTZXJ2aWNlO1xuXG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLyAgICAgICAgICAgICAgICBTdGF0ZUFic3RyYWN0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFN0YXRlQWJzdHJhY3QgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBTdGF0ZUFic3RyYWN0KG9wdGlvbnMpIHtcbiAgLyoqXG4gICAqIElzc3VlcyBhbiBodHRwIHJlcXVlc3QgdG8gU25vd2ZsYWtlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdE9wdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IGh0dHBDbGllbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IGF1dGhcbiAgICogQHJldHVybnMge09iamVjdH0gdGhlIGh0dHAgcmVxdWVzdCBvYmplY3QuXG4gICAqL1xuICBmdW5jdGlvbiBzZW5kSHR0cFJlcXVlc3QocmVxdWVzdE9wdGlvbnMsIGh0dHBDbGllbnQsIGF1dGgpIHtcblxuICAgIGNvbnN0IHBhcmFtcyA9IHJlcXVlc3RPcHRpb25zLnBhcmFtcyB8fCB7fTtcbiAgICBpZiAoIXJlcXVlc3RPcHRpb25zLmV4Y2x1ZGVHdWlkKSB7XG4gICAgICBhZGRHdWlkVG9QYXJhbXMocGFyYW1zKTtcbiAgICB9XG5cbiAgICBjb25zdCByZWFsUmVxdWVzdE9wdGlvbnMgPVxuICAgICAge1xuICAgICAgICBtZXRob2Q6IHJlcXVlc3RPcHRpb25zLm1ldGhvZCxcbiAgICAgICAgaGVhZGVyczogcmVxdWVzdE9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgdXJsOiByZXF1ZXN0T3B0aW9ucy5hYnNvbHV0ZVVybCxcbiAgICAgICAgZ3ppcDogcmVxdWVzdE9wdGlvbnMuZ3ppcCxcbiAgICAgICAganNvbjogcmVxdWVzdE9wdGlvbnMuanNvbixcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgIGNhbGxiYWNrOiBhc3luYyBmdW5jdGlvbiAoZXJyLCByZXNwb25zZSwgYm9keSkge1xuICAgICAgICAgIC8vIGlmIHdlIGdvdCBhbiBlcnJvciwgd3JhcCBpdCBpbnRvIGEgbmV0d29yayBlcnJvclxuICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIC8vIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gREVCVUcgbG9nbGV2ZWwsIHByb2JhYmx5IHdlIHdhbnQgdG8gc2VlIHRoZSBmdWxsIGVycm9yIGluc3RlYWRcbiAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdFbmNvdW50ZXJlZCBhbiBlcnJvciB3aGVuIHNlbmRpbmcgdGhlIHJlcXVlc3QuIERldGFpbHM6ICdcbiAgICAgICAgICAgICAgICArIEpTT04uc3RyaW5naWZ5KGVyciwgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMoZXJyKSkpO1xuXG4gICAgICAgICAgICBlcnIgPSBFcnJvcnMuY3JlYXRlTmV0d29ya0Vycm9yKFxuICAgICAgICAgICAgICBFcnJvckNvZGVzLkVSUl9TRl9ORVRXT1JLX0NPVUxEX05PVF9DT05ORUNULCBlcnIpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXJlc3BvbnNlKSB7XG4gICAgICAgICAgICAvLyBlbXB0eSByZXNwb25zZVxuICAgICAgICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZVVuZXhwZWN0ZWRDb250ZW50RXJyb3IoXG4gICAgICAgICAgICAgIEVycm9yQ29kZXMuRVJSX1NGX1JFU1BPTlNFX05PVF9KU09OLCAnKEVNUFRZKScpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3BvbnNlLCAnc3RhdHVzQ29kZScpICYmXG4gICAgICAgICAgICByZXNwb25zZS5zdGF0dXNDb2RlICE9PSAyMDApIHtcbiAgICAgICAgICAgIC8vIGlmIHdlIGRpZG4ndCBnZXQgYSAyMDAsIHRoZSByZXF1ZXN0IGZhaWxlZFxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwMSAmJiByZXNwb25zZS5ib2R5KSB7XG4gICAgICAgICAgICAgIGxldCBpbm5lckNvZGU7XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaW5uZXJDb2RlID0gSlNPTi5wYXJzZShyZXNwb25zZS5ib2R5KS5jb2RlO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZVJlcXVlc3RGYWlsZWRFcnJvcihcbiAgICAgICAgICAgICAgICAgIEVycm9yQ29kZXMuRVJSX1NGX1JFU1BPTlNFX0ZBSUxVUkUsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnSFRUUCBFcnJvcjogJXMnLCByZXNwb25zZS5zdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAoaW5uZXJDb2RlID09PSAnMzkwMTA0Jykge1xuICAgICAgICAgICAgICAgIGVyciA9IEVycm9ycy5jcmVhdGVSZXF1ZXN0RmFpbGVkRXJyb3IoXG4gICAgICAgICAgICAgICAgICBFcnJvckNvZGVzLkVSUl9TRl9SRVNQT05TRV9JTlZBTElEX1RPS0VOLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0hUVFAgRXJyb3I6ICVzJywgcmVzcG9uc2Uuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZVJlcXVlc3RGYWlsZWRFcnJvcihcbiAgICAgICAgICAgICAgICAgIEVycm9yQ29kZXMuRVJSX1NGX1JFU1BPTlNFX0ZBSUxVUkUsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnSFRUUCBFcnJvcjogJXMnLCByZXNwb25zZS5zdGF0dXNDb2RlKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgZXJyID0gRXJyb3JzLmNyZWF0ZVJlcXVlc3RGYWlsZWRFcnJvcihcbiAgICAgICAgICAgICAgICBFcnJvckNvZGVzLkVSUl9TRl9SRVNQT05TRV9GQUlMVVJFLCByZXNwb25zZSk7XG4gICAgICAgICAgICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdIVFRQIEVycm9yOiAlcycsIHJlc3BvbnNlLnN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVzcG9uc2UgYm9keSBpcyBhIG5vbi1lbXB0eSBzdHJpbmcgYW5kIHRoZSByZXNwb25zZSBpc1xuICAgICAgICAgICAgLy8gc3VwcG9zZWQgdG8gY29udGFpbiBqc29uLCB0cnkgdG8ganNvbi1wYXJzZSB0aGUgYm9keVxuICAgICAgICAgICAgaWYgKFV0aWwuaXNTdHJpbmcoYm9keSkgJiZcbiAgICAgICAgICAgICAgcmVzcG9uc2UuZ2V0UmVzcG9uc2VIZWFkZXIoJ0NvbnRlbnQtVHlwZScpID09PVxuICAgICAgICAgICAgICAnYXBwbGljYXRpb24vanNvbicpIHtcbiAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBpZiAoYm9keS5pbmNsdWRlcygnc21rSWQnKSkge1xuICAgICAgICAgICAgICAgICAgYm9keSA9IFV0aWwuY29udmVydFNta0lkVG9TdHJpbmcoYm9keSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJvZHkgPSBKU09OLnBhcnNlKGJvZHkpO1xuICAgICAgICAgICAgICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gd2UgZXhwZWN0ZWQgdG8gZ2V0IGpzb25cbiAgICAgICAgICAgICAgICBlcnIgPSBFcnJvcnMuY3JlYXRlVW5leHBlY3RlZENvbnRlbnRFcnJvcihcbiAgICAgICAgICAgICAgICAgIEVycm9yQ29kZXMuRVJSX1NGX1JFU1BPTlNFX05PVF9KU09OLCByZXNwb25zZS5ib2R5KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpZiB3ZSB3ZXJlIGFibGUgdG8gc3VjY2Vzc2Z1bGx5IGpzb24tcGFyc2UgdGhlIGJvZHkgYW5kIHRoZVxuICAgICAgICAgICAgLy8gc3VjY2VzcyBmbGFnIGlzIGZhbHNlLCB0aGUgb3BlcmF0aW9uIHdlIHRyaWVkIHRvIHBlcmZvcm0gZmFpbGVkXG4gICAgICAgICAgICBpZiAoYm9keSAmJiAhYm9keS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBib2R5LmRhdGE7XG5cbiAgICAgICAgICAgICAgaWYgKGJvZHkuY29kZSA9PT0gR1NFcnJvcnMuY29kZS5JRF9UT0tFTl9JTlZBTElEICYmIGRhdGEuYXV0aG5NZXRob2QgPT09ICdUT0tFTicpIHtcbiAgICAgICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnSUQgVG9rZW4gYmVpbmcgdXNlZCBoYXMgZXhwaXJlZC4gUmVhdXRoZW50aWNhdGluZycpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IFV0aWwuYnVpbGRDcmVkZW50aWFsQ2FjaGVLZXkoY29ubmVjdGlvbkNvbmZpZy5ob3N0LFxuICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkNvbmZpZy51c2VybmFtZSwgQXV0aGVudGljYXRpb25UeXBlcy5JRF9UT0tFTl9BVVRIRU5USUNBVE9SKTtcbiAgICAgICAgICAgICAgICBhd2FpdCBHbG9iYWxDb25maWcuZ2V0Q3JlZGVudGlhbE1hbmFnZXIoKS5yZW1vdmUoa2V5KTtcbiAgICAgICAgICAgICAgICBhd2FpdCBhdXRoLnJlYXV0aGVudGljYXRlKHJlcXVlc3RPcHRpb25zLmpzb24pO1xuICAgICAgICAgICAgICAgIHJldHVybiBodHRwQ2xpZW50LnJlcXVlc3QocmVhbFJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGVyciA9IEVycm9ycy5jcmVhdGVPcGVyYXRpb25GYWlsZWRFcnJvcihcbiAgICAgICAgICAgICAgICBib2R5LmNvZGUsIGRhdGEsIGJvZHkubWVzc2FnZSxcbiAgICAgICAgICAgICAgICBkYXRhICYmIGRhdGEuc3FsU3RhdGUgPyBkYXRhLnNxbFN0YXRlIDogdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgXG4gICAgICAgICAgLy8gaWYgd2UgaGF2ZSBhbiBlcnJvciwgY2xlYXIgdGhlIGJvZHlcbiAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBib2R5ID0gdW5kZWZpbmVkO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIGlmIGEgY2FsbGJhY2sgd2FzIHNwZWNpZmllZCwgaW52b2tlIGl0XG4gICAgICAgICAgaWYgKFV0aWwuaXNGdW5jdGlvbihyZXF1ZXN0T3B0aW9ucy5jYWxsYmFjaykpIHtcbiAgICAgICAgICAgIGF3YWl0IHJlcXVlc3RPcHRpb25zLmNhbGxiYWNrLmFwcGx5KHJlcXVlc3RPcHRpb25zLnNjb3BlLCBbZXJyLCBib2R5XSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgaWYgKHJlcXVlc3RPcHRpb25zLnJldHJ5ID4gMikge1xuICAgICAgY29uc3QgaW5jbHVkZXNQYXJhbSA9IHJlcXVlc3RPcHRpb25zLnVybC5pbmNsdWRlcygnPycpO1xuICAgICAgcmVhbFJlcXVlc3RPcHRpb25zLnVybCArPSAoaW5jbHVkZXNQYXJhbSA/ICcmJyA6ICc/Jyk7XG4gICAgICByZWFsUmVxdWVzdE9wdGlvbnMudXJsICs9XG4gICAgICAgICgnY2xpZW50U3RhcnRUaW1lPScgKyByZXF1ZXN0T3B0aW9ucy5zdGFydFRpbWVcbiAgICAgICAgICArICcmJyArICdyZXRyeUNvdW50PScgKyAocmVxdWVzdE9wdGlvbnMucmV0cnkgLSAxKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGh0dHBDbGllbnQucmVxdWVzdChyZWFsUmVxdWVzdE9wdGlvbnMpO1xuICB9XG5cbiAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlID0gb3B0aW9ucy5zbm93Zmxha2VTZXJ2aWNlO1xuICB0aGlzLmh0dHBDbGllbnQgPSBvcHRpb25zLmh0dHBDbGllbnQ7XG4gIHRoaXMuY29ubmVjdGlvbkNvbmZpZyA9IG9wdGlvbnMuY29ubmVjdGlvbkNvbmZpZztcbiAgdGhpcy50b2tlbkluZm8gPSBvcHRpb25zLnRva2VuSW5mbztcblxuICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0gb3B0aW9ucy5jb25uZWN0aW9uQ29uZmlnO1xuICBjb25zdCBzbm93Zmxha2VTZXJ2aWNlID0gb3B0aW9ucy5zbm93Zmxha2VTZXJ2aWNlO1xuICBjb25zdCBodHRwQ2xpZW50ID0gb3B0aW9ucy5odHRwQ2xpZW50O1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vICAgICAgICAgICAgICAgIFJlcXVlc3QgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgUmVxdWVzdCB0byBTbm93Zmxha2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0T3B0aW9uc1xuICAgKiBAY29uc3RydWN0b3JcbiAgICovXG4gIGZ1bmN0aW9uIFJlcXVlc3QocmVxdWVzdE9wdGlvbnMpIHtcbiAgICB0aGlzLnJlcXVlc3RPcHRpb25zID0gcmVxdWVzdE9wdGlvbnM7XG4gIH1cblxuICAvKipcbiAgKiBTZW5kcyBvdXQgdGhlIHJlcXVlc3QuXG4gICpcbiAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcmVxdWVzdCB0aGF0IHdhcyBpc3N1ZWQuXG4gICovXG4gIFJlcXVlc3QucHJvdG90eXBlLnNlbmRBc3luYyA9IGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAvLyBwcmUtcHJvY2VzcyB0aGUgcmVxdWVzdCBvcHRpb25zXG4gICAgdGhpcy5wcmVwcm9jZXNzT3B0aW9ucyh0aGlzLnJlcXVlc3RPcHRpb25zKTtcblxuICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMucmVxdWVzdE9wdGlvbnMucGFyYW1zIHx8IHt9O1xuICAgIGlmICghdGhpcy5yZXF1ZXN0T3B0aW9ucy5leGNsdWRlR3VpZCkge1xuICAgICAgYWRkR3VpZFRvUGFyYW1zKHBhcmFtcyk7XG4gICAgfVxuICAgIGNvbnN0IG9wdGlvbnMgPVxuICAgIHtcbiAgICAgIG1ldGhvZDogdGhpcy5yZXF1ZXN0T3B0aW9ucy5tZXRob2QsXG4gICAgICBoZWFkZXJzOiB0aGlzLnJlcXVlc3RPcHRpb25zLmhlYWRlcnMsXG4gICAgICB1cmw6IHRoaXMucmVxdWVzdE9wdGlvbnMuYWJzb2x1dGVVcmwsXG4gICAgICBqc29uOiB0aGlzLnJlcXVlc3RPcHRpb25zLmpzb24sXG4gICAgICBwYXJhbXM6IHBhcmFtc1xuICAgIH07XG5cbiAgICAvLyBpc3N1ZSB0aGUgYXN5bmMgaHR0cCByZXF1ZXN0XG4gICAgLy9UT0RPOiB0aGlzIHNob3VsZCBiZSB3cmFwcGVkIHdpdGggdGhlIHNhbWUgb3BlcmF0aW9ucywgYXMgaW4gdGhlIHN5bmNocm9ub3VzIHNlbmQgbWV0aG9kJ3MgY2FsbGJhY2suXG4gICAgcmV0dXJuIGF3YWl0IGh0dHBDbGllbnQucmVxdWVzdEFzeW5jKG9wdGlvbnMpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFkZEd1aWRUb1BhcmFtcyhwYXJhbXMpIHtcbiAgICAvLyBJbiBjYXNlIG9mIHJlcGVhdGVkIHJlcXVlc3RzIGZvciB0aGUgc2FtZSByZXF1ZXN0IElELFxuICAgIC8vIHRoZSBHbG9iYWwgVUlEIGlzIGFkZGVkIGZvciBiZXR0ZXIgdHJhY2VhYmlsaXR5LlxuICAgIGNvbnN0IGd1aWQgPSB1dWlkdjQoKTtcbiAgICBwYXJhbXNbc2ZQYXJhbXMucGFyYW1zTmFtZXMuU0ZfUkVRVUVTVF9HVUlEXSA9IGd1aWQ7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgb3V0IHRoZSByZXF1ZXN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgcmVxdWVzdCB0aGF0IHdhcyBpc3N1ZWQuXG4gICAqL1xuICBSZXF1ZXN0LnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIHByZS1wcm9jZXNzIHRoZSByZXF1ZXN0IG9wdGlvbnNcbiAgICB0aGlzLnByZXByb2Nlc3NPcHRpb25zKHRoaXMucmVxdWVzdE9wdGlvbnMpO1xuXG4gICAgLy8gaXNzdWUgdGhlIGh0dHAgcmVxdWVzdFxuICAgIHNlbmRIdHRwUmVxdWVzdCh0aGlzLnJlcXVlc3RPcHRpb25zLCBodHRwQ2xpZW50LCBzbm93Zmxha2VTZXJ2aWNlLmdldEF1dGhlbnRpY2F0b3IoKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIFByZS1wcm9jZXNzZXMgdGhlIHJlcXVlc3Qgb3B0aW9ucyBqdXN0IGJlZm9yZSB0aGUgcmVxdWVzdCBpcyBzZW50LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdE9wdGlvbnNcbiAgICovXG4gIFJlcXVlc3QucHJvdG90eXBlLnByZXByb2Nlc3NPcHRpb25zID0gZnVuY3Rpb24gKHJlcXVlc3RPcHRpb25zKSB7XG4gICAgLy8gYXVnbWVudCB0aGUgaGVhZGVycyB3aXRoIHRoZSBkZWZhdWx0IHJlcXVlc3QgaGVhZGVyc1xuICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPVxuICAgICAgVXRpbC5hcHBseSh0aGlzLmdldERlZmF1bHRSZXFIZWFkZXJzKCksIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMgfHwge30pO1xuXG4gICAgaWYgKFV0aWwuaXNMb2dpblJlcXVlc3QocmVxdWVzdE9wdGlvbnMudXJsKSkge1xuICAgICAgVXRpbC5hcHBseShyZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLCB7XG4gICAgICAgICdDTElFTlRfQVBQX1ZFUlNJT04nOiByZXF1ZXN0T3B0aW9ucy5qc29uLmRhdGEuQ0xJRU5UX0FQUF9WRVJTSU9OLFxuICAgICAgICAnQ0xJRU5UX0FQUF9JRCc6IHJlcXVlc3RPcHRpb25zLmpzb24uZGF0YS5DTElFTlRfQVBQX0lELFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gYXVnbWVudCB0aGUgb3B0aW9ucyB3aXRoIHRoZSBhYnNvbHV0ZSB1cmxcbiAgICByZXF1ZXN0T3B0aW9ucy5hYnNvbHV0ZVVybCA9IHRoaXMuYnVpbGRGdWxsVXJsKHJlcXVlc3RPcHRpb25zLnVybCk7XG5cbiAgICByZXF1ZXN0T3B0aW9ucy5leGNsdWRlR3VpZCA9ICFVdGlsLmV4aXN0cyhyZXF1ZXN0T3B0aW9ucy5leGNsdWRlR3VpZCkgPyBmYWxzZSA6IHJlcXVlc3RPcHRpb25zLmV4Y2x1ZGVHdWlkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhIHJlbGF0aXZlIHVybCB0byBhbiBhYnNvbHV0ZSB1cmwuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSByZWxhdGl2ZVVybFxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgUmVxdWVzdC5wcm90b3R5cGUuYnVpbGRGdWxsVXJsID0gZnVuY3Rpb24gKHJlbGF0aXZlVXJsKSB7XG4gICAgcmV0dXJuIGNvbm5lY3Rpb25Db25maWcuYWNjZXNzVXJsICsgcmVsYXRpdmVVcmw7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGRlZmF1bHQgaGVhZGVycyB0byBzZW5kIHdpdGggZXZlcnkgcmVxdWVzdC5cbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIFJlcXVlc3QucHJvdG90eXBlLmdldERlZmF1bHRSZXFIZWFkZXJzID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB7XG4gICAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJ1xuICAgIH07XG4gIH07XG5cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gIC8vLy8gICAgICAgICAgICAgICAgU2Vzc2lvblRva2VuUmVxdWVzdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL1xuICAvLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuICAvKipcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBTZXNzaW9uVG9rZW5SZXF1ZXN0KCkge1xuICAgIFJlcXVlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIFV0aWwuaW5oZXJpdHMoU2Vzc2lvblRva2VuUmVxdWVzdCwgUmVxdWVzdCk7XG5cbiAgLyoqXG4gICAqIEBpbmhlcml0RG9jXG4gICAqL1xuICBTZXNzaW9uVG9rZW5SZXF1ZXN0LnByb3RvdHlwZS5wcmVwcm9jZXNzT3B0aW9ucyA9IGZ1bmN0aW9uIChyZXF1ZXN0T3B0aW9ucykge1xuICAgIC8vIGNhbGwgc3VwZXJcbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5wcmVwcm9jZXNzT3B0aW9ucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgLy8gYWRkIHRoZSBjdXJyZW50IHNlc3Npb24gdG9rZW4gdG8gdGhlIHJlcXVlc3QgaGVhZGVyc1xuICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9XG4gICAgICAnU25vd2ZsYWtlIFRva2VuPVwiJyArIG9wdGlvbnMudG9rZW5JbmZvLmdldFNlc3Npb25Ub2tlbigpICsgJ1wiJztcbiAgICBpZiAoVXRpbC5zdHJpbmcuaXNOb3ROdWxsT3JFbXB0eShcbiAgICAgIFBhcmFtZXRlcnMuZ2V0VmFsdWUoUGFyYW1ldGVycy5uYW1lcy5TRVJWSUNFX05BTUUpKSkge1xuICAgICAgcmVxdWVzdE9wdGlvbnMuaGVhZGVyc1snWC1Tbm93Zmxha2UtU2VydmljZSddID1cbiAgICAgICAgUGFyYW1ldGVycy5nZXRWYWx1ZShQYXJhbWV0ZXJzLm5hbWVzLlNFUlZJQ0VfTkFNRSk7XG4gICAgfVxuICB9O1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vICAgICAgICAgICAgICAgIE1hc3RlclRva2VuUmVxdWVzdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIEBjb25zdHJ1Y3RvclxuICAgKi9cbiAgZnVuY3Rpb24gTWFzdGVyVG9rZW5SZXF1ZXN0KCkge1xuICAgIFJlcXVlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIFV0aWwuaW5oZXJpdHMoTWFzdGVyVG9rZW5SZXF1ZXN0LCBSZXF1ZXN0KTtcblxuICAvKipcbiAgICogQGluaGVyaXREb2NcbiAgICovXG4gIE1hc3RlclRva2VuUmVxdWVzdC5wcm90b3R5cGUucHJlcHJvY2Vzc09wdGlvbnMgPSBmdW5jdGlvbiAocmVxdWVzdE9wdGlvbnMpIHtcbiAgICAvLyBjYWxsIHN1cGVyXG4gICAgUmVxdWVzdC5wcm90b3R5cGUucHJlcHJvY2Vzc09wdGlvbnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgIC8vIGFkZCB0aGUgY3VycmVudCBtYXN0ZXIgdG9rZW4gdG8gdGhlIHJlcXVlc3QgaGVhZGVyc1xuICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMgPSByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzIHx8IHt9O1xuICAgIHJlcXVlc3RPcHRpb25zLmhlYWRlcnMuQXV0aG9yaXphdGlvbiA9XG4gICAgICAnU25vd2ZsYWtlIFRva2VuPVwiJyArIG9wdGlvbnMudG9rZW5JbmZvLmdldE1hc3RlclRva2VuKCkgKyAnXCInO1xuICB9O1xuXG4gIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAvLy8vICAgICAgICAgICAgICAgIFVuYXV0aGVudGljYXRlZFJlcXVlc3QgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy9cbiAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgVW5hdXRoZW50aWNhdGVkUmVxdWVzdC5cbiAgICpcbiAgICogQGNvbnN0cnVjdG9yXG4gICAqL1xuICBmdW5jdGlvbiBVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0KCkge1xuICAgIFJlcXVlc3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIFV0aWwuaW5oZXJpdHMoVW5hdXRoZW50aWNhdGVkUmVxdWVzdCwgUmVxdWVzdCk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgU2Vzc2lvblRva2VuUmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RPcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmNyZWF0ZVNlc3Npb25Ub2tlblJlcXVlc3QgPSBmdW5jdGlvbiAocmVxdWVzdE9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFNlc3Npb25Ub2tlblJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IE1hc3RlclRva2VuUmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3RPcHRpb25zXG4gICAqXG4gICAqIEByZXR1cm5zIHtPYmplY3R9XG4gICAqL1xuICB0aGlzLmNyZWF0ZU1hc3RlclRva2VuUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0T3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTWFzdGVyVG9rZW5SZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgfTtcblxuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBVbmF1dGhlbnRpY2F0ZWRSZXF1ZXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdE9wdGlvbnNcbiAgICpcbiAgICogQHJldHVybnMge09iamVjdH1cbiAgICovXG4gIHRoaXMuY3JlYXRlVW5hdXRoZW50aWNhdGVkUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0T3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgVW5hdXRoZW50aWNhdGVkUmVxdWVzdChyZXF1ZXN0T3B0aW9ucyk7XG4gIH07XG59XG5cbi8qKlxuICogRW50ZXJzIHRoaXMgc3RhdGUuXG4gKiBAYWJzdHJhY3RcbiAqL1xuU3RhdGVBYnN0cmFjdC5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG59O1xuXG4vKipcbiAqIEV4aXRzIHRoaXMgc3RhdGUuXG4gKiBAYWJzdHJhY3RcbiAqL1xuU3RhdGVBYnN0cmFjdC5wcm90b3R5cGUuZXhpdCA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbi8qKlxuICogRXN0YWJsaXNoZXMgYSBjb25uZWN0aW9uIHRvIFNub3dmbGFrZS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuU3RhdGVBYnN0cmFjdC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbn07XG5cbi8qKlxuICogSXNzdWVzIGEgY29ubmVjdC1jb250aW51ZSByZXF1ZXN0IHRvIFNub3dmbGFrZS5cbiAqXG4gKiBAYWJzdHJhY3RcbiAqL1xuU3RhdGVBYnN0cmFjdC5wcm90b3R5cGUuY29udGludWUgPSBmdW5jdGlvbiAoKSB7XG59O1xuXG4vKipcbiAqIElzc3VlcyBhIGdlbmVyaWMgcmVxdWVzdCB0byBTbm93Zmxha2UuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cblN0YXRlQWJzdHJhY3QucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG59O1xuXG4vKipcbiAqIFRlcm1pbmF0ZXMgdGhlIGN1cnJlbnQgY29ubmVjdGlvbiB0byBTbm93Zmxha2UuXG4gKlxuICogQGFic3RyYWN0XG4gKi9cblN0YXRlQWJzdHJhY3QucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8gICAgICAgICAgICAgICAgU3RhdGVQcmlzdGluZSAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIFN0YXRlUHJpc3RpbmUoKSB7XG4gIFN0YXRlQWJzdHJhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuVXRpbC5pbmhlcml0cyhTdGF0ZVByaXN0aW5lLCBTdGF0ZUFic3RyYWN0KTtcblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZVByaXN0aW5lLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gdHJhbnNpdGlvbiB0byB0aGUgQ29ubmVjdGluZyBzdGF0ZSB3aXRoIHRoZSBjYWxsYmFjayBpbiB0aGUgdHJhbnNpdGlvblxuICAvLyBjb250ZXh0XG4gIHRoaXMuc25vd2ZsYWtlU2VydmljZS50cmFuc2l0aW9uVG9Db25uZWN0aW5nKFxuICAgIHtcbiAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICB9KTtcbn07XG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVQcmlzdGluZS5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2soRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9SRVFVRVNUX1NUQVRVU19QUklTVElORSkpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVQcmlzdGluZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIC8vIHdlJ3JlIHN0aWxsIGluIHRoZSBwcmVjb25uZWN0ZWQgc3RhdGUgc28gYW55XG4gIC8vIGF0dGVtcHRzIHRvIGRlc3Ryb3kgc2hvdWxkIHJlc3VsdCBpbiBhbiBlcnJvclxuICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fREVTVFJPWV9TVEFUVVNfUFJJU1RJTkUpKTtcbiAgfSk7XG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8gICAgICAgICAgICAgICAgU3RhdGVDb25uZWN0aW5nICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIFN0YXRlQ29ubmVjdGluZygpIHtcbiAgU3RhdGVBYnN0cmFjdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xufVxuXG5VdGlsLmluaGVyaXRzKFN0YXRlQ29ubmVjdGluZywgU3RhdGVBYnN0cmFjdCk7XG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVDb25uZWN0aW5nLnByb3RvdHlwZS5lbnRlciA9IGZ1bmN0aW9uIChjb250ZXh0KSB7XG4gIC8vIHNhdmUgdGhlIGNvbnRleHRcbiAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcblxuICAvLyBpbml0aWF0ZSB0aGUgY29ubmVjdGlvbiBwcm9jZXNzXG4gIHRoaXMuY29udGludWUoKTtcbn07XG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVDb25uZWN0aW5nLnByb3RvdHlwZS5leGl0ID0gZnVuY3Rpb24gKCkge1xuICAvLyBjbGVhciB0aGUgY29udGV4dFxuICB0aGlzLmNvbnRleHQgPSBudWxsO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZUNvbm5lY3RpbmcucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAvLyB3ZSdyZSBhbHJlYWR5IGNvbm5lY3Rpbmcgc28gYW55IGF0dGVtcHRzXG4gIC8vIHRvIGNvbm5lY3Qgc2hvdWxkIHJlc3VsdCBpbiBhbiBlcnJvclxuICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ09OTkVDVF9TVEFUVVNfQ09OTkVDVElORykpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVDb25uZWN0aW5nLnByb3RvdHlwZS5jb250aW51ZSA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgY29udGV4dCA9IHRoaXMuY29udGV4dDtcbiAgY29uc3QgZXJyID0gY29udGV4dC5vcHRpb25zLmVycjtcbiAgbGV0IGpzb24gPSBjb250ZXh0Lm9wdGlvbnMuanNvbjtcbiAgXG4gIC8vIGlmIG5vIGpzb24gd2FzIHNwZWNpZmllZCwgdHJlYXQgdGhpcyBhcyB0aGUgZmlyc3QgY29ubmVjdFxuICAvLyBhbmQgZ2V0IHRoZSBuZWNlc3NhcnkgaW5mb3JtYXRpb24gZnJvbSBjb25uZWN0aW9uQ29uZmlnXG4gIGlmICghanNvbikge1xuICAgIGpzb24gPVxuICAgICAge1xuICAgICAgICBkYXRhOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIEFDQ09VTlRfTkFNRTogdGhpcy5jb25uZWN0aW9uQ29uZmlnLmFjY291bnQsXG4gICAgICAgICAgICBMT0dJTl9OQU1FOiB0aGlzLmNvbm5lY3Rpb25Db25maWcudXNlcm5hbWUsXG4gICAgICAgICAgICBQQVNTV09SRDogdGhpcy5jb25uZWN0aW9uQ29uZmlnLnBhc3N3b3JkXG4gICAgICAgICAgfVxuICAgICAgfTtcbiAgfVxuXG4gIC8vIGV4dHJhY3QgdGhlIGluZmxpZ2h0IGNvbnRleHQgZnJvbSB0aGUgZXJyb3IgYW5kIHB1dCBpdCBiYWNrIGluIHRoZSBqc29uXG4gIGlmIChlcnIgJiYgZXJyLmRhdGEgJiYgZXJyLmRhdGEuaW5GbGlnaHRDdHgpIHtcbiAgICBqc29uLmluRmxpZ2h0Q3R4ID0gZXJyLmRhdGEuaW5GbGlnaHRDdHg7XG4gIH1cblxuICAvLyBpbml0aWFsaXplIHRoZSBqc29uIGRhdGEgaWYgbmVjZXNzYXJ5XG4gIGpzb24uZGF0YSA9IGpzb24uZGF0YSB8fCB7fTtcblxuICAvLyBhZGQgdGhlIGNsaWVudC1hcHAtaWQsIGNsaWVudC1hcHAtdmVyc2lvbiwgYW5kIGNsaWVudC1hcHAtbmFtZVxuICBjb25zdCBjbGllbnRJbmZvID1cbiAgICB7XG4gICAgICBDTElFTlRfQVBQX0lEOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VHlwZSgpLFxuICAgICAgQ0xJRU5UX0FQUF9WRVJTSU9OOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VmVyc2lvbigpLFxuICAgIH07XG5cbiAgLy8gaWYgd2UgaGF2ZSBzb21lIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjbGllbnQgZW52aXJvbm1lbnQsIGFkZCBpdCBhcyB3ZWxsXG4gIGNvbnN0IGNsaWVudEVudmlyb25tZW50ID0gdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldENsaWVudEVudmlyb25tZW50KCk7XG4gIGlmIChVdGlsLmlzT2JqZWN0KGNsaWVudEVudmlyb25tZW50KSkge1xuICAgIGNsaWVudEluZm8uQ0xJRU5UX0VOVklST05NRU5UID0gY2xpZW50RW52aXJvbm1lbnQ7XG4gIH1cblxuICBjb25zdCBjbGllbnRBcHBsaWNhdGlvbiA9IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRBcHBsaWNhdGlvbigpO1xuICBpZiAoVXRpbC5pc1N0cmluZyhjbGllbnRBcHBsaWNhdGlvbikpIHtcbiAgICBjbGllbnRFbnZpcm9ubWVudFsnQVBQTElDQVRJT04nXSA9IGNsaWVudEFwcGxpY2F0aW9uO1xuICB9XG5cbiAgY29uc3Qgc2Vzc2lvblBhcmFtZXRlcnMgPVxuICAgIHtcbiAgICAgIFNFU1NJT05fUEFSQU1FVEVSUzoge31cbiAgICB9O1xuXG4gIGlmIChVdGlsLmV4aXN0cyh0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50U2Vzc2lvbktlZXBBbGl2ZSgpKSkge1xuICAgIHNlc3Npb25QYXJhbWV0ZXJzLlNFU1NJT05fUEFSQU1FVEVSUy5DTElFTlRfU0VTU0lPTl9LRUVQX0FMSVZFID1cbiAgICAgIHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTZXNzaW9uS2VlcEFsaXZlKCk7XG4gIH1cblxuICBpZiAoVXRpbC5leGlzdHModGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3koKSkpIHtcbiAgICBzZXNzaW9uUGFyYW1ldGVycy5TRVNTSU9OX1BBUkFNRVRFUlMuQ0xJRU5UX1NFU1NJT05fS0VFUF9BTElWRV9IRUFSVEJFQVRfRlJFUVVFTkNZID1cbiAgICAgIHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTZXNzaW9uS2VlcEFsaXZlSGVhcnRiZWF0RnJlcXVlbmN5KCk7XG4gIH1cblxuICBpZiAoVXRpbC5leGlzdHModGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldEpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQoKSkpIHtcbiAgICBzZXNzaW9uUGFyYW1ldGVycy5TRVNTSU9OX1BBUkFNRVRFUlMuSlNfVFJFQVRfSU5URUdFUl9BU19CSUdJTlQgPVxuICAgICAgdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldEpzVHJlYXRJbnRlZ2VyQXNCaWdJbnQoKTtcbiAgfVxuXG4gIGlmIChVdGlsLmV4aXN0cyh0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0R2NzVXNlRG93bnNjb3BlZENyZWRlbnRpYWwoKSkpIHtcbiAgICBzZXNzaW9uUGFyYW1ldGVycy5TRVNTSU9OX1BBUkFNRVRFUlMuR0NTX1VTRV9ET1dOU0NPUEVEX0NSRURFTlRJQUwgPVxuICAgICAgdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldEdjc1VzZURvd25zY29wZWRDcmVkZW50aWFsKCk7XG4gIH1cblxuICBpZiAoVXRpbC5leGlzdHModGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFJlcXVlc3RNRkFUb2tlbigpKSkge1xuICAgIHNlc3Npb25QYXJhbWV0ZXJzLlNFU1NJT05fUEFSQU1FVEVSUy5DTElFTlRfUkVRVUVTVF9NRkFfVE9LRU4gPVxuICAgICAgdGhpcy5jb25uZWN0aW9uQ29uZmlnLmdldENsaWVudFJlcXVlc3RNRkFUb2tlbigpO1xuICB9XG5cbiAgaWYgKFV0aWwuZXhpc3RzKHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwoKSkpIHtcbiAgICBzZXNzaW9uUGFyYW1ldGVycy5TRVNTSU9OX1BBUkFNRVRFUlMuQ0xJRU5UX1NUT1JFX1RFTVBPUkFSWV9DUkVERU5USUFMID1cbiAgICAgIHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRTdG9yZVRlbXBvcmFyeUNyZWRlbnRpYWwoKTtcbiAgfVxuXG4gIFV0aWwuYXBwbHkoanNvbi5kYXRhLCBjbGllbnRJbmZvKTtcbiAgVXRpbC5hcHBseShqc29uLmRhdGEsIHNlc3Npb25QYXJhbWV0ZXJzKTtcblxuICBjb25zdCBjb25uZWN0aW9uQ29uZmlnID0gdGhpcy5jb25uZWN0aW9uQ29uZmlnO1xuICBjb25zdCBtYXhMb2dpblJldHJpZXMgPSBjb25uZWN0aW9uQ29uZmlnLmdldFJldHJ5U2ZNYXhMb2dpblJldHJpZXMoKTtcbiAgY29uc3QgbWF4UmV0cnlUaW1lb3V0ID0gY29ubmVjdGlvbkNvbmZpZy5nZXRSZXRyeVRpbWVvdXQoKTtcbiAgY29uc3Qgc3RhcnRUaW1lID0gY29ubmVjdGlvbkNvbmZpZy5hY2Nlc3NVcmwuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSA/XG4gICAgRGF0ZS5ub3coKSA6ICdGSVhFRFRJTUVTVEFNUCc7XG4gIGxldCBudW1SZXRyaWVzID0gMDtcbiAgbGV0IHNsZWVwID0gY29ubmVjdGlvbkNvbmZpZy5nZXRSZXRyeVNmU3RhcnRpbmdTbGVlcFRpbWUoKTtcbiAgbGV0IHRvdGFsRWxhcHNlZFRpbWUgPSAwO1xuICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnVG90YWwgcmV0cnlUaW1lb3V0IGlzIGZvciB0aGUgcmV0cmllcyA9ICcgKyBtYXhSZXRyeVRpbWVvdXQgPT09IDAgPyBcbiAgICAndW5saW1pdGVkJyA6IG1heFJldHJ5VGltZW91dCk7XG4gIGNvbnN0IHBhcmVudCA9IHRoaXM7XG4gIGNvbnN0IHJlcXVlc3RDYWxsYmFjayA9IGFzeW5jIGZ1bmN0aW9uIChlcnIsIGJvZHkpIHtcbiAgICAvLyBjbGVhciBjcmVkZW50aWFsLXJlbGF0ZWQgaW5mb3JtYXRpb25cbiAgICBjb25uZWN0aW9uQ29uZmlnLmNsZWFyQ3JlZGVudGlhbHMoKTtcblxuICAgIC8vIGlmIHRoZSByZXF1ZXN0IHN1Y2NlZWRlZFxuICAgIGlmICghZXJyKSB7XG4gICAgICBFcnJvcnMuYXNzZXJ0SW50ZXJuYWwoVXRpbC5leGlzdHMoYm9keSkpO1xuICAgICAgRXJyb3JzLmFzc2VydEludGVybmFsKFV0aWwuZXhpc3RzKGJvZHkuZGF0YSkpO1xuXG4gICAgICBwYXJlbnQuc25vd2ZsYWtlU2VydmljZS5zZXRTZXNzaW9uSWQoYm9keS5kYXRhLnNlc3Npb25JZCk7XG4gICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhgTmV3IHNlc3Npb24gd2l0aCBpZCAke3BhcmVudC5zbm93Zmxha2VTZXJ2aWNlLmdldFNlc3Npb25JZCgpfSBpbml0aWFsaXplZGApO1xuICAgICAgXG4gICAgICAvLyB1cGRhdGUgdGhlIHBhcmFtZXRlcnNcbiAgICAgIFBhcmFtZXRlcnMudXBkYXRlKGJvZHkuZGF0YS5wYXJhbWV0ZXJzKTtcblxuICAgICAgLy8gdXBkYXRlIGFsbCB0b2tlbi1yZWxhdGVkIGluZm9ybWF0aW9uXG4gICAgICBwYXJlbnQudG9rZW5JbmZvLnVwZGF0ZShib2R5LmRhdGEpO1xuXG4gICAgICBpZiAoY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRSZXF1ZXN0TUZBVG9rZW4oKSAmJiBib2R5LmRhdGEubWZhVG9rZW4pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gVXRpbC5idWlsZENyZWRlbnRpYWxDYWNoZUtleShjb25uZWN0aW9uQ29uZmlnLmhvc3QsXG4gICAgICAgICAgY29ubmVjdGlvbkNvbmZpZy51c2VybmFtZSwgQXV0aGVudGljYXRpb25UeXBlcy5VU0VSX1BXRF9NRkFfQVVUSEVOVElDQVRPUik7XG4gICAgICAgIGF3YWl0IEdsb2JhbENvbmZpZy5nZXRDcmVkZW50aWFsTWFuYWdlcigpLndyaXRlKGtleSwgYm9keS5kYXRhLm1mYVRva2VuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50U3RvcmVUZW1wb3JhcnlDcmVkZW50aWFsKCkgJiYgYm9keS5kYXRhLmlkVG9rZW4pIHtcbiAgICAgICAgY29uc3Qga2V5ID0gVXRpbC5idWlsZENyZWRlbnRpYWxDYWNoZUtleShjb25uZWN0aW9uQ29uZmlnLmhvc3QsXG4gICAgICAgICAgY29ubmVjdGlvbkNvbmZpZy51c2VybmFtZSwgQXV0aGVudGljYXRpb25UeXBlcy5JRF9UT0tFTl9BVVRIRU5USUNBVE9SKTtcbiAgICAgICAgYXdhaXQgR2xvYmFsQ29uZmlnLmdldENyZWRlbnRpYWxNYW5hZ2VyKCkud3JpdGUoa2V5LCBib2R5LmRhdGEuaWRUb2tlbik7XG4gICAgICB9XG5cbiAgICAgIC8vIHdlJ3JlIG5vdyBjb25uZWN0ZWRcbiAgICAgIHBhcmVudC5zbm93Zmxha2VTZXJ2aWNlLnRyYW5zaXRpb25Ub0Nvbm5lY3RlZCgpO1xuXG4gICAgICBjb25zdCBxY2NTaXplID0gUGFyYW1ldGVycy5nZXRWYWx1ZSgnUVVFUllfQ09OVEVYVF9DQUNIRV9TSVpFJyk7XG4gICAgICBwYXJlbnQuc25vd2ZsYWtlU2VydmljZS5pbml0aWFsaXplUXVlcnlDb250ZXh0Q2FjaGUocWNjU2l6ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChFcnJvcnMuaXNOZXR3b3JrRXJyb3IoZXJyKSB8fCBFcnJvcnMuaXNSZXF1ZXN0RmFpbGVkRXJyb3IoZXJyKSkge1xuICAgICAgICBpZiAobnVtUmV0cmllcyA8IG1heExvZ2luUmV0cmllcyAmJiAoXG4gICAgICAgICAgaXNSZXRyeWFibGVOZXR3b3JrRXJyb3IoZXJyKSB8fCBpc1JldHJ5YWJsZUh0dHBFcnJvcihlcnIpKSAmJlxuICAgICAgICAgIChtYXhSZXRyeVRpbWVvdXQgPT09IDAgfHwgdG90YWxFbGFwc2VkVGltZSA8IG1heFJldHJ5VGltZW91dCkpIHtcbiAgICAgICAgICBudW1SZXRyaWVzKys7XG4gICAgICAgICAgY29uc3Qgaml0dGVyID0gVXRpbC5nZXRKaXR0ZXJlZFNsZWVwVGltZShudW1SZXRyaWVzLCBzbGVlcCwgdG90YWxFbGFwc2VkVGltZSwgbWF4UmV0cnlUaW1lb3V0KTtcbiAgICAgICAgICBzbGVlcCA9IGppdHRlci5zbGVlcDtcbiAgICAgICAgICB0b3RhbEVsYXBzZWRUaW1lID0gaml0dGVyLnRvdGFsRWxhcHNlZFRpbWU7XG5cbiAgICAgICAgICBpZiAoc2xlZXAgPD0gMCkge1xuICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ1JlYWNoZWQgb3V0IHRvIHRoZSBtYXggTG9naW4gVGltZW91dCcpO1xuICAgICAgICAgICAgcGFyZW50LnNub3dmbGFrZVNlcnZpY2UudHJhbnNpdGlvblRvRGlzY29ubmVjdGVkKCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3QgYXV0aCA9IHBhcmVudC5zbm93Zmxha2VTZXJ2aWNlLmdldEF1dGhlbnRpY2F0b3IoKTtcbiAgICAgICAgICBpZiAoYXV0aCBpbnN0YW5jZW9mIEF1dGhPa3RhKSB7XG4gICAgICAgICAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnT0tUQSBhdXRoZW50aWNhdGlvbiByZXF1aXJlcyB0b2tlbiByZWZyZXNoLicpO1xuICAgICAgICAgICAgY29uc3QgcmV0cnlPcHRpb24gPSB7XG4gICAgICAgICAgICAgIHRvdGFsRWxhcHNlZFRpbWUsIFxuICAgICAgICAgICAgICBudW1SZXRyaWVzLFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgYXdhaXQgYXV0aC5yZWF1dGhlbnRpY2F0ZShjb250ZXh0Lm9wdGlvbnMuanNvbiwgcmV0cnlPcHRpb24pO1xuICAgICAgICAgICAgbnVtUmV0cmllcyA9IHJldHJ5T3B0aW9uLm51bVJldHJpZXM7XG4gICAgICAgICAgICB0b3RhbEVsYXBzZWRUaW1lID0gcmV0cnlPcHRpb24udG90YWxFbGFwc2VkVGltZTtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoc2VuZFJlcXVlc3QsIHNsZWVwICogMTAwMCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChhdXRoIGluc3RhbmNlb2YgQXV0aEtleXBhaXIpIHtcbiAgICAgICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0F1dGhLZXlQYWlyIGF1dGhlbnRpY2F0aW9uIHJlcXVpcmVzIHRva2VuIHJlZnJlc2guJyk7XG4gICAgICAgICAgICAgIGF3YWl0IGF1dGgucmVhdXRoZW50aWNhdGUoY29udGV4dC5vcHRpb25zLmpzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2V0VGltZW91dChzZW5kUmVxdWVzdCwgc2xlZXAgKiAxMDAwKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0ZhaWxlZCB0byBhbGwgcmV0cmllcyB0byBTRi4nKTtcbiAgICAgICAgICAvLyB3ZSdyZSBub3cgZGlzY29ubmVjdGVkXG4gICAgICAgICAgcGFyZW50LnNub3dmbGFrZVNlcnZpY2UudHJhbnNpdGlvblRvRGlzY29ubmVjdGVkKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHdlJ3JlIG5vdyBkaXNjb25uZWN0ZWRcbiAgICAgICAgcGFyZW50LnNub3dmbGFrZVNlcnZpY2UudHJhbnNpdGlvblRvRGlzY29ubmVjdGVkKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaW52b2tlIHRoZSB0cmFuc2l0aW9uLWNvbnRleHQgY2FsbGJhY2sgdGhhdCB3YXMgcGFzc2VkIHRvIHVzIGJ5IHRoZVxuICAgIC8vIFByaXN0aW5lIHN0YXRlIG9uIGNvbm5lY3QoKVxuICAgIGlmIChVdGlsLmlzRnVuY3Rpb24oY29udGV4dC5vcHRpb25zLmNhbGxiYWNrKSkge1xuICAgICAgY29udGV4dC5vcHRpb25zLmNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgLy8gYWxsIHF1ZXVlZCBvcGVyYXRpb25zIGFyZSBub3cgZnJlZSB0byBnb1xuICAgIHBhcmVudC5zbm93Zmxha2VTZXJ2aWNlLmRyYWluT3BlcmF0aW9uUXVldWUoKTtcbiAgfTtcblxuICAvLyBpc3N1ZSBhIGxvZ2luIHJlcXVlc3RcbiAgY29uc3Qgc2VuZFJlcXVlc3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgY29uc3QgdGFyZ2V0VXJsID0gYnVpbGRMb2dpblVybChjb25uZWN0aW9uQ29uZmlnKTtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZyhcbiAgICAgICdDb250YWN0aW5nIFNGOiAlcywgKCVzLyVzKScsIHRhcmdldFVybCwgbnVtUmV0cmllcywgbWF4TG9naW5SZXRyaWVzKTtcbiAgICBjb25zdCByZXF1ZXN0ID0gcGFyZW50LmNyZWF0ZVVuYXV0aGVudGljYXRlZFJlcXVlc3Qoe1xuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICB1cmw6IHRhcmdldFVybCxcbiAgICAgIGpzb246IGpzb24sXG4gICAgICBzY29wZTogdGhpcyxcbiAgICAgIHN0YXJ0VGltZTogc3RhcnRUaW1lLFxuICAgICAgcmV0cnk6IG51bVJldHJpZXMsXG4gICAgICBjYWxsYmFjazogcmVxdWVzdENhbGxiYWNrXG4gICAgfSk7XG4gICAgcmVxdWVzdC5zZW5kKCk7XG4gIH07XG4gIHNlbmRSZXF1ZXN0KCk7XG59O1xuXG4vKipcbiAqIEJ1aWxkcyB0aGUgdXJsIGZvciBhIGxvZ2luIHJlcXVlc3QuXG4gKlxuICogQHBhcmFtIGNvbm5lY3Rpb25Db25maWdcbiAqXG4gKiBAcmV0dXJucyB7Kn1cbiAqL1xuZnVuY3Rpb24gYnVpbGRMb2dpblVybChjb25uZWN0aW9uQ29uZmlnKSB7XG4gIGNvbnN0IHF1ZXJ5UGFyYW1zID1cbiAgICBbXG4gICAgICB7IG5hbWU6ICd3YXJlaG91c2UnLCB2YWx1ZTogY29ubmVjdGlvbkNvbmZpZy5nZXRXYXJlaG91c2UoKSB9LFxuICAgICAgeyBuYW1lOiAnZGF0YWJhc2VOYW1lJywgdmFsdWU6IGNvbm5lY3Rpb25Db25maWcuZ2V0RGF0YWJhc2UoKSB9LFxuICAgICAgeyBuYW1lOiAnc2NoZW1hTmFtZScsIHZhbHVlOiBjb25uZWN0aW9uQ29uZmlnLmdldFNjaGVtYSgpIH0sXG4gICAgICB7IG5hbWU6ICdyb2xlTmFtZScsIHZhbHVlOiBjb25uZWN0aW9uQ29uZmlnLmdldFJvbGUoKSB9XG4gICAgXTtcblxuICBjb25zdCBxdWVyeVN0cmluZ09iamVjdCA9IHt9O1xuICBpZiAoIWNvbm5lY3Rpb25Db25maWcuaXNRYU1vZGUoKSkge1xuICAgIC8vIE5vIHJlcXVlc3RJZCBpcyBhdHRhY2hlZCB0byBsb2dpbi1yZXF1ZXN0IGluIHRlc3QgbW9kZS5cbiAgICBxdWVyeVN0cmluZ09iamVjdC5yZXF1ZXN0SWQgPSB1dWlkdjQoKTtcbiAgfVxuICBmb3IgKGxldCBpbmRleCA9IDAsIGxlbmd0aCA9IHF1ZXJ5UGFyYW1zLmxlbmd0aDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICBjb25zdCBxdWVyeVBhcmFtID0gcXVlcnlQYXJhbXNbaW5kZXhdO1xuICAgIGlmIChVdGlsLnN0cmluZy5pc05vdE51bGxPckVtcHR5KHF1ZXJ5UGFyYW0udmFsdWUpKSB7XG4gICAgICBxdWVyeVN0cmluZ09iamVjdFtxdWVyeVBhcmFtLm5hbWVdID0gcXVlcnlQYXJhbS52YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gVXJsLmZvcm1hdChcbiAgICB7XG4gICAgICBwYXRobmFtZTogJy9zZXNzaW9uL3YxL2xvZ2luLXJlcXVlc3QnLFxuICAgICAgc2VhcmNoOiBRdWVyeVN0cmluZy5zdHJpbmdpZnkocXVlcnlTdHJpbmdPYmplY3QpXG4gICAgfSk7XG59XG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVDb25uZWN0aW5nLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gZW5xdWV1ZSB0aGUgcmVxdWVzdCBvcGVyYXRpb25cbiAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLmVucXVldWVSZXF1ZXN0KG9wdGlvbnMpO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZUNvbm5lY3RpbmcucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAvLyBlbnF1ZXVlIHRoZSBkZXN0cm95IG9wZXJhdGlvblxuICB0aGlzLnNub3dmbGFrZVNlcnZpY2UuZW5xdWV1ZURlc3Ryb3kob3B0aW9ucyk7XG59O1xuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vLy8gICAgICAgICAgICAgICAgU3RhdGVDb25uZWN0ZWQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8vL1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5cbmZ1bmN0aW9uIFN0YXRlQ29ubmVjdGVkKCkge1xuICBTdGF0ZUFic3RyYWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cblV0aWwuaW5oZXJpdHMoU3RhdGVDb25uZWN0ZWQsIFN0YXRlQWJzdHJhY3QpO1xuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlQ29ubmVjdGVkLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgLy8gd2UncmUgYWxyZWFkeSBjb25uZWN0ZWQgc28gYW55IGF0dGVtcHRzXG4gIC8vIHRvIGNvbm5lY3Qgc2hvdWxkIHJlc3VsdCBpbiBhbiBlcnJvclxuICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ09OTkVDVF9TVEFUVVNfQ09OTkVDVEVEKSk7XG4gIH0pO1xufTtcblxuU3RhdGVDb25uZWN0ZWQucHJvdG90eXBlLnJlcXVlc3RBc3luYyA9IGFzeW5jIGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIC8vIGNyZWF0ZSBhIHNlc3Npb24gdG9rZW4gcmVxdWVzdCBmcm9tIHRoZSBvcHRpb25zIGFuZCBzZW5kIG91dCB0aGUgcmVxdWVzdFxuICByZXR1cm4gYXdhaXQgdGhpcy5jcmVhdGVTZXNzaW9uVG9rZW5SZXF1ZXN0KG9wdGlvbnMpLnNlbmRBc3luYygpO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZUNvbm5lY3RlZC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIGNvbnN0IHNjb3BlT3JpZyA9IG9wdGlvbnMuc2NvcGU7XG4gIGNvbnN0IGNhbGxiYWNrT3JpZyA9IG9wdGlvbnMuY2FsbGJhY2s7XG5cbiAgLy8gZGVmaW5lIG91ciBvd24gc2NvcGUgYW5kIGNhbGxiYWNrXG4gIG9wdGlvbnMuc2NvcGUgPSB0aGlzO1xuICBvcHRpb25zLmNhbGxiYWNrID0gYXN5bmMgZnVuY3Rpb24gKGVyciwgYm9keSkge1xuICAgIC8vIGlmIHRoZXJlIHdhcyBubyBlcnJvciwgaW52b2tlIHRoZSBjYWxsYmFjayBpZiBvbmUgd2FzIHNwZWNpZmllZFxuICAgIGlmICghZXJyKSB7XG4gICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrT3JpZykpIHtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tPcmlnLmFwcGx5KHNjb3BlT3JpZywgW2VyciwgYm9keV0pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXN0b3JlIHRoZSBvcmlnaW5hbCBzY29wZSBhbmQgY2FsbGJhY2sgdG8gdGhlIG9wdGlvbnMgb2JqZWN0IGJlY2F1c2VcbiAgICAgIC8vIHdlIG1pZ2h0IG5lZWQgdG8gcmVwZWF0IHRoZSByZXF1ZXN0XG4gICAgICBvcHRpb25zLnNjb3BlID0gc2NvcGVPcmlnO1xuICAgICAgb3B0aW9ucy5jYWxsYmFjayA9IGNhbGxiYWNrT3JpZztcblxuICAgICAgLy8gaWYgdGhlIHNlc3Npb24gdG9rZW4gaGFzIGV4cGlyZWRcbiAgICAgIGlmIChlcnIuY29kZSA9PT0gR1NFcnJvcnMuY29kZS5TRVNTSU9OX1RPS0VOX0VYUElSRUQpIHtcbiAgICAgICAgLy8gZW5xdWV1ZSB0aGUgcmVxdWVzdCBvcGVyYXRpb25cbiAgICAgICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLmVucXVldWVSZXF1ZXN0KG9wdGlvbnMpO1xuXG4gICAgICAgIC8vIGlmIGEgc2Vzc2lvbiB0b2tlbiByZW5ld2FsIGlzbid0IGFscmVhZHkgaW4gcHJvZ3Jlc3MsIGlzc3VlIGFcbiAgICAgICAgLy8gcmVxdWVzdCB0byByZW5ldyB0aGUgc2Vzc2lvbiB0b2tlblxuICAgICAgICB0aGlzLnNub3dmbGFrZVNlcnZpY2UudHJhbnNpdGlvblRvUmVuZXdpbmcoKTtcbiAgICAgIH0gZWxzZSBpZiAoKGVyci5jb2RlID09PSBHU0Vycm9ycy5jb2RlLlNFU1NJT05fVE9LRU5fSU5WQUxJRCkgfHxcbiAgICAgICAgKGVyci5jb2RlID09PSBHU0Vycm9ycy5jb2RlLkdPTkVfU0VTU0lPTikpIHtcbiAgICAgICAgLy8gaWYgdGhlIHNlc3Npb24gdG9rZW4gaXMgaW52YWxpZCBvciBpdCBkb2Vzbid0IGV4aXN0XG4gICAgICAgIC8vIGVucXVldWUgdGhlIHJlcXVlc3Qgb3BlcmF0aW9uXG4gICAgICAgIHRoaXMuc25vd2ZsYWtlU2VydmljZS5lbnF1ZXVlUmVxdWVzdChvcHRpb25zKTtcblxuICAgICAgICAvLyB3ZSdyZSBkaXNjb25uZWN0ZWRcbiAgICAgICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLnRyYW5zaXRpb25Ub0Rpc2Nvbm5lY3RlZCgpO1xuXG4gICAgICAgIC8vIGFsbCBxdWV1ZWQgb3BlcmF0aW9ucyBhcmUgbm93IGZyZWUgdG8gZ29cbiAgICAgICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLmRyYWluT3BlcmF0aW9uUXVldWUoKTtcblxuICAgICAgICAvLyBUT0RPOiByZW1lbWJlciB0aGF0IGEgc2Vzc2lvbiByZW5ld2FsIGlzIG5vIGxvbmdlciBpbiBwcm9ncmVzc1xuICAgICAgICAvLyBUT0RPOiBtYWtlIHN1cmUgdGhlIGxhc3Qgc2Vzc2lvbiByZW5ld2FsIGRpZCBub3QgdGltZSBvdXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGl0J3MgYSBub3JtYWwgZmFpbHVyZVxuICAgICAgICAvLyBpZiBhIGNhbGxiYWNrIHdhcyBzcGVjaWZpZWQsIGludm9rZSBpdFxuICAgICAgICBpZiAoVXRpbC5pc0Z1bmN0aW9uKGNhbGxiYWNrT3JpZykpIHtcbiAgICAgICAgICBjYWxsYmFja09yaWcuYXBwbHkoc2NvcGVPcmlnLCBbZXJyLCBib2R5XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgLy8gY3JlYXRlIGEgc2Vzc2lvbiB0b2tlbiByZXF1ZXN0IGZyb20gdGhlIG9wdGlvbnMgYW5kIHNlbmQgb3V0IHRoZSByZXF1ZXN0XG4gIHRoaXMuY3JlYXRlU2Vzc2lvblRva2VuUmVxdWVzdChvcHRpb25zKS5zZW5kKCk7XG59O1xuXG4vKipcbiAqIEBpbmhlcml0RG9jXG4gKi9cblN0YXRlQ29ubmVjdGVkLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgY29uc3QgcmVxdWVzdElEID0gdXVpZHY0KCk7XG5cbiAgLy8gc2VuZCBvdXQgYSBzZXNzaW9uIHRva2VuIHJlcXVlc3QgdG8gdGVybWluYXRlIHRoZSBjdXJyZW50IGNvbm5lY3Rpb25cbiAgdGhpcy5jcmVhdGVTZXNzaW9uVG9rZW5SZXF1ZXN0KFxuICAgIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgdXJsOiBgL3Nlc3Npb24/ZGVsZXRlPXRydWUmcmVxdWVzdElkPSR7cmVxdWVzdElEfWAsXG4gICAgICBzY29wZTogdGhpcyxcbiAgICAgIGNhbGxiYWNrOiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIGlmIHRoZSBkZXN0cm95IHJlcXVlc3Qgc3VjY2VlZGVkIG9yIHRoZSBzZXNzaW9uIGFscmVhZHkgZXhwaXJlZCwgd2UncmUgZGlzY29ubmVjdGVkXG4gICAgICAgIGlmICghZXJyIHx8IGVyci5jb2RlID09PSBHU0Vycm9ycy5jb2RlLkdPTkVfU0VTU0lPTiB8fCBlcnIuY29kZSA9PT0gR1NFcnJvcnMuY29kZS5TRVNTSU9OX1RPS0VOX0VYUElSRUQpIHtcbiAgICAgICAgICBlcnIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLnRyYW5zaXRpb25Ub0Rpc2Nvbm5lY3RlZCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaW52b2tlIHRoZSBvcmlnaW5hbCBjYWxsYmFja1xuICAgICAgICBvcHRpb25zLmNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfSkuc2VuZCgpO1xufTtcblxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLy8vICAgICAgICAgICAgICAgIFN0YXRlUmVuZXdpbmcgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vLy9cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuXG5mdW5jdGlvbiBTdGF0ZVJlbmV3aW5nKCkge1xuICBTdGF0ZUFic3RyYWN0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59XG5cblV0aWwuaW5oZXJpdHMoU3RhdGVSZW5ld2luZywgU3RhdGVBYnN0cmFjdCk7XG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVSZW5ld2luZy5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8vIHNlbmQgb3V0IGEgbWFzdGVyIHRva2VuIHJlcXVlc3QgdG8gcmVuZXcgdGhlIGN1cnJlbnQgc2Vzc2lvbiB0b2tlblxuICB0aGlzLmNyZWF0ZU1hc3RlclRva2VuUmVxdWVzdChcbiAgICB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIHVybDogJy9zZXNzaW9uL3Rva2VuLXJlcXVlc3QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBDTElFTlRfQVBQX0lEOiB0aGlzLmNvbm5lY3Rpb25Db25maWcuZ2V0Q2xpZW50VHlwZSgpLFxuICAgICAgICBDTElFTlRfQVBQX1ZFUlNJT046IHRoaXMuY29ubmVjdGlvbkNvbmZpZy5nZXRDbGllbnRWZXJzaW9uKCksXG4gICAgICB9LFxuICAgICAganNvbjoge1xuICAgICAgICAnUkVRVUVTVF9UWVBFJzogJ1JFTkVXJyxcbiAgICAgICAgJ29sZFNlc3Npb25Ub2tlbic6IHRoaXMudG9rZW5JbmZvLmdldFNlc3Npb25Ub2tlbigpLFxuICAgICAgfSxcbiAgICAgIHNjb3BlOiB0aGlzLFxuICAgICAgY2FsbGJhY2s6IGZ1bmN0aW9uIChlcnIsIGJvZHkpIHtcbiAgICAgICAgLy8gaWYgdGhlIHJlcXVlc3Qgc3VjY2VlZGVkXG4gICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgLy8gdXBkYXRlIHRoZSB0b2tlbiBpbmZvcm1hdGlvblxuICAgICAgICAgIHRoaXMudG9rZW5JbmZvLnVwZGF0ZShib2R5LmRhdGEpO1xuXG4gICAgICAgICAgLy8gd2UncmUgbm93IGNvbm5lY3RlZCBhZ2FpblxuICAgICAgICAgIHRoaXMuc25vd2ZsYWtlU2VydmljZS50cmFuc2l0aW9uVG9Db25uZWN0ZWQoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBpZiB0aGUgbWFzdGVyIHRva2VuIGhhcyBleHBpcmVkLCB0cmFuc2l0aW9uIHRvIHRoZSBkaXNjb25uZWN0ZWRcbiAgICAgICAgICAvLyBzdGF0ZVxuICAgICAgICAgIGlmIChlcnIuY29kZSA9PT0gR1NFcnJvcnMuY29kZS5NQVNURVJfVE9LRU5fRVhQSVJFRCkge1xuICAgICAgICAgICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLnRyYW5zaXRpb25Ub0Rpc2Nvbm5lY3RlZCgpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoRXJyb3JzLmlzTmV0d29ya0Vycm9yKGVycikpIHtcbiAgICAgICAgICAgIC8vIGdvIGJhY2sgdG8gdGhlIGNvbm5lY3RlZCBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5zbm93Zmxha2VTZXJ2aWNlLnRyYW5zaXRpb25Ub0Nvbm5lY3RlZCgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcmVuZXdhbCBmYWlsZWQgZm9yIHNvbWUgb3RoZXIgcmVhc29uLCB3ZSdyZVxuICAgICAgICAgICAgLy8gZGlzY29ubmVjdGVkXG4gICAgICAgICAgICAvLyBUT0RPOiB3aGF0IHNob3VsZCBvdXIgc3RhdGUgYmUgaGVyZT8gYWxzbyBkaXNjb25uZWN0ZWQ/XG4gICAgICAgICAgICB0aGlzLnNub3dmbGFrZVNlcnZpY2UudHJhbnNpdGlvblRvRGlzY29ubmVjdGVkKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gYWxsIHF1ZXVlZCBvcGVyYXRpb25zIGFyZSBub3cgZnJlZSB0byBnb1xuICAgICAgICB0aGlzLnNub3dmbGFrZVNlcnZpY2UuZHJhaW5PcGVyYXRpb25RdWV1ZSgpO1xuICAgICAgfVxuICAgIH0pLnNlbmQoKTtcbn07XG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVSZW5ld2luZy5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIC8vIHdlJ3JlIHJlbmV3aW5nIHRoZSBzZXNzaW9uIHRva2VuLCB3aGljaCBtZWFucyB3ZSdyZSBjb25uZWN0ZWQsXG4gIC8vIHNvIGFueSBhdHRlbXB0cyB0byBjb25uZWN0IHNob3VsZCByZXN1bHQgaW4gYW4gZXJyb3JcbiAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX0NPTk5FQ1RfU1RBVFVTX0NPTk5FQ1RFRCkpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVSZW5ld2luZy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIC8vIGVucXVldWUgdGhlIHJlcXVlc3Qgb3BlcmF0aW9uXG4gIHRoaXMuc25vd2ZsYWtlU2VydmljZS5lbnF1ZXVlUmVxdWVzdChvcHRpb25zKTtcbn07XG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVSZW5ld2luZy5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIC8vIGVucXVldWUgdGhlIGRlc3Ryb3kgb3BlcmF0aW9uXG4gIHRoaXMuc25vd2ZsYWtlU2VydmljZS5lbnF1ZXVlRGVzdHJveShvcHRpb25zKTtcbn07XG5cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8vLyAgICAgICAgICAgICAgICBTdGF0ZURpc2Nvbm5lY3RlZCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLy8vXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cblxuZnVuY3Rpb24gU3RhdGVEaXNjb25uZWN0ZWQoKSB7XG4gIFN0YXRlQWJzdHJhY3QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn1cblxuVXRpbC5pbmhlcml0cyhTdGF0ZURpc2Nvbm5lY3RlZCwgU3RhdGVBYnN0cmFjdCk7XG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVEaXNjb25uZWN0ZWQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAvLyB3ZSdyZSBkaXNjb25uZWN0ZWQgLS0gYW5kIGZhdGFsbHkgc28gLS0gc28gYW55XG4gIC8vIGF0dGVtcHRzIHRvIGNvbm5lY3Qgc2hvdWxkIHJlc3VsdCBpbiBhbiBlcnJvclxuICBjb25zdCBjYWxsYmFjayA9IG9wdGlvbnMuY2FsbGJhY2s7XG4gIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgIGNhbGxiYWNrKEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihcbiAgICAgIEVycm9yQ29kZXMuRVJSX0NPTk5fQ09OTkVDVF9TVEFUVVNfRElTQ09OTkVDVEVEKSk7XG4gIH0pO1xufTtcblxuLyoqXG4gKiBAaW5oZXJpdERvY1xuICovXG5TdGF0ZURpc2Nvbm5lY3RlZC5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gIC8vIHdlJ3JlIGRpc2Nvbm5lY3RlZCwgc28gYW55IGF0dGVtcHRzIHRvXG4gIC8vIHNlbmQgYSByZXF1ZXN0IHNob3VsZCByZXN1bHQgaW4gYW4gZXJyb3JcbiAgY29uc3QgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xuICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICBjYWxsYmFjayhFcnJvcnMuY3JlYXRlQ2xpZW50RXJyb3IoXG4gICAgICBFcnJvckNvZGVzLkVSUl9DT05OX1JFUVVFU1RfU1RBVFVTX0RJU0NPTk5FQ1RFRCwgdHJ1ZSkpO1xuICB9KTtcbn07XG5cbi8qKlxuICogQGluaGVyaXREb2NcbiAqL1xuU3RhdGVEaXNjb25uZWN0ZWQucHJvdG90eXBlLmRlc3Ryb3kgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAvLyB3ZSdyZSBhbHJlYWR5IGRpc2Nvbm5lY3RlZCBzbyBhbnkgYXR0ZW1wdHNcbiAgLy8gdG8gZGVzdHJveSBzaG91bGQgcmVzdWx0IGluIGFuIGVycm9yXG4gIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjaztcbiAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2soRXJyb3JzLmNyZWF0ZUNsaWVudEVycm9yKFxuICAgICAgRXJyb3JDb2Rlcy5FUlJfQ09OTl9ERVNUUk9ZX1NUQVRVU19ESVNDT05ORUNURUQpKTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSBUb2tlbkluZm8gb2JqZWN0IHRoYXQgZW5jYXBzdWxhdGVzIGFsbCB0b2tlbi1yZWxhdGVkIGluZm9ybWF0aW9uLFxuICogZS5nLiB0aGUgbWFzdGVyIHRva2VuLCB0aGUgc2Vzc2lvbiB0b2tlbiwgdGhlIHRva2VucycgZXhwaXJhdGlvbiB0aW1lcywgZXRjLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbY29uZmlnXVxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5mdW5jdGlvbiBUb2tlbkluZm8oY29uZmlnKSB7XG4gIGxldCBtYXN0ZXJUb2tlbjtcbiAgbGV0IHNlc3Npb25Ub2tlbjtcbiAgbGV0IG1hc3RlclRva2VuRXhwaXJhdGlvblRpbWU7XG4gIGxldCBzZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZTtcblxuICBpZiAoVXRpbC5pc09iamVjdChjb25maWcpKSB7XG4gICAgbWFzdGVyVG9rZW4gPSBjb25maWcubWFzdGVyVG9rZW47XG4gICAgc2Vzc2lvblRva2VuID0gY29uZmlnLnNlc3Npb25Ub2tlbjtcbiAgICBtYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lID0gY29uZmlnLm1hc3RlclRva2VuRXhwaXJhdGlvblRpbWU7XG4gICAgc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWUgPSBjb25maWcuc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIGlmIG5vIHRva2VuLXJlbGF0ZWQgaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqXG4gICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgKi9cbiAgdGhpcy5pc0VtcHR5ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAhVXRpbC5leGlzdHMobWFzdGVyVG9rZW4pIHx8XG4gICAgICAhVXRpbC5leGlzdHMobWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZSkgfHxcbiAgICAgICFVdGlsLmV4aXN0cyhzZXNzaW9uVG9rZW4pIHx8XG4gICAgICAhVXRpbC5leGlzdHMoc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWUpO1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGVhcnMgYWxsIHRva2VuLXJlbGF0ZWQgaW5mb3JtYXRpb24uXG4gICAqL1xuICB0aGlzLmNsZWFyVG9rZW5zID0gZnVuY3Rpb24gKCkge1xuICAgIG1hc3RlclRva2VuID0gdW5kZWZpbmVkO1xuICAgIG1hc3RlclRva2VuRXhwaXJhdGlvblRpbWUgPSB1bmRlZmluZWQ7XG4gICAgc2Vzc2lvblRva2VuID0gdW5kZWZpbmVkO1xuICAgIHNlc3Npb25Ub2tlbkV4cGlyYXRpb25UaW1lID0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIC8qKlxuICAgKiBVcGRhdGVzIHRoZSB0b2tlbnMgYW5kIHRoZWlyIGV4cGlyYXRpb24gdGltZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAqL1xuICB0aGlzLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgbWFzdGVyVG9rZW4gPSBkYXRhLm1hc3RlclRva2VuO1xuICAgIHNlc3Npb25Ub2tlbiA9IGRhdGEudG9rZW4gfHwgZGF0YS5zZXNzaW9uVG9rZW47XG5cbiAgICBjb25zdCBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gICAgbWFzdGVyVG9rZW5FeHBpcmF0aW9uVGltZSA9IGN1cnJlbnRUaW1lICtcbiAgICAgIDEwMDAgKiAoZGF0YS5tYXN0ZXJWYWxpZGl0eUluU2Vjb25kcyB8fFxuICAgICAgICBkYXRhLnZhbGlkaXR5SW5TZWNvbmRzTVQpO1xuXG4gICAgc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWUgPSBjdXJyZW50VGltZSArXG4gICAgICAxMDAwICogKGRhdGEudmFsaWRpdHlJblNlY29uZHMgfHxcbiAgICAgICAgZGF0YS52YWxpZGl0eUluU2Vjb25kc1NUKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbWFzdGVyIHRva2VuLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy5nZXRNYXN0ZXJUb2tlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbWFzdGVyVG9rZW47XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGV4cGlyYXRpb24gdGltZSBvZiB0aGUgbWFzdGVyIHRva2VuLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgdGhpcy5nZXRNYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBtYXN0ZXJUb2tlbkV4cGlyYXRpb25UaW1lO1xuICB9O1xuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBzZXNzaW9uIHRva2VuLlxuICAgKlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgKi9cbiAgdGhpcy5nZXRTZXNzaW9uVG9rZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHNlc3Npb25Ub2tlbjtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgZXhwaXJhdGlvbiB0aW1lIG9mIHRoZSBzZXNzaW9uIHRva2VuLlxuICAgKlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgKi9cbiAgdGhpcy5nZXRTZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZSA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gc2Vzc2lvblRva2VuRXhwaXJhdGlvblRpbWU7XG4gIH07XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBjb25maWd1cmF0aW9uIG9iamVjdCB0aGF0IGNhbiBiZSBwYXNzZWQgdG8gdGhlIFRva2VuSW5mb1xuICAgKiBjb25zdHJ1Y3RvciB0byBnZXQgYW4gZXF1aXZhbGVudCBUb2tlbkluZm8gb2JqZWN0LlxuICAgKlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgKi9cbiAgdGhpcy5nZXRDb25maWcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1hc3RlclRva2VuOiBtYXN0ZXJUb2tlbixcbiAgICAgIG1hc3RlclRva2VuRXhwaXJhdGlvblRpbWU6IG1hc3RlclRva2VuRXhwaXJhdGlvblRpbWUsXG4gICAgICBzZXNzaW9uVG9rZW46IHNlc3Npb25Ub2tlbixcbiAgICAgIHNlc3Npb25Ub2tlbkV4cGlyYXRpb25UaW1lOiBzZXNzaW9uVG9rZW5FeHBpcmF0aW9uVGltZVxuICAgIH07XG4gIH07XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/services/sf.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/snowflake.js":
/*!*****************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/snowflake.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const core = __webpack_require__(/*! ./core */ \"(rsc)/./node_modules/snowflake-sdk/lib/core.js\");\nconst Util = __webpack_require__(/*! ./util */ \"(rsc)/./node_modules/snowflake-sdk/lib/util.js\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\nconst ErrorCodes = Errors.codes;\n\nconst clientEnvironment = process.versions;\n\n// if we're not using the minimum supported version of node.js, raise an error\nconst minimumNodeVersion = '6.0.0';\nif (Util.string.compareVersions(clientEnvironment.node, minimumNodeVersion) < 0) {\n  throw Errors.createClientError(\n    ErrorCodes.ERR_UNSUPPORTED_NODE_JS_VERSION, true, minimumNodeVersion);\n}\n\nmodule.exports = core(\n  {\n    httpClientClass: (__webpack_require__(/*! ./http/node */ \"(rsc)/./node_modules/snowflake-sdk/lib/http/node.js\").NodeHttpClient),\n    loggerClass: __webpack_require__(/*! ./logger/node */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger/node.js\"),\n    client:\n      {\n        version: Util.driverVersion,\n        name: Util.driverName,\n        environment: clientEnvironment\n      }\n  });\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvc25vd2ZsYWtlLmpzIiwibWFwcGluZ3MiOiJBQUFBLGFBQWEsbUJBQU8sQ0FBQyw4REFBUTtBQUM3QixhQUFhLG1CQUFPLENBQUMsOERBQVE7QUFDN0IsZUFBZSxtQkFBTyxDQUFDLGtFQUFVO0FBQ2pDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCLDhHQUFxQztBQUMxRCxpQkFBaUIsbUJBQU8sQ0FBQyw0RUFBZTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHIiwic291cmNlcyI6WyIvVXNlcnMvdmljdG9yd2lsc29uL0Rlc2t0b3AvcHJvamVjdHMvRVpWaXovbm9kZV9tb2R1bGVzL3Nub3dmbGFrZS1zZGsvbGliL3Nub3dmbGFrZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBjb3JlID0gcmVxdWlyZSgnLi9jb3JlJyk7XG5jb25zdCBVdGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5jb25zdCBFcnJvcnMgPSByZXF1aXJlKCcuL2Vycm9ycycpO1xuY29uc3QgRXJyb3JDb2RlcyA9IEVycm9ycy5jb2RlcztcblxuY29uc3QgY2xpZW50RW52aXJvbm1lbnQgPSBwcm9jZXNzLnZlcnNpb25zO1xuXG4vLyBpZiB3ZSdyZSBub3QgdXNpbmcgdGhlIG1pbmltdW0gc3VwcG9ydGVkIHZlcnNpb24gb2Ygbm9kZS5qcywgcmFpc2UgYW4gZXJyb3JcbmNvbnN0IG1pbmltdW1Ob2RlVmVyc2lvbiA9ICc2LjAuMCc7XG5pZiAoVXRpbC5zdHJpbmcuY29tcGFyZVZlcnNpb25zKGNsaWVudEVudmlyb25tZW50Lm5vZGUsIG1pbmltdW1Ob2RlVmVyc2lvbikgPCAwKSB7XG4gIHRocm93IEVycm9ycy5jcmVhdGVDbGllbnRFcnJvcihcbiAgICBFcnJvckNvZGVzLkVSUl9VTlNVUFBPUlRFRF9OT0RFX0pTX1ZFUlNJT04sIHRydWUsIG1pbmltdW1Ob2RlVmVyc2lvbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY29yZShcbiAge1xuICAgIGh0dHBDbGllbnRDbGFzczogcmVxdWlyZSgnLi9odHRwL25vZGUnKS5Ob2RlSHR0cENsaWVudCxcbiAgICBsb2dnZXJDbGFzczogcmVxdWlyZSgnLi9sb2dnZXIvbm9kZScpLFxuICAgIGNsaWVudDpcbiAgICAgIHtcbiAgICAgICAgdmVyc2lvbjogVXRpbC5kcml2ZXJWZXJzaW9uLFxuICAgICAgICBuYW1lOiBVdGlsLmRyaXZlck5hbWUsXG4gICAgICAgIGVudmlyb25tZW50OiBjbGllbnRFbnZpcm9ubWVudFxuICAgICAgfVxuICB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/snowflake.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/url_util.js":
/*!****************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/url_util.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("const Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\n\n/**\n * Determines if a given URL is valid.\n *\n * @param url\n *\n * @returns {Boolean}\n */\nexports.isValidURL = function (url) {\n  const regex = '^http(s?)\\\\:\\\\/\\\\/[0-9a-zA-Z]([-.\\\\w]*[0-9a-zA-Z@:])*(:(0-9)*)*(\\\\/?)([a-zA-Z0-9\\\\-\\\\.\\\\?\\\\,\\\\&\\\\(\\\\)\\\\/\\\\\\\\\\\\+&%\\\\$#_=@]*)?$';\n  if (!url.match(regex)) {\n    Logger.getInstance().debug('The provided URL is not a valid URL. URL: %s', url);\n    return false;\n  }\n  return true;\n};\n\n/**\n * Encodes the given URL. \n * \n * @param {String} url \n * \n * @returns {String} the encoded URL\n */\nexports.urlEncode = function (url) { \n  /** The encodeURIComponent() method encodes special characters including: , / ? : @ & = + $ #\n     but escapes space as %20B. Replace with + for consistency across drivers. */\n  return encodeURIComponent(url).replace(/%20/g, '+');\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvdXJsX3V0aWwuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxtQkFBTyxDQUFDLGtFQUFVOztBQUVqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL3ZpY3RvcndpbHNvbi9EZXNrdG9wL3Byb2plY3RzL0VaVml6L25vZGVfbW9kdWxlcy9zbm93Zmxha2Utc2RrL2xpYi91cmxfdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBVUkwgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHVybFxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzVmFsaWRVUkwgPSBmdW5jdGlvbiAodXJsKSB7XG4gIGNvbnN0IHJlZ2V4ID0gJ15odHRwKHM/KVxcXFw6XFxcXC9cXFxcL1swLTlhLXpBLVpdKFstLlxcXFx3XSpbMC05YS16QS1aQDpdKSooOigwLTkpKikqKFxcXFwvPykoW2EtekEtWjAtOVxcXFwtXFxcXC5cXFxcP1xcXFwsXFxcXCZcXFxcKFxcXFwpXFxcXC9cXFxcXFxcXFxcXFwrJiVcXFxcJCNfPUBdKik/JCc7XG4gIGlmICghdXJsLm1hdGNoKHJlZ2V4KSkge1xuICAgIExvZ2dlci5nZXRJbnN0YW5jZSgpLmRlYnVnKCdUaGUgcHJvdmlkZWQgVVJMIGlzIG5vdCBhIHZhbGlkIFVSTC4gVVJMOiAlcycsIHVybCk7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuLyoqXG4gKiBFbmNvZGVzIHRoZSBnaXZlbiBVUkwuIFxuICogXG4gKiBAcGFyYW0ge1N0cmluZ30gdXJsIFxuICogXG4gKiBAcmV0dXJucyB7U3RyaW5nfSB0aGUgZW5jb2RlZCBVUkxcbiAqL1xuZXhwb3J0cy51cmxFbmNvZGUgPSBmdW5jdGlvbiAodXJsKSB7IFxuICAvKiogVGhlIGVuY29kZVVSSUNvbXBvbmVudCgpIG1ldGhvZCBlbmNvZGVzIHNwZWNpYWwgY2hhcmFjdGVycyBpbmNsdWRpbmc6ICwgLyA/IDogQCAmID0gKyAkICNcbiAgICAgYnV0IGVzY2FwZXMgc3BhY2UgYXMgJTIwQi4gUmVwbGFjZSB3aXRoICsgZm9yIGNvbnNpc3RlbmN5IGFjcm9zcyBkcml2ZXJzLiAqL1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHVybCkucmVwbGFjZSgvJTIwL2csICcrJyk7XG59OyJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/url_util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/lib/util.js":
/*!************************************************!*\
  !*** ./node_modules/snowflake-sdk/lib/util.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("const util = __webpack_require__(/*! util */ \"util\");\nconst Url = __webpack_require__(/*! url */ \"url\");\nconst os = __webpack_require__(/*! os */ \"os\");\nconst Logger = __webpack_require__(/*! ./logger */ \"(rsc)/./node_modules/snowflake-sdk/lib/logger.js\");\nconst fs = __webpack_require__(/*! fs */ \"fs\");\nconst Errors = __webpack_require__(/*! ./errors */ \"(rsc)/./node_modules/snowflake-sdk/lib/errors.js\");\n\n/**\n * Note: A simple wrapper around util.inherits() for now, but this might change\n * in the future.\n *\n * Inherits the prototype methods from one constructor into another. The\n * prototype of constructor will be set to a new object created from\n * superConstructor.\n *\n * @param constructor\n * @param superConstructor\n *\n * @returns {Object}\n */\nexports.inherits = function (constructor, superConstructor) {\n  return util.inherits.apply(util, [constructor, superConstructor]);\n};\n\n/**\n * Note: A simple wrapper around util.format() for now, but this will likely\n * change in the future.\n *\n * Returns a formatted string using the first argument as a printf-like format.\n *\n * The first argument is a string that contains zero or more placeholders.\n * Each placeholder is replaced with the converted value from its corresponding\n * argument. Supported placeholders are:\n *   %s - String.\n *   %d - Number (both integer and float).\n *   %j - JSON. Replaced with the string '[Circular]' if the argument contains\n *        circular references.\n *   %% - single percent sign ('%'). This does not consume an argument.\n *\n * If the placeholder does not have a corresponding argument, the placeholder is\n * not replaced.\n *\n * If there are more arguments than placeholders, the extra arguments are\n * coerced to strings (for objects and symbols, util.inspect() is used) and then\n * concatenated, delimited by a space.\n *\n * If the first argument is not a format string then util.format() returns a\n * string that is the concatenation of all its arguments separated by spaces.\n * Each argument is converted to a string with util.inspect().\n *\n * @returns {String}\n */\nexports.format = function (format, ...params) {\n  return util.format.apply(util, [format, ...params]);\n};\n\n/**\n * Determines if a given value is a function.\n *\n * @param value\n *\n * @returns {Boolean}\n */\nexports.isFunction = function (value) {\n  return !!value && typeof value === 'function';\n};\n\nconst toString = Object.prototype.toString;\n\n/**\n * Determines if a given value is an object.\n *\n * @param value\n *\n * @returns {Boolean}\n */\nexports.isObject = function (value) {\n  return toString.call(value) === '[object Object]';\n};\n\n/**\n * Determines if a given value is a Date.\n *\n * @param value\n *\n * @returns {Boolean}\n */\nexports.isDate = function (value) {\n  return toString.call(value) === '[object Date]';\n};\n\n/**\n * Determines if a given value is an array.\n *\n * @param value\n *\n * @returns {Boolean}\n */\nexports.isArray = function (value) {\n  return toString.call(value) === '[object Array]';\n};\n\n/**\n * Determines if a given value is a string.\n *\n * @param value\n *\n * @returns {Boolean}\n */\nexports.isString = function (value) {\n  return typeof value === 'string';\n};\n\n/**\n * Determines if a given value is a boolean.\n *\n * @param value\n *\n * @returns {Boolean}\n */\nexports.isBoolean = function (value) {\n  return typeof value === 'boolean';\n};\n\n/**\n * Determines if a given value is a number.\n *\n * @param value\n *\n * @returns {Boolean}\n */\nexports.isNumber = function (value) {\n  return typeof value === 'number' && isFinite(value);\n};\n\n/**\n * Determines if a given value is a private key string in pem format of type pkcs8.\n *\n * @param value\n *\n * @returns {Boolean}\n */\nexports.isPrivateKey = function (value) {\n  const trimmedValue = value.trim();\n  // The private key is expected to be decrypted when set in the connection string\n  // secret scanner complains about first check since it looks like private key, but it's only check\n  // pragma: allowlist nextline secret\n  return (trimmedValue.startsWith('-----BEGIN PRIVATE KEY-----') &&\n    trimmedValue.endsWith('\\n-----END PRIVATE KEY-----'));\n};\n\n/**\n * A collection of number-related utility functions.\n */\nexports.number =\n  {\n    /**\n     * Determines if a given value is a positive number.\n     *\n     * @param value\n     *\n     * @returns {Boolean}\n     */\n    isPositive: function (value) {\n      return exports.isNumber(value) && (value > 0);\n    },\n\n    /**\n     * Determines if a given value is a non-negative number.\n     *\n     * @param value\n     *\n     * @returns {Boolean}\n     */\n    isNonNegative: function (value) {\n      return exports.isNumber(value) && (value >= 0);\n    },\n\n    /**\n     * Determines if a given value is an integer.\n     *\n     * @param value\n     *\n     * @returns {Boolean}\n     */\n    isInteger: function (value) {\n      return exports.isNumber(value) && (Math.floor(value) === value);\n    },\n\n    /**\n     * Determines if a given value is a positive integer.\n     *\n     * @param value\n     *\n     * @returns {Boolean}\n     */\n    isPositiveInteger: function (value) {\n      return this.isInteger(value) && (value > 0);\n    },\n\n    /**\n     * Determines if a given value is a non-negative integer.\n     *\n     * @param value\n     *\n     * @returns {Boolean}\n     */\n    isNonNegativeInteger: function (value) {\n      return this.isInteger(value) && (value >= 0);\n    }\n  };\n\n/**\n * A collection of string-related utility functions.\n */\nexports.string =\n  {\n    /**\n     * Determines if a given string is not null or empty.\n     *\n     * @param {*} value\n     *\n     * @returns {Boolean}\n     */\n    isNotNullOrEmpty: function (value) {\n      return exports.isString(value) && value;\n    },\n\n    /**\n     * Compares two version numbers of the form 'a.b.c' where a, b and c are\n     * numbers (e.g. '1.0.12'). If one or both inputs are invalid versions, the\n     * function will return NaN, otherwise, it will return -1 if the first\n     * version is smaller, 1 if the first version is bigger, and 0 if the two\n     * versions are equal.\n     *\n     * @param {String} version1\n     * @param {String} version2\n     *\n     * @returns {Number}\n     */\n    compareVersions: function (version1, version2) {\n      // if one or both inputs are valid, return NaN\n      if (!exports.isString(version1) || !exports.isString(version2)) {\n        return NaN;\n      }\n\n      // split on dot\n      const version1Parts = version1.split('.');\n      const version2Parts = version2.split('.');\n\n      // add trailing zeros to make the parts arrays the same length\n      while (version1Parts.length < version2Parts.length) {\n        version1Parts.push('0');\n      }\n      while (version2Parts.length < version1Parts.length) {\n        version2Parts.push('0');\n      }\n\n      // compare elements in the two arrays one by one\n      let result = 0;\n      let version1Part, version2Part;\n      for (let index = 0, length = version1Parts.length; index < length; index++) {\n        // convert to number before doing any arithmetic\n        version1Part = Number(version1Parts[index]);\n        version2Part = Number(version2Parts[index]);\n\n        // if one or both values are not numerical, consider the input invalid\n        if (!exports.isNumber(version1Part) || !exports.isNumber(version2Part)) {\n          result = NaN;\n          break;\n        }\n\n        // if the two values are different, pick the\n        // correct result based on which value is smaller\n        if (version1Part !== version2Part) {\n          result = version1Part < version2Part ? -1 : 1;\n          break;\n        }\n      }\n\n      return result;\n    }\n  };\n\n/**\n * Determines if a given value is not null or undefined.\n *\n * @param value\n *\n * @returns {Boolean}\n */\nexports.exists = function (value) {\n  return (value !== null) && (value !== undefined);\n};\n\n/**\n * A collection of url-related utility functions.\n */\nexports.url =\n  {\n    /**\n     * Appends a query parameter to a url. If an invalid url is specified, an\n     * exception is thrown.\n     *\n     * @param {String} url\n     * @param {String} paramName the name of the query parameter.\n     * @param {String} paramValue the value of the query parameter.\n     *\n     * @returns {String}\n     */\n    appendParam: function (url, paramName, paramValue) {\n      // if the specified url is valid\n      const urlAsObject = Url.parse(url);\n      if (urlAsObject) {\n        // if the url already has query parameters, use '&' as the separator\n        // when appending the additional query parameter, otherwise use '?'\n        url += (urlAsObject.search ? '&' : '?') + paramName + '=' + paramValue;\n      }\n\n      return url;\n    },\n\n    appendRetryParam: function (option) {\n      let retryUrl = this.appendParam(option.url, 'retryCount', option.retryCount);\n      if (option.includeRetryReason) {\n        retryUrl = this.appendParam(retryUrl, 'retryReason', option.retryReason);\n      }\n\n      return retryUrl;\n    }\n  };\n\n/**\n * Shallow-copies everything from a source object into a destination object.\n *\n * @param {Object} dst the object to copy properties to.\n * @param {Object} src the object to copy properties from.\n *\n * @returns {Object} the destination object.\n */\nexports.apply = function (dst, src) {\n  // if both dst and src are objects, copy everything from src to dst\n  if (this.isObject(dst) && this.isObject(src)) {\n    for (const key in src) {\n      if (Object.prototype.hasOwnProperty.call(src, key)) {\n        dst[key] = src[key];\n      }\n    }\n  }\n\n  return dst;\n};\n\n/**\n * Returns true if the code is currently being run in the browser, false\n * otherwise.\n *\n * @returns {Boolean}\n */\nexports.isBrowser = function () {\n  return !!(process && false);\n};\n\n/**\n * Returns true if the code is currently being run in node, false otherwise.\n *\n * @returns {Boolean}\n */\nexports.isNode = function () {\n  return !this.isBrowser();\n};\n\n/**\n * Returns the next sleep time calculated by exponential backoff with\n * decorrelated jitter.\n * sleep = min(cap, random_between(base, sleep * 3))\n * for more details, check out:\n * http://www.awsarchitectureblog.com/2015/03/backoff.html\n * @param base minimum seconds\n * @param cap maximum seconds\n * @param previousSleep previous sleep time\n * @returns {number} next sleep time\n */\nexports.nextSleepTime = function (\n  base, cap, previousSleep) {\n  return Math.min(cap, Math.abs(previousSleep * 3 - base) * Math.random() +\n    Math.min(base, previousSleep * 3));\n};\n\n\n/**\n * Return next sleep time calculated by the jitter rule.\n *\n * @param {Number} numofRetries\n * @param {Number} currentSleepTime\n * @param {Number} totalElapsedTime\n * @param {Number} maxRetryTimeout\n * @returns {JSON} return next sleep Time and totalTime.\n */\nexports.getJitteredSleepTime = function (numofRetries, currentSleepTime, totalElapsedTime, maxRetryTimeout) {\n  const nextsleep = getNextSleepTime(numofRetries, currentSleepTime);\n  const sleep = maxRetryTimeout !== 0 ? Math.min((maxRetryTimeout - totalElapsedTime), nextsleep) : nextsleep;\n  totalElapsedTime += sleep;\n  return { sleep, totalElapsedTime };\n};\n\n/**\n * Choose one of the number between two numbers.\n *\n * @param {Number} firstNumber\n * @param {Number} secondNumber\n * @returns {Number} return a random number between two numbers.\n */\nfunction chooseRandom(firstNumber, secondNumber) {\n  return Math.random() * (firstNumber - secondNumber) + secondNumber;\n}\n\nexports.chooseRandom = chooseRandom;\n\n/**\n * return the next sleep Time.\n * @param {Number} numofRetries\n * @param {Number} currentSleepTime\n * @returns {Number} return jitter.\n */\nfunction getNextSleepTime(numofRetries,  currentSleepTime) {\n  const nextSleep = (2 ** (numofRetries));\n  return chooseRandom(currentSleepTime + getJitter(currentSleepTime), nextSleep + getJitter(currentSleepTime));\n}\n\nexports.getNextSleepTime = getNextSleepTime;\n\n/**\n * return the jitter value.\n * @param {Number} currentSleepTime\n * @returns {Number} return jitter.\n */\nfunction getJitter(currentSleepTime) {\n  const multiplicationFactor = chooseRandom(1, -1);\n  return 0.5 * currentSleepTime * multiplicationFactor;\n}\n\nexports.getJitter = getJitter;\n\n/**\n * Check whether the request is the login-request or not.\n *\n * @param loginurl HTTP request url\n * @returns {Boolean} true if it is loginRequest, otherwise false.\n */\nexports.isLoginRequest = function (loginUrl) {\n  const endPoints = ['/v1/login-request', '/authenticator-request',];\n  return endPoints.some((endPoint) => loginUrl.includes(endPoint));\n};\n\n/**\n * Checks if the HTTP response code is retryable\n *\n * @param response HTTP response object\n * @param retry403 will retry HTTP 403?\n * @returns {*|boolean} true if retryable otherwise false\n */\nexports.isRetryableHttpError = function (response, retry403) {\n  return response &&\n    ((response.statusCode >= 500 && response.statusCode < 600) ||\n      (retry403 && response.statusCode === 403) ||\n      (response.statusCode === 408) ||\n      (response.statusCode === 429));\n};\n\nexports.validateClientSessionKeepAliveHeartbeatFrequency = function (input, masterValidity) {\n  let heartbeatFrequency = input;\n  const realMax = Math.floor(masterValidity / 4);\n  const realMin = Math.floor(realMax / 4);\n  if (input > realMax) {\n    heartbeatFrequency = realMax;\n  } else if (input < realMin) {\n    heartbeatFrequency = realMin;\n  }\n\n  heartbeatFrequency = Math.floor(heartbeatFrequency);\n  return heartbeatFrequency;\n};\n\n// driver name\nconst driverName = (__webpack_require__(/*! ./../package.json */ \"(rsc)/./node_modules/snowflake-sdk/package.json\").name);\nexports.driverName = driverName;\n\n// driver version\nconst driverVersion = (__webpack_require__(/*! ./../package.json */ \"(rsc)/./node_modules/snowflake-sdk/package.json\").version);\nexports.driverVersion = driverVersion;\n\n// nodeJS version\nlet nodeJSVersion = process.version;\nif (nodeJSVersion && nodeJSVersion.startsWith('v')) {\n  nodeJSVersion = nodeJSVersion.substring(1);\n}\n// user-agent HTTP header\nconst userAgent = 'JavaScript' + '/' + driverVersion\n  + ' (' + process.platform + '-' + process.arch + ') ' + 'NodeJS' + '/' + nodeJSVersion;\n\nexports.userAgent = userAgent;\n\n/**\n * Constructs host name using region and account\n *\n * @param region where the account is located\n * @param account which account to connect to\n * @returns {string} host name\n */\nexports.constructHostname = function (region, account) {\n  let host;\n  if (region === 'us-west-2') {\n    host = account + '.snowflakecomputing.com';\n  } else if (region != null) {\n    if (account.indexOf('.') > 0) {\n      account = account.substring(0, account.indexOf('.'));\n    }\n    if (region.startsWith('cn-') || region.startsWith('CN-')) {\n      host = account + '.' + region + '.snowflakecomputing.cn';\n    } else {\n      host = account + '.' + region + '.snowflakecomputing.com';\n    }\n\n  } else {\n    host = account + '.snowflakecomputing.com';\n  }\n  return host;\n};\n\n/**\n * Returns true if host indicates private link\n *\n * @returns {boolean}\n */\nexports.isPrivateLink = function (host) {\n  Errors.checkArgumentExists(this.exists(host), Errors.codes.ERR_CONN_CREATE_MISSING_HOST);\n  return host.toLowerCase().includes('privatelink.snowflakecomputing.');\n};\n/**\n * Returns true if host indicates private link\n *\n * @returns {boolean}\n */\nexports.createOcspResponseCacheServerUrl = function (host) {\n  return `http://ocsp.${host}/ocsp_response_cache.json`;\n};\n\n/**\n * Returns if command is a PUT command\n *\n * @param sqlText the query command\n * @returns {boolean}\n */\nexports.isPutCommand = function (sqlText) {\n  return (sqlText.trim().substring(0, 3).toUpperCase() === 'PUT');\n};\n\n/**\n * Returns if command is a GET command\n *\n * @param sqlText the query command\n * @returns {boolean}\n */\nexports.isGetCommand = function (sqlText) {\n  return (sqlText.trim().substring(0, 3).toUpperCase() === 'GET');\n};\n\n/**\n * Add double quotes to smkId's value to parse it as a string instead of integer\n * to preserve precision of numbers exceeding JavaScript's max safe integer\n * e.g (inputting 32621973126123526\toutputs 32621973126123530)\n *\n * @param body the data in JSON\n * @returns {string}\n */\nexports.convertSmkIdToString = function (body) {\n  return body.replace(/\"smkId\" : ([0-9]*)/g, '\"smkId\" : \"$1\"');\n};\n\n/**\n * Under some circumstances the object passed to JSON.stringify in exception handling\n * can contain circular reference, on which JSON.stringify bails out\n * MDN way of handling such error\n * @returns string\n */\nexports.getCircularReplacer = function () {\n  const ancestors = [];\n  return function (key, value) {\n    if (typeof value !== 'object' || value === null) {\n      return value;\n    }\n    // `this` is the object that value is contained in,\n    // i.e., its direct parent.\n    while (ancestors.length > 0 && ancestors[ancestors.length - 1] !== this) {\n      ancestors.pop();\n    }\n    if (ancestors.includes(value)) {\n      return '[Circular]';\n    }\n    ancestors.push(value);\n    return value;\n  };\n};\n\n/**\n * Returns if the provided string is a valid subdomain.\n * @param value\n * @returns {boolean}\n */\nexports.isCorrectSubdomain = function (value) {\n  const subdomainRegex = RegExp(/^\\w+([.-]\\w+)*$/i);\n  return subdomainRegex.test(value);\n};\n\nexports.buildCredentialCacheKey = function (host, username, credType) {\n  if (!host || !username || !credType) {\n    Logger.getInstance().debug('Cannot build the credential cache key because one of host, username, and credType is null');\n    return null;\n  }\n  return `{${host.toUpperCase()}}:{${username.toUpperCase()}}:{SF_NODE_JS_DRIVER}:{${credType.toUpperCase()}}`;\n};\n\n/**\n * \n * @param {Object} customCredentialManager \n * @returns \n */\nexports.checkValidCustomCredentialManager = function (customCredentialManager) {\n  if ( typeof customCredentialManager !== 'object') {\n    return false;\n  }\n\n  const requireMethods = ['write', 'read', 'remove'];\n\n  for (const method of requireMethods) {\n    if (!Object.hasOwnProperty.call(customCredentialManager, method) || typeof customCredentialManager[method] !== 'function') {\n      return false;\n    }\n  }\n  return true;\n};\n\nexports.checkParametersDefined = function (...parameters) {\n  return parameters.every((element) => element !== undefined && element !== null);\n};\n\nexports.buildCredentialCacheKey = function (host, username, credType) {\n  if (!host || !username || !credType) {\n    Logger.getInstance().debug('Cannot build the credential cache key because one of host, username, and credType is null');\n    return null;\n  }\n  return `{${host.toUpperCase()}}:{${username.toUpperCase()}}:{SF_NODE_JS_DRIVER}:{${credType.toUpperCase()}}`;\n};\n\n/**\n * \n * @param {Object} customCredentialManager \n * @returns \n */\nexports.checkValidCustomCredentialManager = function (customCredentialManager) {\n  if ( typeof customCredentialManager !== 'object') {\n    return false;\n  }\n  \n  const requireMethods = ['write', 'read', 'remove'];\n\n  for (const method of requireMethods) {\n    if (!Object.hasOwnProperty.call(customCredentialManager, method) || typeof customCredentialManager[method] !== 'function') {\n      return false;\n    }\n  }\n  return true;\n};\n\nexports.checkParametersDefined = function (...parameters) {\n  return parameters.every((element) => element !== undefined && element !== null);\n};\n\nexports.shouldPerformGCPBucket = function (accessToken) {\n  return !!accessToken && process.env.SNOWFLAKE_FORCE_GCP_USE_DOWNSCOPED_CREDENTIAL !== 'true';\n};\n\n/**\n * Checks if the provided file or directory permissions are correct.\n * @param filePath\n * @param expectedMode\n * @param fsPromises\n * @returns {Promise<boolean>} resolves always to true for Windows\n */\nexports.isFileModeCorrect = async function (filePath, expectedMode, fsPromises) {\n  if (os.platform() === 'win32') {\n    return true;\n  }\n  return await fsPromises.stat(filePath).then((stats) => {\n    // we have to limit the number of LSB bits to 9 with the mask, as the stats.mode starts with the file type,\n    // e.g. the directory with permissions 755 will have stats.mask of 40755.\n    const mask = (1 << 9) - 1;\n    return (stats.mode & mask) === expectedMode;\n  });\n};\n\n/**\n * Checks if the provided file or directory is writable only by the user.\n * @param configFilePath\n * @param fsPromises\n * @returns {Promise<boolean>} resolves always to true for Windows\n */\nexports.isFileNotWritableByGroupOrOthers = async function (configFilePath, fsPromises) {\n  if (os.platform() === 'win32') {\n    return true;\n  }\n  const stats = await fsPromises.stat(configFilePath);\n  return (stats.mode & (1 << 4)) === 0 && (stats.mode & (1 << 1)) === 0;\n};\n\nexports.shouldRetryOktaAuth = function ({ maxRetryTimeout, maxRetryCount, numRetries, startTime, remainingTimeout }) {\n  return  (maxRetryTimeout === 0 || Date.now() < startTime + remainingTimeout) && numRetries <= maxRetryCount;\n};\n\nexports.getDriverDirectory = function () {\n  return __dirname;\n};\n\nexports.validatePath = function (dir) {\n  try {\n    const stat = fs.statSync(dir);\n    return stat.isDirectory();\n  } catch {\n    Logger.getInstance().error('The path location is invalid. Please check this location is accessible or existing');\n    return false;\n  }\n};\n\nexports.getEnvVar = function (variable) {\n  return process.env[variable.toLowerCase()] || process.env[variable.toUpperCase()];\n};\n\nexports.validateEmptyString = function (value) {\n  return value !== '' ? value : undefined;\n};\n\nexports.isNotEmptyAsString = function (variable) {\n  if (typeof variable === 'string') {\n    return variable;\n  }\n  return exports.exists(variable);\n};\n/**\n * Checks Whether the object is empty (can be null or undefined) or not.\n * @param object\n * @returns {boolean} \n */\nexports.isEmptyObject = (object) => {\n  if (!this.exists(object)) {\n    return true;\n  }\n  if (typeof object !== 'object') {\n    return false;\n  }\n  return Object.keys(object).length === 0;\n};\n\nexports.isWindows = function () {\n  return os.platform() === 'win32';\n};\n\n/**\n* Left strip the specified character from a string.\n*\n* @param {String} str\n* @param {Character} remove\n*\n* @returns {String}\n*/\nexports.lstrip = function (str, remove) {\n  while (str.length > 0 && remove.indexOf(str.charAt(0)) !== -1) {\n    str = str.substr(1);\n  }\n  return str;\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQSxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsWUFBWSxtQkFBTyxDQUFDLGdCQUFLO0FBQ3pCLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGVBQWUsbUJBQU8sQ0FBQyxrRUFBVTtBQUNqQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixlQUFlLG1CQUFPLENBQUMsa0VBQVU7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkI7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsZ0JBQWdCO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsaUJBQWlCO0FBQ2pCLHVCQUF1QixLQUFlO0FBQ3RDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsTUFBTTtBQUNuQjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsV0FBVztBQUN4QjtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsc0dBQWlDO0FBQ3BELGtCQUFrQjs7QUFFbEI7QUFDQSxzQkFBc0IseUdBQW9DO0FBQzFELHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7O0FBRWpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLHdDQUF3QztBQUN4Qyx3QkFBd0IsS0FBSztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEVBQUUsb0JBQW9CLEVBQUUsRUFBRSx3QkFBd0IsRUFBRSxrQkFBa0IsRUFBRSxFQUFFLHdCQUF3QjtBQUM3Rzs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsRUFBRSxvQkFBb0IsRUFBRSxFQUFFLHdCQUF3QixFQUFFLGtCQUFrQixFQUFFLEVBQUUsd0JBQXdCO0FBQzdHOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixlQUFlLHlFQUF5RTtBQUNuSDtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsaUJBQWlCO0FBQ2pCO0FBQ0E7O0FBRUEsMkJBQTJCO0FBQzNCO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxpQkFBaUI7QUFDakI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLFFBQVE7QUFDbEIsVUFBVSxXQUFXO0FBQ3JCO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy92aWN0b3J3aWxzb24vRGVza3RvcC9wcm9qZWN0cy9FWlZpei9ub2RlX21vZHVsZXMvc25vd2ZsYWtlLXNkay9saWIvdXRpbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB1dGlsID0gcmVxdWlyZSgndXRpbCcpO1xuY29uc3QgVXJsID0gcmVxdWlyZSgndXJsJyk7XG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJyk7XG5jb25zdCBMb2dnZXIgPSByZXF1aXJlKCcuL2xvZ2dlcicpO1xuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xuY29uc3QgRXJyb3JzID0gcmVxdWlyZSgnLi9lcnJvcnMnKTtcblxuLyoqXG4gKiBOb3RlOiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB1dGlsLmluaGVyaXRzKCkgZm9yIG5vdywgYnV0IHRoaXMgbWlnaHQgY2hhbmdlXG4gKiBpbiB0aGUgZnV0dXJlLlxuICpcbiAqIEluaGVyaXRzIHRoZSBwcm90b3R5cGUgbWV0aG9kcyBmcm9tIG9uZSBjb25zdHJ1Y3RvciBpbnRvIGFub3RoZXIuIFRoZVxuICogcHJvdG90eXBlIG9mIGNvbnN0cnVjdG9yIHdpbGwgYmUgc2V0IHRvIGEgbmV3IG9iamVjdCBjcmVhdGVkIGZyb21cbiAqIHN1cGVyQ29uc3RydWN0b3IuXG4gKlxuICogQHBhcmFtIGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0gc3VwZXJDb25zdHJ1Y3RvclxuICpcbiAqIEByZXR1cm5zIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuaW5oZXJpdHMgPSBmdW5jdGlvbiAoY29uc3RydWN0b3IsIHN1cGVyQ29uc3RydWN0b3IpIHtcbiAgcmV0dXJuIHV0aWwuaW5oZXJpdHMuYXBwbHkodXRpbCwgW2NvbnN0cnVjdG9yLCBzdXBlckNvbnN0cnVjdG9yXSk7XG59O1xuXG4vKipcbiAqIE5vdGU6IEEgc2ltcGxlIHdyYXBwZXIgYXJvdW5kIHV0aWwuZm9ybWF0KCkgZm9yIG5vdywgYnV0IHRoaXMgd2lsbCBsaWtlbHlcbiAqIGNoYW5nZSBpbiB0aGUgZnV0dXJlLlxuICpcbiAqIFJldHVybnMgYSBmb3JtYXR0ZWQgc3RyaW5nIHVzaW5nIHRoZSBmaXJzdCBhcmd1bWVudCBhcyBhIHByaW50Zi1saWtlIGZvcm1hdC5cbiAqXG4gKiBUaGUgZmlyc3QgYXJndW1lbnQgaXMgYSBzdHJpbmcgdGhhdCBjb250YWlucyB6ZXJvIG9yIG1vcmUgcGxhY2Vob2xkZXJzLlxuICogRWFjaCBwbGFjZWhvbGRlciBpcyByZXBsYWNlZCB3aXRoIHRoZSBjb252ZXJ0ZWQgdmFsdWUgZnJvbSBpdHMgY29ycmVzcG9uZGluZ1xuICogYXJndW1lbnQuIFN1cHBvcnRlZCBwbGFjZWhvbGRlcnMgYXJlOlxuICogICAlcyAtIFN0cmluZy5cbiAqICAgJWQgLSBOdW1iZXIgKGJvdGggaW50ZWdlciBhbmQgZmxvYXQpLlxuICogICAlaiAtIEpTT04uIFJlcGxhY2VkIHdpdGggdGhlIHN0cmluZyAnW0NpcmN1bGFyXScgaWYgdGhlIGFyZ3VtZW50IGNvbnRhaW5zXG4gKiAgICAgICAgY2lyY3VsYXIgcmVmZXJlbmNlcy5cbiAqICAgJSUgLSBzaW5nbGUgcGVyY2VudCBzaWduICgnJScpLiBUaGlzIGRvZXMgbm90IGNvbnN1bWUgYW4gYXJndW1lbnQuXG4gKlxuICogSWYgdGhlIHBsYWNlaG9sZGVyIGRvZXMgbm90IGhhdmUgYSBjb3JyZXNwb25kaW5nIGFyZ3VtZW50LCB0aGUgcGxhY2Vob2xkZXIgaXNcbiAqIG5vdCByZXBsYWNlZC5cbiAqXG4gKiBJZiB0aGVyZSBhcmUgbW9yZSBhcmd1bWVudHMgdGhhbiBwbGFjZWhvbGRlcnMsIHRoZSBleHRyYSBhcmd1bWVudHMgYXJlXG4gKiBjb2VyY2VkIHRvIHN0cmluZ3MgKGZvciBvYmplY3RzIGFuZCBzeW1ib2xzLCB1dGlsLmluc3BlY3QoKSBpcyB1c2VkKSBhbmQgdGhlblxuICogY29uY2F0ZW5hdGVkLCBkZWxpbWl0ZWQgYnkgYSBzcGFjZS5cbiAqXG4gKiBJZiB0aGUgZmlyc3QgYXJndW1lbnQgaXMgbm90IGEgZm9ybWF0IHN0cmluZyB0aGVuIHV0aWwuZm9ybWF0KCkgcmV0dXJucyBhXG4gKiBzdHJpbmcgdGhhdCBpcyB0aGUgY29uY2F0ZW5hdGlvbiBvZiBhbGwgaXRzIGFyZ3VtZW50cyBzZXBhcmF0ZWQgYnkgc3BhY2VzLlxuICogRWFjaCBhcmd1bWVudCBpcyBjb252ZXJ0ZWQgdG8gYSBzdHJpbmcgd2l0aCB1dGlsLmluc3BlY3QoKS5cbiAqXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICovXG5leHBvcnRzLmZvcm1hdCA9IGZ1bmN0aW9uIChmb3JtYXQsIC4uLnBhcmFtcykge1xuICByZXR1cm4gdXRpbC5mb3JtYXQuYXBwbHkodXRpbCwgW2Zvcm1hdCwgLi4ucGFyYW1zXSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzRnVuY3Rpb24gPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xufTtcblxuY29uc3QgdG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNPYmplY3QgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBPYmplY3RdJztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgRGF0ZS5cbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0RhdGUgPSBmdW5jdGlvbiAodmFsdWUpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09PSAnW29iamVjdCBEYXRlXSc7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc0FycmF5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbi8qKlxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xufTtcblxuLyoqXG4gKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gdmFsdWUgaXMgYSBib29sZWFuLlxuICpcbiAqIEBwYXJhbSB2YWx1ZVxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzQm9vbGVhbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqXG4gKiBAcGFyYW0gdmFsdWVcbiAqXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc051bWJlciA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWx1ZSk7XG59O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIHByaXZhdGUga2V5IHN0cmluZyBpbiBwZW0gZm9ybWF0IG9mIHR5cGUgcGtjczguXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNQcml2YXRlS2V5ID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIGNvbnN0IHRyaW1tZWRWYWx1ZSA9IHZhbHVlLnRyaW0oKTtcbiAgLy8gVGhlIHByaXZhdGUga2V5IGlzIGV4cGVjdGVkIHRvIGJlIGRlY3J5cHRlZCB3aGVuIHNldCBpbiB0aGUgY29ubmVjdGlvbiBzdHJpbmdcbiAgLy8gc2VjcmV0IHNjYW5uZXIgY29tcGxhaW5zIGFib3V0IGZpcnN0IGNoZWNrIHNpbmNlIGl0IGxvb2tzIGxpa2UgcHJpdmF0ZSBrZXksIGJ1dCBpdCdzIG9ubHkgY2hlY2tcbiAgLy8gcHJhZ21hOiBhbGxvd2xpc3QgbmV4dGxpbmUgc2VjcmV0XG4gIHJldHVybiAodHJpbW1lZFZhbHVlLnN0YXJ0c1dpdGgoJy0tLS0tQkVHSU4gUFJJVkFURSBLRVktLS0tLScpICYmXG4gICAgdHJpbW1lZFZhbHVlLmVuZHNXaXRoKCdcXG4tLS0tLUVORCBQUklWQVRFIEtFWS0tLS0tJykpO1xufTtcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2YgbnVtYmVyLXJlbGF0ZWQgdXRpbGl0eSBmdW5jdGlvbnMuXG4gKi9cbmV4cG9ydHMubnVtYmVyID1cbiAge1xuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIHBvc2l0aXZlIG51bWJlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNQb3NpdGl2ZTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5pc051bWJlcih2YWx1ZSkgJiYgKHZhbHVlID4gMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzTm9uTmVnYXRpdmU6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGV4cG9ydHMuaXNOdW1iZXIodmFsdWUpICYmICh2YWx1ZSA+PSAwKTtcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIHZhbHVlIGlzIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzSW50ZWdlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5pc051bWJlcih2YWx1ZSkgJiYgKE1hdGguZmxvb3IodmFsdWUpID09PSB2YWx1ZSk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIHBvc2l0aXZlIGludGVnZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtCb29sZWFufVxuICAgICAqL1xuICAgIGlzUG9zaXRpdmVJbnRlZ2VyOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzSW50ZWdlcih2YWx1ZSkgJiYgKHZhbHVlID4gMCk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBhIG5vbi1uZWdhdGl2ZSBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAgICAgKi9cbiAgICBpc05vbk5lZ2F0aXZlSW50ZWdlcjogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdGhpcy5pc0ludGVnZXIodmFsdWUpICYmICh2YWx1ZSA+PSAwKTtcbiAgICB9XG4gIH07XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHN0cmluZy1yZWxhdGVkIHV0aWxpdHkgZnVuY3Rpb25zLlxuICovXG5leHBvcnRzLnN0cmluZyA9XG4gIHtcbiAgICAvKipcbiAgICAgKiBEZXRlcm1pbmVzIGlmIGEgZ2l2ZW4gc3RyaW5nIGlzIG5vdCBudWxsIG9yIGVtcHR5LlxuICAgICAqXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgICAqXG4gICAgICogQHJldHVybnMge0Jvb2xlYW59XG4gICAgICovXG4gICAgaXNOb3ROdWxsT3JFbXB0eTogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZXhwb3J0cy5pc1N0cmluZyh2YWx1ZSkgJiYgdmFsdWU7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIENvbXBhcmVzIHR3byB2ZXJzaW9uIG51bWJlcnMgb2YgdGhlIGZvcm0gJ2EuYi5jJyB3aGVyZSBhLCBiIGFuZCBjIGFyZVxuICAgICAqIG51bWJlcnMgKGUuZy4gJzEuMC4xMicpLiBJZiBvbmUgb3IgYm90aCBpbnB1dHMgYXJlIGludmFsaWQgdmVyc2lvbnMsIHRoZVxuICAgICAqIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIE5hTiwgb3RoZXJ3aXNlLCBpdCB3aWxsIHJldHVybiAtMSBpZiB0aGUgZmlyc3RcbiAgICAgKiB2ZXJzaW9uIGlzIHNtYWxsZXIsIDEgaWYgdGhlIGZpcnN0IHZlcnNpb24gaXMgYmlnZ2VyLCBhbmQgMCBpZiB0aGUgdHdvXG4gICAgICogdmVyc2lvbnMgYXJlIGVxdWFsLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZlcnNpb24xXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHZlcnNpb24yXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7TnVtYmVyfVxuICAgICAqL1xuICAgIGNvbXBhcmVWZXJzaW9uczogZnVuY3Rpb24gKHZlcnNpb24xLCB2ZXJzaW9uMikge1xuICAgICAgLy8gaWYgb25lIG9yIGJvdGggaW5wdXRzIGFyZSB2YWxpZCwgcmV0dXJuIE5hTlxuICAgICAgaWYgKCFleHBvcnRzLmlzU3RyaW5nKHZlcnNpb24xKSB8fCAhZXhwb3J0cy5pc1N0cmluZyh2ZXJzaW9uMikpIHtcbiAgICAgICAgcmV0dXJuIE5hTjtcbiAgICAgIH1cblxuICAgICAgLy8gc3BsaXQgb24gZG90XG4gICAgICBjb25zdCB2ZXJzaW9uMVBhcnRzID0gdmVyc2lvbjEuc3BsaXQoJy4nKTtcbiAgICAgIGNvbnN0IHZlcnNpb24yUGFydHMgPSB2ZXJzaW9uMi5zcGxpdCgnLicpO1xuXG4gICAgICAvLyBhZGQgdHJhaWxpbmcgemVyb3MgdG8gbWFrZSB0aGUgcGFydHMgYXJyYXlzIHRoZSBzYW1lIGxlbmd0aFxuICAgICAgd2hpbGUgKHZlcnNpb24xUGFydHMubGVuZ3RoIDwgdmVyc2lvbjJQYXJ0cy5sZW5ndGgpIHtcbiAgICAgICAgdmVyc2lvbjFQYXJ0cy5wdXNoKCcwJyk7XG4gICAgICB9XG4gICAgICB3aGlsZSAodmVyc2lvbjJQYXJ0cy5sZW5ndGggPCB2ZXJzaW9uMVBhcnRzLmxlbmd0aCkge1xuICAgICAgICB2ZXJzaW9uMlBhcnRzLnB1c2goJzAnKTtcbiAgICAgIH1cblxuICAgICAgLy8gY29tcGFyZSBlbGVtZW50cyBpbiB0aGUgdHdvIGFycmF5cyBvbmUgYnkgb25lXG4gICAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICAgIGxldCB2ZXJzaW9uMVBhcnQsIHZlcnNpb24yUGFydDtcbiAgICAgIGZvciAobGV0IGluZGV4ID0gMCwgbGVuZ3RoID0gdmVyc2lvbjFQYXJ0cy5sZW5ndGg7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIC8vIGNvbnZlcnQgdG8gbnVtYmVyIGJlZm9yZSBkb2luZyBhbnkgYXJpdGhtZXRpY1xuICAgICAgICB2ZXJzaW9uMVBhcnQgPSBOdW1iZXIodmVyc2lvbjFQYXJ0c1tpbmRleF0pO1xuICAgICAgICB2ZXJzaW9uMlBhcnQgPSBOdW1iZXIodmVyc2lvbjJQYXJ0c1tpbmRleF0pO1xuXG4gICAgICAgIC8vIGlmIG9uZSBvciBib3RoIHZhbHVlcyBhcmUgbm90IG51bWVyaWNhbCwgY29uc2lkZXIgdGhlIGlucHV0IGludmFsaWRcbiAgICAgICAgaWYgKCFleHBvcnRzLmlzTnVtYmVyKHZlcnNpb24xUGFydCkgfHwgIWV4cG9ydHMuaXNOdW1iZXIodmVyc2lvbjJQYXJ0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IE5hTjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGlmIHRoZSB0d28gdmFsdWVzIGFyZSBkaWZmZXJlbnQsIHBpY2sgdGhlXG4gICAgICAgIC8vIGNvcnJlY3QgcmVzdWx0IGJhc2VkIG9uIHdoaWNoIHZhbHVlIGlzIHNtYWxsZXJcbiAgICAgICAgaWYgKHZlcnNpb24xUGFydCAhPT0gdmVyc2lvbjJQYXJ0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmVyc2lvbjFQYXJ0IDwgdmVyc2lvbjJQYXJ0ID8gLTEgOiAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICB9O1xuXG4vKipcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiB2YWx1ZSBpcyBub3QgbnVsbCBvciB1bmRlZmluZWQuXG4gKlxuICogQHBhcmFtIHZhbHVlXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuZXhpc3RzID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiAodmFsdWUgIT09IG51bGwpICYmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKTtcbn07XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIHVybC1yZWxhdGVkIHV0aWxpdHkgZnVuY3Rpb25zLlxuICovXG5leHBvcnRzLnVybCA9XG4gIHtcbiAgICAvKipcbiAgICAgKiBBcHBlbmRzIGEgcXVlcnkgcGFyYW1ldGVyIHRvIGEgdXJsLiBJZiBhbiBpbnZhbGlkIHVybCBpcyBzcGVjaWZpZWQsIGFuXG4gICAgICogZXhjZXB0aW9uIGlzIHRocm93bi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB1cmxcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcGFyYW1OYW1lIHRoZSBuYW1lIG9mIHRoZSBxdWVyeSBwYXJhbWV0ZXIuXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHBhcmFtVmFsdWUgdGhlIHZhbHVlIG9mIHRoZSBxdWVyeSBwYXJhbWV0ZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7U3RyaW5nfVxuICAgICAqL1xuICAgIGFwcGVuZFBhcmFtOiBmdW5jdGlvbiAodXJsLCBwYXJhbU5hbWUsIHBhcmFtVmFsdWUpIHtcbiAgICAgIC8vIGlmIHRoZSBzcGVjaWZpZWQgdXJsIGlzIHZhbGlkXG4gICAgICBjb25zdCB1cmxBc09iamVjdCA9IFVybC5wYXJzZSh1cmwpO1xuICAgICAgaWYgKHVybEFzT2JqZWN0KSB7XG4gICAgICAgIC8vIGlmIHRoZSB1cmwgYWxyZWFkeSBoYXMgcXVlcnkgcGFyYW1ldGVycywgdXNlICcmJyBhcyB0aGUgc2VwYXJhdG9yXG4gICAgICAgIC8vIHdoZW4gYXBwZW5kaW5nIHRoZSBhZGRpdGlvbmFsIHF1ZXJ5IHBhcmFtZXRlciwgb3RoZXJ3aXNlIHVzZSAnPydcbiAgICAgICAgdXJsICs9ICh1cmxBc09iamVjdC5zZWFyY2ggPyAnJicgOiAnPycpICsgcGFyYW1OYW1lICsgJz0nICsgcGFyYW1WYWx1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHVybDtcbiAgICB9LFxuXG4gICAgYXBwZW5kUmV0cnlQYXJhbTogZnVuY3Rpb24gKG9wdGlvbikge1xuICAgICAgbGV0IHJldHJ5VXJsID0gdGhpcy5hcHBlbmRQYXJhbShvcHRpb24udXJsLCAncmV0cnlDb3VudCcsIG9wdGlvbi5yZXRyeUNvdW50KTtcbiAgICAgIGlmIChvcHRpb24uaW5jbHVkZVJldHJ5UmVhc29uKSB7XG4gICAgICAgIHJldHJ5VXJsID0gdGhpcy5hcHBlbmRQYXJhbShyZXRyeVVybCwgJ3JldHJ5UmVhc29uJywgb3B0aW9uLnJldHJ5UmVhc29uKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldHJ5VXJsO1xuICAgIH1cbiAgfTtcblxuLyoqXG4gKiBTaGFsbG93LWNvcGllcyBldmVyeXRoaW5nIGZyb20gYSBzb3VyY2Ugb2JqZWN0IGludG8gYSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRzdCB0aGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyB0by5cbiAqIEBwYXJhbSB7T2JqZWN0fSBzcmMgdGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbS5cbiAqXG4gKiBAcmV0dXJucyB7T2JqZWN0fSB0aGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICovXG5leHBvcnRzLmFwcGx5ID0gZnVuY3Rpb24gKGRzdCwgc3JjKSB7XG4gIC8vIGlmIGJvdGggZHN0IGFuZCBzcmMgYXJlIG9iamVjdHMsIGNvcHkgZXZlcnl0aGluZyBmcm9tIHNyYyB0byBkc3RcbiAgaWYgKHRoaXMuaXNPYmplY3QoZHN0KSAmJiB0aGlzLmlzT2JqZWN0KHNyYykpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBzcmMpIHtcbiAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc3JjLCBrZXkpKSB7XG4gICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRzdDtcbn07XG5cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSBjb2RlIGlzIGN1cnJlbnRseSBiZWluZyBydW4gaW4gdGhlIGJyb3dzZXIsIGZhbHNlXG4gKiBvdGhlcndpc2UuXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNCcm93c2VyID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gISEocHJvY2VzcyAmJiBwcm9jZXNzLmJyb3dzZXIpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGNvZGUgaXMgY3VycmVudGx5IGJlaW5nIHJ1biBpbiBub2RlLCBmYWxzZSBvdGhlcndpc2UuXG4gKlxuICogQHJldHVybnMge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNOb2RlID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gIXRoaXMuaXNCcm93c2VyKCk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIG5leHQgc2xlZXAgdGltZSBjYWxjdWxhdGVkIGJ5IGV4cG9uZW50aWFsIGJhY2tvZmYgd2l0aFxuICogZGVjb3JyZWxhdGVkIGppdHRlci5cbiAqIHNsZWVwID0gbWluKGNhcCwgcmFuZG9tX2JldHdlZW4oYmFzZSwgc2xlZXAgKiAzKSlcbiAqIGZvciBtb3JlIGRldGFpbHMsIGNoZWNrIG91dDpcbiAqIGh0dHA6Ly93d3cuYXdzYXJjaGl0ZWN0dXJlYmxvZy5jb20vMjAxNS8wMy9iYWNrb2ZmLmh0bWxcbiAqIEBwYXJhbSBiYXNlIG1pbmltdW0gc2Vjb25kc1xuICogQHBhcmFtIGNhcCBtYXhpbXVtIHNlY29uZHNcbiAqIEBwYXJhbSBwcmV2aW91c1NsZWVwIHByZXZpb3VzIHNsZWVwIHRpbWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IG5leHQgc2xlZXAgdGltZVxuICovXG5leHBvcnRzLm5leHRTbGVlcFRpbWUgPSBmdW5jdGlvbiAoXG4gIGJhc2UsIGNhcCwgcHJldmlvdXNTbGVlcCkge1xuICByZXR1cm4gTWF0aC5taW4oY2FwLCBNYXRoLmFicyhwcmV2aW91c1NsZWVwICogMyAtIGJhc2UpICogTWF0aC5yYW5kb20oKSArXG4gICAgTWF0aC5taW4oYmFzZSwgcHJldmlvdXNTbGVlcCAqIDMpKTtcbn07XG5cblxuLyoqXG4gKiBSZXR1cm4gbmV4dCBzbGVlcCB0aW1lIGNhbGN1bGF0ZWQgYnkgdGhlIGppdHRlciBydWxlLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1vZlJldHJpZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50U2xlZXBUaW1lXG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxFbGFwc2VkVGltZVxuICogQHBhcmFtIHtOdW1iZXJ9IG1heFJldHJ5VGltZW91dFxuICogQHJldHVybnMge0pTT059IHJldHVybiBuZXh0IHNsZWVwIFRpbWUgYW5kIHRvdGFsVGltZS5cbiAqL1xuZXhwb3J0cy5nZXRKaXR0ZXJlZFNsZWVwVGltZSA9IGZ1bmN0aW9uIChudW1vZlJldHJpZXMsIGN1cnJlbnRTbGVlcFRpbWUsIHRvdGFsRWxhcHNlZFRpbWUsIG1heFJldHJ5VGltZW91dCkge1xuICBjb25zdCBuZXh0c2xlZXAgPSBnZXROZXh0U2xlZXBUaW1lKG51bW9mUmV0cmllcywgY3VycmVudFNsZWVwVGltZSk7XG4gIGNvbnN0IHNsZWVwID0gbWF4UmV0cnlUaW1lb3V0ICE9PSAwID8gTWF0aC5taW4oKG1heFJldHJ5VGltZW91dCAtIHRvdGFsRWxhcHNlZFRpbWUpLCBuZXh0c2xlZXApIDogbmV4dHNsZWVwO1xuICB0b3RhbEVsYXBzZWRUaW1lICs9IHNsZWVwO1xuICByZXR1cm4geyBzbGVlcCwgdG90YWxFbGFwc2VkVGltZSB9O1xufTtcblxuLyoqXG4gKiBDaG9vc2Ugb25lIG9mIHRoZSBudW1iZXIgYmV0d2VlbiB0d28gbnVtYmVycy5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gZmlyc3ROdW1iZXJcbiAqIEBwYXJhbSB7TnVtYmVyfSBzZWNvbmROdW1iZXJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IHJldHVybiBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiB0d28gbnVtYmVycy5cbiAqL1xuZnVuY3Rpb24gY2hvb3NlUmFuZG9tKGZpcnN0TnVtYmVyLCBzZWNvbmROdW1iZXIpIHtcbiAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAoZmlyc3ROdW1iZXIgLSBzZWNvbmROdW1iZXIpICsgc2Vjb25kTnVtYmVyO1xufVxuXG5leHBvcnRzLmNob29zZVJhbmRvbSA9IGNob29zZVJhbmRvbTtcblxuLyoqXG4gKiByZXR1cm4gdGhlIG5leHQgc2xlZXAgVGltZS5cbiAqIEBwYXJhbSB7TnVtYmVyfSBudW1vZlJldHJpZXNcbiAqIEBwYXJhbSB7TnVtYmVyfSBjdXJyZW50U2xlZXBUaW1lXG4gKiBAcmV0dXJucyB7TnVtYmVyfSByZXR1cm4gaml0dGVyLlxuICovXG5mdW5jdGlvbiBnZXROZXh0U2xlZXBUaW1lKG51bW9mUmV0cmllcywgIGN1cnJlbnRTbGVlcFRpbWUpIHtcbiAgY29uc3QgbmV4dFNsZWVwID0gKDIgKiogKG51bW9mUmV0cmllcykpO1xuICByZXR1cm4gY2hvb3NlUmFuZG9tKGN1cnJlbnRTbGVlcFRpbWUgKyBnZXRKaXR0ZXIoY3VycmVudFNsZWVwVGltZSksIG5leHRTbGVlcCArIGdldEppdHRlcihjdXJyZW50U2xlZXBUaW1lKSk7XG59XG5cbmV4cG9ydHMuZ2V0TmV4dFNsZWVwVGltZSA9IGdldE5leHRTbGVlcFRpbWU7XG5cbi8qKlxuICogcmV0dXJuIHRoZSBqaXR0ZXIgdmFsdWUuXG4gKiBAcGFyYW0ge051bWJlcn0gY3VycmVudFNsZWVwVGltZVxuICogQHJldHVybnMge051bWJlcn0gcmV0dXJuIGppdHRlci5cbiAqL1xuZnVuY3Rpb24gZ2V0Sml0dGVyKGN1cnJlbnRTbGVlcFRpbWUpIHtcbiAgY29uc3QgbXVsdGlwbGljYXRpb25GYWN0b3IgPSBjaG9vc2VSYW5kb20oMSwgLTEpO1xuICByZXR1cm4gMC41ICogY3VycmVudFNsZWVwVGltZSAqIG11bHRpcGxpY2F0aW9uRmFjdG9yO1xufVxuXG5leHBvcnRzLmdldEppdHRlciA9IGdldEppdHRlcjtcblxuLyoqXG4gKiBDaGVjayB3aGV0aGVyIHRoZSByZXF1ZXN0IGlzIHRoZSBsb2dpbi1yZXF1ZXN0IG9yIG5vdC5cbiAqXG4gKiBAcGFyYW0gbG9naW51cmwgSFRUUCByZXF1ZXN0IHVybFxuICogQHJldHVybnMge0Jvb2xlYW59IHRydWUgaWYgaXQgaXMgbG9naW5SZXF1ZXN0LCBvdGhlcndpc2UgZmFsc2UuXG4gKi9cbmV4cG9ydHMuaXNMb2dpblJlcXVlc3QgPSBmdW5jdGlvbiAobG9naW5VcmwpIHtcbiAgY29uc3QgZW5kUG9pbnRzID0gWycvdjEvbG9naW4tcmVxdWVzdCcsICcvYXV0aGVudGljYXRvci1yZXF1ZXN0JyxdO1xuICByZXR1cm4gZW5kUG9pbnRzLnNvbWUoKGVuZFBvaW50KSA9PiBsb2dpblVybC5pbmNsdWRlcyhlbmRQb2ludCkpO1xufTtcblxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIEhUVFAgcmVzcG9uc2UgY29kZSBpcyByZXRyeWFibGVcbiAqXG4gKiBAcGFyYW0gcmVzcG9uc2UgSFRUUCByZXNwb25zZSBvYmplY3RcbiAqIEBwYXJhbSByZXRyeTQwMyB3aWxsIHJldHJ5IEhUVFAgNDAzP1xuICogQHJldHVybnMgeyp8Ym9vbGVhbn0gdHJ1ZSBpZiByZXRyeWFibGUgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmV4cG9ydHMuaXNSZXRyeWFibGVIdHRwRXJyb3IgPSBmdW5jdGlvbiAocmVzcG9uc2UsIHJldHJ5NDAzKSB7XG4gIHJldHVybiByZXNwb25zZSAmJlxuICAgICgocmVzcG9uc2Uuc3RhdHVzQ29kZSA+PSA1MDAgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDYwMCkgfHxcbiAgICAgIChyZXRyeTQwMyAmJiByZXNwb25zZS5zdGF0dXNDb2RlID09PSA0MDMpIHx8XG4gICAgICAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDA4KSB8fFxuICAgICAgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyOSkpO1xufTtcblxuZXhwb3J0cy52YWxpZGF0ZUNsaWVudFNlc3Npb25LZWVwQWxpdmVIZWFydGJlYXRGcmVxdWVuY3kgPSBmdW5jdGlvbiAoaW5wdXQsIG1hc3RlclZhbGlkaXR5KSB7XG4gIGxldCBoZWFydGJlYXRGcmVxdWVuY3kgPSBpbnB1dDtcbiAgY29uc3QgcmVhbE1heCA9IE1hdGguZmxvb3IobWFzdGVyVmFsaWRpdHkgLyA0KTtcbiAgY29uc3QgcmVhbE1pbiA9IE1hdGguZmxvb3IocmVhbE1heCAvIDQpO1xuICBpZiAoaW5wdXQgPiByZWFsTWF4KSB7XG4gICAgaGVhcnRiZWF0RnJlcXVlbmN5ID0gcmVhbE1heDtcbiAgfSBlbHNlIGlmIChpbnB1dCA8IHJlYWxNaW4pIHtcbiAgICBoZWFydGJlYXRGcmVxdWVuY3kgPSByZWFsTWluO1xuICB9XG5cbiAgaGVhcnRiZWF0RnJlcXVlbmN5ID0gTWF0aC5mbG9vcihoZWFydGJlYXRGcmVxdWVuY3kpO1xuICByZXR1cm4gaGVhcnRiZWF0RnJlcXVlbmN5O1xufTtcblxuLy8gZHJpdmVyIG5hbWVcbmNvbnN0IGRyaXZlck5hbWUgPSByZXF1aXJlKCcuLy4uL3BhY2thZ2UuanNvbicpLm5hbWU7XG5leHBvcnRzLmRyaXZlck5hbWUgPSBkcml2ZXJOYW1lO1xuXG4vLyBkcml2ZXIgdmVyc2lvblxuY29uc3QgZHJpdmVyVmVyc2lvbiA9IHJlcXVpcmUoJy4vLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbmV4cG9ydHMuZHJpdmVyVmVyc2lvbiA9IGRyaXZlclZlcnNpb247XG5cbi8vIG5vZGVKUyB2ZXJzaW9uXG5sZXQgbm9kZUpTVmVyc2lvbiA9IHByb2Nlc3MudmVyc2lvbjtcbmlmIChub2RlSlNWZXJzaW9uICYmIG5vZGVKU1ZlcnNpb24uc3RhcnRzV2l0aCgndicpKSB7XG4gIG5vZGVKU1ZlcnNpb24gPSBub2RlSlNWZXJzaW9uLnN1YnN0cmluZygxKTtcbn1cbi8vIHVzZXItYWdlbnQgSFRUUCBoZWFkZXJcbmNvbnN0IHVzZXJBZ2VudCA9ICdKYXZhU2NyaXB0JyArICcvJyArIGRyaXZlclZlcnNpb25cbiAgKyAnICgnICsgcHJvY2Vzcy5wbGF0Zm9ybSArICctJyArIHByb2Nlc3MuYXJjaCArICcpICcgKyAnTm9kZUpTJyArICcvJyArIG5vZGVKU1ZlcnNpb247XG5cbmV4cG9ydHMudXNlckFnZW50ID0gdXNlckFnZW50O1xuXG4vKipcbiAqIENvbnN0cnVjdHMgaG9zdCBuYW1lIHVzaW5nIHJlZ2lvbiBhbmQgYWNjb3VudFxuICpcbiAqIEBwYXJhbSByZWdpb24gd2hlcmUgdGhlIGFjY291bnQgaXMgbG9jYXRlZFxuICogQHBhcmFtIGFjY291bnQgd2hpY2ggYWNjb3VudCB0byBjb25uZWN0IHRvXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBob3N0IG5hbWVcbiAqL1xuZXhwb3J0cy5jb25zdHJ1Y3RIb3N0bmFtZSA9IGZ1bmN0aW9uIChyZWdpb24sIGFjY291bnQpIHtcbiAgbGV0IGhvc3Q7XG4gIGlmIChyZWdpb24gPT09ICd1cy13ZXN0LTInKSB7XG4gICAgaG9zdCA9IGFjY291bnQgKyAnLnNub3dmbGFrZWNvbXB1dGluZy5jb20nO1xuICB9IGVsc2UgaWYgKHJlZ2lvbiAhPSBudWxsKSB7XG4gICAgaWYgKGFjY291bnQuaW5kZXhPZignLicpID4gMCkge1xuICAgICAgYWNjb3VudCA9IGFjY291bnQuc3Vic3RyaW5nKDAsIGFjY291bnQuaW5kZXhPZignLicpKTtcbiAgICB9XG4gICAgaWYgKHJlZ2lvbi5zdGFydHNXaXRoKCdjbi0nKSB8fCByZWdpb24uc3RhcnRzV2l0aCgnQ04tJykpIHtcbiAgICAgIGhvc3QgPSBhY2NvdW50ICsgJy4nICsgcmVnaW9uICsgJy5zbm93Zmxha2Vjb21wdXRpbmcuY24nO1xuICAgIH0gZWxzZSB7XG4gICAgICBob3N0ID0gYWNjb3VudCArICcuJyArIHJlZ2lvbiArICcuc25vd2ZsYWtlY29tcHV0aW5nLmNvbSc7XG4gICAgfVxuXG4gIH0gZWxzZSB7XG4gICAgaG9zdCA9IGFjY291bnQgKyAnLnNub3dmbGFrZWNvbXB1dGluZy5jb20nO1xuICB9XG4gIHJldHVybiBob3N0O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgaG9zdCBpbmRpY2F0ZXMgcHJpdmF0ZSBsaW5rXG4gKlxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmV4cG9ydHMuaXNQcml2YXRlTGluayA9IGZ1bmN0aW9uIChob3N0KSB7XG4gIEVycm9ycy5jaGVja0FyZ3VtZW50RXhpc3RzKHRoaXMuZXhpc3RzKGhvc3QpLCBFcnJvcnMuY29kZXMuRVJSX0NPTk5fQ1JFQVRFX01JU1NJTkdfSE9TVCk7XG4gIHJldHVybiBob3N0LnRvTG93ZXJDYXNlKCkuaW5jbHVkZXMoJ3ByaXZhdGVsaW5rLnNub3dmbGFrZWNvbXB1dGluZy4nKTtcbn07XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBob3N0IGluZGljYXRlcyBwcml2YXRlIGxpbmtcbiAqXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5jcmVhdGVPY3NwUmVzcG9uc2VDYWNoZVNlcnZlclVybCA9IGZ1bmN0aW9uIChob3N0KSB7XG4gIHJldHVybiBgaHR0cDovL29jc3AuJHtob3N0fS9vY3NwX3Jlc3BvbnNlX2NhY2hlLmpzb25gO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGlmIGNvbW1hbmQgaXMgYSBQVVQgY29tbWFuZFxuICpcbiAqIEBwYXJhbSBzcWxUZXh0IHRoZSBxdWVyeSBjb21tYW5kXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAqL1xuZXhwb3J0cy5pc1B1dENvbW1hbmQgPSBmdW5jdGlvbiAoc3FsVGV4dCkge1xuICByZXR1cm4gKHNxbFRleHQudHJpbSgpLnN1YnN0cmluZygwLCAzKS50b1VwcGVyQ2FzZSgpID09PSAnUFVUJyk7XG59O1xuXG4vKipcbiAqIFJldHVybnMgaWYgY29tbWFuZCBpcyBhIEdFVCBjb21tYW5kXG4gKlxuICogQHBhcmFtIHNxbFRleHQgdGhlIHF1ZXJ5IGNvbW1hbmRcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzR2V0Q29tbWFuZCA9IGZ1bmN0aW9uIChzcWxUZXh0KSB7XG4gIHJldHVybiAoc3FsVGV4dC50cmltKCkuc3Vic3RyaW5nKDAsIDMpLnRvVXBwZXJDYXNlKCkgPT09ICdHRVQnKTtcbn07XG5cbi8qKlxuICogQWRkIGRvdWJsZSBxdW90ZXMgdG8gc21rSWQncyB2YWx1ZSB0byBwYXJzZSBpdCBhcyBhIHN0cmluZyBpbnN0ZWFkIG9mIGludGVnZXJcbiAqIHRvIHByZXNlcnZlIHByZWNpc2lvbiBvZiBudW1iZXJzIGV4Y2VlZGluZyBKYXZhU2NyaXB0J3MgbWF4IHNhZmUgaW50ZWdlclxuICogZS5nIChpbnB1dHRpbmcgMzI2MjE5NzMxMjYxMjM1MjZcdG91dHB1dHMgMzI2MjE5NzMxMjYxMjM1MzApXG4gKlxuICogQHBhcmFtIGJvZHkgdGhlIGRhdGEgaW4gSlNPTlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuZXhwb3J0cy5jb252ZXJ0U21rSWRUb1N0cmluZyA9IGZ1bmN0aW9uIChib2R5KSB7XG4gIHJldHVybiBib2R5LnJlcGxhY2UoL1wic21rSWRcIiA6IChbMC05XSopL2csICdcInNta0lkXCIgOiBcIiQxXCInKTtcbn07XG5cbi8qKlxuICogVW5kZXIgc29tZSBjaXJjdW1zdGFuY2VzIHRoZSBvYmplY3QgcGFzc2VkIHRvIEpTT04uc3RyaW5naWZ5IGluIGV4Y2VwdGlvbiBoYW5kbGluZ1xuICogY2FuIGNvbnRhaW4gY2lyY3VsYXIgcmVmZXJlbmNlLCBvbiB3aGljaCBKU09OLnN0cmluZ2lmeSBiYWlscyBvdXRcbiAqIE1ETiB3YXkgb2YgaGFuZGxpbmcgc3VjaCBlcnJvclxuICogQHJldHVybnMgc3RyaW5nXG4gKi9cbmV4cG9ydHMuZ2V0Q2lyY3VsYXJSZXBsYWNlciA9IGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYW5jZXN0b3JzID0gW107XG4gIHJldHVybiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIC8vIGB0aGlzYCBpcyB0aGUgb2JqZWN0IHRoYXQgdmFsdWUgaXMgY29udGFpbmVkIGluLFxuICAgIC8vIGkuZS4sIGl0cyBkaXJlY3QgcGFyZW50LlxuICAgIHdoaWxlIChhbmNlc3RvcnMubGVuZ3RoID4gMCAmJiBhbmNlc3RvcnNbYW5jZXN0b3JzLmxlbmd0aCAtIDFdICE9PSB0aGlzKSB7XG4gICAgICBhbmNlc3RvcnMucG9wKCk7XG4gICAgfVxuICAgIGlmIChhbmNlc3RvcnMuaW5jbHVkZXModmFsdWUpKSB7XG4gICAgICByZXR1cm4gJ1tDaXJjdWxhcl0nO1xuICAgIH1cbiAgICBhbmNlc3RvcnMucHVzaCh2YWx1ZSk7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9O1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIGlmIHRoZSBwcm92aWRlZCBzdHJpbmcgaXMgYSB2YWxpZCBzdWJkb21haW4uXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEByZXR1cm5zIHtib29sZWFufVxuICovXG5leHBvcnRzLmlzQ29ycmVjdFN1YmRvbWFpbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBjb25zdCBzdWJkb21haW5SZWdleCA9IFJlZ0V4cCgvXlxcdysoWy4tXVxcdyspKiQvaSk7XG4gIHJldHVybiBzdWJkb21haW5SZWdleC50ZXN0KHZhbHVlKTtcbn07XG5cbmV4cG9ydHMuYnVpbGRDcmVkZW50aWFsQ2FjaGVLZXkgPSBmdW5jdGlvbiAoaG9zdCwgdXNlcm5hbWUsIGNyZWRUeXBlKSB7XG4gIGlmICghaG9zdCB8fCAhdXNlcm5hbWUgfHwgIWNyZWRUeXBlKSB7XG4gICAgTG9nZ2VyLmdldEluc3RhbmNlKCkuZGVidWcoJ0Nhbm5vdCBidWlsZCB0aGUgY3JlZGVudGlhbCBjYWNoZSBrZXkgYmVjYXVzZSBvbmUgb2YgaG9zdCwgdXNlcm5hbWUsIGFuZCBjcmVkVHlwZSBpcyBudWxsJyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcmV0dXJuIGB7JHtob3N0LnRvVXBwZXJDYXNlKCl9fTp7JHt1c2VybmFtZS50b1VwcGVyQ2FzZSgpfX06e1NGX05PREVfSlNfRFJJVkVSfTp7JHtjcmVkVHlwZS50b1VwcGVyQ2FzZSgpfX1gO1xufTtcblxuLyoqXG4gKiBcbiAqIEBwYXJhbSB7T2JqZWN0fSBjdXN0b21DcmVkZW50aWFsTWFuYWdlciBcbiAqIEByZXR1cm5zIFxuICovXG5leHBvcnRzLmNoZWNrVmFsaWRDdXN0b21DcmVkZW50aWFsTWFuYWdlciA9IGZ1bmN0aW9uIChjdXN0b21DcmVkZW50aWFsTWFuYWdlcikge1xuICBpZiAoIHR5cGVvZiBjdXN0b21DcmVkZW50aWFsTWFuYWdlciAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCByZXF1aXJlTWV0aG9kcyA9IFsnd3JpdGUnLCAncmVhZCcsICdyZW1vdmUnXTtcblxuICBmb3IgKGNvbnN0IG1ldGhvZCBvZiByZXF1aXJlTWV0aG9kcykge1xuICAgIGlmICghT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwoY3VzdG9tQ3JlZGVudGlhbE1hbmFnZXIsIG1ldGhvZCkgfHwgdHlwZW9mIGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyW21ldGhvZF0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5leHBvcnRzLmNoZWNrUGFyYW1ldGVyc0RlZmluZWQgPSBmdW5jdGlvbiAoLi4ucGFyYW1ldGVycykge1xuICByZXR1cm4gcGFyYW1ldGVycy5ldmVyeSgoZWxlbWVudCkgPT4gZWxlbWVudCAhPT0gdW5kZWZpbmVkICYmIGVsZW1lbnQgIT09IG51bGwpO1xufTtcblxuZXhwb3J0cy5idWlsZENyZWRlbnRpYWxDYWNoZUtleSA9IGZ1bmN0aW9uIChob3N0LCB1c2VybmFtZSwgY3JlZFR5cGUpIHtcbiAgaWYgKCFob3N0IHx8ICF1c2VybmFtZSB8fCAhY3JlZFR5cGUpIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5kZWJ1ZygnQ2Fubm90IGJ1aWxkIHRoZSBjcmVkZW50aWFsIGNhY2hlIGtleSBiZWNhdXNlIG9uZSBvZiBob3N0LCB1c2VybmFtZSwgYW5kIGNyZWRUeXBlIGlzIG51bGwnKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICByZXR1cm4gYHske2hvc3QudG9VcHBlckNhc2UoKX19Onske3VzZXJuYW1lLnRvVXBwZXJDYXNlKCl9fTp7U0ZfTk9ERV9KU19EUklWRVJ9Onske2NyZWRUeXBlLnRvVXBwZXJDYXNlKCl9fWA7XG59O1xuXG4vKipcbiAqIFxuICogQHBhcmFtIHtPYmplY3R9IGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyIFxuICogQHJldHVybnMgXG4gKi9cbmV4cG9ydHMuY2hlY2tWYWxpZEN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyID0gZnVuY3Rpb24gKGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyKSB7XG4gIGlmICggdHlwZW9mIGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBcbiAgY29uc3QgcmVxdWlyZU1ldGhvZHMgPSBbJ3dyaXRlJywgJ3JlYWQnLCAncmVtb3ZlJ107XG5cbiAgZm9yIChjb25zdCBtZXRob2Qgb2YgcmVxdWlyZU1ldGhvZHMpIHtcbiAgICBpZiAoIU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGN1c3RvbUNyZWRlbnRpYWxNYW5hZ2VyLCBtZXRob2QpIHx8IHR5cGVvZiBjdXN0b21DcmVkZW50aWFsTWFuYWdlclttZXRob2RdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuZXhwb3J0cy5jaGVja1BhcmFtZXRlcnNEZWZpbmVkID0gZnVuY3Rpb24gKC4uLnBhcmFtZXRlcnMpIHtcbiAgcmV0dXJuIHBhcmFtZXRlcnMuZXZlcnkoKGVsZW1lbnQpID0+IGVsZW1lbnQgIT09IHVuZGVmaW5lZCAmJiBlbGVtZW50ICE9PSBudWxsKTtcbn07XG5cbmV4cG9ydHMuc2hvdWxkUGVyZm9ybUdDUEJ1Y2tldCA9IGZ1bmN0aW9uIChhY2Nlc3NUb2tlbikge1xuICByZXR1cm4gISFhY2Nlc3NUb2tlbiAmJiBwcm9jZXNzLmVudi5TTk9XRkxBS0VfRk9SQ0VfR0NQX1VTRV9ET1dOU0NPUEVEX0NSRURFTlRJQUwgIT09ICd0cnVlJztcbn07XG5cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBwcm92aWRlZCBmaWxlIG9yIGRpcmVjdG9yeSBwZXJtaXNzaW9ucyBhcmUgY29ycmVjdC5cbiAqIEBwYXJhbSBmaWxlUGF0aFxuICogQHBhcmFtIGV4cGVjdGVkTW9kZVxuICogQHBhcmFtIGZzUHJvbWlzZXNcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSByZXNvbHZlcyBhbHdheXMgdG8gdHJ1ZSBmb3IgV2luZG93c1xuICovXG5leHBvcnRzLmlzRmlsZU1vZGVDb3JyZWN0ID0gYXN5bmMgZnVuY3Rpb24gKGZpbGVQYXRoLCBleHBlY3RlZE1vZGUsIGZzUHJvbWlzZXMpIHtcbiAgaWYgKG9zLnBsYXRmb3JtKCkgPT09ICd3aW4zMicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gYXdhaXQgZnNQcm9taXNlcy5zdGF0KGZpbGVQYXRoKS50aGVuKChzdGF0cykgPT4ge1xuICAgIC8vIHdlIGhhdmUgdG8gbGltaXQgdGhlIG51bWJlciBvZiBMU0IgYml0cyB0byA5IHdpdGggdGhlIG1hc2ssIGFzIHRoZSBzdGF0cy5tb2RlIHN0YXJ0cyB3aXRoIHRoZSBmaWxlIHR5cGUsXG4gICAgLy8gZS5nLiB0aGUgZGlyZWN0b3J5IHdpdGggcGVybWlzc2lvbnMgNzU1IHdpbGwgaGF2ZSBzdGF0cy5tYXNrIG9mIDQwNzU1LlxuICAgIGNvbnN0IG1hc2sgPSAoMSA8PCA5KSAtIDE7XG4gICAgcmV0dXJuIChzdGF0cy5tb2RlICYgbWFzaykgPT09IGV4cGVjdGVkTW9kZTtcbiAgfSk7XG59O1xuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgcHJvdmlkZWQgZmlsZSBvciBkaXJlY3RvcnkgaXMgd3JpdGFibGUgb25seSBieSB0aGUgdXNlci5cbiAqIEBwYXJhbSBjb25maWdGaWxlUGF0aFxuICogQHBhcmFtIGZzUHJvbWlzZXNcbiAqIEByZXR1cm5zIHtQcm9taXNlPGJvb2xlYW4+fSByZXNvbHZlcyBhbHdheXMgdG8gdHJ1ZSBmb3IgV2luZG93c1xuICovXG5leHBvcnRzLmlzRmlsZU5vdFdyaXRhYmxlQnlHcm91cE9yT3RoZXJzID0gYXN5bmMgZnVuY3Rpb24gKGNvbmZpZ0ZpbGVQYXRoLCBmc1Byb21pc2VzKSB7XG4gIGlmIChvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qgc3RhdHMgPSBhd2FpdCBmc1Byb21pc2VzLnN0YXQoY29uZmlnRmlsZVBhdGgpO1xuICByZXR1cm4gKHN0YXRzLm1vZGUgJiAoMSA8PCA0KSkgPT09IDAgJiYgKHN0YXRzLm1vZGUgJiAoMSA8PCAxKSkgPT09IDA7XG59O1xuXG5leHBvcnRzLnNob3VsZFJldHJ5T2t0YUF1dGggPSBmdW5jdGlvbiAoeyBtYXhSZXRyeVRpbWVvdXQsIG1heFJldHJ5Q291bnQsIG51bVJldHJpZXMsIHN0YXJ0VGltZSwgcmVtYWluaW5nVGltZW91dCB9KSB7XG4gIHJldHVybiAgKG1heFJldHJ5VGltZW91dCA9PT0gMCB8fCBEYXRlLm5vdygpIDwgc3RhcnRUaW1lICsgcmVtYWluaW5nVGltZW91dCkgJiYgbnVtUmV0cmllcyA8PSBtYXhSZXRyeUNvdW50O1xufTtcblxuZXhwb3J0cy5nZXREcml2ZXJEaXJlY3RvcnkgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBfX2Rpcm5hbWU7XG59O1xuXG5leHBvcnRzLnZhbGlkYXRlUGF0aCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBzdGF0ID0gZnMuc3RhdFN5bmMoZGlyKTtcbiAgICByZXR1cm4gc3RhdC5pc0RpcmVjdG9yeSgpO1xuICB9IGNhdGNoIHtcbiAgICBMb2dnZXIuZ2V0SW5zdGFuY2UoKS5lcnJvcignVGhlIHBhdGggbG9jYXRpb24gaXMgaW52YWxpZC4gUGxlYXNlIGNoZWNrIHRoaXMgbG9jYXRpb24gaXMgYWNjZXNzaWJsZSBvciBleGlzdGluZycpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZXhwb3J0cy5nZXRFbnZWYXIgPSBmdW5jdGlvbiAodmFyaWFibGUpIHtcbiAgcmV0dXJuIHByb2Nlc3MuZW52W3ZhcmlhYmxlLnRvTG93ZXJDYXNlKCldIHx8IHByb2Nlc3MuZW52W3ZhcmlhYmxlLnRvVXBwZXJDYXNlKCldO1xufTtcblxuZXhwb3J0cy52YWxpZGF0ZUVtcHR5U3RyaW5nID0gZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPT0gJycgPyB2YWx1ZSA6IHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydHMuaXNOb3RFbXB0eUFzU3RyaW5nID0gZnVuY3Rpb24gKHZhcmlhYmxlKSB7XG4gIGlmICh0eXBlb2YgdmFyaWFibGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhcmlhYmxlO1xuICB9XG4gIHJldHVybiBleHBvcnRzLmV4aXN0cyh2YXJpYWJsZSk7XG59O1xuLyoqXG4gKiBDaGVja3MgV2hldGhlciB0aGUgb2JqZWN0IGlzIGVtcHR5IChjYW4gYmUgbnVsbCBvciB1bmRlZmluZWQpIG9yIG5vdC5cbiAqIEBwYXJhbSBvYmplY3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBcbiAqL1xuZXhwb3J0cy5pc0VtcHR5T2JqZWN0ID0gKG9iamVjdCkgPT4ge1xuICBpZiAoIXRoaXMuZXhpc3RzKG9iamVjdCkpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBpZiAodHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID09PSAwO1xufTtcblxuZXhwb3J0cy5pc1dpbmRvd3MgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBvcy5wbGF0Zm9ybSgpID09PSAnd2luMzInO1xufTtcblxuLyoqXG4qIExlZnQgc3RyaXAgdGhlIHNwZWNpZmllZCBjaGFyYWN0ZXIgZnJvbSBhIHN0cmluZy5cbipcbiogQHBhcmFtIHtTdHJpbmd9IHN0clxuKiBAcGFyYW0ge0NoYXJhY3Rlcn0gcmVtb3ZlXG4qXG4qIEByZXR1cm5zIHtTdHJpbmd9XG4qL1xuZXhwb3J0cy5sc3RyaXAgPSBmdW5jdGlvbiAoc3RyLCByZW1vdmUpIHtcbiAgd2hpbGUgKHN0ci5sZW5ndGggPiAwICYmIHJlbW92ZS5pbmRleE9mKHN0ci5jaGFyQXQoMCkpICE9PSAtMSkge1xuICAgIHN0ciA9IHN0ci5zdWJzdHIoMSk7XG4gIH1cbiAgcmV0dXJuIHN0cjtcbn07Il0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/snowflake-sdk/lib/util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/snowflake-sdk/package.json":
/*!*************************************************!*\
  !*** ./node_modules/snowflake-sdk/package.json ***!
  \*************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"snowflake-sdk","version":"2.0.3","description":"Node.js driver for Snowflake","dependencies":{"@aws-sdk/client-s3":"^3.726.0","@smithy/node-http-handler":"^4.0.1","@azure/storage-blob":"12.26.x","@google-cloud/storage":"^7.7.0","@techteamer/ocsp":"1.0.1","asn1.js-rfc2560":"^5.0.0","asn1.js-rfc5280":"^3.0.0","axios":"^1.7.7","big-integer":"^1.6.43","bignumber.js":"^9.1.2","binascii":"0.0.2","bn.js":"^5.2.1","browser-request":"^0.3.3","expand-tilde":"^2.0.2","fast-xml-parser":"^4.2.5","fastest-levenshtein":"^1.0.16","generic-pool":"^3.8.2","glob":"^10.0.0","https-proxy-agent":"^7.0.2","jsonwebtoken":"^9.0.0","mime-types":"^2.1.29","mkdirp":"^1.0.3","moment":"^2.29.4","moment-timezone":"^0.5.15","open":"^7.3.1","python-struct":"^1.1.3","simple-lru-cache":"^0.0.2","toml":"^3.0.0","uuid":"^8.3.2","winston":"^3.1.0"},"devDependencies":{"@aws-sdk/types":"^3.387.0","async":"^3.2.3","check-dts":"^0.8.2","eslint":"^8.41.0","mocha":"^10.2.0","mock-require":"^3.0.3","nyc":"^15.1.0","test-console":"^2.0.0"},"peerDependencies":{"asn1.js":"^5.4.1"},"overrides":{"semver":"^7.5.2"},"repository":{"type":"git","url":"https://github.com/snowflakedb/snowflake-connector-nodejs"},"typings":"./index.d.ts","scripts":{"lint:check":"eslint && check-dts index.d.ts","lint:check:all":"eslint lib samples system_test test && check-dts index.d.ts","lint:check:all:errorsOnly":"npm run lint:check:all -- --quiet","lint:fix":"eslint --fix","test":"mocha -timeout 180000 --recursive --full-trace test/unit/**/*.js test/unit/*.js","test:authentication":"mocha --exit -timeout 180000 --recursive --full-trace test/authentication/**/*.js test/authentication/*.js","test:integration":"mocha -timeout 180000 --recursive --full-trace test/integration/**/*.js test/integration/*.js","test:single":"mocha -timeout 180000 --full-trace","test:system":"mocha -timeout 180000 --recursive --full-trace system_test/*.js","test:unit":"mocha -timeout 180000 --recursive --full-trace test/unit/**/*.js test/unit/*.js","test:unit:coverage":"nyc npm run test:unit","test:ci":"mocha -timeout 180000 --recursive --full-trace \'test/{unit,integration}/**/*.js\'","test:ci:coverage":"nyc npm run test:ci","test:ci:withSystemTests":"mocha -timeout 180000 --recursive --full-trace \'test/{unit,integration}/**/*.js\' system_test/*.js","test:ci:withSystemTests:coverage":"nyc npm run test:ci:withSystemTests","test:manual":"mocha -timeout 180000 --full-trace --full-trace test/integration/testManualConnection.js"},"author":{"name":"Snowflake Computing, Inc.","email":"support@snowflake.com","url":"https://www.snowflake.com/"},"license":"Apache-2.0"}');

/***/ })

};
;